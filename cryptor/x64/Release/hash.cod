; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?MurmurHash2A@@YAIPEBXHI@Z			; MurmurHash2A
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MurmurHash2A@@YAIPEBXHI@Z DD imagerel $LN57
	DD	imagerel $LN57+370
	DD	imagerel $unwind$?MurmurHash2A@@YAIPEBXHI@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MurmurHash2A@@YAIPEBXHI@Z DD 021519H
	DD	070029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\hash.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\hash.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\hash.cpp
;	COMDAT ?MurmurHash2A@@YAIPEBXHI@Z
_TEXT	SEGMENT
temp$ = 0
__$ArrayPad$ = 64
key$ = 96
len$ = 104
seed$dead$ = 112
?MurmurHash2A@@YAIPEBXHI@Z PROC				; MurmurHash2A, COMDAT

; 8    : {

$LN57:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00015	4c 8b c1	 mov	 r8, rcx

; 9    : 	char temp[64];
; 10   : 	RtlSecureZeroMemory(temp, 64);
; 11   : 	memory::Copy(temp, (PVOID)key, len);

  00018	4c 63 d2	 movsxd	 r10, edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0001b	33 c0		 xor	 eax, eax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\hash.cpp

; 8    : {

  0001d	44 8b ca	 mov	 r9d, edx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h

; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00020	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00025	48 8d 3c 24	 lea	 rdi, QWORD PTR temp$[rsp]
  00029	f3 aa		 rep stosb
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 28   : 	for (len = size / wordsize; len--; _src += wordsize, _dst += wordsize)

  0002b	49 8b fa	 mov	 rdi, r10
  0002e	48 8d 0c 24	 lea	 rcx, QWORD PTR temp$[rsp]
  00032	48 c1 ef 03	 shr	 rdi, 3
  00036	48 85 ff	 test	 rdi, rdi
  00039	74 19		 je	 SHORT $LN27@MurmurHash
  0003b	0f 1f 44 00 00	 npad	 5
$LL19@MurmurHash:

; 29   : 		*(size_t*)_dst = *(size_t*)_src;

  00040	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00043	49 83 c0 08	 add	 r8, 8
  00047	48 89 01	 mov	 QWORD PTR [rcx], rax
  0004a	48 83 c1 08	 add	 rcx, 8
  0004e	48 83 ef 01	 sub	 rdi, 1
  00052	75 ec		 jne	 SHORT $LL19@MurmurHash
$LN27@MurmurHash:

; 30   : 
; 31   : 	len = size % wordsize;

  00054	49 8b d2	 mov	 rdx, r10
  00057	83 e2 07	 and	 edx, 7

; 32   : 	while (len--)

  0005a	74 16		 je	 SHORT $LN29@MurmurHash
  0005c	49 2b c8	 sub	 rcx, r8
  0005f	90		 npad	 1
$LL20@MurmurHash:

; 33   : 		*_dst++ = *_src++;

  00060	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00064	42 88 04 01	 mov	 BYTE PTR [rcx+r8], al
  00068	4d 8d 40 01	 lea	 r8, QWORD PTR [r8+1]
  0006c	48 83 ea 01	 sub	 rdx, 1
  00070	75 ee		 jne	 SHORT $LL20@MurmurHash
$LN29@MurmurHash:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\hash.cpp

; 13   : 	for (int i = 0; i < len; i++) {

  00072	45 33 c0	 xor	 r8d, r8d
  00075	45 85 c9	 test	 r9d, r9d
  00078	7e 1f		 jle	 SHORT $LN3@MurmurHash
  0007a	41 8b d0	 mov	 edx, r8d
  0007d	0f 1f 00	 npad	 3
$LL33@MurmurHash:

; 14   : 		LowerChar(temp[i]);

  00080	0f b6 0c 14	 movzx	 ecx, BYTE PTR temp$[rsp+rdx]
  00084	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00087	3c 19		 cmp	 al, 25
  00089	77 06		 ja	 SHORT $LN34@MurmurHash
  0008b	80 c1 20	 add	 cl, 32			; 00000020H
  0008e	88 0c 14	 mov	 BYTE PTR temp$[rsp+rdx], cl
$LN34@MurmurHash:

; 13   : 	for (int i = 0; i < len; i++) {

  00091	48 ff c2	 inc	 rdx
  00094	49 3b d2	 cmp	 rdx, r10
  00097	7c e7		 jl	 SHORT $LL33@MurmurHash
$LN3@MurmurHash:

; 20   : 
; 21   : 	const unsigned char* data = (const unsigned char*)temp;

  00099	48 8d 14 24	 lea	 rdx, QWORD PTR temp$[rsp]
  0009d	45 8b d9	 mov	 r11d, r9d

; 22   : 
; 23   : 	unsigned int h = seed;

  000a0	41 ba da fc 01
	b8		 mov	 r10d, -1207829286	; b801fcdaH

; 24   : 	unsigned int k;
; 25   : 
; 26   : 	while (len >= 4)

  000a6	41 83 f9 04	 cmp	 r9d, 4
  000aa	7c 3b		 jl	 SHORT $LN6@MurmurHash

; 15   : 	}
; 16   : 
; 17   : 	const unsigned int m = 0x5bd1e995;
; 18   : 	const int r = 24;
; 19   : 	unsigned int l = len;

  000ac	49 8b f9	 mov	 rdi, r9
  000af	48 c1 ef 02	 shr	 rdi, 2
  000b3	8b c7		 mov	 eax, edi
  000b5	f7 d8		 neg	 eax
  000b7	45 8d 0c 81	 lea	 r9d, DWORD PTR [r9+rax*4]
  000bb	0f 1f 44 00 00	 npad	 5
$LL5@MurmurHash:

; 27   : 	{
; 28   : 		k = *(unsigned int*)data;
; 29   : 
; 30   : 		mmix(h, k);

  000c0	69 02 95 e9 d1
	5b		 imul	 eax, DWORD PTR [rdx], 1540483477 ; 5bd1e995H

; 31   : 
; 32   : 		data += 4;

  000c6	48 83 c2 04	 add	 rdx, 4
  000ca	45 69 d2 95 e9
	d1 5b		 imul	 r10d, r10d, 1540483477	; 5bd1e995H
  000d1	8b c8		 mov	 ecx, eax
  000d3	c1 e9 18	 shr	 ecx, 24
  000d6	33 c8		 xor	 ecx, eax
  000d8	69 c9 95 e9 d1
	5b		 imul	 ecx, ecx, 1540483477	; 5bd1e995H
  000de	44 33 d1	 xor	 r10d, ecx
  000e1	48 83 ef 01	 sub	 rdi, 1
  000e5	75 d9		 jne	 SHORT $LL5@MurmurHash
$LN6@MurmurHash:

; 33   : 		len -= 4;
; 34   : 	}
; 35   : 
; 36   : 	unsigned int t = 0;
; 37   : 
; 38   : 	switch (len)

  000e7	41 83 e9 01	 sub	 r9d, 1
  000eb	74 1f		 je	 SHORT $LN12@MurmurHash
  000ed	41 83 e9 01	 sub	 r9d, 1
  000f1	74 0f		 je	 SHORT $LN11@MurmurHash
  000f3	41 83 f9 01	 cmp	 r9d, 1
  000f7	75 19		 jne	 SHORT $LN7@MurmurHash

; 39   : 	{
; 40   : 	case 3: t ^= data[2] << 16;

  000f9	44 0f b6 42 02	 movzx	 r8d, BYTE PTR [rdx+2]
  000fe	41 c1 e0 10	 shl	 r8d, 16
$LN11@MurmurHash:

; 41   : 	case 2: t ^= data[1] << 8;

  00102	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00106	c1 e0 08	 shl	 eax, 8
  00109	44 33 c0	 xor	 r8d, eax
$LN12@MurmurHash:

; 42   : 	case 1: t ^= data[0];

  0010c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0010f	44 33 c0	 xor	 r8d, eax
$LN7@MurmurHash:

; 43   : 	};
; 44   : 
; 45   : 	mmix(h, t);

  00112	41 69 c8 95 e9
	d1 5b		 imul	 ecx, r8d, 1540483477	; 5bd1e995H

; 46   : 	mmix(h, l);

  00119	41 69 fb 95 e9
	d1 5b		 imul	 edi, r11d, 1540483477	; 5bd1e995H
  00120	8b c1		 mov	 eax, ecx
  00122	c1 e8 18	 shr	 eax, 24
  00125	33 c1		 xor	 eax, ecx
  00127	69 c8 95 e9 d1
	5b		 imul	 ecx, eax, 1540483477	; 5bd1e995H
  0012d	41 69 c2 95 e9
	d1 5b		 imul	 eax, r10d, 1540483477	; 5bd1e995H
  00134	33 c8		 xor	 ecx, eax
  00136	8b c7		 mov	 eax, edi
  00138	c1 e8 18	 shr	 eax, 24
  0013b	33 c7		 xor	 eax, edi
  0013d	69 d1 95 e9 d1
	5b		 imul	 edx, ecx, 1540483477	; 5bd1e995H
  00143	69 c0 95 e9 d1
	5b		 imul	 eax, eax, 1540483477	; 5bd1e995H
  00149	33 d0		 xor	 edx, eax

; 47   : 
; 48   : 	h ^= h >> 13;

  0014b	8b c2		 mov	 eax, edx
  0014d	c1 e8 0d	 shr	 eax, 13
  00150	33 c2		 xor	 eax, edx

; 49   : 	h *= m;

  00152	69 c8 95 e9 d1
	5b		 imul	 ecx, eax, 1540483477	; 5bd1e995H

; 50   : 	h ^= h >> 15;

  00158	8b c1		 mov	 eax, ecx
  0015a	c1 e8 0f	 shr	 eax, 15
  0015d	33 c1		 xor	 eax, ecx

; 51   : 
; 52   : 	return h;
; 53   : }

  0015f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00164	48 33 cc	 xor	 rcx, rsp
  00167	e8 00 00 00 00	 call	 __security_check_cookie
  0016c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00170	5f		 pop	 rdi
  00171	c3		 ret	 0
?MurmurHash2A@@YAIPEBXHI@Z ENDP				; MurmurHash2A
_TEXT	ENDS
END
