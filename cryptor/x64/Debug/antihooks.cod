; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__FE09AF47_concurrencysal@h DB 01H
__C073CA79_sal@h DB 01H
__D6AFE870_vadefs@h DB 01H
__D63E96CF_vcruntime@h DB 01H
__514B86D7_excpt@h DB 01H
__9A7D38D9_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__3EADF068_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__10D4A829_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__E15BF856_windows@h DB 01H
__832A4112_inaddr@h DB 01H
__C59B8995_ws2def@h DB 01H
__F9202461_qos@h DB 01H
__50CB22FA_WinSock2@h DB 01H
__48BF11AE_antihooks@h DB 01H
__32E3D3D2_xkeycheck@h DB 01H
__CFD6EDFA_yvals_core@h DB 01H
__B9985323_float@h DB 01H
__6F1D8D42_cfloat DB 01H
__9CD02892_climits DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__1C5946C5_cstdio DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__86D29096_cwchar DB 01H
__26E6E2A9_xtr1common DB 01H
__F5A7E1DF_intrin0@inl@h DB 01H
__50567835_intrin0@h DB 01H
__09FBC026_limits DB 01H
__62F75DE5_metarandom2@h DB 01H
__A3D3E4E8_vcruntime_new@h DB 01H
__8D1A214D_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__497BC13E_crtdefs@h DB 01H
__DDE8D0E0_use_ansi@h DB 01H
__AE7FBCDF_yvals@h DB 01H
__BDF4D0CD_cstddef DB 01H
__E4CFD974_initializer_list DB 01H
__AEA28616_stdint@h DB 01H
__A561EB1D_cstdint DB 01H
__7C4A1519_type_traits DB 01H
__2F328FEB_utility DB 01H
__91F58E7E___msvc_iter_core@hpp DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__183F0A60_cstdlib DB 01H
__54ADA280_cstring DB 01H
__C27AFEEB_xutility DB 01H
__93160BA8_array DB 01H
__722C6D77_MetaString@h DB 01H
__BE6CFB00___msvc_sanitizer_annotate_container@hpp DB 01H
__C51215A0_iosfwd DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__EEF52EF9_eh@h DB 01H
__85F4241F_vcruntime_exception@h DB 01H
__8124AFA8_exception DB 01H
__5003AD96_new DB 01H
__8B28237E_xatomic@h DB 01H
__45A7EC28_xmemory DB 01H
__31746AB4_xstring DB 01H
__1392A162_cctype DB 01H
__C1864A34_string DB 01H
__9D469CC8_common@h DB 01H
__AE454FA2_lmcons@h DB 01H
__67F5F762_mprapidef@h DB 01H
__1F2B86E1_ipifcons@h DB 01H
__EFFE9D94_ifdef@h DB 01H
__AF31E881_ifmib@h DB 01H
__8BC2807C_nldef@h DB 01H
__7ABE0907_ipmib@h DB 01H
__2E95CCCA_tcpmib@h DB 01H
__2798F2DA_udpmib@h DB 01H
__FCC255DB_iprtrmib@h DB 01H
__B01BC3FD_in6addr@h DB 01H
__D834A143_ipexport@h DB 01H
__0A9237D2_time@h DB 01H
__82EB0637_iptypes@h DB 01H
__6063C472_tcpestats@h DB 01H
__63D3B6A5_netioapi@h DB 01H
__D1674A86_iphlpapi@h DB 01H
__F5D3A320_RestartManager@h DB 01H
__AAAC9FBE_TlHelp32@h DB 01H
__9B49ECA4_getapi@h DB 01H
__295B1E01_antihooks@cpp DB 01H
msvcjmc	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	?DisableHooks@@YAXXZ				; DisableHooks
PUBLIC	?removeHooks@@YAXPEAUHINSTANCE__@@@Z		; removeHooks
PUBLIC	?positive_modulo@@YAHHH@Z			; positive_modulo
PUBLIC	?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z	; pGetFileSizeEx
PUBLIC	?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z ; pCreateFileW
PUBLIC	?pCloseHandle@@YAHPEAX@Z			; pCloseHandle
PUBLIC	?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z ; apGetModuleFileNameW
PUBLIC	?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z ; apCreateFileMappingW
PUBLIC	?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z		; apMapViewOfFile
PUBLIC	?apVirtualProtect@@YAHPEAX_KKPEAK@Z		; apVirtualProtect
PUBLIC	?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z	; apLoadLibraryA
PUBLIC	?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z ; apGetProcAddress
PUBLIC	??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?m_memcmp@@YAHPEBX0_K@Z				; m_memcmp
PUBLIC	?Rva2Offset@@YAKK_K@Z				; Rva2Offset
PUBLIC	?ah_isalfanum@@YA_ND@Z				; ah_isalfanum
PUBLIC	?isForwardedFunc@@YA_NPEBX@Z			; isForwardedFunc
PUBLIC	??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll@		; `string'
PUBLIC	??_C@_0L@EANHMAHB@ws2_32?4dll@			; `string'
PUBLIC	??_C@_0N@DOHINHCI@Advapi32?4dll@		; `string'
PUBLIC	??_C@_09FLKFJBLM@ntdll?4dll@			; `string'
PUBLIC	??_C@_0N@NKKEACFL@Rstrtmgr?4dll@		; `string'
PUBLIC	??_C@_09MDJBOJHM@Ole32?4dll@			; `string'
PUBLIC	??_C@_0N@BHPCGNMJ@OleAut32?4dll@		; `string'
PUBLIC	??_C@_0N@NKMBPHLD@Netapi32?4dll@		; `string'
PUBLIC	??_C@_0N@KCFEDKNO@Iphlpapi?4dll@		; `string'
PUBLIC	??_C@_0M@OHCDEFLB@Shlwapi?4dll@			; `string'
PUBLIC	??_C@_0M@LNAMDANG@Shell32?4dll@			; `string'
EXTRN	memcpy:PROC
EXTRN	?SetRestartManagerLoaded@getapi@@YAXH@Z:PROC	; getapi::SetRestartManagerLoaded
EXTRN	?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z:PROC	; getapi::GetProcAddressEx2
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DisableHooks@@YAXXZ DD imagerel $LN14
	DD	imagerel $LN14+715
	DD	imagerel $unwind$?DisableHooks@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD imagerel $LN24
	DD	imagerel $LN24+1457
	DD	imagerel $unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?positive_modulo@@YAHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?positive_modulo@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+145
	DD	imagerel $unwind$?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pCloseHandle@@YAHPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?pCloseHandle@@YAHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z DD imagerel $LN3
	DD	imagerel $LN3+103
	DD	imagerel $unwind$?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+137
	DD	imagerel $unwind$?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apVirtualProtect@@YAHPEAX_KKPEAK@Z DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$?apVirtualProtect@@YAHPEAX_KKPEAK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+542
	DD	imagerel $unwind$??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+500
	DD	imagerel $unwind$??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+500
	DD	imagerel $unwind$??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+584
	DD	imagerel $unwind$??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+584
	DD	imagerel $unwind$??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?m_memcmp@@YAHPEBX0_K@Z DD imagerel $LN10
	DD	imagerel $LN10+225
	DD	imagerel $unwind$?m_memcmp@@YAHPEBX0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Rva2Offset@@YAKK_K@Z DD imagerel $LN12
	DD	imagerel $LN12+422
	DD	imagerel $unwind$?Rva2Offset@@YAKK_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ah_isalfanum@@YA_ND@Z DD imagerel $LN8
	DD	imagerel $LN8+148
	DD	imagerel $unwind$?ah_isalfanum@@YA_ND@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isForwardedFunc@@YA_NPEBX@Z DD imagerel $LN7
	DD	imagerel $LN7+192
	DD	imagerel $unwind$?isForwardedFunc@@YA_NPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0M@LNAMDANG@Shell32?4dll@
CONST	SEGMENT
??_C@_0M@LNAMDANG@Shell32?4dll@ DB 'Shell32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHCDEFLB@Shlwapi?4dll@
CONST	SEGMENT
??_C@_0M@OHCDEFLB@Shlwapi?4dll@ DB 'Shlwapi.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCFEDKNO@Iphlpapi?4dll@
CONST	SEGMENT
??_C@_0N@KCFEDKNO@Iphlpapi?4dll@ DB 'Iphlpapi.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKMBPHLD@Netapi32?4dll@
CONST	SEGMENT
??_C@_0N@NKMBPHLD@Netapi32?4dll@ DB 'Netapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BHPCGNMJ@OleAut32?4dll@
CONST	SEGMENT
??_C@_0N@BHPCGNMJ@OleAut32?4dll@ DB 'OleAut32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MDJBOJHM@Ole32?4dll@
CONST	SEGMENT
??_C@_09MDJBOJHM@Ole32?4dll@ DB 'Ole32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKKEACFL@Rstrtmgr?4dll@
CONST	SEGMENT
??_C@_0N@NKKEACFL@Rstrtmgr?4dll@ DB 'Rstrtmgr.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLKFJBLM@ntdll?4dll@
CONST	SEGMENT
??_C@_09FLKFJBLM@ntdll?4dll@ DB 'ntdll.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOHINHCI@Advapi32?4dll@
CONST	SEGMENT
??_C@_0N@DOHINHCI@Advapi32?4dll@ DB 'Advapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EANHMAHB@ws2_32?4dll@
CONST	SEGMENT
??_C@_0L@EANHMAHB@ws2_32?4dll@ DB 'ws2_32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll@ DB 'kernel32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isForwardedFunc@@YA_NPEBX@Z DD 025051301H
	DD	010e2313H
	DD	07007002dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ah_isalfanum@@YA_ND@Z DD 025051201H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Rva2Offset@@YAKK_K@Z DD 025051701H
	DD	01122317H
	DD	0700b0035H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?m_memcmp@@YAHPEBX0_K@Z DD 025051d01H
	DD	0118231dH
	DD	07011002dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	022dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	022dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01d9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01d9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0203H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apVirtualProtect@@YAHPEAX_KKPEAK@Z DD 025052201H
	DD	011d2322H
	DD	070160021H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z DD 035052101H
	DD	011c3321H
	DD	070150023H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z DD 035052201H
	DD	011d3322H
	DD	070160023H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z DD 025051d01H
	DD	0118231dH
	DD	070110021H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCloseHandle@@YAHPEAX@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z DD 045052101H
	DD	011c4321H
	DD	070150025H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?positive_modulo@@YAHHH@Z DD 025051601H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	07eH
	DW	088H
	DW	024fH
	DW	0279H
	DW	0598H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?removeHooks@@YAXPEAUHINSTANCE__@@@Z DD 045053d19H
	DD	010e4313H
	DD	0700700fdH
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	07d8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$0 DB 06dH	; removeHooks
	DB	06fH
	DB	064H
	DB	075H
	DB	06cH
	DB	065H
	DB	052H
	DB	065H
	DB	061H
	DB	06cH
	DB	050H
	DB	061H
	DB	074H
	DB	068H
	DB	00H
	ORG $+1
?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$1 DB 04cH	; removeHooks
	DB	061H
	DB	072H
	DB	067H
	DB	065H
	DB	049H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+7
?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$2 DB 06fH	; removeHooks
	DB	06cH
	DB	064H
	DB	050H
	DB	072H
	DB	06fH
	DB	074H
	DB	065H
	DB	063H
	DB	074H
	DB	00H
	ORG $+5
?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$3 DB 06fH	; removeHooks
	DB	06cH
	DB	064H
	DB	050H
	DB	072H
	DB	06fH
	DB	074H
	DB	065H
	DB	063H
	DB	074H
	DB	031H
	DB	00H
	ORG $+4
?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcVarDesc DD 0554H ; removeHooks
	DD	04H
	DQ	FLAT:?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$3
	DD	0534H
	DD	04H
	DQ	FLAT:?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$2
	DD	0458H
	DD	08H
	DQ	FLAT:?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$1
	DD	0150H
	DD	0208H
	DQ	FLAT:?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcName$0
	ORG $+192
?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcFrameData DD 04H ; removeHooks
	DD	00H
	DQ	FLAT:?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DisableHooks@@YAXXZ DD 025050f01H
	DD	010a230fH
	DD	0700300a3H
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 41	 sub	 eax, 65			; 00000041H
  0002d	6b c0 c1	 imul	 eax, eax, -63		; ffffffffffffffc1H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	8d 44 00 41	 lea	 eax, DWORD PTR [rax+rax+65]
  0002e	99		 cdq
  0002f	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00034	f7 f9		 idiv	 ecx
  00036	8b c2		 mov	 eax, edx

; 76   :     }

  00038	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0003f	5f		 pop	 rdi
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?isForwardedFunc@@YA_NPEBX@Z
_TEXT	SEGMENT
func$ = 8
max_check$ = 36
forwarder$ = 68
i$1 = 100
funcAddr$ = 352
?isForwardedFunc@@YA_NPEBX@Z PROC			; isForwardedFunc, COMDAT

; 165  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__295B1E01_antihooks@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 166  :     char* func = (char*)funcAddr;

  0001f	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR funcAddr$[rbp]
  00026	48 89 45 08	 mov	 QWORD PTR func$[rbp], rax

; 167  :     const int max_check = 128;

  0002a	c7 45 24 80 00
	00 00		 mov	 DWORD PTR max_check$[rbp], 128 ; 00000080H

; 168  :     bool forwarder = true;

  00031	c6 45 44 01	 mov	 BYTE PTR forwarder$[rbp], 1

; 169  : 
; 170  :     for (int i = 0; func[i] && i < max_check; ++i) {

  00035	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$1[rbp], 0
  0003c	eb 08		 jmp	 SHORT $LN4@isForwarde
$LN2@isForwarde:
  0003e	8b 45 64	 mov	 eax, DWORD PTR i$1[rbp]
  00041	ff c0		 inc	 eax
  00043	89 45 64	 mov	 DWORD PTR i$1[rbp], eax
$LN4@isForwarde:
  00046	48 63 45 64	 movsxd	 rax, DWORD PTR i$1[rbp]
  0004a	48 8b 4d 08	 mov	 rcx, QWORD PTR func$[rbp]
  0004e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00052	85 c0		 test	 eax, eax
  00054	74 5c		 je	 SHORT $LN3@isForwarde
  00056	81 7d 64 80 00
	00 00		 cmp	 DWORD PTR i$1[rbp], 128	; 00000080H
  0005d	7d 53		 jge	 SHORT $LN3@isForwarde

; 171  : 
; 172  :         if (!(ah_isalfanum(func[i]) || func[i] == '.' || func[i] == '_' || func[i] == '-')) {

  0005f	48 63 45 64	 movsxd	 rax, DWORD PTR i$1[rbp]
  00063	48 8b 4d 08	 mov	 rcx, QWORD PTR func$[rbp]
  00067	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0006b	e8 00 00 00 00	 call	 ?ah_isalfanum@@YA_ND@Z	; ah_isalfanum
  00070	0f b6 c0	 movzx	 eax, al
  00073	85 c0		 test	 eax, eax
  00075	75 39		 jne	 SHORT $LN5@isForwarde
  00077	48 63 45 64	 movsxd	 rax, DWORD PTR i$1[rbp]
  0007b	48 8b 4d 08	 mov	 rcx, QWORD PTR func$[rbp]
  0007f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00083	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00086	74 28		 je	 SHORT $LN5@isForwarde
  00088	48 63 45 64	 movsxd	 rax, DWORD PTR i$1[rbp]
  0008c	48 8b 4d 08	 mov	 rcx, QWORD PTR func$[rbp]
  00090	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00094	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00097	74 17		 je	 SHORT $LN5@isForwarde
  00099	48 63 45 64	 movsxd	 rax, DWORD PTR i$1[rbp]
  0009d	48 8b 4d 08	 mov	 rcx, QWORD PTR func$[rbp]
  000a1	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000a5	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000a8	74 06		 je	 SHORT $LN5@isForwarde

; 173  :             forwarder = false;

  000aa	c6 45 44 00	 mov	 BYTE PTR forwarder$[rbp], 0

; 174  :             break;

  000ae	eb 02		 jmp	 SHORT $LN3@isForwarde
$LN5@isForwarde:

; 175  :         }
; 176  :     }

  000b0	eb 8c		 jmp	 SHORT $LN2@isForwarde
$LN3@isForwarde:

; 177  : 
; 178  :     return forwarder;

  000b2	0f b6 45 44	 movzx	 eax, BYTE PTR forwarder$[rbp]

; 179  : }

  000b6	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000bd	5f		 pop	 rdi
  000be	5d		 pop	 rbp
  000bf	c3		 ret	 0
?isForwardedFunc@@YA_NPEBX@Z ENDP			; isForwardedFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?ah_isalfanum@@YA_ND@Z
_TEXT	SEGMENT
res$ = 4
tv76 = 212
C$ = 256
?ah_isalfanum@@YA_ND@Z PROC				; ah_isalfanum, COMDAT

; 159  : {

$LN8:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__295B1E01_antihooks@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 160  :     bool res = (C >= 'a' && C <= 'z') || (C >= 'A' && C <= 'Z') || (C >= '0' && C <= '9');

  0001e	0f be 85 00 01
	00 00		 movsx	 eax, BYTE PTR C$[rbp]
  00025	83 f8 61	 cmp	 eax, 97			; 00000061H
  00028	7c 0c		 jl	 SHORT $LN3@ah_isalfan
  0002a	0f be 85 00 01
	00 00		 movsx	 eax, BYTE PTR C$[rbp]
  00031	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00034	7e 3c		 jle	 SHORT $LN5@ah_isalfan
$LN3@ah_isalfan:
  00036	0f be 85 00 01
	00 00		 movsx	 eax, BYTE PTR C$[rbp]
  0003d	83 f8 41	 cmp	 eax, 65			; 00000041H
  00040	7c 0c		 jl	 SHORT $LN4@ah_isalfan
  00042	0f be 85 00 01
	00 00		 movsx	 eax, BYTE PTR C$[rbp]
  00049	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  0004c	7e 24		 jle	 SHORT $LN5@ah_isalfan
$LN4@ah_isalfan:
  0004e	0f be 85 00 01
	00 00		 movsx	 eax, BYTE PTR C$[rbp]
  00055	83 f8 30	 cmp	 eax, 48			; 00000030H
  00058	7c 0c		 jl	 SHORT $LN6@ah_isalfan
  0005a	0f be 85 00 01
	00 00		 movsx	 eax, BYTE PTR C$[rbp]
  00061	83 f8 39	 cmp	 eax, 57			; 00000039H
  00064	7e 0c		 jle	 SHORT $LN5@ah_isalfan
$LN6@ah_isalfan:
  00066	c7 85 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR tv76[rbp], 0
  00070	eb 0a		 jmp	 SHORT $LN7@ah_isalfan
$LN5@ah_isalfan:
  00072	c7 85 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR tv76[rbp], 1
$LN7@ah_isalfan:
  0007c	0f b6 85 d4 00
	00 00		 movzx	 eax, BYTE PTR tv76[rbp]
  00083	88 45 04	 mov	 BYTE PTR res$[rbp], al

; 161  :     return res;

  00086	0f b6 45 04	 movzx	 eax, BYTE PTR res$[rbp]

; 162  : }

  0008a	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00091	5f		 pop	 rdi
  00092	5d		 pop	 rbp
  00093	c3		 ret	 0
?ah_isalfanum@@YA_ND@Z ENDP				; ah_isalfanum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?Rva2Offset@@YAKK_K@Z
_TEXT	SEGMENT
wIndex$ = 4
wNumberOfSections$ = 36
pSectionHeader$ = 72
pNtHeaders$ = 104
pNtHeaders32$1 = 136
pNtHeaders64$2 = 168
dwRva$ = 416
uiBaseAddress$ = 424
?Rva2Offset@@YAKK_K@Z PROC				; Rva2Offset, COMDAT

; 114  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__295B1E01_antihooks@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 115  :     WORD wIndex = 0;

  00023	33 c0		 xor	 eax, eax
  00025	66 89 45 04	 mov	 WORD PTR wIndex$[rbp], ax

; 116  :     WORD wNumberOfSections = 0;

  00029	33 c0		 xor	 eax, eax
  0002b	66 89 45 24	 mov	 WORD PTR wNumberOfSections$[rbp], ax

; 117  :     PIMAGE_SECTION_HEADER pSectionHeader = NULL;

  0002f	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR pSectionHeader$[rbp], 0

; 118  : 
; 119  :     PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew);

  00037	48 8b 85 a8 01
	00 00		 mov	 rax, QWORD PTR uiBaseAddress$[rbp]
  0003e	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00042	48 8b 8d a8 01
	00 00		 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  00049	48 03 c8	 add	 rcx, rax
  0004c	48 8b c1	 mov	 rax, rcx
  0004f	48 89 45 68	 mov	 QWORD PTR pNtHeaders$[rbp], rax

; 120  : 
; 121  :     if (pNtHeaders->OptionalHeader.Magic == 0x010B) {

  00053	48 8b 45 68	 mov	 rax, QWORD PTR pNtHeaders$[rbp]
  00057	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  0005b	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  00060	75 37		 jne	 SHORT $LN5@Rva2Offset

; 122  : 
; 123  :         // PE32
; 124  : 
; 125  :         PIMAGE_NT_HEADERS32 pNtHeaders32 = (PIMAGE_NT_HEADERS32)pNtHeaders;

  00062	48 8b 45 68	 mov	 rax, QWORD PTR pNtHeaders$[rbp]
  00066	48 89 85 88 00
	00 00		 mov	 QWORD PTR pNtHeaders32$1[rbp], rax

; 126  :         pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&pNtHeaders32->OptionalHeader) + pNtHeaders32->FileHeader.SizeOfOptionalHeader);

  0006d	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR pNtHeaders32$1[rbp]
  00074	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  00078	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR pNtHeaders32$1[rbp]
  0007f	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  00084	48 89 45 48	 mov	 QWORD PTR pSectionHeader$[rbp], rax

; 127  :         wNumberOfSections = pNtHeaders32->FileHeader.NumberOfSections;

  00088	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR pNtHeaders32$1[rbp]
  0008f	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00093	66 89 45 24	 mov	 WORD PTR wNumberOfSections$[rbp], ax

; 128  :     }

  00097	eb 4d		 jmp	 SHORT $LN6@Rva2Offset
$LN5@Rva2Offset:

; 129  :     else {
; 130  :         if (pNtHeaders->OptionalHeader.Magic == 0x020B) {

  00099	48 8b 45 68	 mov	 rax, QWORD PTR pNtHeaders$[rbp]
  0009d	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  000a1	3d 0b 02 00 00	 cmp	 eax, 523		; 0000020bH
  000a6	75 37		 jne	 SHORT $LN7@Rva2Offset

; 131  : 
; 132  :             // PE64
; 133  : 
; 134  :             PIMAGE_NT_HEADERS64 pNtHeaders64 = (PIMAGE_NT_HEADERS64)pNtHeaders;

  000a8	48 8b 45 68	 mov	 rax, QWORD PTR pNtHeaders$[rbp]
  000ac	48 89 85 a8 00
	00 00		 mov	 QWORD PTR pNtHeaders64$2[rbp], rax

; 135  :             pSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&pNtHeaders64->OptionalHeader) + pNtHeaders64->FileHeader.SizeOfOptionalHeader);

  000b3	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR pNtHeaders64$2[rbp]
  000ba	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  000be	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR pNtHeaders64$2[rbp]
  000c5	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  000ca	48 89 45 48	 mov	 QWORD PTR pSectionHeader$[rbp], rax

; 136  :             wNumberOfSections = pNtHeaders64->FileHeader.NumberOfSections;

  000ce	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR pNtHeaders64$2[rbp]
  000d5	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  000d9	66 89 45 24	 mov	 WORD PTR wNumberOfSections$[rbp], ax

; 137  :         }

  000dd	eb 07		 jmp	 SHORT $LN8@Rva2Offset
$LN7@Rva2Offset:

; 138  :         else
; 139  :         {
; 140  :             return 0;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 b6 00 00 00	 jmp	 $LN1@Rva2Offset
$LN8@Rva2Offset:
$LN6@Rva2Offset:

; 141  :         }
; 142  :     }
; 143  : 
; 144  :     if (dwRva < pSectionHeader[0].PointerToRawData)

  000e6	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  000eb	48 6b c0 00	 imul	 rax, rax, 0
  000ef	48 8b 4d 48	 mov	 rcx, QWORD PTR pSectionHeader$[rbp]
  000f3	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  000f7	39 85 a0 01 00
	00		 cmp	 DWORD PTR dwRva$[rbp], eax
  000fd	73 0b		 jae	 SHORT $LN9@Rva2Offset

; 145  :         return dwRva;

  000ff	8b 85 a0 01 00
	00		 mov	 eax, DWORD PTR dwRva$[rbp]
  00105	e9 92 00 00 00	 jmp	 $LN1@Rva2Offset
$LN9@Rva2Offset:

; 146  : 
; 147  :     for (wIndex = 0; wIndex < wNumberOfSections; wIndex++) {

  0010a	33 c0		 xor	 eax, eax
  0010c	66 89 45 04	 mov	 WORD PTR wIndex$[rbp], ax
  00110	eb 0b		 jmp	 SHORT $LN4@Rva2Offset
$LN2@Rva2Offset:
  00112	0f b7 45 04	 movzx	 eax, WORD PTR wIndex$[rbp]
  00116	66 ff c0	 inc	 ax
  00119	66 89 45 04	 mov	 WORD PTR wIndex$[rbp], ax
$LN4@Rva2Offset:
  0011d	0f b7 45 04	 movzx	 eax, WORD PTR wIndex$[rbp]
  00121	0f b7 4d 24	 movzx	 ecx, WORD PTR wNumberOfSections$[rbp]
  00125	3b c1		 cmp	 eax, ecx
  00127	7d 71		 jge	 SHORT $LN3@Rva2Offset

; 148  : 
; 149  :         if (dwRva >= pSectionHeader[wIndex].VirtualAddress && dwRva < (pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].SizeOfRawData)) {

  00129	0f b7 45 04	 movzx	 eax, WORD PTR wIndex$[rbp]
  0012d	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00131	48 8b 4d 48	 mov	 rcx, QWORD PTR pSectionHeader$[rbp]
  00135	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00139	39 85 a0 01 00
	00		 cmp	 DWORD PTR dwRva$[rbp], eax
  0013f	72 54		 jb	 SHORT $LN10@Rva2Offset
  00141	0f b7 45 04	 movzx	 eax, WORD PTR wIndex$[rbp]
  00145	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00149	0f b7 4d 04	 movzx	 ecx, WORD PTR wIndex$[rbp]
  0014d	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  00151	48 8b 55 48	 mov	 rdx, QWORD PTR pSectionHeader$[rbp]
  00155	8b 44 02 0c	 mov	 eax, DWORD PTR [rdx+rax+12]
  00159	48 8b 55 48	 mov	 rdx, QWORD PTR pSectionHeader$[rbp]
  0015d	03 44 0a 10	 add	 eax, DWORD PTR [rdx+rcx+16]
  00161	39 85 a0 01 00
	00		 cmp	 DWORD PTR dwRva$[rbp], eax
  00167	73 2c		 jae	 SHORT $LN10@Rva2Offset

; 150  : 
; 151  :             return (dwRva - pSectionHeader[wIndex].VirtualAddress + pSectionHeader[wIndex].PointerToRawData);

  00169	0f b7 45 04	 movzx	 eax, WORD PTR wIndex$[rbp]
  0016d	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00171	48 8b 4d 48	 mov	 rcx, QWORD PTR pSectionHeader$[rbp]
  00175	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00179	8b 8d a0 01 00
	00		 mov	 ecx, DWORD PTR dwRva$[rbp]
  0017f	2b c8		 sub	 ecx, eax
  00181	8b c1		 mov	 eax, ecx
  00183	0f b7 4d 04	 movzx	 ecx, WORD PTR wIndex$[rbp]
  00187	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0018b	48 8b 55 48	 mov	 rdx, QWORD PTR pSectionHeader$[rbp]
  0018f	03 44 0a 14	 add	 eax, DWORD PTR [rdx+rcx+20]
  00193	eb 07		 jmp	 SHORT $LN1@Rva2Offset
$LN10@Rva2Offset:

; 152  :         }
; 153  :     }

  00195	e9 78 ff ff ff	 jmp	 $LN2@Rva2Offset
$LN3@Rva2Offset:

; 154  : 
; 155  :     return 0;

  0019a	33 c0		 xor	 eax, eax
$LN1@Rva2Offset:

; 156  : }

  0019c	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  001a3	5f		 pop	 rdi
  001a4	5d		 pop	 rbp
  001a5	c3		 ret	 0
?Rva2Offset@@YAKK_K@Z ENDP				; Rva2Offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?m_memcmp@@YAHPEBX0_K@Z
_TEXT	SEGMENT
p1$ = 8
p2$ = 40
rc$ = 68
i$1 = 104
buf1$ = 352
buf2$ = 360
count$ = 368
?m_memcmp@@YAHPEBX0_K@Z PROC				; m_memcmp, COMDAT

; 81   : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__295B1E01_antihooks@cpp
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 82   :     if (!buf1 || !buf2)

  00029	48 83 bd 60 01
	00 00 00	 cmp	 QWORD PTR buf1$[rbp], 0
  00031	74 0a		 je	 SHORT $LN6@m_memcmp
  00033	48 83 bd 68 01
	00 00 00	 cmp	 QWORD PTR buf2$[rbp], 0
  0003b	75 0a		 jne	 SHORT $LN5@m_memcmp
$LN6@m_memcmp:

; 83   :     {
; 84   :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	e9 90 00 00 00	 jmp	 $LN1@m_memcmp
$LN5@m_memcmp:

; 85   :     }
; 86   : 
; 87   :     unsigned char* p1 = (unsigned char*)buf1;

  00047	48 8b 85 60 01
	00 00		 mov	 rax, QWORD PTR buf1$[rbp]
  0004e	48 89 45 08	 mov	 QWORD PTR p1$[rbp], rax

; 88   :     unsigned char* p2 = (unsigned char*)buf2;

  00052	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR buf2$[rbp]
  00059	48 89 45 28	 mov	 QWORD PTR p2$[rbp], rax

; 89   : 
; 90   :     int   rc = 0;

  0005d	c7 45 44 00 00
	00 00		 mov	 DWORD PTR rc$[rbp], 0

; 91   : 
; 92   :     for (size_t i = 0; i < count; i++)

  00064	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0006c	eb 0b		 jmp	 SHORT $LN4@m_memcmp
$LN2@m_memcmp:
  0006e	48 8b 45 68	 mov	 rax, QWORD PTR i$1[rbp]
  00072	48 ff c0	 inc	 rax
  00075	48 89 45 68	 mov	 QWORD PTR i$1[rbp], rax
$LN4@m_memcmp:
  00079	48 8b 85 70 01
	00 00		 mov	 rax, QWORD PTR count$[rbp]
  00080	48 39 45 68	 cmp	 QWORD PTR i$1[rbp], rax
  00084	73 4e		 jae	 SHORT $LN3@m_memcmp

; 93   :     {
; 94   :         if (*p1 < *p2)

  00086	48 8b 45 08	 mov	 rax, QWORD PTR p1$[rbp]
  0008a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008d	48 8b 4d 28	 mov	 rcx, QWORD PTR p2$[rbp]
  00091	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00094	3b c1		 cmp	 eax, ecx
  00096	7d 09		 jge	 SHORT $LN7@m_memcmp

; 95   :         {
; 96   :             rc = -1;

  00098	c7 45 44 ff ff
	ff ff		 mov	 DWORD PTR rc$[rbp], -1

; 97   :             break;

  0009f	eb 33		 jmp	 SHORT $LN3@m_memcmp
$LN7@m_memcmp:

; 98   :         }
; 99   : 
; 100  :         if (*p1 > * p2)

  000a1	48 8b 45 08	 mov	 rax, QWORD PTR p1$[rbp]
  000a5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a8	48 8b 4d 28	 mov	 rcx, QWORD PTR p2$[rbp]
  000ac	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000af	3b c1		 cmp	 eax, ecx
  000b1	7e 09		 jle	 SHORT $LN8@m_memcmp

; 101  :         {
; 102  :             rc = 1;

  000b3	c7 45 44 01 00
	00 00		 mov	 DWORD PTR rc$[rbp], 1

; 103  :             break;

  000ba	eb 18		 jmp	 SHORT $LN3@m_memcmp
$LN8@m_memcmp:

; 104  :         }
; 105  : 
; 106  :         p1++;

  000bc	48 8b 45 08	 mov	 rax, QWORD PTR p1$[rbp]
  000c0	48 ff c0	 inc	 rax
  000c3	48 89 45 08	 mov	 QWORD PTR p1$[rbp], rax

; 107  :         p2++;

  000c7	48 8b 45 28	 mov	 rax, QWORD PTR p2$[rbp]
  000cb	48 ff c0	 inc	 rax
  000ce	48 89 45 28	 mov	 QWORD PTR p2$[rbp], rax

; 108  :     }

  000d2	eb 9a		 jmp	 SHORT $LN2@m_memcmp
$LN3@m_memcmp:

; 109  : 
; 110  :     return rc;

  000d4	8b 45 44	 mov	 eax, DWORD PTR rc$[rbp]
$LN1@m_memcmp:

; 111  : }

  000d7	48 8d a5 48 01
	00 00		 lea	 rsp, QWORD PTR [rbp+328]
  000de	5f		 pop	 rdi
  000df	5d		 pop	 rbp
  000e0	c3		 ret	 0
?m_memcmp@@YAHPEBX0_K@Z ENDP				; m_memcmp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 0e	 sub	 eax, 14
  0002d	6b c0 09	 imul	 eax, eax, 9
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 71	 imul	 eax, eax, 113		; 00000071H
  0002d	83 c0 0e	 add	 eax, 14
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0c	 cmp	 QWORD PTR i$1[rbp], 12
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv182 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0022d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00231	88 85 c0 00 00
	00		 mov	 BYTE PTR tv182[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00237	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0023e	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00245	5f		 pop	 rdi
  00246	5d		 pop	 rbp
  00247	c3		 ret	 0
??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 4b	 sub	 eax, 75			; 0000004bH
  0002d	6b c0 e5	 imul	 eax, eax, -27
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 2f	 imul	 eax, eax, 47		; 0000002fH
  0002d	83 c0 4b	 add	 eax, 75			; 0000004bH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0c	 cmp	 QWORD PTR i$1[rbp], 12
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv182 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0022d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00231	88 85 c0 00 00
	00		 mov	 BYTE PTR tv182[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00237	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0023e	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00245	5f		 pop	 rdi
  00246	5d		 pop	 rbp
  00247	c3		 ret	 0
??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 50	 sub	 eax, 80			; 00000050H
  0002d	6b c0 ee	 imul	 eax, eax, -18
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 07	 imul	 eax, eax, 7
  0002d	83 c0 50	 add	 eax, 80			; 00000050H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 71	 sub	 eax, 113		; 00000071H
  0002d	6b c0 f5	 imul	 eax, eax, -11
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 17	 imul	 eax, eax, 23
  0002d	83 c0 71	 add	 eax, 113		; 00000071H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 06	 sub	 eax, 6
  0002d	6b c0 19	 imul	 eax, eax, 25
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 3d	 imul	 eax, eax, 61		; 0000003dH
  0002d	83 c0 06	 add	 eax, 6
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 5f	 sub	 eax, 95			; 0000005fH
  0002d	6b c0 1f	 imul	 eax, eax, 31
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 29	 imul	 eax, eax, 41		; 00000029H
  0002d	83 c0 5f	 add	 eax, 95			; 0000005fH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0a	 cmp	 QWORD PTR i$1[rbp], 10
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv168 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001d9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001dd	88 85 c0 00 00
	00		 mov	 BYTE PTR tv168[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  001e3	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001ea	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  001f1	5f		 pop	 rdi
  001f2	5d		 pop	 rbp
  001f3	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 56	 sub	 eax, 86			; 00000056H
  0002d	6b c0 e8	 imul	 eax, eax, -24
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 25	 imul	 eax, eax, 37		; 00000025H
  0002d	83 c0 56	 add	 eax, 86			; 00000056H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 3f	 sub	 eax, 63			; 0000003fH
  0002d	6b c0 25	 imul	 eax, eax, 37		; 00000025H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 67	 imul	 eax, eax, 103		; 00000067H
  0002d	83 c0 3f	 add	 eax, 63			; 0000003fH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0a	 cmp	 QWORD PTR i$1[rbp], 10
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv168 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001d9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001dd	88 85 c0 00 00
	00		 mov	 BYTE PTR tv168[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  001e3	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001ea	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  001f1	5f		 pop	 rdi
  001f2	5d		 pop	 rbp
  001f3	c3		 ret	 0
??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 6e	 sub	 eax, 110		; 0000006eH
  0002d	6b c0 0c	 imul	 eax, eax, 12
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 35	 imul	 eax, eax, 53		; 00000035H
  0002d	83 c0 6e	 add	 eax, 110		; 0000006eH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 3b	 sub	 eax, 59			; 0000003bH
  0002d	6b c0 d8	 imul	 eax, eax, -40		; ffffffffffffffd8H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 49	 imul	 eax, eax, 73		; 00000049H
  0002d	83 c0 3b	 add	 eax, 59			; 0000003bH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0b	 cmp	 QWORD PTR i$1[rbp], 11
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ PROC ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ENDP ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv175 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00203	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00207	88 85 c0 00 00
	00		 mov	 BYTE PTR tv175[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  0020d	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00214	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0021b	5f		 pop	 rdi
  0021c	5d		 pop	 rbp
  0021d	c3		 ret	 0
??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 78	 sub	 eax, 120		; 00000078H
  0002d	6b c0 09	 imul	 eax, eax, 9
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 71	 imul	 eax, eax, 113		; 00000071H
  0002d	83 c0 78	 add	 eax, 120		; 00000078H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z
_TEXT	SEGMENT
pFunction$ = 8
hModule$ = 256
lpProcName$ = 264
?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z PROC ; apGetProcAddress, COMDAT

; 1276 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1277 : 	FARPROC(WINAPI * pFunction)(HMODULE, LPCSTR);
; 1278 : 	pFunction = (FARPROC(WINAPI*)(HMODULE, LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xb6a6d4a2, 3);

  00024	41 b9 03 00 00
	00		 mov	 r9d, 3
  0002a	41 b8 a2 d4 a6
	b6		 mov	 r8d, -1230580574	; b6a6d4a2H
  00030	ba 0f 00 00 00	 mov	 edx, 15
  00035	33 c9		 xor	 ecx, ecx
  00037	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  0003c	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 1279 : 	return pFunction(hModule, lpProcName);

  00040	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR lpProcName$[rbp]
  00047	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR hModule$[rbp]
  0004e	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 1280 : }

  00051	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00058	5f		 pop	 rdi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z ENDP ; apGetProcAddress
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z
_TEXT	SEGMENT
pFunction$ = 8
lpLibFileName$ = 256
?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z PROC		; apLoadLibraryA, COMDAT

; 1263 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1264 : 	HMODULE(WINAPI * pFunction)(LPCSTR);
; 1265 : 	pFunction = (HMODULE(WINAPI*)(LPCSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x439c7e33, 4);

  0001f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00025	41 b8 33 7e 9c
	43		 mov	 r8d, 1134329395		; 439c7e33H
  0002b	ba 0f 00 00 00	 mov	 edx, 15
  00030	33 c9		 xor	 ecx, ecx
  00032	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00037	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 1266 : 	return pFunction(lpLibFileName);

  0003b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR lpLibFileName$[rbp]
  00042	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 1267 : }

  00045	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ENDP		; apLoadLibraryA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apVirtualProtect@@YAHPEAX_KKPEAK@Z
_TEXT	SEGMENT
pFunction$ = 8
lpAddress$ = 256
dwSize$ = 264
flNewProtect$ = 272
lpflOldProtect$ = 280
?apVirtualProtect@@YAHPEAX_KKPEAK@Z PROC		; apVirtualProtect, COMDAT

; 1251 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1252 : 	BOOL(WINAPI * pFunction)(LPVOID, SIZE_T, DWORD, PDWORD);
; 1253 : 	pFunction = (BOOL(WINAPI*)(LPVOID, SIZE_T, DWORD, PDWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x00a7e8a5, 5);

  0002e	41 b9 05 00 00
	00		 mov	 r9d, 5
  00034	41 b8 a5 e8 a7
	00		 mov	 r8d, 11004069		; 00a7e8a5H
  0003a	ba 0f 00 00 00	 mov	 edx, 15
  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00046	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 1254 : 	return pFunction(lpAddress, dwSize, flNewProtect, lpflOldProtect);

  0004a	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR lpflOldProtect$[rbp]
  00051	44 8b 85 10 01
	00 00		 mov	 r8d, DWORD PTR flNewProtect$[rbp]
  00058	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR dwSize$[rbp]
  0005f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR lpAddress$[rbp]
  00066	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 1255 : }

  00069	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00070	5f		 pop	 rdi
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
?apVirtualProtect@@YAHPEAX_KKPEAK@Z ENDP		; apVirtualProtect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z
_TEXT	SEGMENT
pFunction$ = 8
hFileMappingObject$ = 256
dwDesiredAccess$ = 264
dwFileOffsetHigh$ = 272
dwFileOffsetLow$ = 280
dwNumberOfBytesToMap$ = 288
?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z PROC		; apMapViewOfFile, COMDAT

; 1236 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001c	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1237 : 	LPVOID(WINAPI * pFunction)(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
; 1238 : 	pFunction = (LPVOID(WINAPI*)(HANDLE, DWORD, DWORD, DWORD, SIZE_T))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x0ab3c572, 6);

  0002d	41 b9 06 00 00
	00		 mov	 r9d, 6
  00033	41 b8 72 c5 b3
	0a		 mov	 r8d, 179553650		; 0ab3c572H
  00039	ba 0f 00 00 00	 mov	 edx, 15
  0003e	33 c9		 xor	 ecx, ecx
  00040	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00045	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 1239 : 	return pFunction(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);

  00049	48 8b 85 20 01
	00 00		 mov	 rax, QWORD PTR dwNumberOfBytesToMap$[rbp]
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	44 8b 8d 18 01
	00 00		 mov	 r9d, DWORD PTR dwFileOffsetLow$[rbp]
  0005c	44 8b 85 10 01
	00 00		 mov	 r8d, DWORD PTR dwFileOffsetHigh$[rbp]
  00063	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR dwDesiredAccess$[rbp]
  00069	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR hFileMappingObject$[rbp]
  00070	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 1240 : }

  00073	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0007a	5f		 pop	 rdi
  0007b	5d		 pop	 rbp
  0007c	c3		 ret	 0
?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z ENDP		; apMapViewOfFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z
_TEXT	SEGMENT
pFunction$ = 8
hFile$ = 256
lpFileMappingAttributes$ = 264
flProtect$ = 272
dwMaximumSizeHigh$ = 280
dwMaximumSizeLow$ = 288
lpName$ = 296
?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z PROC ; apCreateFileMappingW, COMDAT

; 1220 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1221 : 	HANDLE(WINAPI * pFunction)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR);
; 1222 : 	pFunction = (HANDLE(WINAPI*)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x90b93fda, 7);

  0002e	41 b9 07 00 00
	00		 mov	 r9d, 7
  00034	41 b8 da 3f b9
	90		 mov	 r8d, -1866907686	; 90b93fdaH
  0003a	ba 0f 00 00 00	 mov	 edx, 15
  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00046	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 1223 : 	return pFunction(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

  0004a	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR lpName$[rbp]
  00051	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00056	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR dwMaximumSizeLow$[rbp]
  0005c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00060	44 8b 8d 18 01
	00 00		 mov	 r9d, DWORD PTR dwMaximumSizeHigh$[rbp]
  00067	44 8b 85 10 01
	00 00		 mov	 r8d, DWORD PTR flProtect$[rbp]
  0006e	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR lpFileMappingAttributes$[rbp]
  00075	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  0007c	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 1224 : }

  0007f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00086	5f		 pop	 rdi
  00087	5d		 pop	 rbp
  00088	c3		 ret	 0
?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z ENDP ; apCreateFileMappingW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z
_TEXT	SEGMENT
pFunction$ = 8
hModule$ = 256
lpFilename$ = 264
nSize$ = 272
?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z PROC ; apGetModuleFileNameW, COMDAT

; 1203 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1204 : 	DWORD(WINAPI * pFunction)(HMODULE, LPWSTR, DWORD);
; 1205 : 	pFunction = (DWORD(WINAPI*)(HMODULE, LPWSTR, DWORD))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xebd9a617, 8);

  00029	41 b9 08 00 00
	00		 mov	 r9d, 8
  0002f	41 b8 17 a6 d9
	eb		 mov	 r8d, -338057705		; ebd9a617H
  00035	ba 0f 00 00 00	 mov	 edx, 15
  0003a	33 c9		 xor	 ecx, ecx
  0003c	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00041	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 1206 : 	return pFunction(hModule, lpFilename, nSize);

  00045	44 8b 85 10 01
	00 00		 mov	 r8d, DWORD PTR nSize$[rbp]
  0004c	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR lpFilename$[rbp]
  00053	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR hModule$[rbp]
  0005a	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 1207 : }

  0005d	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00064	5f		 pop	 rdi
  00065	5d		 pop	 rbp
  00066	c3		 ret	 0
?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z ENDP ; apGetModuleFileNameW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCloseHandle@@YAHPEAX@Z
_TEXT	SEGMENT
pFunction$ = 8
hObject$ = 256
?pCloseHandle@@YAHPEAX@Z PROC				; pCloseHandle, COMDAT

; 226  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 227  : 	BOOL(WINAPI * pFunction)(HANDLE);
; 228  : 	pFunction = (BOOL(WINAPI*)(HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0xca528872, 91);//GetProcAddress(hKernel32, OBFA("CloseHandle"));

  0001f	41 b9 5b 00 00
	00		 mov	 r9d, 91			; 0000005bH
  00025	41 b8 72 88 52
	ca		 mov	 r8d, -900560782		; ca528872H
  0002b	ba 0f 00 00 00	 mov	 edx, 15
  00030	33 c9		 xor	 ecx, ecx
  00032	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00037	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 229  : 	return pFunction(hObject);

  0003b	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR hObject$[rbp]
  00042	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 230  : }

  00045	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
?pCloseHandle@@YAHPEAX@Z ENDP				; pCloseHandle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z
_TEXT	SEGMENT
pFunction$ = 8
lpFileName$ = 256
dwDesiredAccess$ = 264
dwShareMode$ = 272
lpSecurityAttributes$ = 280
dwCreationDisposition$ = 288
dwFlagsAndAttributes$ = 296
hTemplateFile$ = 304
?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z PROC ; pCreateFileW, COMDAT

; 172  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001c	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 173  : 	HANDLE(WINAPI * pFunction)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
; 174  : 	pFunction = (HANDLE(WINAPI*)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x017610e8, 97);//GetProcAddress(hKernel32, OBFA("CreateFileW"));

  0002d	41 b9 61 00 00
	00		 mov	 r9d, 97			; 00000061H
  00033	41 b8 e8 10 76
	01		 mov	 r8d, 24514792		; 017610e8H
  00039	ba 0f 00 00 00	 mov	 edx, 15
  0003e	33 c9		 xor	 ecx, ecx
  00040	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  00045	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 175  : 	return pFunction(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

  00049	48 8b 85 30 01
	00 00		 mov	 rax, QWORD PTR hTemplateFile$[rbp]
  00050	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00055	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR dwFlagsAndAttributes$[rbp]
  0005b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0005f	8b 85 20 01 00
	00		 mov	 eax, DWORD PTR dwCreationDisposition$[rbp]
  00065	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00069	4c 8b 8d 18 01
	00 00		 mov	 r9, QWORD PTR lpSecurityAttributes$[rbp]
  00070	44 8b 85 10 01
	00 00		 mov	 r8d, DWORD PTR dwShareMode$[rbp]
  00077	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR dwDesiredAccess$[rbp]
  0007d	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR lpFileName$[rbp]
  00084	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 176  : }

  00087	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0008e	5f		 pop	 rdi
  0008f	5d		 pop	 rbp
  00090	c3		 ret	 0
?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z ENDP ; pCreateFileW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.h
;	COMDAT ?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
pFunction$ = 8
hFile$ = 256
lpFileSize$ = 264
?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z PROC	; pGetFileSizeEx, COMDAT

; 100  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__9B49ECA4_getapi@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 101  : 	BOOL(WINAPI * pFunction)(HANDLE, PLARGE_INTEGER);
; 102  : 	pFunction = (BOOL(WINAPI*)(HANDLE, PLARGE_INTEGER))getapi::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x43ba1ffb, 104);//GetProcAddress(hKernel32, OBFA("GetFileSizeEx"));

  00024	41 b9 68 00 00
	00		 mov	 r9d, 104		; 00000068H
  0002a	41 b8 fb 1f ba
	43		 mov	 r8d, 1136271355		; 43ba1ffbH
  00030	ba 0f 00 00 00	 mov	 edx, 15
  00035	33 c9		 xor	 ecx, ecx
  00037	e8 00 00 00 00	 call	 ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ; getapi::GetProcAddressEx2
  0003c	48 89 45 08	 mov	 QWORD PTR pFunction$[rbp], rax

; 103  : 	return pFunction(hFile, lpFileSize);

  00040	48 8b 95 08 01
	00 00		 mov	 rdx, QWORD PTR lpFileSize$[rbp]
  00047	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  0004e	ff 55 08	 call	 QWORD PTR pFunction$[rbp]

; 104  : }

  00051	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00058	5f		 pop	 rdi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z ENDP	; pGetFileSizeEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?positive_modulo@@YAHHH@Z
_TEXT	SEGMENT
a$ = 224
n$ = 232
?positive_modulo@@YAHHH@Z PROC				; positive_modulo, COMDAT

; 39   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 40   :     return (a % n + n) % n;

  00022	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00028	99		 cdq
  00029	f7 bd e8 00 00
	00		 idiv	 DWORD PTR n$[rbp]
  0002f	8b c2		 mov	 eax, edx
  00031	03 85 e8 00 00
	00		 add	 eax, DWORD PTR n$[rbp]
  00037	99		 cdq
  00038	f7 bd e8 00 00
	00		 idiv	 DWORD PTR n$[rbp]
  0003e	8b c2		 mov	 eax, edx

; 41   : }

  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
?positive_modulo@@YAHHH@Z ENDP				; positive_modulo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?removeHooks@@YAXPEAUHINSTANCE__@@@Z
_TEXT	SEGMENT
uiBaseAddress$ = 8
uiExportDir$ = 40
uiNameArray$ = 72
uiAddressArray$ = 104
uiNameOrdinals$ = 136
dwCounter$ = 164
pe32magic$ = 196
pe64magic$ = 228
moduleRealPath$ = 272
hFileMap$ = 824
hFile$ = 856
originDll$ = 888
res$ = 916
hKernel32$ = 952
Size$ = 980
LargeInt$ = 1048
cpExportedFunctionName$7 = 1080
funcAddr$8 = 1112
isForwarder$9 = 1140
funcHooked$10 = 1176
p$11 = 1208
funcIsHooked$12 = 1236
oldProtect$13 = 1268
oldProtect1$14 = 1300
$T15 = 1912
tv235 = 1940
tv189 = 1940
__$ArrayPad$ = 1944
hmodule$ = 1984
?removeHooks@@YAXPEAUHINSTANCE__@@@Z PROC		; removeHooks, COMDAT

; 183  : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 07
	00 00		 sub	 rsp, 2024		; 000007e8H
  0000e	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  00013	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]
  00018	b9 5a 01 00 00	 mov	 ecx, 346		; 0000015aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 08
	08 00 00	 mov	 rcx, QWORD PTR [rsp+2056]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 98 07
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__295B1E01_antihooks@cpp
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 184  :     UINT_PTR uiBaseAddress = 0;

  00049	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR uiBaseAddress$[rbp], 0

; 185  :     UINT_PTR uiExportDir = 0;

  00051	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR uiExportDir$[rbp], 0

; 186  :     UINT_PTR uiNameArray = 0;

  00059	48 c7 45 48 00
	00 00 00	 mov	 QWORD PTR uiNameArray$[rbp], 0

; 187  :     UINT_PTR uiAddressArray = 0;

  00061	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR uiAddressArray$[rbp], 0

; 188  :     UINT_PTR uiNameOrdinals = 0;

  00069	48 c7 85 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR uiNameOrdinals$[rbp], 0

; 189  :     DWORD dwCounter = 0;

  00074	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR dwCounter$[rbp], 0

; 190  :     volatile int pe32magic = 0x10b;

  0007e	c7 85 c4 00 00
	00 0b 01 00 00	 mov	 DWORD PTR pe32magic$[rbp], 267 ; 0000010bH

; 191  :     volatile int pe64magic = 0x20b;

  00088	c7 85 e4 00 00
	00 0b 02 00 00	 mov	 DWORD PTR pe64magic$[rbp], 523 ; 0000020bH

; 192  :     TCHAR moduleRealPath[MAX_PATH];
; 193  : 
; 194  :     HANDLE hFileMap = NULL;

  00092	48 c7 85 38 03
	00 00 00 00 00
	00		 mov	 QWORD PTR hFileMap$[rbp], 0

; 195  :     HANDLE hFile = NULL;

  0009d	48 c7 85 58 03
	00 00 00 00 00
	00		 mov	 QWORD PTR hFile$[rbp], 0

; 196  : 
; 197  :     LPBYTE originDll = NULL;

  000a8	48 c7 85 78 03
	00 00 00 00 00
	00		 mov	 QWORD PTR originDll$[rbp], 0

; 198  :     int res = 0;

  000b3	c7 85 94 03 00
	00 00 00 00 00	 mov	 DWORD PTR res$[rbp], 0

; 199  : 
; 200  :     HMODULE hKernel32 = apLoadLibraryA(_STR("kernel32.dll"));

  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@MDJJJHMB@kernel32?4dll@
  000c4	48 8d 8d 78 07
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  000cb	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$01$0EB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<2,65,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  000d8	48 8b c8	 mov	 rcx, rax
  000db	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  000e0	48 89 85 b8 03
	00 00		 mov	 QWORD PTR hKernel32$[rbp], rax

; 201  : 
; 202  :     /*
; 203  : #ifdef UNICODE
; 204  :     typedef DWORD(WINAPI* GetModuleFileNameFunc)(HMODULE, LPWSTR, DWORD);
; 205  :     GetModuleFileNameFunc pGetModuleFileName =
; 206  :         (GetModuleFileNameFunc)GetProcAddress(hKernel32, _STR("GetModuleFileNameW"));
; 207  : #else
; 208  :     typedef DWORD(WINAPI* GetModuleFileNameFunc)(HMODULE, LPSTR, DWORD);
; 209  :     GetModuleFileNameFunc pGetModuleFileName =
; 210  :         (GetModuleFileNameFunc)GetProcAddress(hKernel32, _STR("GetModuleFileNameA"));
; 211  : #endif // UNICODE
; 212  : */
; 213  : 
; 214  :     apGetModuleFileNameW(hmodule, moduleRealPath, MAX_PATH);

  000e7	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000ed	48 8d 95 10 01
	00 00		 lea	 rdx, QWORD PTR moduleRealPath$[rbp]
  000f4	48 8b 8d c0 07
	00 00		 mov	 rcx, QWORD PTR hmodule$[rbp]
  000fb	e8 00 00 00 00	 call	 ?apGetModuleFileNameW@@YAKPEAUHINSTANCE__@@PEA_WK@Z ; apGetModuleFileNameW

; 215  : 
; 216  :     /*
; 217  : #ifdef UNICODE
; 218  :     typedef HANDLE(WINAPI* CreateFileFunc)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD,
; 219  :         DWORD, HANDLE);
; 220  :     CreateFileFunc pCreateFile = (CreateFileFunc)GetProcAddress(hKernel32,
; 221  :         _STR("CreateFileW"));
; 222  : #else
; 223  :     typedef HANDLE(WINAPI* CreateFileFunc)(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD,
; 224  :         DWORD, HANDLE);
; 225  :     CreateFileFunc pCreateFile = (CreateFileFunc)GetProcAddress(hKernel32,
; 226  :         _STR("CreateFileA"));
; 227  : #endif // UNICODE
; 228  : */
; 229  : 
; 230  :     hFile = pCreateFileW(moduleRealPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING,

  00100	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00109	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  00111	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00119	45 33 c9	 xor	 r9d, r9d
  0011c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00122	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00127	48 8d 8d 10 01
	00 00		 lea	 rcx, QWORD PTR moduleRealPath$[rbp]
  0012e	e8 00 00 00 00	 call	 ?pCreateFileW@@YAPEAXPEB_WKKPEAU_SECURITY_ATTRIBUTES@@KKPEAX@Z ; pCreateFileW
  00133	48 89 85 58 03
	00 00		 mov	 QWORD PTR hFile$[rbp], rax

; 231  :         FILE_ATTRIBUTE_NORMAL, 0);
; 232  :     if (!hFile)

  0013a	48 83 bd 58 03
	00 00 00	 cmp	 QWORD PTR hFile$[rbp], 0
  00142	75 05		 jne	 SHORT $LN5@removeHook

; 233  :         return;

  00144	e9 3f 04 00 00	 jmp	 $LN1@removeHook
$LN5@removeHook:

; 234  : 
; 235  :     /*
; 236  :     typedef DWORD(WINAPI* GetFileSizeFunc)(HANDLE, LPDWORD);
; 237  :     GetFileSizeFunc pGetFileSize = (GetFileSizeFunc)GetProcAddress(hKernel32,
; 238  :         _STR("GetFileSize"));
; 239  : 
; 240  :     typedef BOOL(WINAPI* CloseHandleFunc)(HANDLE);
; 241  :     CloseHandleFunc pCloseHandle = (CloseHandleFunc)GetProcAddress(hKernel32,
; 242  :         _STR("CloseHandle"));
; 243  :         */
; 244  : 
; 245  : 
; 246  : 
; 247  :     DWORD Size = 0;

  00149	c7 85 d4 03 00
	00 00 00 00 00	 mov	 DWORD PTR Size$[rbp], 0

; 248  :     DWORD H;
; 249  :     LARGE_INTEGER LargeInt;
; 250  :     pGetFileSizeEx(hFile, &LargeInt);

  00153	48 8d 95 18 04
	00 00		 lea	 rdx, QWORD PTR LargeInt$[rbp]
  0015a	48 8b 8d 58 03
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  00161	e8 00 00 00 00	 call	 ?pGetFileSizeEx@@YAHPEAXPEAT_LARGE_INTEGER@@@Z ; pGetFileSizeEx

; 251  :     Size = LargeInt.QuadPart;

  00166	8b 85 18 04 00
	00		 mov	 eax, DWORD PTR LargeInt$[rbp]
  0016c	89 85 d4 03 00
	00		 mov	 DWORD PTR Size$[rbp], eax

; 252  :     if (!Size)

  00172	83 bd d4 03 00
	00 00		 cmp	 DWORD PTR Size$[rbp], 0
  00179	75 11		 jne	 SHORT $LN6@removeHook

; 253  :     {
; 254  :         pCloseHandle(hFile);

  0017b	48 8b 8d 58 03
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  00182	e8 00 00 00 00	 call	 ?pCloseHandle@@YAHPEAX@Z ; pCloseHandle

; 255  :         return;

  00187	e9 fc 03 00 00	 jmp	 $LN1@removeHook
$LN6@removeHook:

; 256  :     }
; 257  : 
; 258  :     /*
; 259  : #ifdef UNICODE
; 260  :     typedef HANDLE(WINAPI* CreateFileMappingFunc)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD,
; 261  :         DWORD, LPCWSTR);
; 262  :     CreateFileMappingFunc pCreateFileMapping =
; 263  :         (CreateFileMappingFunc)GetProcAddress(hKernel32, _STR("CreateFileMappingW"));
; 264  : #else
; 265  :     typedef HANDLE(WINAPI* CreateFileMappingFunc)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD,
; 266  :         DWORD, LPCSTR);
; 267  :     CreateFileMappingFunc pCreateFileMapping =
; 268  :         (CreateFileMappingFunc)GetProcAddress(hKernel32, _STR("CreateFileMappingA"));
; 269  : #endif // UNICODE
; 270  : */
; 271  : 
; 272  :     hFileMap = apCreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

  0018c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00195	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0019d	45 33 c9	 xor	 r9d, r9d
  001a0	41 b8 02 00 00
	00		 mov	 r8d, 2
  001a6	33 d2		 xor	 edx, edx
  001a8	48 8b 8d 58 03
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  001af	e8 00 00 00 00	 call	 ?apCreateFileMappingW@@YAPEAXPEAXPEAU_SECURITY_ATTRIBUTES@@KKKPEB_W@Z ; apCreateFileMappingW
  001b4	48 89 85 38 03
	00 00		 mov	 QWORD PTR hFileMap$[rbp], rax

; 273  :     if (!hFileMap)

  001bb	48 83 bd 38 03
	00 00 00	 cmp	 QWORD PTR hFileMap$[rbp], 0
  001c3	75 11		 jne	 SHORT $LN7@removeHook

; 274  :     {
; 275  :         pCloseHandle(hFile);

  001c5	48 8b 8d 58 03
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  001cc	e8 00 00 00 00	 call	 ?pCloseHandle@@YAHPEAX@Z ; pCloseHandle

; 276  :         return;

  001d1	e9 b2 03 00 00	 jmp	 $LN1@removeHook
$LN7@removeHook:

; 277  :     }
; 278  : 
; 279  :     /*
; 280  :     typedef LPVOID(WINAPI* MapViewOfFileFunc)(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
; 281  :     MapViewOfFileFunc pMapViewOfFile = (MapViewOfFileFunc)GetProcAddress(hKernel32,
; 282  :         _STR("MapViewOfFile"));
; 283  :         */
; 284  : 
; 285  :     originDll = (LPBYTE)apMapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, Size);

  001d6	8b 85 d4 03 00
	00		 mov	 eax, DWORD PTR Size$[rbp]
  001dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e1	45 33 c9	 xor	 r9d, r9d
  001e4	45 33 c0	 xor	 r8d, r8d
  001e7	ba 04 00 00 00	 mov	 edx, 4
  001ec	48 8b 8d 38 03
	00 00		 mov	 rcx, QWORD PTR hFileMap$[rbp]
  001f3	e8 00 00 00 00	 call	 ?apMapViewOfFile@@YAPEAXPEAXKKK_K@Z ; apMapViewOfFile
  001f8	48 89 85 78 03
	00 00		 mov	 QWORD PTR originDll$[rbp], rax

; 286  :     if (!originDll)

  001ff	48 83 bd 78 03
	00 00 00	 cmp	 QWORD PTR originDll$[rbp], 0
  00207	75 1d		 jne	 SHORT $LN8@removeHook

; 287  :     {
; 288  :         pCloseHandle(hFileMap);

  00209	48 8b 8d 38 03
	00 00		 mov	 rcx, QWORD PTR hFileMap$[rbp]
  00210	e8 00 00 00 00	 call	 ?pCloseHandle@@YAHPEAX@Z ; pCloseHandle

; 289  :         pCloseHandle(hFile);

  00215	48 8b 8d 58 03
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  0021c	e8 00 00 00 00	 call	 ?pCloseHandle@@YAHPEAX@Z ; pCloseHandle

; 290  :         return;

  00221	e9 62 03 00 00	 jmp	 $LN1@removeHook
$LN8@removeHook:

; 291  :     }
; 292  : 
; 293  :     uiBaseAddress = (UINT_PTR)originDll;

  00226	48 8b 85 78 03
	00 00		 mov	 rax, QWORD PTR originDll$[rbp]
  0022d	48 89 45 08	 mov	 QWORD PTR uiBaseAddress$[rbp], rax

; 294  : 
; 295  :     // get the File Offset of the modules NT Header
; 296  :     uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew;

  00231	48 8b 45 08	 mov	 rax, QWORD PTR uiBaseAddress$[rbp]
  00235	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00239	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  0023d	48 03 c8	 add	 rcx, rax
  00240	48 8b c1	 mov	 rax, rcx
  00243	48 89 45 28	 mov	 QWORD PTR uiExportDir$[rbp], rax

; 297  : 
; 298  :     if (((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.Magic == pe32magic)

  00247	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  0024b	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  0024f	8b 8d c4 00 00
	00		 mov	 ecx, DWORD PTR pe32magic$[rbp]
  00255	3b c1		 cmp	 eax, ecx
  00257	75 18		 jne	 SHORT $LN9@removeHook

; 299  :     {
; 300  :         uiNameArray = (UINT_PTR) & ((PIMAGE_NT_HEADERS32)

  00259	b8 08 00 00 00	 mov	 eax, 8
  0025e	48 6b c0 00	 imul	 rax, rax, 0
  00262	48 8b 4d 28	 mov	 rcx, QWORD PTR uiExportDir$[rbp]
  00266	48 8d 44 01 78	 lea	 rax, QWORD PTR [rcx+rax+120]
  0026b	48 89 45 48	 mov	 QWORD PTR uiNameArray$[rbp], rax

; 301  :             uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
; 302  :     }

  0026f	eb 4a		 jmp	 SHORT $LN10@removeHook
$LN9@removeHook:

; 303  :     else
; 304  :     {
; 305  :         if (((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.Magic == pe64magic)

  00271	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  00275	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  00279	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR pe64magic$[rbp]
  0027f	3b c1		 cmp	 eax, ecx
  00281	75 1b		 jne	 SHORT $LN11@removeHook

; 306  :         {
; 307  :             uiNameArray = (UINT_PTR) & ((PIMAGE_NT_HEADERS64)

  00283	b8 08 00 00 00	 mov	 eax, 8
  00288	48 6b c0 00	 imul	 rax, rax, 0
  0028c	48 8b 4d 28	 mov	 rcx, QWORD PTR uiExportDir$[rbp]
  00290	48 8d 84 01 88
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+136]
  00298	48 89 45 48	 mov	 QWORD PTR uiNameArray$[rbp], rax

; 308  :                 uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
; 309  :         }

  0029c	eb 1d		 jmp	 SHORT $LN12@removeHook
$LN11@removeHook:

; 310  :         else
; 311  :         {
; 312  :             pCloseHandle(hFileMap);

  0029e	48 8b 8d 38 03
	00 00		 mov	 rcx, QWORD PTR hFileMap$[rbp]
  002a5	e8 00 00 00 00	 call	 ?pCloseHandle@@YAHPEAX@Z ; pCloseHandle

; 313  :             pCloseHandle(hFile);

  002aa	48 8b 8d 58 03
	00 00		 mov	 rcx, QWORD PTR hFile$[rbp]
  002b1	e8 00 00 00 00	 call	 ?pCloseHandle@@YAHPEAX@Z ; pCloseHandle

; 314  :             return;

  002b6	e9 cd 02 00 00	 jmp	 $LN1@removeHook
$LN12@removeHook:
$LN10@removeHook:

; 315  :         }
; 316  :     }
; 317  : 
; 318  :     // get the File Offset of the export directory
; 319  :     uiExportDir = uiBaseAddress

  002bb	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  002bf	48 8b 45 48	 mov	 rax, QWORD PTR uiNameArray$[rbp]
  002c3	8b 08		 mov	 ecx, DWORD PTR [rax]
  002c5	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  002ca	8b c0		 mov	 eax, eax
  002cc	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  002d0	48 03 c8	 add	 rcx, rax
  002d3	48 8b c1	 mov	 rax, rcx
  002d6	48 89 45 28	 mov	 QWORD PTR uiExportDir$[rbp], rax

; 320  :         + Rva2Offset(((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress, uiBaseAddress);
; 321  : 
; 322  :     // get the File Offset for the array of name pointers
; 323  :     uiNameArray = uiBaseAddress

  002da	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  002de	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  002e2	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  002e5	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  002ea	8b c0		 mov	 eax, eax
  002ec	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  002f0	48 03 c8	 add	 rcx, rax
  002f3	48 8b c1	 mov	 rax, rcx
  002f6	48 89 45 48	 mov	 QWORD PTR uiNameArray$[rbp], rax

; 324  :         + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNames, uiBaseAddress);
; 325  : 
; 326  :     // get the File Offset for the array of addresses
; 327  :     uiAddressArray = uiBaseAddress

  002fa	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  002fe	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  00302	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00305	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  0030a	8b c0		 mov	 eax, eax
  0030c	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  00310	48 03 c8	 add	 rcx, rax
  00313	48 8b c1	 mov	 rax, rcx
  00316	48 89 45 68	 mov	 QWORD PTR uiAddressArray$[rbp], rax

; 328  :         + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions,
; 329  :             uiBaseAddress);
; 330  : 
; 331  :     // get the File Offset for the array of name ordinals
; 332  :     uiNameOrdinals = uiBaseAddress

  0031a	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  0031e	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  00322	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00325	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  0032a	8b c0		 mov	 eax, eax
  0032c	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  00330	48 03 c8	 add	 rcx, rax
  00333	48 8b c1	 mov	 rax, rcx
  00336	48 89 85 88 00
	00 00		 mov	 QWORD PTR uiNameOrdinals$[rbp], rax

; 333  :         + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNameOrdinals,
; 334  :             uiBaseAddress);
; 335  : 
; 336  :     // get a counter for the number of exported functions...
; 337  :     dwCounter = ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->NumberOfNames;

  0033d	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  00341	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00344	89 85 a4 00 00
	00		 mov	 DWORD PTR dwCounter$[rbp], eax

; 338  : 
; 339  :     //    
; 340  :     for (; dwCounter--; uiNameArray += sizeof(DWORD), uiNameOrdinals += sizeof(WORD))

  0034a	eb 1e		 jmp	 SHORT $LN4@removeHook
$LN2@removeHook:
  0034c	48 8b 45 48	 mov	 rax, QWORD PTR uiNameArray$[rbp]
  00350	48 83 c0 04	 add	 rax, 4
  00354	48 89 45 48	 mov	 QWORD PTR uiNameArray$[rbp], rax
  00358	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR uiNameOrdinals$[rbp]
  0035f	48 83 c0 02	 add	 rax, 2
  00363	48 89 85 88 00
	00 00		 mov	 QWORD PTR uiNameOrdinals$[rbp], rax
$LN4@removeHook:
  0036a	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR dwCounter$[rbp]
  00370	89 85 94 07 00
	00		 mov	 DWORD PTR tv189[rbp], eax
  00376	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR dwCounter$[rbp]
  0037c	ff c8		 dec	 eax
  0037e	89 85 a4 00 00
	00		 mov	 DWORD PTR dwCounter$[rbp], eax
  00384	83 bd 94 07 00
	00 00		 cmp	 DWORD PTR tv189[rbp], 0
  0038b	0f 84 f7 01 00
	00		 je	 $LN3@removeHook

; 341  :     {
; 342  : 
; 343  :         char* cpExportedFunctionName = (char*)(uiBaseAddress

  00391	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  00395	48 8b 45 48	 mov	 rax, QWORD PTR uiNameArray$[rbp]
  00399	8b 08		 mov	 ecx, DWORD PTR [rax]
  0039b	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  003a0	8b c0		 mov	 eax, eax
  003a2	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  003a6	48 03 c8	 add	 rcx, rax
  003a9	48 8b c1	 mov	 rax, rcx
  003ac	48 89 85 38 04
	00 00		 mov	 QWORD PTR cpExportedFunctionName$7[rbp], rax

; 344  :             + Rva2Offset(DEREF_32(uiNameArray), uiBaseAddress));
; 345  : 
; 346  :         uiAddressArray = uiBaseAddress

  003b3	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  003b7	48 8b 45 28	 mov	 rax, QWORD PTR uiExportDir$[rbp]
  003bb	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  003be	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  003c3	8b c0		 mov	 eax, eax
  003c5	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  003c9	48 03 c8	 add	 rcx, rax
  003cc	48 8b c1	 mov	 rax, rcx
  003cf	48 89 45 68	 mov	 QWORD PTR uiAddressArray$[rbp], rax

; 347  :             + Rva2Offset(((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions,
; 348  :                 uiBaseAddress);
; 349  : 
; 350  :         // use the functions name ordinal as an index into the array of name pointers
; 351  :         uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));

  003d3	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR uiNameOrdinals$[rbp]
  003da	0f b7 00	 movzx	 eax, WORD PTR [rax]
  003dd	48 8b 4d 68	 mov	 rcx, QWORD PTR uiAddressArray$[rbp]
  003e1	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  003e5	48 89 45 68	 mov	 QWORD PTR uiAddressArray$[rbp], rax

; 352  : 
; 353  :         // compute the File Offset to the function code
; 354  :         UINT_PTR funcAddr = uiBaseAddress + Rva2Offset(DEREF_32(uiAddressArray),

  003e9	48 8b 55 08	 mov	 rdx, QWORD PTR uiBaseAddress$[rbp]
  003ed	48 8b 45 68	 mov	 rax, QWORD PTR uiAddressArray$[rbp]
  003f1	8b 08		 mov	 ecx, DWORD PTR [rax]
  003f3	e8 00 00 00 00	 call	 ?Rva2Offset@@YAKK_K@Z	; Rva2Offset
  003f8	8b c0		 mov	 eax, eax
  003fa	48 8b 4d 08	 mov	 rcx, QWORD PTR uiBaseAddress$[rbp]
  003fe	48 03 c8	 add	 rcx, rax
  00401	48 8b c1	 mov	 rax, rcx
  00404	48 89 85 58 04
	00 00		 mov	 QWORD PTR funcAddr$8[rbp], rax

; 355  :             uiBaseAddress);
; 356  : 
; 357  :         bool isForwarder = isForwardedFunc((const void*)funcAddr);

  0040b	48 8b 8d 58 04
	00 00		 mov	 rcx, QWORD PTR funcAddr$8[rbp]
  00412	e8 00 00 00 00	 call	 ?isForwardedFunc@@YA_NPEBX@Z ; isForwardedFunc
  00417	88 85 74 04 00
	00		 mov	 BYTE PTR isForwarder$9[rbp], al

; 358  : 
; 359  :         // forwarder        
; 360  :         if (isForwarder) continue;

  0041d	0f b6 85 74 04
	00 00		 movzx	 eax, BYTE PTR isForwarder$9[rbp]
  00424	85 c0		 test	 eax, eax
  00426	74 05		 je	 SHORT $LN13@removeHook
  00428	e9 1f ff ff ff	 jmp	 $LN2@removeHook
$LN13@removeHook:

; 361  : 
; 362  :         void* funcHooked = apGetProcAddress(hmodule, cpExportedFunctionName);

  0042d	48 8b 95 38 04
	00 00		 mov	 rdx, QWORD PTR cpExportedFunctionName$7[rbp]
  00434	48 8b 8d c0 07
	00 00		 mov	 rcx, QWORD PTR hmodule$[rbp]
  0043b	e8 00 00 00 00	 call	 ?apGetProcAddress@@YAP6A_JXZPEAUHINSTANCE__@@PEBD@Z ; apGetProcAddress
  00440	48 89 85 98 04
	00 00		 mov	 QWORD PTR funcHooked$10[rbp], rax

; 363  : 
; 364  :         if (!funcHooked) continue;

  00447	48 83 bd 98 04
	00 00 00	 cmp	 QWORD PTR funcHooked$10[rbp], 0
  0044f	75 05		 jne	 SHORT $LN14@removeHook
  00451	e9 f6 fe ff ff	 jmp	 $LN2@removeHook
$LN14@removeHook:

; 365  : 
; 366  :         BYTE* p = (BYTE*)funcHooked;

  00456	48 8b 85 98 04
	00 00		 mov	 rax, QWORD PTR funcHooked$10[rbp]
  0045d	48 89 85 b8 04
	00 00		 mov	 QWORD PTR p$11[rbp], rax

; 367  :         if (p[0] != 0xe9) {

  00464	b8 01 00 00 00	 mov	 eax, 1
  00469	48 6b c0 00	 imul	 rax, rax, 0
  0046d	48 8b 8d b8 04
	00 00		 mov	 rcx, QWORD PTR p$11[rbp]
  00474	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00478	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  0047d	74 3e		 je	 SHORT $LN15@removeHook

; 368  :             if (p[0] != 0xff) continue;

  0047f	b8 01 00 00 00	 mov	 eax, 1
  00484	48 6b c0 00	 imul	 rax, rax, 0
  00488	48 8b 8d b8 04
	00 00		 mov	 rcx, QWORD PTR p$11[rbp]
  0048f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00493	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00498	74 05		 je	 SHORT $LN16@removeHook
  0049a	e9 ad fe ff ff	 jmp	 $LN2@removeHook
$LN16@removeHook:

; 369  :             if (p[1] != 0x25) continue;

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	48 6b c0 01	 imul	 rax, rax, 1
  004a8	48 8b 8d b8 04
	00 00		 mov	 rcx, QWORD PTR p$11[rbp]
  004af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004b3	83 f8 25	 cmp	 eax, 37			; 00000025H
  004b6	74 05		 je	 SHORT $LN17@removeHook
  004b8	e9 8f fe ff ff	 jmp	 $LN2@removeHook
$LN17@removeHook:
$LN15@removeHook:

; 370  :         }
; 371  : 
; 372  : #ifdef __MINGW32__
; 373  :         bool funcIsHooked = (memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0);
; 374  : #else
; 375  :         bool funcIsHooked = m_memcmp((const void*)funcAddr, (const void*)funcHooked, 2) != 0;

  004bd	41 b8 02 00 00
	00		 mov	 r8d, 2
  004c3	48 8b 95 98 04
	00 00		 mov	 rdx, QWORD PTR funcHooked$10[rbp]
  004ca	48 8b 8d 58 04
	00 00		 mov	 rcx, QWORD PTR funcAddr$8[rbp]
  004d1	e8 00 00 00 00	 call	 ?m_memcmp@@YAHPEBX0_K@Z	; m_memcmp
  004d6	85 c0		 test	 eax, eax
  004d8	74 0c		 je	 SHORT $LN22@removeHook
  004da	c7 85 94 07 00
	00 01 00 00 00	 mov	 DWORD PTR tv235[rbp], 1
  004e4	eb 0a		 jmp	 SHORT $LN23@removeHook
$LN22@removeHook:
  004e6	c7 85 94 07 00
	00 00 00 00 00	 mov	 DWORD PTR tv235[rbp], 0
$LN23@removeHook:
  004f0	0f b6 85 94 07
	00 00		 movzx	 eax, BYTE PTR tv235[rbp]
  004f7	88 85 d4 04 00
	00		 mov	 BYTE PTR funcIsHooked$12[rbp], al

; 376  : #endif // __MINGW32
; 377  :         if (!funcIsHooked) continue;

  004fd	0f b6 85 d4 04
	00 00		 movzx	 eax, BYTE PTR funcIsHooked$12[rbp]
  00504	85 c0		 test	 eax, eax
  00506	75 05		 jne	 SHORT $LN18@removeHook
  00508	e9 3f fe ff ff	 jmp	 $LN2@removeHook
$LN18@removeHook:

; 378  : 
; 379  :         DWORD oldProtect = 0;

  0050d	c7 85 f4 04 00
	00 00 00 00 00	 mov	 DWORD PTR oldProtect$13[rbp], 0

; 380  :         DWORD oldProtect1 = 0;

  00517	c7 85 14 05 00
	00 00 00 00 00	 mov	 DWORD PTR oldProtect1$14[rbp], 0

; 381  : 
; 382  :         /*
; 383  :         typedef BOOL(WINAPI* VirtualProtectFunc)(LPVOID, SIZE_T, DWORD, PDWORD);
; 384  :         VirtualProtectFunc pVirtualProtect = (VirtualProtectFunc)GetProcAddress(hKernel32,
; 385  :             _STR("VirtualProtect"));
; 386  :             */
; 387  : 
; 388  :         if (!apVirtualProtect(funcHooked, 64, PAGE_EXECUTE_READWRITE, &oldProtect))

  00521	4c 8d 8d f4 04
	00 00		 lea	 r9, QWORD PTR oldProtect$13[rbp]
  00528	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0052e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00533	48 8b 8d 98 04
	00 00		 mov	 rcx, QWORD PTR funcHooked$10[rbp]
  0053a	e8 00 00 00 00	 call	 ?apVirtualProtect@@YAHPEAX_KKPEAK@Z ; apVirtualProtect
  0053f	85 c0		 test	 eax, eax
  00541	75 02		 jne	 SHORT $LN19@removeHook

; 389  :             break;

  00543	eb 43		 jmp	 SHORT $LN3@removeHook
$LN19@removeHook:

; 390  : 
; 391  :         //memcpy((void*)funcHooked, (void*)funcAddr, 10);
; 392  :         CopyMemory((void*)funcHooked, (void*)funcAddr, 10);

  00545	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0054b	48 8b 95 58 04
	00 00		 mov	 rdx, QWORD PTR funcAddr$8[rbp]
  00552	48 8b 8d 98 04
	00 00		 mov	 rcx, QWORD PTR funcHooked$10[rbp]
  00559	e8 00 00 00 00	 call	 memcpy

; 393  : 
; 394  :         if (!apVirtualProtect(funcHooked, 64, oldProtect, &oldProtect1))

  0055e	4c 8d 8d 14 05
	00 00		 lea	 r9, QWORD PTR oldProtect1$14[rbp]
  00565	44 8b 85 f4 04
	00 00		 mov	 r8d, DWORD PTR oldProtect$13[rbp]
  0056c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00571	48 8b 8d 98 04
	00 00		 mov	 rcx, QWORD PTR funcHooked$10[rbp]
  00578	e8 00 00 00 00	 call	 ?apVirtualProtect@@YAHPEAX_KKPEAK@Z ; apVirtualProtect
  0057d	85 c0		 test	 eax, eax
  0057f	75 02		 jne	 SHORT $LN20@removeHook

; 395  :             break;

  00581	eb 05		 jmp	 SHORT $LN3@removeHook
$LN20@removeHook:

; 396  :     }

  00583	e9 c4 fd ff ff	 jmp	 $LN2@removeHook
$LN3@removeHook:
$LN1@removeHook:

; 397  : }

  00588	48 8d 4d c0	 lea	 rcx, QWORD PTR [rbp-64]
  0058c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?removeHooks@@YAXPEAUHINSTANCE__@@@Z$rtcFrameData
  00593	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00598	48 8b 8d 98 07
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0059f	48 33 cd	 xor	 rcx, rbp
  005a2	e8 00 00 00 00	 call	 __security_check_cookie
  005a7	48 8d a5 a8 07
	00 00		 lea	 rsp, QWORD PTR [rbp+1960]
  005ae	5f		 pop	 rdi
  005af	5d		 pop	 rbp
  005b0	c3		 ret	 0
?removeHooks@@YAXPEAUHINSTANCE__@@@Z ENDP		; removeHooks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\antihooks\antihooks.cpp
;	COMDAT ?DisableHooks@@YAXXZ
_TEXT	SEGMENT
hKernel32$ = 8
hWs2_32$ = 40
hAdvapi32$ = 72
hNtdll$ = 104
hRstrtmgr$ = 136
hOle32$ = 168
hOleAut$ = 200
hNetApi32$ = 232
hIphlp32$ = 264
hShlwapi$ = 296
hShell32$ = 328
$T1 = 744
$T2 = 792
$T3 = 840
$T4 = 888
$T5 = 936
$T6 = 984
$T7 = 1032
$T8 = 1080
$T9 = 1128
$T10 = 1176
$T11 = 1224
?DisableHooks@@YAXXZ PROC				; DisableHooks, COMDAT

; 15   : {

$LN14:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 18 05
	00 00		 sub	 rsp, 1304		; 00000518H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__295B1E01_antihooks@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 16   :     HMODULE hKernel32 = apLoadLibraryA(OBFA("kernel32.dll"));

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@MDJJJHMB@kernel32?4dll@
  00022	48 8d 8d e8 02
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00029	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0HB@$0HI@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<113,120,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  0003e	48 89 45 08	 mov	 QWORD PTR hKernel32$[rbp], rax

; 17   :     HMODULE hWs2_32 = apLoadLibraryA(OBFA("ws2_32.dll"));

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@EANHMAHB@ws2_32?4dll@
  00049	48 8d 8d 18 03
	00 00		 lea	 rcx, QWORD PTR $T2[rbp]
  00050	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EJ@$0DL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<73,59,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  00065	48 89 45 28	 mov	 QWORD PTR hWs2_32$[rbp], rax

; 18   :     HMODULE hAdvapi32 = apLoadLibraryA(OBFA("Advapi32.dll"));

  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DOHINHCI@Advapi32?4dll@
  00070	48 8d 8d 48 03
	00 00		 lea	 rcx, QWORD PTR $T3[rbp]
  00077	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DF@$0GO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<53,110,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  0008c	48 89 45 48	 mov	 QWORD PTR hAdvapi32$[rbp], rax

; 19   :     HMODULE hNtdll = apLoadLibraryA(OBFA("ntdll.dll"));

  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FLKFJBLM@ntdll?4dll@
  00097	48 8d 8d 78 03
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  0009e	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
  000a3	48 8b c8	 mov	 rcx, rax
  000a6	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GH@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<103,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  000b3	48 89 45 68	 mov	 QWORD PTR hNtdll$[rbp], rax

; 20   :     HMODULE hRstrtmgr = apLoadLibraryA(OBFA("Rstrtmgr.dll"));

  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NKKEACFL@Rstrtmgr?4dll@
  000be	48 8d 8d a8 03
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  000c5	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CF@$0FG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<37,86,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  000da	48 89 85 88 00
	00 00		 mov	 QWORD PTR hRstrtmgr$[rbp], rax

; 21   :     HMODULE hOle32 = apLoadLibraryA(OBFA("Ole32.dll"));

  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MDJBOJHM@Ole32?4dll@
  000e8	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  000ef	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
  000f4	48 8b c8	 mov	 rcx, rax
  000f7	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0FP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,95,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  000fc	48 8b c8	 mov	 rcx, rax
  000ff	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  00104	48 89 85 a8 00
	00 00		 mov	 QWORD PTR hOle32$[rbp], rax

; 22   :     HMODULE hOleAut = apLoadLibraryA(OBFA("OleAut32.dll"));

  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BHPCGNMJ@OleAut32?4dll@
  00112	48 8d 8d 08 04
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  00119	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  0011e	48 8b c8	 mov	 rcx, rax
  00121	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0DN@$05U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<61,6,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  00126	48 8b c8	 mov	 rcx, rax
  00129	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  0012e	48 89 85 c8 00
	00 00		 mov	 QWORD PTR hOleAut$[rbp], rax

; 23   :     HMODULE hNetApi32 = apLoadLibraryA(OBFA("Netapi32.dll"));

  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NKMBPHLD@Netapi32?4dll@
  0013c	48 8d 8d 38 04
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  00143	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  00148	48 8b c8	 mov	 rcx, rax
  0014b	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BH@$0HB@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<23,113,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  00150	48 8b c8	 mov	 rcx, rax
  00153	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  00158	48 89 85 e8 00
	00 00		 mov	 QWORD PTR hNetApi32$[rbp], rax

; 24   :     HMODULE hIphlp32 = apLoadLibraryA(OBFA("Iphlpapi.dll"));

  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KCFEDKNO@Iphlpapi?4dll@
  00166	48 8d 8d 68 04
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  0016d	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  00172	48 8b c8	 mov	 rcx, rax
  00175	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0FA@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,80,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  00182	48 89 85 08 01
	00 00		 mov	 QWORD PTR hIphlp32$[rbp], rax

; 25   :     HMODULE hShlwapi = apLoadLibraryA(OBFA("Shlwapi.dll"));

  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OHCDEFLB@Shlwapi?4dll@
  00190	48 8d 8d 98 04
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00197	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
  0019c	48 8b c8	 mov	 rcx, rax
  0019f	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CP@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<47,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  001ac	48 89 85 28 01
	00 00		 mov	 QWORD PTR hShlwapi$[rbp], rax

; 26   :     HMODULE hShell32 = apLoadLibraryA(OBFA("Shell32.dll"));

  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LNAMDANG@Shell32?4dll@
  001ba	48 8d 8d c8 04
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  001c1	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0HB@$0O@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<113,14,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  001ce	48 8b c8	 mov	 rcx, rax
  001d1	e8 00 00 00 00	 call	 ?apLoadLibraryA@@YAPEAUHINSTANCE__@@PEBD@Z ; apLoadLibraryA
  001d6	48 89 85 48 01
	00 00		 mov	 QWORD PTR hShell32$[rbp], rax

; 27   : 
; 28   : 
; 29   :     if (hKernel32) {

  001dd	48 83 7d 08 00	 cmp	 QWORD PTR hKernel32$[rbp], 0
  001e2	74 09		 je	 SHORT $LN2@DisableHoo

; 30   :         removeHooks(hKernel32);

  001e4	48 8b 4d 08	 mov	 rcx, QWORD PTR hKernel32$[rbp]
  001e8	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN2@DisableHoo:

; 31   :     }
; 32   : 
; 33   : 
; 34   :     if (hWs2_32) {

  001ed	48 83 7d 28 00	 cmp	 QWORD PTR hWs2_32$[rbp], 0
  001f2	74 09		 je	 SHORT $LN3@DisableHoo

; 35   :         removeHooks(hWs2_32);

  001f4	48 8b 4d 28	 mov	 rcx, QWORD PTR hWs2_32$[rbp]
  001f8	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN3@DisableHoo:

; 36   :     }
; 37   : 
; 38   :     if (hAdvapi32) {

  001fd	48 83 7d 48 00	 cmp	 QWORD PTR hAdvapi32$[rbp], 0
  00202	74 09		 je	 SHORT $LN4@DisableHoo

; 39   :         removeHooks(hAdvapi32);

  00204	48 8b 4d 48	 mov	 rcx, QWORD PTR hAdvapi32$[rbp]
  00208	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN4@DisableHoo:

; 40   :     }
; 41   : 
; 42   : 
; 43   :     if (hRstrtmgr) {

  0020d	48 83 bd 88 00
	00 00 00	 cmp	 QWORD PTR hRstrtmgr$[rbp], 0
  00215	74 16		 je	 SHORT $LN5@DisableHoo

; 44   : 
; 45   :         getapi::SetRestartManagerLoaded(TRUE);

  00217	b9 01 00 00 00	 mov	 ecx, 1
  0021c	e8 00 00 00 00	 call	 ?SetRestartManagerLoaded@getapi@@YAXH@Z ; getapi::SetRestartManagerLoaded

; 46   :         removeHooks(hRstrtmgr);

  00221	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR hRstrtmgr$[rbp]
  00228	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN5@DisableHoo:

; 47   : 
; 48   :     }
; 49   : 
; 50   :     if (hOle32) {

  0022d	48 83 bd a8 00
	00 00 00	 cmp	 QWORD PTR hOle32$[rbp], 0
  00235	74 0c		 je	 SHORT $LN6@DisableHoo

; 51   :         removeHooks(hOle32);

  00237	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR hOle32$[rbp]
  0023e	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN6@DisableHoo:

; 52   :     }
; 53   : 
; 54   :     if (hOleAut) {

  00243	48 83 bd c8 00
	00 00 00	 cmp	 QWORD PTR hOleAut$[rbp], 0
  0024b	74 0c		 je	 SHORT $LN7@DisableHoo

; 55   :         removeHooks(hOle32);

  0024d	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR hOle32$[rbp]
  00254	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN7@DisableHoo:

; 56   :     }
; 57   : 
; 58   :     if (hNetApi32) {

  00259	48 83 bd e8 00
	00 00 00	 cmp	 QWORD PTR hNetApi32$[rbp], 0
  00261	74 0c		 je	 SHORT $LN8@DisableHoo

; 59   :         removeHooks(hNetApi32);

  00263	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR hNetApi32$[rbp]
  0026a	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN8@DisableHoo:

; 60   :     }
; 61   : 
; 62   :     if (hIphlp32) {

  0026f	48 83 bd 08 01
	00 00 00	 cmp	 QWORD PTR hIphlp32$[rbp], 0
  00277	74 0c		 je	 SHORT $LN9@DisableHoo

; 63   :         removeHooks(hIphlp32);

  00279	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR hIphlp32$[rbp]
  00280	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN9@DisableHoo:

; 64   :     }
; 65   : 
; 66   :     if (hShlwapi) {

  00285	48 83 bd 28 01
	00 00 00	 cmp	 QWORD PTR hShlwapi$[rbp], 0
  0028d	74 0c		 je	 SHORT $LN10@DisableHoo

; 67   :         removeHooks(hShlwapi);

  0028f	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR hShlwapi$[rbp]
  00296	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN10@DisableHoo:

; 68   :     }
; 69   : 
; 70   :     if (hShell32) {

  0029b	48 83 bd 48 01
	00 00 00	 cmp	 QWORD PTR hShell32$[rbp], 0
  002a3	74 0c		 je	 SHORT $LN11@DisableHoo

; 71   :         removeHooks(hShell32);

  002a5	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR hShell32$[rbp]
  002ac	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN11@DisableHoo:

; 72   :     }
; 73   : 
; 74   :     if (hNtdll) {

  002b1	48 83 7d 68 00	 cmp	 QWORD PTR hNtdll$[rbp], 0
  002b6	74 09		 je	 SHORT $LN12@DisableHoo

; 75   :         removeHooks(hNtdll);

  002b8	48 8b 4d 68	 mov	 rcx, QWORD PTR hNtdll$[rbp]
  002bc	e8 00 00 00 00	 call	 ?removeHooks@@YAXPEAUHINSTANCE__@@@Z ; removeHooks
$LN12@DisableHoo:

; 76   :     }
; 77   : 
; 78   : }

  002c1	48 8d a5 f8 04
	00 00		 lea	 rsp, QWORD PTR [rbp+1272]
  002c8	5f		 pop	 rdi
  002c9	5d		 pop	 rbp
  002ca	c3		 ret	 0
?DisableHooks@@YAXXZ ENDP				; DisableHooks
_TEXT	ENDS
END
